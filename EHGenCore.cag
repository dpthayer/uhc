% $Id: EHC.lag 199 2004-05-12 19:11:13Z andres $

%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Generation of core
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR AGItf [ | | cmodule: CModule ]

SEM AGItf
  | AGItf       lhs         .   cmodule     =   CModule_Mod @lhs.baseName
                                                    (foldr (\(c,b) e -> mkCExprLet c b e)
                                                        (mkCExprLet CBindPlain [CBind_Bind hsnMain @expr.letCBody] (CExpr_Var hsnMain))
                                                        @expr.letCBindL)
%%]

%%[9
%%]

SEM AGItf
  | AGItf       lhs         .   cmodule     :=  CModule_Mod @lhs.baseName
                                                    (mkCExprLet CBindRec (mkCBindLForUIDL @prfCBindLMap (const True)) @expr.cexpr)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Expr
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR Expr [ | | cexpr: CExpr ]

SEM Expr
  | IConst      loc         .   cexpr       =   CExpr_Int @int
  | CConst      loc         .   cexpr       =   CExpr_Char @char
  | Var         loc         .   cexpr       =   CExpr_Var @nm
  | Con         loc         .   cexpr       =   CExpr_Var @nm
  | Let         loc         .   letCBindL   =   [(CBindFFI,@decls.ffiCBindL),(CBindRec,@decls.cbindL)]
                            .   cexpr       =   foldr (\(c,b) e -> mkCExprLet c b e) @body.cexpr @letCBindL
  | App         loc         .   cexpr       =   CExpr_App @func.cexpr @arg.cexpr
  | Lam         loc         .   cexpr       =   CExpr_Lam @arg.topNm
                                                    (rceMatch (RCEEnv @lhs.valGam @lhs.tyGam) [@arg.topNm] [CAlt_Alt [@arg.cpat] @body.cexpr] cvarUndefined)
  | Case        loc         .   cexpr       =   let  n = uidHNm @lUniq
                                                in   mkCExprLet CBindPlain [CBind_Bind n @expr.cexpr]
                                                        (rceMatch (RCEEnv @lhs.valGam @lhs.tyGam) [n] @alts.caltL cvarUndefined)
  | AppTop      loc         .   cexpr       =   @expr.cexpr
  | Parens      loc         .   cexpr       =   @expr.cexpr
  | TypeAs      loc         .   cexpr       =   @expr.cexpr
  | Undefined   loc         .   cexpr       =   cvarUndefined
%%]

%%[9
SEM Expr
  | Var Con     loc         .   cexpr       :=  foAppCoe @fo @lhs.finTyCnstr @lhs.cSubst (CExpr_Var @nm)
  | IConst      loc         .   cexpr       :=  foAppCoe @fo @lhs.finTyCnstr @lhs.cSubst (CExpr_Int @int)
  | CConst      loc         .   cexpr       :=  foAppCoe @fo @lhs.finTyCnstr @lhs.cSubst (CExpr_Char @char)
  | Let         loc         .   letCBindL   :=  [(CBindFFI,@decls.ffiCBindL)
                                                ,(CBindRec
                                                    ,@decls.cbindL ++ mkCBindLForUIDL @prfCBindLMap (not.(`elementOf` @quantPrIdSet))
                                                         ++ mkCBindLForUIDL @bodyPrfCBindLMap (const True))
                                                ]
  | App AppImpl
                loc         .   cexpr       :=  CExpr_App
                                                    (coeWipeWeave @lhs.finTyCnstr @lhs.cSubst @appImplsCoeL []
                                                      `coeEvalOn` @func.cexpr)
                                                    @arg.cexpr
  | Lam LamImpl loc         .   cexpr       :=  coeWipeWeave @lhs.finTyCnstr @cSubst @lamBodyCoeL @lamArgCoeL `coeEvalOn` @body.appFunCExpr
  | AppTop      loc         .   cexpr       :=  coeWipeWeave @lhs.finTyCnstr @cSubst [] @lamArgCoeL `coeEvalOn` @expr.cexpr
  | TypeAs      loc         .   cexpr       :=  foAppCoe @fo @lhs.finTyCnstr @lhs.cSubst @expr.cexpr
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Records, construction
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
SEM Expr
  | Rec         loc         .   rcexpr          =   if @recExpr.isExtFromEmpty
                                                    then  foldl CExpr_App (CExpr_Tup CTagRec)
                                                          . map (\(_,CExpr_TupIns _ _ _ _ e) -> e)
                                                          . tyRowCanonOrder
                                                          $ @recExpr.fuCExprL
                                                    else  let  (n:nL) = map uidHNm . mkNewLevUIDL (length @recExpr.fuCExprL + 1) $ @lUniq3
                                                               (oL,fuL) = rfuReorder nL . reverse $ @recExpr.fuCExprL
                                                               bL = CBind_Bind n @recExpr.recCExpr : zipWith CBind_Bind nL oL
                                                          in   mkCExprLet CBindStrict bL . foldl (\r (_,f) -> f r) (CExpr_Var n) $ fuL
                loc         .   cexpr           =   @rcexpr
%%]

%%[8
ATTR RecExpr [ | | recCExpr: CExpr ^^ fuCExprL: {FieldUpdateL CExpr} ]

SEM RecExpr
  | Empty       loc         .   recCExpr        =   CExpr_Tup CTagRec
                lhs         .   fuCExprL        =   []
  | Expr        loc         .   recCExpr        =   @expr.cexpr
                lhs         .   fuCExprL        =   []
  | Ext         loc         .   rcexpr          =   CExpr_TupIns @recExpr.recCExpr CTagRec @nm @offset @expr.cexpr
  | Upd         loc         .   rcexpr          =   CExpr_TupUpd @recExpr.recCExpr CTagRec @nm @offset @expr.cexpr
  | Ext Upd     lhs         .   fuCExprL        =   if @knRecHasLab
                                                    then (@nm,@rcexpr) : @recExpr.fuCExprL
                                                    else @recExpr.fuCExprL
%%]

%%[8
ATTR RecExpr [ | | isExtFromEmpty: Bool ]

SEM RecExpr
  | Empty       lhs         .   isExtFromEmpty  =   True
  | Expr        lhs         .   isExtFromEmpty  =   False
  | Upd         lhs         .   isExtFromEmpty  =   not @knRecHasLab && @recExpr.isExtFromEmpty
  | Ext         lhs         .   isExtFromEmpty  =   @recExpr.isExtFromEmpty
%%]

%%[8
SEM RecExpr
  | Ext Upd     loc         .   offset          =   CExpr_Int (tyRecOffset @nm (@lhs.finTyCnstr |=> @recExpr.ty))
%%]

%%[10
SEM RecExpr
  | Ext Upd     loc         .   offset          :=  @lhs.cSubst `cAppSubst` CExpr_Hole @prUid
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Records, dissection
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
SEM Expr
  | Sel         loc         .   offset          =   CExpr_Int (tyRecOffset @lbl (@lhs.finTyCnstr |=> @expr.ty))
                            .   cexpr           =   let  [n1,n2] = map uidHNm . mkNewUIDL 2 $ @lUniq
                                                    in   mkCExprSelCase (RCEEnv @lhs.valGam @lhs.tyGam) n1 @expr.cexpr CTagRec n2 @lbl @offset
%%]
                            .   cexpr           =   CExpr_TupSel @expr.cexpr CTagRec @offset

%%[10
SEM Expr
  | Sel         loc         .   offset          :=  @lhs.cSubst `cAppSubst` CExpr_Hole @prUid
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Pat for use in case alt
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR PatExpr [ | | cpat: CPat ]

SEM PatExpr
  | Var VarAs AppTop Rec Con
                loc         .   cpNm        =   maybe (CPatNmUniq @topNm) CPatNmOrig @mbTopNm
  | Var         lhs         .   cpat        =   CPat_Var @cpNm
  | VarAs       lhs         .   cpat        =   case @patExpr.cpat of
                                                    CPat_Con _ t r ps  -> CPat_Con @cpNm t r ps
                                                    _                  -> @patExpr.cpat
  | AppTop Con  loc         .   finResTy    =   @lhs.finTyCnstr |=> @knResTy
                            .   finResTGI   =   let  (c,_)  = tyAppFunArgs @finResTy
                                                     n      = tyConNm c
                                                in   fromJust . tyGamLookup n $ @lhs.tyGam
                            .   tag         =   fromJust . lookupFM (tgiDataTagMp @finResTGI) $ @appFunNm
                            .   rest        =   CPatRest_Empty
  | Rec         loc         .   tag         =   CTagRec
                            .   rest        =   @recPatExpr.patCRest
  | AppTop Rec  loc         .   cpatBinds   =   map (\(o,(n,(_,p))) -> CPatBind_Bind n (CExpr_Int o) n p) . zip [0..] . tyRowCanonOrder . reverse $ @fsCPatL
  | AppTop      lhs         .   cpat        =   CPat_Con @cpNm @tag @rest @cpatBinds
  | Con         lhs         .   cpat        =   CPat_Con @cpNm @tag CPatRest_Empty []
  | Rec         lhs         .   cpat        =   case @rest of
                                                    CPatRest_Empty
                                                      ->  CPat_Con @cpNm @tag @rest @cpatBinds
                                                    CPatRest_Var r
                                                      ->  CPat_Con @cpNm @tag @rest pbL
                                                          where  pbL = rpbReorder . map (\(n,(o,p)) -> CPatBind_Bind n o n p) . reverse $ @fsCPatL
  | CConst IConst
                lhs         .   cpat        =   CPat_Undef
%%]

%%[8 hs
type FieldSplitL = AssocL HsName (CExpr,CPat)

rpbReorder :: CPatBindL -> CPatBindL
rpbReorder pbL
  =  let  (pbL',_)
            =  foldr
                 (\(CPatBind_Bind l o n p) (pbL,exts) 
                     ->  let  mkOff lbl exts o
                                =  let nrSmaller = length . filter (\e -> rowLabCmp e lbl == LT) $ exts
                                   in  if nrSmaller == 0 then o else mkCExprAddInt o (CExpr_Int nrSmaller)
                         in   ((CPatBind_Bind l (mkOff l exts o) n p):pbL,l:exts)
                 )
                 ([],[])
            $  pbL
          cmpPB (CPatBind_Bind l1 _ _ _)  (CPatBind_Bind l2 _ _ _) = rowLabCmp l1 l2
     in   sortBy cmpPB pbL'

patBindLOffset :: CPatBindL -> (CPatBindL,[CBindL])
patBindLOffset
  =  unzip
  .  map
       (\b@(CPatBind_Bind l o n p@(CPat_Var pn))
           ->  let  offNm = hsnPrefix "off_" . cpatNmNm $ pn
               in   case o of
                      CExpr_Int _  -> (b,[])
                      _            -> (CPatBind_Bind l (CExpr_Var offNm) n p,[CBind_Bind offNm o])
       )
%%]

%%[8
ATTR AllPatExpr [ | | patCRest: CPatRest ]

SEM RecPatExpr
  | Empty       lhs         .   patCRest    =   CPatRest_Empty
  | Ext         lhs         .   patCRest    =   @recPatExpr.patCRest

SEM PatExpr
  | Var         lhs         .   patCRest    =   CPatRest_Var @nm
  | * - Var     lhs         .   patCRest    =   CPatRest_Empty
%%]

%%[8
ATTR AllPatExpr [ | | fsCPatL: FieldSplitL ]

SEM RecPatExpr
  | Empty       lhs         .   fsCPatL     =   []
  | Ext         lhs         .   fsCPatL     =   (@nm,(@offset,@patExpr.cpat)) : @recPatExpr.fsCPatL

SEM PatExpr
  | App         lhs         .   fsCPatL     =   (hsnUnknown,(CExpr_Int 0,@arg.cpat)) : @func.fsCPatL
  | AppTop      loc         .   fsCPatL     =   @patExpr.fsCPatL
  | Rec         loc         .   fsCPatL     =   @recPatExpr.fsCPatL
  | Con         loc         .   fsCPatL     =   []
  | * - App Con
                lhs         .   fsCPatL     =   []
%%]

%%[8
SEM RecPatExpr
  | Ext         loc         .   offset      =   CExpr_Int (tyRecOffset @nm (@lhs.finTyCnstr |=> @recPatExpr.ty))
%%]

%%[10
SEM RecPatExpr
  | Ext         loc         .   offset      :=  @lhs.cSubst `cAppSubst` CExpr_Hole @prUid
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Reorder record Field Update (to sorted on label, upd's first, then ext's)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs
type FieldUpdateL e = AssocL HsName e

rfuReorder :: [HsName] -> FieldUpdateL CExpr -> ([CExpr],FieldUpdateL (CExpr -> CExpr))
rfuReorder nL fuL
  =  let  (fuL',offL,_)
            =  foldl
                 (\(fuL,offL,exts) (n,(lbl,f))
                     ->  let  mkOff lbl exts o
                                =  let nrSmaller = length . filter (\e -> rowLabCmp e lbl == LT) $ exts
                                   in  if nrSmaller == 0 then o else mkCExprAddInt o (CExpr_Int (-nrSmaller))
                              o' = CExpr_Var n
                         in   case f of
                                 CExpr_TupIns _ t l o e -> ((l,True,\r -> CExpr_TupIns r t l o' e) : fuL,(mkOff l exts o):offL,l:exts)
                                 CExpr_TupUpd _ t l o e -> ((l,False,\r -> CExpr_TupUpd r t l o' e) : fuL,(mkOff l exts o):offL,exts)
                 )
                 ([],[],[])
            .  zip nL
            $  fuL
          cmpFU (n1,_,_    )  (n2,_,_    )                          = rowLabCmp n1 n2
     in   (offL, map (\(n,_,fu) -> (n,fu)) . sortBy cmpFU $ fuL')
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Gathering coercions/cexpr for app args for optimization by weaving above apptop
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[9
ATTR Expr [ | | appArgCoeL: {[Coe]} ^^ appFunCExpr: CExpr ]

SEM Expr
  | App AppImpl
                lhs         .   appArgCoeL      =   @func.appArgCoeL ++ @appImplsCoeL ++ [mkAppCoe emptyCBindLMap [@arg.cexpr]]
                            .   appFunCExpr     =   @func.appFunCExpr
  | AppTop      lhs         .   (appArgCoeL,appFunCExpr)
                                                =   if null @lamArgCoeL
                                                    then (@expr.appArgCoeL,@expr.appFunCExpr)
                                                    else ([],@cexpr)
  | * - App AppImpl AppTop
                lhs         .   appArgCoeL      =   []
                            .   appFunCExpr     =   @cexpr
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Decl
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR Decls Decl AllDataConstr [ | | cbindL, ffiCBindL USE {++} {[]}: CBindL ]

SEM Decl
  | Val         lhs         .   cbindL          =   [CBind_Bind @patExpr.topNm @expr.cexpr] ++ @patExpr.cbindL
  | TySig       lhs         .   cbindL          =   []
  | FFI         lhs         .   ffiCBindL       =   [CBind_FFI @callconv @safety @impEnt @nm @sigTy]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Let bindings + body separately
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR Expr [ | | letCBindL: {[(CBindCateg,CBindL)]} ^^ letCBody: CExpr ]

SEM Expr
  | Let         lhs         .   letCBody        =   @body.letCBody
                            .   letCBindL       =   @letCBindL ++ @body.letCBindL
  | * - Let     lhs         .   letCBody        =   @cexpr
                            .   letCBindL       =   []
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Class
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[9 hs
cdictOffset :: HsName -> Ty -> CExpr
cdictOffset n r = CExpr_Int . tyRecOffset n $ r
%%]

%%[9
SEM Decl
  | Class       lhs         .   cbindL      =   let  nDflt = rulNmEvid . pigiRule $ @pigi
                                                     nD = hsnPrefix "$self_" nDflt
                                                     nR = hsnPrefix "$res_" nDflt
                                                     lookupBnd n = let b = map (\(CBind_Bind n v) -> (n,v)) @decls.cbindL
                                                                   in  lookup n b
                                                     dDflt = mkCExprLam [nD]
                                                                (mkCExprLetRec
                                                                    [CBind_Bind nR
                                                                        (mkCExprApp (CExpr_Tup CTagRec)
                                                                            (map (\(n,_) -> maybe cvarUndefined id (lookupBnd n)) . tyRowCanonOrder . snd . tyRecExts $ @clsTyRec))]
                                                                    (CExpr_Var nR)
                                                                )
                                                     x = HNm "x"
                                                     vx = CExpr_Var x
                                                     mkSel n = mkCExprSelCase emptyRCEEnv (hsnSuffix x "!") vx CTagRec n n (cdictOffset n @clsTyRec)
                                                in   [CBind_Bind nDflt dDflt]
                                                     ++ [ CBind_Bind n (x `CExpr_Lam` (mkSel n `CExpr_App` vx))
                                                        | (n,_) <- @clsFldL
                                                        ]
%%]

                            .   cexpr           =   let  [n1,n2] = map uidHNm . mkNewUIDL 2 $ @lUniq
                                                    in   mkCExprSelCase (RCEEnv @lhs.valGam @lhs.tyGam) n1 @expr.cexpr CTagRec n2 @lbl @offset


                                                     mkSel n = mkCExprSelCase emptyRCEEnv (hsnSuffix x "!") vx CTagRec n n (cdictOffset n @clsTyRec)
                                                in   [CBind_Bind nDflt dDflt]
                                                     ++ [ CBind_Bind n (x `CExpr_Lam` (mkSel n `CExpr_App` vx))
                                                        | (n,_) <- @clsFldL
                                                        ]

                                                     mkSel n = mkCExprSelCase emptyRCEEnv (hsnSuffix x "!") vx CTagRec n n (cdictOffset n @clsTyRec)
                                                in   [CBind_Bind nDflt dDflt]
                                                     ++ [ CBind_Bind n (x `CExpr_Lam` (CExpr_TupSel vx CTagRec (cdictOffset n @clsTyRec) `CExpr_App` vx))
                                                        | (n,_) <- @clsFldL
                                                        ]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Instance
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[9
SEM Decl
  | Instance    lhs         .   cbindL      =   let  nDflt = rulNmEvid . pigiRule $ @pigi
                                                     nR = hsnPrefix "$res_" @dictNm
                                                     nStrictR = hsnSuffix nR "!"
                                                     mkSet d n v = CExpr_TupUpd d CTagRec n (cdictOffset n . head $ @recTyL) v
                                                     dDflt = foldr
                                                                (\(n,e) d -> mkSet d n e)
                                                                (CExpr_App (CExpr_Var nDflt) (CExpr_Var nR))
                                                                (zip @supClsNmL @supEvidL)
                                                     mkSetFlds d bs = foldr (\(CBind_Bind n v) d -> mkSet d n v) d bs
                                                     dD = mkCExprLam @ctxtArgNmL
                                                                (mkCExprLetRec
                                                                    ([CBind_Bind nR
                                                                        (mkCExprStrictIn nStrictR dDflt (\d -> mkSetFlds d @decls.cbindL))]
                                                                     ++ mkCBindLForUIDL (@prfCBindLMap `plusFM` @supPrfCBindLMap) (const True))
                                                                    (CExpr_Var nR)
                                                                )
                                                in   [CBind_Bind @dictNm (@cSubst `cAppSubst` dD)]
  | InstanceIntro
                lhs         .   cbindL      =   [CBind_Bind @dictNm @expr.cexpr]
%%]

mkCExprStrictIn :: HsName -> CExpr -> (CExpr -> CExpr) -> CExpr
mkCExprStrictIn nm e mkC = CExpr_Let CBindStrict [CBind_Bind nm e] (mkC (CExpr_Var nm))


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Case
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR CaseAlt [ | | calt: CAlt ]
ATTR CaseAlts [ | | caltL: CAltL ]

SEM CaseAlt
  | Pat         lhs         .   calt        =   CAlt_Alt [@patExpr.cpat] @expr.cexpr

SEM CaseAlts
  | Nil         lhs         .   caltL       =   []
  | Cons        lhs         .   caltL       =   @hd.calt : @tl.caltL
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Pat for use in (recursive) let bindings (lazy unpacking)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs
mkCExprSelCase :: RCEEnv -> HsName -> CExpr -> CTag -> HsName -> HsName -> CExpr -> CExpr
mkCExprSelCase env ne e ct n lbl off
  =  let  alt = CAlt_Alt
                    [CPat_Con (CPatNmOrig ne) ct (CPatRest_Var hsnWild)
                        [CPatBind_Bind lbl off n (CPat_Var (CPatNmOrig n))]]
                    (CExpr_Var n)
     in   mkCExprLet CBindPlain [CBind_Bind ne e]
            (rceMatch env [ne] [alt] cvarUndefined)
%%]
mkCExprSelCase :: RCEEnv -> HsName -> CExpr -> CTag -> HsName -> HsName -> CExpr -> CExpr
mkCExprSelCase env ne e ct n lbl off
  =  let  alt = CAlt_Alt
                    [CPat_Con (CPatNmOrig ne) ct (CPatRest_Var hsnWild)
                        [CPatBind_Bind lbl off n (CPat_Var (CPatNmOrig n))]]
                    (CExpr_Var n)
     in   mkCExprLet CBindStrict [CBind_Bind ne e]
            (rceMatch env [ne] [alt] cvarUndefined)

%%[8
ATTR AllPatExpr [ | | cbindL USE {++} {[]}: CBindL ]
ATTR AllPatExpr [ ceParentNm: HsName | | ]

SEM PatExpr
  | AppTop Rec  loc         .   cbindL      =   concat
                                                .  map  (\(CPatBind_Bind l o _ p)
                                                            -> let  b n = [CBind_Bind n (mkCExprSelCase (RCEEnv @lhs.valGam @lhs.tyGam) pn' (CExpr_Var pn) @tag n l o)]
                                                                          where pn = @lhs.ceParentNm
                                                                                pn' = hsnSuffix pn "!"
                                                               in   case cpatVarNm p of
                                                                        CPatNmOrig n                          -> b n
                                                                        CPatNmUniq n | not (null @cbindLSub)  -> b n
                                                                        _                                     -> []
                                                        )
                                                $  @cpatBinds
                lhs         .   cbindL      =   @cbindL ++ @cbindLSub
  | AppTop      loc         .   cbindLSub   =   @patExpr.cbindL
  | Rec         loc         .   cbindLSub   =   @recPatExpr.cbindL
  | App         arg         .   ceParentNm  =   cpatNmNm (cpatVarNm @arg.cpat)

SEM RecPatExpr
  | Ext         patExpr     .   ceParentNm  =   cpatNmNm (cpatVarNm @patExpr.cpat)

SEM Decl
  | Val         patExpr     .   ceParentNm  =   @patExpr.topNm

SEM CaseAlt
  | Pat         patExpr     .   ceParentNm  =   @patExpr.topNm

SEM Expr
  | Lam         arg         .   ceParentNm  =   @arg.topNm
%%]

%%[9
SEM Expr
  | LamImpl     arg         .   ceParentNm  =   @arg.topNm
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Reordering of Case Expression (RCE)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs
data RCEEnv = RCEEnv {rceValGam :: ValGam, rceTyGam :: TyGam}

emptyRCEEnv :: RCEEnv
emptyRCEEnv = RCEEnv emptyGam emptyGam

rceEnvDataAlts :: RCEEnv -> CTag -> [CTag]
rceEnvDataAlts env t
  =  case t of
       CTag _ _ conNm
          ->  case valGamLookup conNm . rceValGam $ env of
                Just vgi
                   ->  let  tyNm = tyAppFunConNm . snd . tyArrowArgsRes . vgiTy $ vgi
                       in   maybe [] (assocLElts . fmToList . tgiDataTagMp) . tyGamLookup tyNm . rceTyGam $ env
                _  ->  []
       _  ->  []
%%]

%%[8 hs
rceSplit :: (CAlt -> Bool) -> CAltL -> [CAltL]
rceSplit f []   = []
rceSplit f [x]  = [[x]]
rceSplit f (x:xs@(x':_))
  | f x == f x'  =  let  (z:zs) = rceSplit f xs
                    in   (x:z) : zs
  | otherwise    =  [x] : rceSplit f xs

rceRebinds :: HsName -> CAltL -> CBindL
rceRebinds nm alts = [ CBind_Bind n (CExpr_Var nm) | (CPatNmOrig n) <- caltLPatNms alts, n /= nm ]

rceMatchVar :: RCEEnv ->  [HsName] -> CAltL -> CExpr -> CExpr
rceMatchVar env (arg:args') alts ce
  =  let  remMatch  = rceMatch env args' [CAlt_Alt remPats e | (CAlt_Alt (CPat_Var n : remPats) e) <- alts] ce
     in   mkCExprLet CBindPlain (rceRebinds arg alts) remMatch

rceMatchCon :: RCEEnv -> [HsName] -> CAltL -> CExpr -> CExpr
rceMatchCon env args@(arg:args') alts ce
  =  let  arg'   =  hsnSuffix arg "!"
          sortAltsOnTag = sortBy (\a1 a2 -> caltTag a1 `compare` caltTag a2)
          mkAltAndSubAlts alts
            =  let  (subAlts,subAltSubNms)
                      =  unzip
                           [ (CAlt_Alt (pats ++ ps) e, map (cpatNmNm . cpatVarNm) pats)
                           | (CAlt_Alt (CPat_Con _ _ _ pbinds : ps) e) <- alts,
                             let pats = [ p | (CPatBind_Bind _ _ _ p) <- pbinds ]
                           ]
                    subMatch
                      =  rceMatch env (head subAltSubNms ++ args') subAlts ce
                    (altPat,altOffBL)
                      =  case head alts of
                           CAlt_Alt (CPat_Con n t r pbL : _) _
                             ->  (CPat_Con n t r pbL3,offBL)
                                 where  pbL2 = [ CPatBind_Bind l o n (CPat_Var (cpatVarNm p))| (CPatBind_Bind l o n p) <- pbL ]
                                        (pbL3,offBL) = patBindLOffset pbL2
                                        
               in   (CAlt_Alt [altPat] (mkCExprLet CBindPlain (rceRebinds arg' alts) subMatch),concat altOffBL)
          (alts',(altOffBL:_))
            =  unzip . map mkAltAndSubAlts
            .  groupBy (\a1 a2 -> caltTag a1 == caltTag a2) . sortAltsOnTag
            .  filter (not . null . caltPatL) $ alts
          altTags = [ t | (CAlt_Alt (CPat_Con _ t _ _ : _) _) <- alts' ]
          absentTagArities = filter (\t -> t `notElem` altTags) . rceEnvDataAlts env . head $ altTags
          absentAlts
                 =  [ CAlt_Alt [mkP ct a] ce | ct@(CTag _ a _) <- absentTagArities ]
                 where  mkB o = CPatBind_Bind hsnUnknown (CExpr_Int o) (cpatNmNm cpatNmNone) (CPat_Var cpatNmNone)
                        mkP ct a = CPat_Con cpatNmNone ct CPatRest_Empty [mkB o | o <- [0..a-1]]
     in   mkCExprStrictIn arg' (CExpr_Var arg)
            (\n -> mkCExprLet CBindStrict altOffBL (CExpr_Case n (sortAltsOnTag (alts' ++ absentAlts)) ce))

rceMatchVarCon :: RCEEnv -> [HsName] -> CAltL -> CExpr -> CExpr
rceMatchVarCon env args alts@(alt:_) ce
  |  caltIsVar alt  = rceMatchVar env args alts ce
  |  otherwise      = rceMatchCon env args alts ce

rceMatch :: RCEEnv -> [HsName] -> CAltL -> CExpr -> CExpr
rceMatch _ [] []    ce =  ce
rceMatch _ [] alts  ce
  =  case [ e | (CAlt_Alt [] e) <- alts ] of
       (e:_)  -> e
       _      -> ce
rceMatch env args alts ce
  =  foldr
        (\alts e
           ->  case e of
                  CExpr_Var _
                     ->  rceMatchVarCon env args alts e
                  _  ->  let  bnm = hsnPrefix "_casecont_" (cpatNmNm . cpatVarNm . caltPat . head $ alts)
                              vc = rceMatchVarCon env args alts (CExpr_Var bnm)
                         in   mkCExprLet CBindPlain [CBind_Bind bnm e] vc
        )
        ce
     $ (rceSplit caltIsVar alts)
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Data
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR AllDataConstr [ dataAltTy: Ty | | ]

SEM DataConstr
  | Constr      lhs         .   cbindL      =   let  len = length @fields.tyL
                                                     nms = map (\i -> HNm ("x" ++ show i)) [1..len]
                                                in   [CBind_Bind @conNm
                                                        (mkCExprLam nms
                                                          (mkCExprApp (CExpr_Tup @ctag)
                                                            (map CExpr_Var nms)))
                                                     ]
%%]

