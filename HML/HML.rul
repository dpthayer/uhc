{
{-# LANGUAGE BangPatterns          #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE TypeSynonymInstances  #-}
module HML where

import Control.Monad.Error
import Pretty   
import qualified Data.Map as M
import Control.Monad
import Control.Arrow hiding (app)
import Control.Applicative((<$>))

import Data.List
import Data.Maybe hiding (mapMaybe)

import EH8.EH
import EH8.Base.HsName
import EH8.Ty(tyQu_Forall)

import EqHML

import EH.Util.Pretty hiding (pp, empty)
import qualified Debug.Trace as D

-- | Create a HsName from a string.
mkName :: String -> HsName
mkName = mkHNmBase -- id

-- type Prefix  = [TyIndex]
-- type HsName  = String
-- type Env     = M.Map HsName TyScheme
type Sub     = (HsName, TyScheme)
type ErrorMessage = String
newtype Gamma = Gamma { unGam :: Env }

-- | Remove entries from a Env based on their key
remove :: Env -> [HsName] -> Env
remove env entries = foldl (.) id (map rm entries) env

-- | Filter a prefix based on the bounds and not the variable
elide :: Prefix -> TyQuantifiedScheme -> Prefix
elide []     _     = []
elide (x:xs) bound = case x of 
                       TyIndex_Group _ b | b == bound -> elide xs bound
                       _ -> x : elide xs bound

-- | Split domains
split :: (Prefix, [HsName]) -> (Prefix, Prefix)
split (a ,[])      = ([], a)
split ([], _)      = ([], [])
split ((p@(TyIndex_Group var phi):q), vars) 
 = case var `elem` vars of
     True  -> let fvars = case phi of
                            TyScheme_Quant _ phi' -> ftv phi'
                            _                     -> []
                  (q1, q2) = split (q, (var `delete` vars) ++ fvars)
              in (p:q1, q2)
     False -> let (q1, q2) = split (q, vars)
              in (q1, p:q2)
          
-- | Helper functions to make the convertion from map to list easier          
mapMaybe = \v -> map (id *** \a -> (maybe a id (v a)))
empty = []
rm :: Eq k => k -> [(k, v)] -> [(k, v)]
rm _ [] = []
rm k1 (x@(k,v):xs) | k1 == k   = rm k1 xs
                       | otherwise = x : rm k1 xs

-- | Apply a set of substitution to an environment
apply :: Env -> Gamma -> Either Gamma [ErrorMessage]
apply sub env 
  = let lst  = map (mapMaybe . app) sub
        set  = foldl' (.) id lst
    in Left (Gamma $ set $ unGam env)
    
instance Apply Gamma where
   app s   gam = case apply [s] gam of
                  Left e  -> Just e
                  Right _ -> Nothing
   appAll e gam = case apply e gam of
                   Left e  -> Just e
                   Right _ -> Nothing
                   
instance Util Gamma where
    ftv  _ = []
    vars _ = []
    
-- | Apply a substitution
createMask :: Sub -> (TyExpr -> Maybe TyExpr)
createMask (nm, ty) = mask
 where rep :: TyExpr -> Maybe TyExpr
       rep val = case isTyVar val nm of
                   False -> return val
                   True  -> let ty' = strip ty
                            in return $ mkParens ty'
                   
       strip :: TyScheme -> TyExpr
       strip (TyScheme_SystemF  a) = a
       strip (TyScheme_Quant  _ a) = strip a
       strip (TyScheme_Sugar  _ a) = strip a
       strip (TyScheme_Forall _ a) = strip a
       strip TyScheme_Bottom       = error "A value of Bottom cannot be stripped."
                   
       mask :: TyExpr -> Maybe TyExpr
       mask val = case val of
                    TyExpr_App a b -> 
                      do a' <- mask a
                         b' <- mask b
                         return $ TyExpr_App a' b'
                    TyExpr_AppTop a ->
                      do a' <- mask a
                         return $ TyExpr_AppTop a'
                    TyExpr_Parens a ->
                      do a' <- mask a
                         return $ TyExpr_Parens a'
                    TyExpr_Ann a b ->
                      do b' <- mask b
                         return $ TyExpr_Ann a b'
                    TyExpr_Quant a b c ->
                      do c' <- mask c
                         return $ TyExpr_Quant a b c'
                    var@(TyExpr_Var{}) ->
                      do rep var
                    x -> rep x
       
class Eq a => Normal a where
  nf :: a -> a
  isNf :: a -> Bool
  isNf x = nf x == x
  
class Util a => Apply a where
  app    :: Sub -> a -> Maybe a
  appAll :: Env -> a -> Maybe a
  appAll env a = foldl (>=>) return (map app env) a
  
instance Apply a => Apply [a] where
  app s = return . catMaybes . map (app s)
  
class Util a where
  ftv  :: a -> [HsName]
  vars :: a -> [HsName]
  
  isTyVar :: a -> HsName -> Bool
  isTyVar _ _ = False
  
  isUnQualTy :: a -> Bool
  isUnQualTy = const False
  
-- | Conditionally add Parenthesis around expressions that contain any kind of Application.
--   They are most likely higher order, and if they weren't meant to be, the simplifier would take care of it
mkParens :: TyExpr -> TyExpr
mkParens x@(TyExpr_App{}) = TyExpr_Parens x
mkParens x                = x

-- | Wraps a AppTop around the right places
mkTop :: TyExpr -> TyExpr
mkTop a = if noArr a then a else TyExpr_Parens $ TyExpr_AppTop a
  
instance Util a => Util [a] where
  ftv  = concatMap ftv
  vars = concatMap vars
  
  isTyVar x nm = and (map (flip isTyVar nm) x)
  
  isUnQualTy = and . map isUnQualTy
  
instance Apply TyExpr where
    app = createMask
    
instance Apply TyIndex where
    app s (TyIndex_Group nm a) = TyIndex_Group nm <$> app s a
  
instance Util TyExpr where
    ftv (TyExpr_App     a b) = ftv a ++ ftv b
    ftv (TyExpr_AppTop    a) = ftv a
    ftv (TyExpr_Parens    a) = ftv a
    ftv (TyExpr_Ann     _ a) = ftv a
    ftv (TyExpr_Var       a) = [a]
    ftv (TyExpr_VarWild   a) = [a]
    ftv (TyExpr_Quant _ a b) = (nub $ ftv b) \\ [a]
    ftv                    _ = []
    
    vars (TyExpr_App     a b) = vars a ++ vars b
    vars (TyExpr_AppTop    a) = vars a
    vars (TyExpr_Parens    a) = vars a
    vars (TyExpr_Ann     _ a) = vars a
    vars (TyExpr_Var       a) = [a]
    vars (TyExpr_VarWild   a) = [a]
    vars (TyExpr_Quant _ a b) = (nub $ vars b)
    vars                    _ = []

    isTyVar (TyExpr_Var nm) hsnm = hsnm == nm
    isTyVar _ _                  = False
    
    isUnQualTy (TyExpr_Quant{})  = False
    isUnQualTy (TyExpr_Parens a) = isUnQualTy a
    isUnQualTy (TyExpr_AppTop a) = isUnQualTy a
    isUnQualTy _                 = True 
    
-- instance Apply TyQuantifiedScheme where
    -- app m (TyQuantifiedScheme_Quant i s) = TyQuantifiedScheme_Quant i <$> app m s
    -- app _ TyQuantifiedScheme_Bottom      = return TyQuantifiedScheme_Bottom
  
instance Apply TyScheme where
    app tp@(x1,x2) = mask
         where          
           mask :: TyScheme -> Maybe TyScheme
           mask val = case val of
                        TyScheme_Quant a b -> 
                          do b' <- app tp b
                             return $ TyScheme_Quant a b'
                        TyScheme_SystemF a ->
                          do a' <- app tp a
                             return $ TyScheme_SystemF a'
                        TyScheme_Forall a b -> -- This will only work top level
                          do b' <- app tp b
                             return $ TyScheme_Forall (sort $ replace (x1,head $ ftv x2) a) b'
                        _                  -> return val
                        
-- | Replace every occurence of a value in a list with another value. Preserving ordering
replace :: Eq a => (a,a) -> [a] -> [a]
replace   (_,_) [] = []
replace p@(a,b) (x:xs) |  a == x   = b:replace p xs
                       | otherwise = x:replace p xs
                        
-- munion a b = let f = map (uncurry minsert)
                 -- xs = f a ++ f b
             -- in foldl' (.) id xs []
munion = (++)

minsert k v []  = [(k,v)]
minsert k v (x@(k',v'):xs) | k == k'   = (k, v):xs
                           | otherwise = x : minsert k v xs

instance Util TyScheme where
    ftv TyScheme_Bottom       = []
    ftv (TyScheme_SystemF  a) = ftv a
    ftv (TyScheme_Quant (Scheme_Simple a ph1) ph2) 
      = let f2 = nub $ ftv ph2
        in case a `elem` f2 of
             True  -> (nub $ ftv ph1) ++ (a `delete` f2)
             False -> f2
    ftv b@(TyScheme_Sugar{}) = ftv (desugar b)
    ftv (TyScheme_Forall a b) = (ftv b) \\ a
    
    vars TyScheme_Bottom       = []
    vars (TyScheme_SystemF  a) = vars a
    vars (TyScheme_Quant  a b) = nub $ vars b
    vars (TyScheme_Sugar  _ b) = vars b
    vars (TyScheme_Forall a b) = vars b

    isTyVar (TyScheme_SystemF a) hnm = isTyVar a hnm
    isTyVar  _ _                     = False
    
    isUnQualTy (TyScheme_SystemF a) = isUnQualTy a
    isUnQualTy _                    = False  

-- instance Util TyQuantifiedScheme where
  -- ftv  (TyQuantifiedScheme_Quant a b) = (nub $ ftv b) \\ (ftv a)
  -- ftv  _                              = []
  -- vars (TyQuantifiedScheme_Quant a b) = nub $ (vars b) ++ (vars a)
  
instance Util TyIndex where
  ftv  (TyIndex_Group nm a) = (nub $ ftv a) \\ [nm]
  vars (TyIndex_Group nm a) = nm : vars a
    
instance Util Scheme where
    ftv (Scheme_Simple a b) = a : ftv b
    vars (Scheme_Simple a b) = a : vars b
  
instance Normal TyScheme where
  nf (TyScheme_Quant (Scheme_Simple a phi1) phi2)
       | a `notElem` (ftv phi2) = nf phi2
       | isTyVar (nf phi2) a    = nf phi1
       | isUnQualTy (nf phi1)   = let x = app (a, p) phi2
                                      p = nf phi1
                                  in maybe (error "Substitution failed in Normal for UnQualTy") nf x
       | otherwise              = TyScheme_Quant (Scheme_Simple a (nf phi1)) (nf phi2)
  nf a = a 

instance Normal TyExpr where
  nf = id
  
class Domain a where
  domain   :: a -> [HsName]
  codomain :: a -> [HsName]
  
instance Domain a => Domain [a] where
  domain   = concatMap domain
  codomain = concatMap codomain
  
instance (Domain a, Domain b) => Domain (a, b) where
  domain   = domain . fst
  codomain = codomain . snd
  
instance Domain HsName where
  domain   = return
  codomain = return
  
instance Domain TyScheme where
  domain   = nub . ftv
  codomain = nub . ftv 
  
instance Domain TyIndex where
  domain   (TyIndex_Group a _) = return a
  codomain (TyIndex_Group _ a) = ftv a
  
-- instance Domain Env where
  -- domain   = M.keys
  -- codomain = concatMap ftv . M.Elems
  
instance Domain Scheme where
  domain   (Scheme_Simple a _) = [a]
  codomain (Scheme_Simple _ a) = nub $ vars a
  
-- | Updating a prefix
update :: (Prefix, Either Scheme Sub) -> (Prefix, Env)
update (q, Right (a, p))
  = let (q0, (q1,q2)) = id *** (`splitOn` a) $ split (q, ftv p)
        q2' = case app (a,p) (safeTail q2) of
               Nothing -> error "Update failed. Could not apply substitution"
               Just ax -> D.trace (   "** Var:" ++ pp a
                                   ++ "\n** Q1 :" ++ pp q1
                                    ++ "\n** Q2 :" ++ pp q2) ax
    in  (q0 ++ q1 ++ q2', [(a,p)])
update (q, Left (Scheme_Simple var phi2))
  = let (q0, (q1,q2)) = id *** (`splitOn` var) $ split (q, ftv phi2)
        p   = nf phi2       
        q2' = case app (var,p) (safeTail q2) of
               Nothing -> error "Update failed. Could not apply substitution"
               Just ax -> ax
    in case isUnQualTy p of
         True  -> (q0 ++ q1 ++ q2', [(var, p)])
         False -> (q0 ++ q1 ++ (TyIndex_Group var (promote phi2):(safeTail q2)) ,empty)
        
safeTail :: [a] -> [a]
safeTail []     = []
safeTail (x:xs) = xs
        
-- | Split a prefix based on a variable
splitOn :: Prefix -> HsName -> (Prefix, Prefix)
splitOn [] _ 
  = ([], [])
splitOn (x@(TyIndex_Group v1 _):xs) v2
  = case v1 == v2 of
      True  -> ([],x:xs)
      False -> let (a,b) = splitOn xs v2
               in (x:a, b)
  
-- | Extending a Prefix with a Scheme
extend :: (Prefix, Scheme, Int) -> Bool -> ((Prefix, Env), Int)
extend (q, scheme@(Scheme_Simple var phi), frs) ren
 = let p = nf phi
   in case isUnQualTy p of
        True  -> ((q, [(var, p)]), frs)
        -- TyScheme_Quant s t   -> case s of
                                 -- Scheme_Simple v t' 
                                   -- -> let s' = Scheme_Simple var t'
                                          -- (Just tx) = app (v, mkVar var) t
                                          -- ty = TyScheme_Quant s' tx
                                      -- in ((q++[TyIndex_Group var (promote ty)], empty), frs)
        -- _  -> case sweep p of
               -- (schemes, ph2) | not (null schemes) ->
                  -- let (varsc, frs') = freshM frs (length schemes)
                      -- env           = zipWith (\a b-> (a, mkVar b)) (domain schemes) varsc
                      -- (Just ph2')   = appAll (M.fromAscList env) ph2
                      -- pre           = q ++ [TyIndex_Group v (promote p) | (v, p) <- zipWith (\a (Scheme_Simple _ x)->(a, x)) varsc schemes ]
                  -- in ((pre, M.fromAscList [(var, ph2')]), frs')
        _     -> let (ph2, frs', subs) = if ren 
                                            then renameVars frs phi
                                            else (phi, frs,[])
                 in D.trace ("@" ++ pp var ++ " == " ++ pp phi ++ " -- " ++ sche phi ++ " -- " ++ pp (promote ph2) ++ " @ " ++ pp subs) ((q++[TyIndex_Group var (promote ph2)], subs), frs')

renameVars :: Int -> TyScheme -> (TyScheme, Int, Env)
renameVars frs ty 
 = (fc ty, frs', env)
  where
    fc (TyScheme_Quant (Scheme_Simple a b) c) = TyScheme_Quant (Scheme_Simple (ren a) (fc b)) (fc c)
    fc (TyScheme_SystemF exp) = let -- (Just a) = appAll env exp
                                     a = fullRename env' exp
                                in  TyScheme_SystemF a
    fc TyScheme_Bottom        = TyScheme_Bottom
    fc (TyScheme_Sugar a b)   = TyScheme_Sugar (map fi a) (fc b)
    fc (TyScheme_Forall a b)  = TyScheme_Forall (map ren a) (fc b)
   
    fi (TyIndex_Group a d) 
       = let d' = case d of
                   TyScheme_Quant (Scheme_Simple a b) c -> TyScheme_Quant (Scheme_Simple (ren a) (fc b)) (fc c)
                   TyScheme_Bottom    -> TyScheme_Bottom
         in TyIndex_Group (ren a) d'
    vc         = vars ty
    (nvc,frs') = freshM frs (length vc)
    env        = zipWith (\a b->(a, mkVar b)) vc nvc
    env'       = zipWith (\a b->(a, b)) vc nvc
    ren x      = maybe x id $ lookup x env'
    
-- | Fully rename a TyExpr's variables. ALL variables, not just those that are bound
fullRename ::  [(HsName, HsName)] -> TyExpr -> TyExpr
fullRename env = rename
 where 
   rename :: TyExpr -> TyExpr
   rename (TyExpr_App      f a) = TyExpr_App (rename f) (rename a)
   rename (TyExpr_AppTop     a) = TyExpr_AppTop (rename a)
   rename (TyExpr_Parens     a) = TyExpr_Parens (rename a)
   rename (TyExpr_Ann      a t) = TyExpr_Ann a (rename t)
   rename (TyExpr_Var        a) = TyExpr_Var $ ren a
   rename (TyExpr_VarWild    a) = TyExpr_Var $ ren a
   rename (TyExpr_Quant  q v t) = TyExpr_Quant q (ren v) (rename t)
   rename (TyExpr_Forall q v t) = TyExpr_Forall q (map ren v) (rename t)
   rename e = e
   
   ren a = maybe a id $ lookup a env
   
-- | Collects all the schemes for TyScheme_Quant
sweep :: TyScheme -> ([Scheme], TyScheme)
sweep (TyScheme_Quant a p) 
  = let (s,r) = sweep p
    in  (a:s, r)
sweep x = ([], x)
        
-- | Checks a prefix to see if it has a binding for a variable and select it
contains :: Prefix -> HsName -> Maybe TyQuantifiedScheme
contains pref name = msum $ map (\(TyIndex_Group nm b) -> guard (nm == name) >> return b) pref

-- | Drop a quantification from a TyQuantifiedScheme
dropQuant :: TyQuantifiedScheme -> TyScheme
dropQuant = id
-- dropQuant (TyScheme_Quant b t) = desugar $ TyScheme_Sugar [b] t
-- dropQuant TyScheme_Bottom      = TyScheme_Bottom

-- | Split a quantifier of a TyScheme
splitQuant :: TyScheme -> (Prefix, TyScheme)
splitQuant ty = let TyScheme_Sugar q t = sugar ty
                in (q, t)

-- | Drop a TyScheme to a TyExpr
dropScheme :: TyScheme -> TyExpr
dropScheme (TyScheme_SystemF a) = a
dropScheme (TyScheme_Quant{}  ) = error "Cannot drop a Quant to a TyExpr"
dropScheme (TyScheme_Sugar{}  ) = error "Cannot drop a Sugar to a TyExpr"
dropScheme (TyScheme_Forall{} ) = error "Cannot drop a Forall to a TyExpr"
dropScheme TyScheme_Bottom      = error "Cannot drop a _|_ to a TyExpr"

-- | Collect the LHS bindings (Names)
getBindLHs :: Decls -> [HsName]
getBindLHs = concatMap getBindLH
 where getBindLH :: Decl -> [HsName]
       getBindLH (Decl_Val p _) = getB p
       getBindLH _              = []
       
       getB :: PatExpr -> [HsName]
       getB (PatExpr_Var a) = [a]
       getB _               = []
      
-- | Promote/Convert a Type Scheme to a quantified type scheme. 
--   This greatly influences the types. Might need to be reconsidered and checked 
--   to see if we can simplify the types generates
promote :: TyScheme -> TyQuantifiedScheme
promote TyScheme_Bottom                            = TyScheme_Bottom
promote (TyScheme_Quant (Scheme_Simple nm ty) ty') = TyScheme_Quant (Scheme_Simple nm (promote ty)) ty'
promote (TyScheme_SystemF x)                   
  = embedF x
promote (TyScheme_Sugar{})                         = error "TyScheme_Sugar cannot be promoted. It's purely syntaxtical sugar. Please call desugar before that"

-- | Represent a SystemF type as a flexible type, This is not implemented for higher rank types yet
embedF :: TyExpr -> TyScheme
embedF = embed id
 where embed :: (TyScheme -> TyScheme) -> TyExpr -> TyScheme
       embed val (TyExpr_Quant  _ a t) = let e = TyScheme_Quant (Scheme_Simple a TyScheme_Bottom)
                                         in  embed (val . e) t
       embed val (TyExpr_Forall _ v t) = let e = foldl' (.) id [ TyScheme_Quant (Scheme_Simple a TyScheme_Bottom) | a <- v ] 
                                         in  embed (val . e) t
       embed val e                     = val (TyScheme_SystemF e)

-- | Generate a fresh variable and increase the counter
fresh :: Int -> (HsName, Int)
fresh x = (mkName $ "a" ++ show x, x+1)

-- | Generate a list of fresh variables and a new counter
freshM :: Int -> Int -> ([HsName], Int)
freshM s c = fresh' c ([], s)
 where fresh' 0 d     = d
       fresh' c (l,s) = let (n, i) = fresh s
                        in fresh' (c-1) (n:l, i)

-- | Creates an arrow between two types.
--   e.g given type a and b returns the type a -> b or (-> b) a rather
mkArrow :: TyExpr -> TyExpr -> TyExpr
mkArrow a b =  TyExpr_AppTop $ TyExpr_App (TyExpr_App (TyExpr_Con $ mkName "->") a) b

-- | The same as mkArrow except it allows a TyScheme as first argument and resulting type
mkArrowL :: TyScheme -> TyExpr -> TyScheme
mkArrowL a b = 
  case a of
    TyScheme_Quant  c d -> TyScheme_Quant c (mkArrowL d b)
    TyScheme_SystemF  d -> TyScheme_SystemF (d `mkArrow` b)
    TyScheme_Bottom     -> TyScheme_Bottom
    TyScheme_Sugar  p d -> TyScheme_Sugar p (mkArrowL d b)
    TyScheme_Forall q d -> TyScheme_Forall q (d `mkArrowL` b)

mkVar :: HsName -> TyScheme
mkVar = TyScheme_SystemF . TyExpr_Var

mkQVar :: HsName -> TyScheme
mkQVar = mkQuantified . TyExpr_Var

mkSkolem :: HsName -> TyScheme
mkSkolem = TyScheme_SystemF . TyExpr_Con

-- | Desugar a forall Q.phi to (a>=phi1).(b>=phi2).phi etc
--   basically unfolds the type
desugar :: TyScheme -> TyScheme
desugar (TyScheme_Sugar q t) = let bounds = [TyScheme_Quant (Scheme_Simple nm (toScheme b)) | (TyIndex_Group nm b) <- q] 
                               in foldr (.) id bounds t
desugar x = x

-- | Insure that the TyScheme is in a sugared form if possible
sugar :: TyScheme -> TyScheme
sugar (TyScheme_Quant (Scheme_Simple nm b) t) 
    = let q' = TyIndex_Group nm (fromScheme b)
      in case t of
          (TyScheme_SystemF _) -> TyScheme_Sugar [q']   t
          _                    ->
             case sugar t of
              TyScheme_Sugar q t -> TyScheme_Sugar (q':q) t
              x                  -> TyScheme_Sugar [q']   t
sugar (TyScheme_SystemF a) = case mkQuantified a of
                               y@(TyScheme_SystemF {}) -> TyScheme_Sugar [] y
                               x                       -> sugar x
sugar x = x

-- | Convert a Quantified Scheme to a TyScheme such that
--   toScheme . fromScheme == id
toScheme :: TyQuantifiedScheme -> TyScheme
toScheme = id
-- toScheme TyQuantifiedScheme_Bottom                             = TyScheme_Bottom
-- toScheme (TyQuantifiedScheme_Quant (TyIndex_Group nm bound) t) = TyScheme_Quant (Scheme_Simple nm (toScheme bound)) t

-- | Convert a TyScheme to a Quantified Scheme such that
--   toScheme . fromScheme == id
fromScheme :: TyScheme -> TyQuantifiedScheme
fromScheme = id
-- fromScheme TyScheme_Bottom                         = TyQuantifiedScheme_Bottom
-- fromScheme (TyScheme_Quant (Scheme_Simple nm b) t) = TyQuantifiedScheme_Quant (TyIndex_Group nm (fromScheme b)) t

-- | Fully quantify a type based on the type variable it contains.
--   e.g. List a becomes forall (a>=_|_). List a
mkQuantified :: TyExpr -> TyScheme
mkQuantified exp 
  = let vars = [TyScheme_Quant (Scheme_Simple x TyScheme_Bottom) | x <- nub (ftv exp)]
    in  if null vars
           then TyScheme_SystemF exp
           else foldl' (.) id vars (TyScheme_SystemF exp)
           
class Simplify a where
  simplify :: a -> a
  clean    :: a -> a
  
instance (Simplify a, Simplify b) => Simplify (a,b) where
  simplify (k,v) = (simplify k, simplify v)
  clean    (k,v) = (simplify k, clean v)
  
instance Simplify HsName where
  simplify = id
  clean    = id 
  
-- | A strong but inefficient alpha renamer (for pretty printing)
alpha_rename :: TyScheme -> TyScheme
alpha_rename ty 
 = let nvars = map (TyScheme_SystemF . TyExpr_Var . mkName) $ (map (:[]) ['a'..'z']) ++ liftM2 (\b a -> a : show b) [1..] ['a'..'z']
       fvars = sortBy lexord $ nub $ vars ty
       lexord a b = case length (pp a) `compare` length (pp b) of
                     LT -> LT
                     GT -> GT
                     EQ -> a `compare` b
       env   = zip fvars nvars
   in  maybe ty id $ appAll env ty
     
-- | Check to see if a tyScheme is _|_    
isBottom :: TyScheme -> Bool
isBottom TyScheme_Bottom = True
isBottom _               = False
   
instance Simplify TyScheme where           
    -- | Simplify a type scheme for presentation, dropping trivial quantifications
    --   e.g. (a>=_|_) to a, and expanding types.
    --   simplify :: TyScheme -> TyScheme
    simplify exp = let (v, e) = simpl' empty exp
                   in case appAll e v of
                       Just a  -> a
                       Nothing -> v
      where simpl' env s@(TyScheme_Quant scheme ty) 
              = case scheme of
                 Scheme_Simple a TyScheme_Bottom -> let (next, e2) = simpl' env ty
                                                    in case next of
                                                         TyScheme_Forall x ty' -> case a `elem` ftv ty' of
                                                                                    True  -> (TyScheme_Forall (nub $ a:x) ty', e2)
                                                                                    False -> (TyScheme_Forall x ty', e2)
                                                         z                     -> case a `elem` ftv z of
                                                                                    True  -> (TyScheme_Forall [a] z, e2)
                                                                                    False -> (TyScheme_Forall []  z, e2)
                 Scheme_Simple a bounds          -> let (newb, e1) = simpl' env bounds
                                                        env' = (a, newb): e1
                                                    in  case appAll env' ty of
                                                          Nothing -> (s, env')
                                                          Just x  -> let (next, e3) = simpl' env' x
                                                                         newv = nub $ ftv next
                                                                     in case next of
                                                                          TyScheme_Forall x' ty' -> (TyScheme_Forall (nub $ newv++x') ty', e3)
                                                                          z                      -> (TyScheme_Forall newv z, e3)
            simpl' env s@(TyScheme_Sugar{})   = simpl' env (desugar s)
            simpl' env (TyScheme_SystemF exp) = (TyScheme_SystemF (simplify exp), env)
            simpl' env scheme                 = (scheme, env)
    
    clean = alpha_rename . simplify
    
instance Simplify TyExpr where
    -- | Simplify a type expression for presentation. This version just drops superflous parenthesis
    --   simplify :: TyExpr -> TyExpr and wrap things in an AppTop for pretty printing
    simplify = simpl False
      where simpl :: Bool -> TyExpr -> TyExpr
            simpl True  p@(TyExpr_Parens    a) = let x  = noArr a
                                                     p' = TyExpr_Parens (simpl x a)
                                                 in if x then p' else TyExpr_AppTop p'
            simpl False p@(TyExpr_Parens    a) = let x  = noArr a
                                                     a' = simpl True a
                                                 in if x then a' else TyExpr_AppTop a'
            simpl _       (TyExpr_App     a b) = let e1 = noArr a
                                                     e2 = noArr b
                                                 in TyExpr_App (simpl e1 a) (simpl e2 b)
            simpl f       (TyExpr_AppTop    a) = TyExpr_AppTop    (simpl f a)
            simpl f       (TyExpr_Ann     a b) = TyExpr_Ann a     (simpl f b)
            simpl f       (TyExpr_Quant a b c) = TyExpr_Quant a b (simpl f c)   
            simpl _ a                          = a
            
    clean = (\(TyScheme_SystemF a)->a) . alpha_rename . simplify . TyScheme_SystemF

-- | Checks if the expression contains an arrow. False will be returned if it does. This is needed for pretty printing in UHC
noArr :: TyExpr -> Bool
noArr (TyExpr_Con a)    = not $ pp a == "->"
noArr (TyExpr_App a b)  = noArr a && noArr b
-- noArr (TyExpr_AppTop a) = noArr a
noArr (TyExpr_Parens a) = noArr a
noArr _                 = True
            
-- | Checks to see if a pattern expression is a variable or something else
isVar :: PatExpr -> Bool
isVar (PatExpr_Var{}) = True
isVar _               = False

mkQuant :: TyExpr -> TyExpr
mkQuant x@(TyExpr_Quant{}) = x
mkQuant x                 = 
  let vars = ftv x
      f    = TyExpr_Quant tyQu_Forall
      c    = map f vars
  in  foldl (.) id c x
  
mkForall :: TyExpr -> TyExpr
mkForall (TyExpr_Quant q a t) 
 = let (xs, t') = mk t
   in TyExpr_Forall q xs t'
   where 
     mk :: TyExpr -> ([HsName], TyExpr)
     mk y@(TyExpr_Quant m b c) 
       = let (x,t') = mk c
         in case m == q of
              False -> ([a], y)
              True  -> (b:x, t')
     mk x = ([a], x)
mkForall x@(TyExpr_Forall{}) 
 = x
mkForall x 
 = TyExpr_Forall tyQu_Forall [] x
 
occursCheck :: HsName -> Prefix -> TyScheme -> Bool
occursCheck a q phi 
  = let (q0,q1,q2) = let (r1,r2) = (q `splitOn` a)
                        in case r2 of
                             (x:xs) -> (r1, [x], xs)
                             []     -> (r1, [], [])
        fvs           = ftv (TyScheme_Sugar q2 phi)
    in case null q1 of
         True  -> let d1 = D.trace ("++Var: " ++ pp a)
                      d2 = D.trace ("++Pre: " ++ pp q)
                  in d1 $ d2 $ error "Cannot occurs check. The split does not return a value"
         False -> let d1 = D.trace ("++Var: " ++ pp a)
                      d2 = D.trace ("++Pre: " ++ pp q ++ "\n++Q0 = " ++ pp q0 ++ "\n++Q1 = " ++ pp q1 ++ "\n++Q2 = " ++ pp q2)
                      d3 = D.trace ("++Phi: " ++ pp phi ++ "\n++Ftv: " ++ pp (ftv phi) ++ "\n\n")
                  in a `elem` fvs
}
    
data TyQu
  con TyForall
    
data TyExpr
  con Con
    nm        :: HsName
  con App
    func      :: TyExpr
    arg       :: TyExpr
  con AppTop
    tyExpr    :: TyExpr
  con Parens
    tyExpr    :: TyExpr
  con Ann
    ann       :: TyExprAnn
    tyExpr    :: TyExpr
  con Wild
  con Mono
  con Var
    nm        :: HsName
  con VarWild
    mm        :: HsName
  con Quant
    qu        :: TyQu
    tyVar     :: HsName
    tyExpr    :: TyExpr
  con Forall
    qu        :: TyQu
    tyVar     :: [HsName]
    tyExpr    :: TyExpr    
  con Row
    rowTyExpr :: RowTyExpr
    
data TyVar
  con Var
    nm      :: HsName
    
type TyVars : [TyVar]
    
-- Type Index (a1 >= TyQuantifiedScheme)
data TyIndex
  con Group
    varnm   :: HsName
    bounds  :: TyQuantifiedScheme
    
-- -- Quantified type scheme
-- data TyQuantifiedScheme
  -- con Quant
    -- tyIndex  :: TyIndex
    -- tyScheme :: TyScheme
  -- con Bottom
   
{
type TyQuantifiedScheme = TyScheme
sche :: TyScheme -> String
sche (TyScheme_Quant{})   = "Quant"
sche (TyScheme_SystemF{}) = "SystemF"
sche (TyScheme_Bottom{})  = "Bottom"
sche (TyScheme_Sugar{})   = "Sugar"
sche (TyScheme_Forall{})  = "Forall"
}

{
con :: TyExpr -> String
con (TyExpr_Con a)    = "Con " ++ show a
con (TyExpr_Var a)    = "Var " ++ show a
con (TyExpr_App a b)  = con a ++ "; " ++ con b
con (TyExpr_AppTop a) = "AppTop (" ++ con a ++ ")"
con (TyExpr_Parens a) = "(" ++ con a ++ ")"
con (TyExpr_Quant _ _ a) = "Quant: " ++ con a
con _                 = "unmapped"
}
   
-- Type Schemes
data TyScheme
  con Quant
    subst    :: Scheme
    tyExpr   :: TyScheme
  con SystemF
    tyExpr   :: TyExpr
  con Bottom
  -- These next two are just used internally
  con Sugar
     prefix  :: Prefix
     tyExpr  :: TyScheme
  con Forall
     tyQuant :: [HsName]
     tyExpr  :: TyScheme

-- A simple tybound e.f. (a >= phi)
data Scheme
  con Simple
    varnm  :: HsName
    bounds :: TyScheme
  
-- Mono type
data TyMono 
  con Var 
    nm      :: HsName
  con App
    func    :: TyMono
    arg     :: TyMono
  con Con
    nm      :: HsName
  con AppTop
    tyMono  :: TyMono
    
-- Unqualified typed
data TyPoly
  con Var 
    nm      :: HsName
  con App
    func    :: TyPoly
    arg     :: TyPoly
  con Con
    nm      :: HsName
  con SystemF
    tyExpr  :: TyExpr
    
data DataFieldExpr
  con Upd
    dataFieldExpr  :  DataFieldExpr
    nm             :: HsName
    expr           :  Expr
  con Con
    nm             :: HsName
  con Expr
    expr           :  Expr
   
data DataFieldPatExpr
  con Ext
    dataFieldPatExpr  :: DataFieldPatExpr
    nm                :: HsName
    patExpr           :: PatExpr
  con Con
    nm                :: HsName
    
data RecExpr
  con Empty
  con Ext
    recExpr     :  RecExpr
    mbNm        :: (Maybe HsName)
    expr        :  Expr
  con Upd
    recExpr     :  RecExpr
    mbNm        :: HsName
    expr        :  Expr
  con Expr
    expr        :  Expr
    
data RecPatExpr
  con Empty
  con Ext
    recPatExpr  :  RecPatExpr
    mbNm        :: (Maybe HsName)
    patExpr     :: PatExpr
  con Expr
    patExpr     :: PatExpr
    
data RowTyExpr
  con Empty
  con Ext
    rowTyExpr       :: RowTyExpr
    mbNm            :: (Maybe HsName)
    tyExpr          :: TyExpr
    
data KiExpr
  con Con
    nm       :: HsName
  con Var
    nm       :: HsName
  con App
    func     :: KiExpr
    arg      :: KiExpr
  con AppTop
    kiExpr   :: KiExpr
  con Parens
    kiExpr   :: KiExpr
  con Ann
    ann      :: KiExprAnn
    kiExpr   :: KiExpr
    
data Expr
  con IConst
    int           :: Int
  con CConst
    char          :: Char
  con Con
    nm            :: HsName
  con Var
    nm            :: HsName
  con App
    func          :  Expr
    arg           :  Expr
  con Let
    isStrict      :: Bool
    decls         :  Decls
    body          :  Expr
  con Lam
    arg           :: PatExpr
    body          :  Expr
  con AppTop
    expr          :  Expr
  con Parens
    expr          :  Expr
  con TypeAs
    tyExpr        :: TyExpr
    expr          :  Expr
  con Ann
    ann           :: ExprAnn
    expr          :  Expr
  con AppImpred
    func          :  Expr
    arg           :  Expr
  con SConst 
    str           :: String
  con Case
    expr          :  Expr
    alts          :: CaseAlts
    mbCaseIds     :: (Maybe UIDS)
    caseFailS     :: UIDS
    isTupOfArg    :: Bool
  con DataFields
    dataFieldExpr :: DataFieldExpr
  con Rec
    recExpr       :: RecExpr
  con Sel
    expr          :  Expr
    lbl           :: HsName
  con Undefined
  con CaseAltFail 
    caseId        :: UID
    
data PatExpr
  con IConst
    int              :: Int
  con CConst
    char             :: Char
  con Con
    nm               :: HsName
  con Var
    nm               :: HsName
  con VarAs
    nm               :: HsName
    patExpr          :: PatExpr
  con App
    func             :: PatExpr
    arg              :: PatExpr
  con AppTop
    patExpr          :: PatExpr
  con Parens
    patExpr          :: PatExpr
  con Ann
    ann              :: PatExprAnn
    patExpr          :: PatExpr
  con TypeAs
    tyExpr           :: TyExpr
    patExpr          :: PatExpr
  con SConst
    str              :: String
  con Rec
    recPatExpr       :: RecPatExpr
  con DataFields
    dataFieldPatExpr :: DataFieldPatExpr
  con Irrefutable
    patExpr          :: PatExpr
    
data CaseAlt
  con Pat
    patExpr   :: PatExpr
    expr      :  Expr

type CaseAlts : [CaseAlt]
    
data DataConstr
  con Constr
    conNm      :: HsName
    fields     :  DataFields
    
type DataConstrs : [DataConstr]

data DataField
  con Field
    mbLabels     :: (Maybe [HsName])
    tyExpr       :: TyExpr
    
type DataFields : [DataField]
   
data ExprAnn
  con Empty
  
data TyExprAnn
  con Empty

data PatExprAnn
  con Empty
  
data KiExprAnn
  con Empty
  
data Decl
  con TySig
    nm         :: HsName
    tyExpr     :: TyExpr
  con Val
    patExpr    :: PatExpr
    expr       :  Expr
  con Data
    isNewType  :: Bool
    tyNm       :: HsName
    tyVars     :: TyVars
    constrs    :: DataConstrs
  con KiSig
    nm         :: HsName
    kiExpr     :: KiExpr
  con FFI
    callconv   :: FFIWay
    safety     :: String
    impEnt     :: String
    nm         :: HsName
    tyExpr     :: TyExpr
  
type TyExprs : [TyExpr]
type Decls   : [Decl]
  
itf Expr
  visit infer
    inh pre :: Prefix
    inh env :: Gamma
    inh ast :: Expr
    inh exp :: Expr
    inh frs :: Int
    syn nxe :: Prefix
    syn sub :: Env
    syn res :: [TyScheme]
    syn frs :: Int
    
itf DataConstrs
  visit findTypes
    inh ast :: DataConstrs
    inh nm  :: TyExpr
    syn ty  :: [(HsName, TyExpr)]
    
itf DataConstr
  visit findType
    inh ast :: DataConstr
    inh nm  :: TyExpr
    syn ty  :: (HsName, TyExpr)
    
itf DataFields
  visit findTypes
    inh ast :: DataFields
    syn ty  :: TyExprs
    
itf DataField
  visit findType
    inh ast :: DataField
    syn ty  :: TyExpr
    
itf Decls
  visit infer
    inh ast :: Decls
    inh pre :: Prefix
    inh env :: Gamma
    inh frs :: Int
    syn nxe :: Prefix
    syn env :: Gamma
    syn sub :: Env
    syn frs :: Int
    
itf Decl
  visit infer
    inh ast :: Decl
    inh pre :: Prefix
    inh env :: Gamma
    inh frs :: Int
    syn nxe :: Prefix
    syn env :: Gamma -- These declarations can update the gamma in a non-linear way, so we have to return the new one
    syn sub :: Env
    syn frs :: Int
    
itf PatExpr
  visit vars
    inh ast    :: PatExpr
    syn var_nm :: HsName
  visit infer
    inh pre :: Prefix
    inh env :: Gamma
    inh exp :: PatExpr
    inh frs :: Int
    syn nxe :: Prefix
    syn env :: Gamma -- A PatExpr might want to expand the Gamma, so we need to again return it.
    syn sub :: Env
    syn res :: [TyScheme]
    syn frs :: Int
    
datasem DataFields monad IO
  clause Cons
    lhs.ty = hd.ty : tl.ty
  clause Nil
    lhs.ty = []
    
datasem DataField monad IO
  clause Field
    lhs.ty = loc.tyExpr
    
datasem DataConstr monad IO
  clause Constr
    lhs.ty = (loc.conNm, foldr mkArrow lhs.nm fields.ty)
    
datasem DataConstrs monad IO
  clause Cons
    hd.nm = lhs.nm
    tl.nm = lhs.nm
    lhs.ty = hd.ty : tl.ty
  clause Nil
    lhs.ty = []
    
datasem PatExpr monad IO
  clause IConst
    lhs.var_nm = error "IConst not a var"
    
    lhs.res = []
    -- lhs.sub = lhs.env
    lhs.env = lhs.env
    lhs.sub = []
    lhs.nxe = lhs.pre
    lhs.frs = lhs.frs
  clause CConst
    lhs.var_nm = error "CConst not a var"
    
    lhs.res = []
    -- lhs.sub = lhs.env
    lhs.env = lhs.env
    lhs.sub = []
    lhs.nxe = lhs.pre
    lhs.frs = lhs.frs
  clause Con
    lhs.var_nm = error "Constructors not supported"
    
    lhs.res = []
    -- lhs.sub = lhs.env
    lhs.env = lhs.env
    lhs.sub = []
    lhs.nxe = lhs.pre
    lhs.frs = lhs.frs
  clause Var
    lhs.var_nm = loc.nm 
    
    (loc.a, loc.frs1) = fresh lhs.frs
    loc.exp_a  = TyScheme_SystemF $ TyExpr_Var loc.a
    lhs.res    = [loc.exp_a]
    lhs.env    = Gamma $ minsert loc.nm loc.exp_a (unGam lhs.env)
    lhs.sub    = []
    lhs.nxe    = (TyIndex_Group loc.a TyScheme_Bottom):lhs.pre
    lhs.frs    = loc.frs1
  clause VarAs
    lhs.var_nm = loc.nm 
    
    lhs.res = []
    -- lhs.sub = lhs.env
    lhs.env = lhs.env
    lhs.sub = []
    lhs.nxe = lhs.pre
    lhs.frs = lhs.frs
  clause App
    lhs.var_nm = error "App not a var"
    
    lhs.res = []
    -- lhs.sub = lhs.env
    lhs.env = lhs.env
    lhs.sub = []
    lhs.nxe = lhs.pre
    lhs.frs = lhs.frs
  clause AppTop
    lhs.var_nm = error "AppTop not a var"
    
    lhs.res = []
    -- lhs.sub = lhs.env
    lhs.env = lhs.env
    lhs.sub = []
    lhs.nxe = lhs.pre
    lhs.frs = lhs.frs
  clause Parens
    child patExpr : PatExpr
    patExpr.ast = loc.patExpr
    
    patExpr.exp = loc.patExpr
    patExpr.env = lhs.env
    patExpr.frs = lhs.frs
    patExpr.pre = lhs.pre
    
    invoke vars of patExpr
    -- invoke infer of patExpr
    
    lhs.var_nm = patExpr.var_nm
    
    lhs.res = patExpr.res
    lhs.sub = patExpr.sub
    lhs.nxe = patExpr.nxe
    lhs.env = patExpr.env
    lhs.frs = patExpr.frs
  clause Ann
    child patExpr : PatExpr
    patExpr.ast = loc.patExpr
        
    invoke vars of patExpr
    
    patExpr.exp = loc.patExpr
    patExpr.env = lhs.env
    patExpr.frs = lhs.frs
    patExpr.pre = lhs.pre
    
    lhs.var_nm = patExpr.var_nm 
    
    lhs.res = patExpr.res
    lhs.sub = patExpr.sub
    lhs.env = patExpr.env
    lhs.nxe = patExpr.nxe
    lhs.frs = patExpr.frs
  clause TypeAs
    child patExpr : PatExpr
    patExpr.ast = loc.patExpr
    
    invoke vars of patExpr
    
    lhs.var_nm = patExpr.var_nm
    
    loc.ans = TyScheme_SystemF (TyExpr_Parens loc.tyExpr)
    lhs.res = [loc.ans]
    lhs.env = Gamma $ minsert patExpr.var_nm loc.ans (unGam lhs.env)
    lhs.sub = []
    lhs.nxe = lhs.pre
    lhs.frs = lhs.frs
  clause SConst
    lhs.var_nm = error "SConst not a var"
    
    lhs.res = []
    -- lhs.sub = lhs.env
    lhs.sub = []
    lhs.nxe = lhs.pre
    lhs.env = lhs.env
    lhs.frs = lhs.frs
  clause Rec
    lhs.var_nm = error "Rec not a var"
    
    lhs.res = []
    -- lhs.sub = lhs.env
    lhs.sub = []
    lhs.nxe = lhs.pre
    lhs.env = lhs.env
    lhs.frs = lhs.frs
  clause DataFields
    lhs.var_nm = error "DataFields not a var"
    
    lhs.res = []
    -- lhs.sub = lhs.env
    lhs.sub = []
    lhs.nxe = lhs.pre
    lhs.env = lhs.env
    lhs.frs = lhs.frs
  clause Irrefutable 
    lhs.var_nm = error "Irrefutable not a var"
    
    lhs.res = []
    -- lhs.sub = lhs.env
    lhs.sub = []
    lhs.nxe = lhs.pre
    lhs.env = lhs.env
    lhs.frs = lhs.frs
    
datasem Decl monad IO
  default? sub = const []
  -- default? env = last
  clause Val
    match PatExpr.Var@loc = loc.patExpr
    
    expr.pre = lhs.pre
    expr.env = lhs.env
    expr.exp = loc.expr
    expr.frs = lhs.frs

    invoke infer of expr

    lhs.nxe = expr.nxe
    lhs.env = let (Left adjusted) = apply expr.sub lhs.env
              in case expr.res of
                   [] -> error  $ "Inference failed datasem Decl clause Val. No result"
                   x  -> Gamma $ foldr (\a->minsert loc.nm a) (unGam adjusted) x -- update the Gamma
    lhs.frs = expr.frs
  clause TySig
    lhs.nxe = lhs.pre
    lhs.env = Gamma $ minsert loc.nm (TyScheme_SystemF loc.tyExpr) (unGam lhs.env)  -- update the Gamma
    lhs.frs = lhs.frs
  clause Data
     child constrs : DataConstrs
     constrs.ast = loc.constrs
     constrs.nm = let vars = map (\(TyVar_Var x) -> TyExpr_Var x) loc.tyVars
                  in  foldl TyExpr_App (TyExpr_Con loc.tyNm) vars
     
     invoke findTypes of constrs
     
     lhs.env = Gamma $ (foldr (.) id . map (\(k,v)->minsert k (mkQuantified v))) constrs.ty (unGam lhs.env) -- update the Gamma
     lhs.nxe = lhs.pre
     lhs.frs = lhs.frs
  clause FFI
     loc.vars = nub $ ftv loc.tyExpr
     loc.exp = let tyExpr = simplify loc.tyExpr
               in case null loc.vars of
                   True  -> tyExpr
                   False -> foldl (.) id (map (TyExpr_Quant tyQu_Forall) loc.vars) tyExpr
     lhs.env = Gamma $ minsert loc.nm (TyScheme_SystemF loc.exp) (unGam lhs.env) -- update the Gamma
     lhs.nxe = lhs.pre
     lhs.frs = lhs.frs
  clause KiSig
     -- lhs.sub = lhs.env
     lhs.env = lhs.env
     lhs.nxe = lhs.pre
     lhs.frs = lhs.frs
    
datasem Decls monad IO
  default? sub = const []
  -- default? env = last
  -- default? nxe = last
  -- default? frs = last
  clause Cons
    hd.pre     = lhs.pre
    hd.env     = lhs.env
    hd.frs     = lhs.frs
    invoke infer of hd
    
    tl.env     = hd.env
    tl.pre     = hd.nxe
    tl.frs     = hd.frs
    invoke infer of tl
    
    lhs.nxe       = tl.nxe
    lhs.sub       = munion hd.sub tl.sub
    lhs.frs       = tl.frs
    lhs.env       = tl.env
  clause Nil
    -- lhs.sub       = lhs.env
    lhs.nxe       = lhs.pre
    lhs.frs       = lhs.frs
    lhs.env       = lhs.env
       
datasem Expr monad IO
    clause Var
        -- lhs.res = maybe (error "Variable not found in lookup") (:[]) $ M.lookup loc.nm lhs.env
        (lhs.res, loc.frs)
             = case lookup loc.nm (unGam lhs.env) of
                Just a  -> ([a], lhs.frs) -- Is this the proper way to get mutual recursion working?
                Nothing -> error $ "Variable '" ++ show loc.nm ++ "' not in scope"
                -- Nothing -> (return . TyScheme_SystemF . TyExpr_Var *** id) (fresh lhs.frs)
        lhs.sub = empty
        lhs.nxe = lhs.pre
        lhs.frs = loc.frs
    clause IConst
       lhs.res = return $ TyScheme_SystemF $ TyExpr_Con $ mkName "Int"
       lhs.sub = empty
       lhs.nxe = lhs.pre
       lhs.frs = lhs.frs
    clause CConst
       lhs.res = return $ TyScheme_SystemF $ TyExpr_Con $ mkName "Char"
       lhs.sub = empty
       lhs.nxe = lhs.pre
       lhs.frs = lhs.frs
    clause Con
       lhs.res = maybe (error "Constructor not found in lookup") (:[]) $ lookup loc.nm (unGam lhs.env)
       lhs.sub = empty
       lhs.nxe = lhs.pre
       lhs.frs = lhs.frs
    clause App
       loc.frs            = lhs.frs
       (loc.a1, loc.frs1) = fresh loc.frs
       (loc.a2, loc.frs2) = fresh loc.frs1
       (loc.b , loc.frs3) = fresh loc.frs2
       
       func.exp = loc.func
       func.frs = loc.frs3
       func.pre = lhs.pre
       func.env = lhs.env
       
       invoke infer of func
       
       arg.exp = loc.arg
       arg.frs = func.frs
       arg.pre = func.nxe
       arg.env = let (Just e) = appAll func.sub lhs.env
                 in e
       
       invoke infer of arg
       
       loc.debug1 = D.trace ("[App] func -- " ++ concatMap sche func.res ++ " # " ++ pp func.res) func.res
       loc.debug2 = D.trace ("[App] arg  -- " ++ concatMap sche arg.res  ++ " # " ++ pp arg.res) arg.res
       loc.debug3 = D.trace ("A1: " ++ show loc.a1 ++ ", A2: " ++ show loc.a2 ++ ", B: " ++ show loc.b) arg.res
       
       (loc.temp1, loc.frt1) = extend (arg.nxe, Scheme_Simple loc.a1 (fromJust $ appAll arg.sub (head func.res)), arg.frs) True
       (loc.temp2, loc.frt2) = extend (fst loc.temp1, Scheme_Simple loc.a2 (head arg.res), loc.frt1) True
       (loc.temp3, loc.frt3) = extend (fst loc.temp2, Scheme_Simple loc.b  (TyScheme_Bottom), loc.frt2) True
       
       (loc.q2', loc.e2') = (fst loc.temp3, (snd loc.temp1) `munion` (snd loc.temp2) `munion` (snd loc.temp3))
       
       child u : Unify = unify
       u.pre  = D.trace ("app - unify " ++ pp loc.q2' ++ " -- " ++ pp loc.e2') loc.q2'
       -- unsafe. Needs to be rewritten
       u.exp1 = let c = fromJust $ appAll loc.e2' (TyExpr_Var loc.a1)
                in D.trace ("Con1: " ++ con c ++ " # " ++ pp c) c
       u.exp2 = let c = (fromJust $ appAll loc.e2' (TyExpr_Var loc.a2)) `mkArrow` (TyExpr_Var loc.b)
                in D.trace ("Con2: " ++ con c ++ " # " ++ pp c) c
       u.frs  = loc.frt3
       
       invoke unify of u
       
       loc.q3 = u.pre
       loc.e3 = D.trace ("unify done: " ++ pp u.sub) u.sub
       (loc.q4, loc.q5) = curry split loc.q3 (domain lhs.pre)
    
       lhs.res = let b = TyExpr_Var loc.b
                 in case appAll (loc.e3 `munion` loc.e2') b of
                      Just v  -> return $ nf $ desugar $ TyScheme_Sugar loc.q5 (TyScheme_SystemF v)
                      Nothing -> error "App failed, cannot apply substitution"
       loc.temp_sub = func.sub `munion` arg.sub `munion` loc.e3 -- added union
       lhs.sub = loc.temp_sub
       lhs.nxe = loc.q4
       lhs.frs = let d1 = D.trace ("^^Unify pre: " ++ pp u.pre)
                     d2 = D.trace ("^^NXE: " ++ pp loc.q4)
                     d3 = D.trace ("^^Sub: " ++ pp loc.temp_sub)
                 in d1 $ d2 $ d3 u.frs
    clause Let
        -- | Preprocess the binds to fill the environemnt
        (loc.frs, loc.binds)  = let nms         = getBindLHs loc.decls
                                    (vars, frs) = freshM lhs.frs (length nms)
                                in (frs, zipWith (\a b->(a, mkQVar b)) nms vars)
        loc.env   = Gamma $ foldr (.) id (map (\(k,v)->minsert k v) loc.binds) (unGam lhs.env) -- temporaty update the environment. this will later be updated
        
        decls.pre = lhs.pre
        decls.env = loc.env
        decls.frs = loc.frs

        invoke infer of decls

        body.pre = decls.nxe
        body.env = decls.env
        body.exp = loc.body
        body.frs = decls.frs

        invoke infer of body

        lhs.nxe = body.nxe
        lhs.res = body.res
        lhs.sub = munion decls.sub body.sub
        lhs.frs = body.frs
    clause Lam
        child arg : PatExpr
        arg.ast = loc.arg
        arg.env = lhs.env
        arg.pre = lhs.pre
        arg.exp = loc.arg
        arg.frs = lhs.frs
        
        invoke vars of arg
        invoke infer of arg
    
       loc.frs           = arg.frs
       (TyScheme_SystemF loc.exp_a) = case arg.res of -- error reporting on local variables is off
                                        [x] -> x
                                        _   -> error "No type infered from PatExpr in Lam"
       (loc.b, loc.frs2) = fresh loc.frs
       loc.q'            = arg.nxe
       loc.env'          = arg.env
       
       body.frs = loc.frs2
       body.env = loc.env'
       body.pre = loc.q'
       body.exp = loc.body
       
       invoke infer of body
       
       loc.env_full = munion arg.sub body.sub
       
       loc.tau = let x = appAll loc.env_full loc.exp_a
                 in case x of
                      (Just x') | (isUnQualTy x' || not (isVar loc.arg))
                                       -> x
                      _                -> error "The resulting type is not a Tau type"
       (loc.q2,  loc.q3)  = curry split body.nxe (domain lhs.pre)
       loc.phi1           = case body.res of
                              []  -> error "Inference of Expressions failed in Lam, no type infered for body"
                              [x] -> x
                              _   -> error "Too many options, I only need one"
       ((loc.q3', loc.e3'), loc.frs') = extend (loc.q3, (Scheme_Simple loc.b loc.phi1), body.frs) False
       
       lhs.res = let (Just b')    = appAll loc.e3' (TyExpr_Var loc.b)
                     (Just a')    = appAll body.sub loc.exp_a -- (TyExpr_Var loc.a)
                     arrow = mkArrow a' b'
                 in return $ desugar $ TyScheme_Sugar loc.q3' (TyScheme_SystemF arrow)
       lhs.sub = body.sub
       lhs.nxe = loc.q2
       lhs.frs = loc.frs'
    clause AppTop
       expr.pre = lhs.pre
       expr.env = lhs.env
       expr.frs = lhs.frs
       expr.exp = loc.expr
       
       invoke infer of expr
       
       lhs.res = expr.res
       lhs.sub = expr.sub
       lhs.nxe = expr.nxe
       lhs.frs = expr.frs
    clause Parens
       expr.pre = lhs.pre
       expr.env = lhs.env
       expr.frs = lhs.frs
       expr.exp = loc.expr
       
       invoke infer of expr
       
       lhs.res = expr.res
       lhs.sub = expr.sub
       lhs.nxe = expr.nxe
       lhs.frs = expr.frs
    clause TypeAs
       lhs.res = []
       lhs.sub = []
       lhs.nxe = lhs.pre
       lhs.frs = lhs.frs
    clause Ann
       expr.pre = lhs.pre
       expr.env = lhs.env
       expr.frs = lhs.frs
       expr.exp = loc.expr
       
       invoke infer of expr
       
       lhs.res = expr.res
       lhs.sub = expr.sub
       lhs.nxe = expr.nxe
       lhs.frs = expr.frs
    clause   AppImpred
       lhs.res = []
       lhs.sub = [] -- lhs.env
       lhs.nxe = lhs.pre
       lhs.frs = lhs.frs
    clause Case
       lhs.res = []
       lhs.sub = [] -- lhs.env
       lhs.nxe = lhs.pre
       lhs.frs = lhs.frs
    clause CaseAltFail
       lhs.res = []
       lhs.sub = [] -- lhs.env
       lhs.nxe = lhs.pre
       lhs.frs = lhs.frs
    clause DataFields
       lhs.res = []
       lhs.sub = [] -- lhs.env
       lhs.nxe = lhs.pre
       lhs.frs = lhs.frs
    clause Rec
       lhs.res = []
       lhs.sub = [] -- lhs.env
       lhs.nxe = lhs.pre
       lhs.frs = lhs.frs
    clause SConst
       lhs.res = []
       lhs.sub = [] -- lhs.env
       lhs.nxe = lhs.pre
       lhs.frs = lhs.frs
    clause Sel
       lhs.res = []
       lhs.sub = [] -- lhs.env
       lhs.nxe = lhs.pre
       lhs.frs = lhs.frs
    clause Undefined
       (loc.a, loc.frs1) = fresh lhs.frs
       lhs.res = [TyScheme_SystemF $ TyExpr_Var loc.a]
       lhs.sub = [] -- lhs.env
       lhs.nxe = lhs.pre
       lhs.frs = loc.frs1
       
itf Unify
  visit unify
    inh pre  :: Prefix
    inh exp1 :: TyExpr
    inh exp2 :: TyExpr
    inh frs  :: Int
    syn pre  :: Prefix
    syn sub  :: Env
    syn frs  :: Int

itf Subsume
  visit subsume
    inh pre  :: Prefix
    inh exp  :: TyExpr
    inh ty   :: TyScheme
    inh frs  :: Int
    syn pre  :: Prefix
    syn sub  :: Env
    syn frs  :: Int
    
itf UnifyScheme
  visit unifyScheme
    inh pre  :: Prefix
    inh ty1  :: TyScheme
    inh ty2  :: TyScheme
    inh frs  :: Int
    syn pre  :: Prefix
    syn sub  :: Env
    syn ty   :: TyScheme
    syn frs  :: Int

{
unifyScheme = sem unifyScheme : UnifyScheme monad IO
                visit unifyScheme
                  default? pre = last
                  default? frs = last
                  default? sub = const empty
                  clause Main_unifyScheme
                    loc.nfTy = isNf lhs.ty1
                    loc.nfTs = isNf lhs.ty2
                    loc.nf   = loc.nfTy && loc.nfTs
                    internal nf_check
                        loc.b1 = isBottom lhs.ty1
                        loc.b2 = isBottom lhs.ty2
                        clause s_subsume
                          match True       = loc.nf
                          internal bot_check
                            clause first_bottom
                                match True = loc.b1
                                (loc.q, loc.tyx) = splitQuant lhs.ty2
                                lhs.ty     = lhs.ty2 -- loc.tyx
                                lhs.pre    = lhs.pre -- munion loc.q lhs.pre
                            clause second_bottom
                                match True = loc.b2
                                (loc.q, loc.tyx) = splitQuant lhs.ty1
                                lhs.ty     = lhs.ty1 -- loc.tyx
                                lhs.pre    = lhs.pre -- munion loc.q lhs.pre
                            clause norm
                                match False = loc.b1 || loc.b2
                                match TyScheme.Sugar@exp1 = sugar lhs.ty1
                                match TyScheme.Sugar@exp2 = sugar lhs.ty2
                                
                                loc.q = lhs.pre
                                
                                child u : Unify = unify
                                
                                u.pre  = let q = loc.q ++ exp1.prefix ++ exp2.prefix
                                         in D.trace (";;; Q: " ++ pp q) q
                                u.exp1 = dropScheme exp1.tyExpr
                                u.exp2 = dropScheme exp2.tyExpr
                                u.frs  = lhs.frs
                                
                                invoke unify of u
                                
                                loc.q3 = u.pre
                                loc.e3 = u.sub
                                
                                (loc.q4, loc.q5) = split (loc.q3, domain loc.q)
                                
                                lhs.frs = u.frs
                                lhs.pre = loc.q4
                                lhs.sub = loc.e3
                                lhs.ty  = let (Just ty)  = appAll loc.e3 exp1.tyExpr
                                              ret = TyScheme_Sugar loc.q5 ty
                                          in desugar ret
                        clause f_subsume
                          match False                 = loc.nf
                          lhs.ty = error "unifyScheme failure, ty1 or ty2 is not in normal form"

subsume = sem subsume : Subsume monad IO 
             visit subsume
               default? pre = last
               default? frs = last
               clause Main_subsume
                loc.nfTy = isNf lhs.exp
                loc.nfTs = isNf lhs.ty
                loc.nf   = loc.nfTy && loc.nfTs
                internal nf_check
                    clause s_subsume
                      match True                  = loc.nf
                      match TyExpr.Forall@exp     = mkForall lhs.exp -- $ mkQuant lhs.exp
                      match TyScheme.Sugar@scheme = sugar lhs.ty
                      
                      loc.q  = lhs.pre
                      loc.q2 = scheme.prefix
                      
                      child u : Unify = unify
                      
                      (loc.c, loc.frs1) = D.trace ("subsume - init " ++ pp (const scheme.prefix exp.tyExpr)) $ freshM lhs.frs (length exp.tyVar)
                      loc.qq2 = let q = loc.q ++ loc.q2
                                in D.trace ("subsume -- " ++ pp q) q
                      u.pre  = loc.qq2
                      u.exp1 = case appAll (zipWith (\a b->(a, mkSkolem b)) exp.tyVar loc.c) exp.tyExpr of
                                 Just a  -> D.trace ("un1: " ++ con a) (const a scheme.prefix)
                                 Nothing -> error "Subsume failure, substitution failed"
                      u.exp2 = let f = dropScheme scheme.tyExpr
                               in D.trace ("un2: " ++ con f) (const f exp.tyExpr)
                      u.frs  = loc.frs1
                      
                      invoke unify of u
                      
                      loc.q1 = u.pre
                      loc.e1 = u.sub
                      
                      (loc.q3, loc.q4) = split (loc.q1, domain loc.qq2)
                      loc.e2 = let x = nub (domain loc.q4)
                               in D.trace (   "Removing domain: " ++ pp x 
                                           ++ "\n\t&&> " ++ pp loc.e1
                                           ++ "\n\t&&> " ++ pp (loc.e1 `remove` x)) $ loc.e1 `remove` x
                      
                      loc.check =  any (flip elem (codomain loc.e2 ++ codomain loc.q3)) loc.c
                      
                      internal skol_check
                        clause succeeded
                          match False  = loc.check
                          lhs.pre = loc.q3
                          lhs.sub = D.trace ("Subscheme result: " ++ pp loc.e2) loc.e2
                          lhs.frs = u.frs
                        clause failed
                          match (loc.bla, True) = ((), loc.check)
                          lhs.sub = const (error "Subsume failure, a skolem variable has leaked to the env.") loc.bla
                    
                    clause wild_subsume
                      match True                  = loc.nf
                      match (loc.fo, TyScheme.Bottom@l)     = ((), sugar lhs.ty)
                      lhs.sub = D.trace "Wild subsume" (const empty loc.fo)
                      
                    clause f_subsume
                      match (loc.bla, False) = ((), loc.nf)
                      lhs.sub = const (error $ "Subsume failure, the given type is not in normal form.") loc.bla

unify = sem unify : Unify monad IO    
          visit unify
             default? pre = last
             default? frs = last
             default? sub = const (error "Generic Unify failure")
             clause Main_unify
               loc.nfTy1 = isNf lhs.exp1
               loc.nfTy2 = isNf lhs.exp2
               loc.nf    = loc.nfTy1 && loc.nfTy2
               internal nf_check
                 clause s_unify
                   match True  = loc.nf
                   internal ty_check
                     clause LeftTop
                       match TyExpr.AppTop@app = lhs.exp1
                       
                       child u : Unify = unify
                       
                       u.pre  = lhs.pre
                       u.frs  = lhs.frs
                       u.exp2 = lhs.exp2
                       u.exp1 = D.trace ("AppTop Stripped. # " ++ con app.tyExpr) app.tyExpr
                       
                       invoke unify of u
                       
                       lhs.frs = u.frs
                       lhs.pre = u.pre
                       lhs.sub = u.sub
                     clause RightTop
                       match TyExpr.AppTop@app = lhs.exp2
                       
                       child u : Unify = unify
                       
                       u.pre  = lhs.pre
                       u.frs  = lhs.frs
                       u.exp1 = lhs.exp1
                       u.exp2 = D.trace ("AppTop Stripped. # " ++ con app.tyExpr) app.tyExpr
                       
                       invoke unify of u
                       
                       lhs.frs = u.frs
                       lhs.pre = u.pre
                       lhs.sub = u.sub
                     clause LeftParens
                       match TyExpr.Parens@app = lhs.exp1
                       
                       child u : Unify = unify
                       
                       u.pre  = lhs.pre
                       u.frs  = lhs.frs
                       u.exp2 = lhs.exp2
                       u.exp1 = D.trace ("Parens Stripped. # " ++ con app.tyExpr) app.tyExpr
                       
                       invoke unify of u
                       
                       lhs.frs = u.frs
                       lhs.pre = u.pre
                       lhs.sub = u.sub
                     clause RightParens
                       match TyExpr.Parens@app = lhs.exp2
                       
                       child u : Unify = unify
                       
                       u.pre  = lhs.pre
                       u.frs  = lhs.frs
                       u.exp1 = lhs.exp1
                       u.exp2 = D.trace ("Parens Stripped. # " ++ con app.tyExpr) app.tyExpr
                       
                       invoke unify of u
                       
                       lhs.frs = u.frs
                       lhs.pre = u.pre
                       lhs.sub = u.sub
                     clause vars
                       match TyExpr.Var@var1 = lhs.exp1
                       match TyExpr.Var@var2 = lhs.exp2
                       
                       internal case_check
                         clause eq_vars
                           match True = var1.nm == var2.nm
                           lhs.sub = D.trace "Variable match" empty
                         clause rest_vars
                           loc.q  = lhs.pre
                           loc.p1 = loc.q `contains` var1.nm
                           loc.p2 = loc.q `contains` var2.nm
                           internal var_check
                             loc.isJust    = isJust loc.p1 && isJust loc.p2
                             clause pure_var
                               match False = loc.isJust
                               lhs.sub = empty 
                             clause ty_var
                               match True  = loc.isJust
                               loc.phi1 = fromJust loc.p1
                               loc.phi2 = fromJust loc.p2
                               -- loc.exists = let v1 = (loc.q `elide` loc.phi1) `contains` var1.nm
                                                -- v2 = (loc.q `elide` loc.phi2) `contains` var2.nm
                                            -- in isJust v1 || isJust v2
                               loc.exists = let v1 = occursCheck var1.nm loc.q (toScheme loc.phi2)
                                                v2 = occursCheck var2.nm loc.q (toScheme loc.phi1)
                                            in v1 || v2
                               internal dom_check
                                 clause s_dom_check
                                   match True  = loc.exists
                                   lhs.sub = error "Domain check failed in Unify"
                                 clause f_dom_check
                                   match False = loc.exists
                                   
                                   child s : UnifyScheme = unifyScheme
                                   
                                   s.pre = loc.q
                                   s.frs = lhs.frs
                                   s.ty1 = let ty = dropQuant loc.phi1
                                           in D.trace (";;; ty2 = " ++ pp ty ++" -- " ++ pp loc.phi1) ty
                                   s.ty2 = let ty = dropQuant loc.phi2
                                           in D.trace (";;; ty2 = " ++ pp ty) ty
                                   
                                   invoke unifyScheme of s
                                   
                                   loc.q1  = s.pre
                                   loc.e1  = s.sub
                                   loc.phi = s.ty
                                   
                                   (loc.q2, loc.e2) = update (loc.q1, Right (var1.nm, TyScheme_SystemF $ TyExpr_Var var2.nm))
                                   (loc.q3, loc.e3) = update (loc.q2, Left (Scheme_Simple var2.nm loc.phi)) 
                                   
                                   lhs.frs = s.frs
                                   lhs.pre = loc.q3
                                   lhs.sub = let x = loc.e3 `munion` loc.e2 `munion` loc.e1
                                                 d0 = D.trace ("++ q3 [" ++ pp var2.nm ++ "]= " ++ pp loc.q3)
                                                 dx = D.trace ("++ q2 = " ++ pp loc.q2)
                                                 di = D.trace ("++ q1 = " ++ pp loc.q2)
                                                 dj = D.trace ("++ ty = " ++ pp loc.phi)
                                                 d1 = D.trace ("++ e3 = " ++ pp loc.e3)
                                                 d2 = D.trace ("++ e2 = " ++ pp loc.e2)
                                                 d3 = D.trace ("++ e1 = " ++ pp loc.e1)
                                             in di $ dj $ dx $ d0 $ d1 $ d2 $ d3 $ D.trace ("++ unifyScheme + unify done: " ++ pp x) x
                     clause cons
                       match TyExpr.Con@var1 = lhs.exp1
                       match TyExpr.Con@var2 = lhs.exp2
                       
                       loc.eq = var1.nm == var2.nm
                       
                       internal con_check
                          clause succeeded1
                            match True  = loc.eq
                            lhs.sub     = empty
                          clause failed1
                            match False = loc.eq
                            lhs.sub = error $ "Constructor mismatch, expected '" ++ show var1.nm ++ "' but got '" ++ show var2.nm ++ "'"
                     clause apptype
                       match TyExpr.App@app1 = lhs.exp1
                       match TyExpr.App@app2 = lhs.exp2
                       
                       loc.fake =(const . const) "" app1.func app2.func
                       
                       child uf : Unify = unify
                       
                       uf.frs  = D.trace "-- Unify App --" lhs.frs
                       uf.pre  = lhs.pre
                       uf.exp1 = D.trace ("Func1L: " ++ con app1.func ++ loc.fake) app1.func
                       uf.exp2 = D.trace ("Func2L: " ++ con app2.func ++ loc.fake) app2.func
                       
                       invoke unify of uf
                       
                       child ua : Unify = unify
                       
                       ua.frs  = uf.frs
                       ua.pre  = uf.pre
                       ua.exp1 = let (Just arg) = appAll uf.sub app1.arg
                                     d1 = D.trace ("&Pref: " ++ pp uf.pre ++ "\n&Sub:  " ++ pp uf.sub)
                                 in d1 $ D.trace ("Func1R: " ++ con arg) arg
                       ua.exp2 = let (Just arg) = appAll uf.sub app2.arg
                                 in D.trace ("Func2R: " ++ con arg) arg
                       
                       invoke unify of ua
                       
                       lhs.pre = ua.pre
                       lhs.sub = uf.sub `munion` ua.sub
                       
                     clause vartype
                       -- hopefully clauses are tried in-order, or else this would be a problem  
                           
                       internal varchoice
                         clause leftvar
                           match TyExpr.Var@var1 = lhs.exp1
                           loc.expr  = lhs.exp2
                           loc.varnm = var1.nm
                           -- | code duplication, bah, the graph reordering is screwed up
                           loc.q = D.trace ("unify - leftvar " ++ show (domain lhs.pre)) lhs.pre
                           loc.phi = loc.q `contains` loc.varnm
                           
                           internal occurs_check
                             clause valid
                               match False = occursCheck loc.varnm loc.q (TyScheme_SystemF loc.expr)
                               loc.phi' = fromJust loc.phi
                               
                               loc.p = loc.expr
                               
                               child s : Subsume = subsume
                               
                               s.pre = loc.q
                               s.exp = loc.p
                               s.frs = D.trace ("Left: " ++ con loc.p ++ " - " ++ pp loc.p) lhs.frs
                               s.ty  = let c = dropQuant loc.phi'
                                       in D.trace ("Ty: " ++ sche c ++ " - " ++ pp c) c
                               
                               invoke subsume of s
                               
                               (loc.q2, loc.e2) = case D.trace "--> subsume end" $ appAll s.sub loc.expr of
                                                    Nothing -> error "Application failed in unify"
                                                    Just a  -> let sub = (loc.varnm, TyScheme_SystemF $ mkTop a) 
                                                               in D.trace ("!!! " ++ pp sub) $ update (s.pre, Right sub)
                               
                               lhs.pre = loc.q2
                               loc.ret = loc.e2 `munion` s.sub
                               lhs.sub = D.trace ("updating prefix: " ++ pp s.sub
                                               ++ " \n\t# " ++ pp s.pre 
                                               ++ " \n\t> " ++ pp loc.q2 
                                               ++ " \n\t("  ++ pp loc.expr ++ " => " ++ pp loc.ret ++ ")") loc.ret
                               lhs.frs = D.trace "unify - ***leftvar***" s.frs  
                             clause invalid
                               match True = isJust loc.phi
                               lhs.sub = empty
                               -- lhs.sub = error $ "Unable to execute unification on '"
                                              -- ++ pp lhs.exp1 ++ "' and '"++ pp lhs.exp2 ++ "', occurs check failed in prefix: "
                                              -- ++ pp lhs.pre
                         clause rightvar
                           match TyExpr.Var@var2 = lhs.exp2
                           loc.expr  = lhs.exp1
                           loc.varnm = var2.nm
                           -- | code duplication, bah, the graph reordering is screwed up
                           loc.q = D.trace ("unify - rightvar " ++ show (domain lhs.pre)) lhs.pre
                           loc.phi = loc.q `contains` loc.varnm
                           
                           internal occurs_check
                             clause valid2
                               match False = occursCheck loc.varnm loc.q (TyScheme_SystemF loc.expr)
                               loc.phi' = fromJust loc.phi
                               
                               loc.p = loc.expr
                               
                               child s : Subsume = subsume
                               
                               s.pre = loc.q
                               s.exp = loc.p
                               s.frs = D.trace ("Right: " ++ con loc.p ++ " - " ++ pp loc.p) lhs.frs
                               s.ty  = let c = dropQuant loc.phi'
                                       in D.trace ("Ty: " ++ sche c ++ " - " ++ pp c) c
                               
                               invoke subsume of s
                               
                               (loc.q2, loc.e2) = case D.trace "--> subsume end" $ appAll s.sub loc.expr of
                                                    Nothing -> error "Application failed in unify"
                                                    Just a  -> let sub = (loc.varnm, TyScheme_SystemF $ mkTop a) 
                                                               in D.trace ("!!! " ++ pp sub) $ update (s.pre, Right sub)
                               
                               lhs.pre = loc.q2
                               loc.ret = loc.e2 `munion` s.sub
                               lhs.sub = D.trace ("updating prefix: " ++ pp s.sub
                                               ++ " \n\t# " ++ pp s.pre 
                                               ++ " \n\t> " ++ pp loc.q2 
                                               ++ " \n\t("  ++ pp loc.expr ++ " => " ++ pp loc.ret ++ ")") loc.ret
                               lhs.frs = D.trace "unify - ***rightvar***" s.frs  
                             clause invalid2
                               match True = isJust loc.phi
                               lhs.sub = empty
                               -- lhs.sub = error $ "Unable to execute unification on '"
                                              -- ++ pp lhs.exp1 ++ "' and '"++ pp lhs.exp2 ++ "', occurs check failed in prefix: "
                                              -- ++ pp lhs.pre
                     clause quant
                       match TyExpr.Quant@var1 = lhs.exp1
                       match TyExpr.Quant@var2 = lhs.exp2
                       
                       child u : Unify = unify
                       
                       (loc.c, loc.frs1) = fresh lhs.frs
                       loc.varc = mkSkolem loc.c
                       u.frs  = loc.frs1
                       u.pre  = D.trace (  "[App] - Quant =>"
                                        ++ "\n\t(1) [" ++ pp var1.tyVar ++ ":=" ++ pp loc.varc ++ "] " ++ pp var1.tyExpr
                                        ++ "\n\t(2) [" ++ pp var2.tyVar ++ ":=" ++ pp loc.varc ++ "] " ++ pp var2.tyExpr) $ lhs.pre
                       u.exp1 = maybe (error "App failed in unify - exp1") id $ app (var1.tyVar, loc.varc) var1.tyExpr
                       u.exp2 = maybe (error "App failed in unify - exp2") id $ app (var2.tyVar, loc.varc) var2.tyExpr
                       
                       invoke unify of u
                       
                       loc.q1 = u.pre
                       loc.e1 = u.sub
                       
                       loc.check = loc.c `elem` (codomain loc.e1 ++ codomain loc.q1)
                       
                       internal skol_check
                          clause succeeded
                            match False  = loc.check
                            lhs.pre = loc.q1
                            lhs.sub = loc.e1
                            lhs.frs = u.frs
                          clause failed
                            match (loc.bla, True) = ((), loc.check)
                            lhs.sub = const (error "Subsume failure, A skolem constant has leaked outside") loc.bla
                     -- clause explicit_quant_left
                       -- match TyExpr.Quant@var1 = lhs.exp1
                       
                       -- child u : Unify = unify
                       
                       -- (loc.c, loc.frs1) = fresh lhs.frs
                       -- loc.varc = mkVar loc.c
                       
                       -- u.frs = loc.frs1
                       -- u.pre = D.trace ("Expanding Environment, Adding Universally quantified variable - " ++ pp loc.c) 
                                  -- $ lhs.pre ++ [TyIndex_Group loc.c TyQuantifiedScheme_Bottom]
                       -- u.exp2 = lhs.exp2
                       -- u.exp1 = case app (var1.tyVar, loc.varc) var1.tyExpr of
                                  -- Nothing -> error "Explicit quantification failed in app"
                                  -- Just a  -> a
                                  
                       -- invoke unify of u
                       
                       -- lhs.pre = u.pre
                       -- lhs.sub = u.sub
                     -- clause explicit_quant_right
                       -- match TyExpr.Quant@var1 = lhs.exp2
                       
                       -- child u : Unify = unify
                       
                       -- (loc.c, loc.frs1) = fresh lhs.frs
                       -- loc.varc = mkVar loc.c
                       
                       -- u.frs = loc.frs1
                       -- u.pre = D.trace ("Expanding Environment, Adding Universally quantified variable" ++ pp loc.c) 
                                  -- $ lhs.pre ++ [TyIndex_Group loc.c TyQuantifiedScheme_Bottom]
                       -- u.exp1 = lhs.exp1
                       -- u.exp2 = case app (var1.tyVar, loc.varc) var1.tyExpr of
                                  -- Nothing -> error "Explicit quantification failed in app"
                                  -- Just a  -> a
                                  
                       -- invoke unify of u
                       
                       -- lhs.pre = u.pre
                       -- lhs.sub = u.sub
                     clause mismatch
                       lhs.sub = error $   "Could not match expected type '" 
                                        ++ pp (clean lhs.exp1) ++ "' with inferred type '" 
                                        ++ pp (clean lhs.exp2) -- ++ "' under Prefix: " 
                                        -- ++ pp lhs.pre
                 clause f_unify
                   match (loc.bla, False) = ((), loc.nf)
                   lhs.sub = const (error "Unify failure, one or both of the TyExpr are not in normal form.") loc.bla
 
typeCheck ::  Expr -> IO ([TyScheme], Env, Prefix, Int)
typeCheck exp = do
  let inh = Inh_Expr_infer { exp_Inh_Expr = exp
                           , env_Inh_Expr = Gamma empty
                           , pre_Inh_Expr = []
                           , ast_Inh_Expr = exp
                           , frs_Inh_Expr = 1
                           }
  syn <- invoke_Expr_infer dnt_Expr inh
  let res = res_Syn_Expr syn
      sub = sub_Syn_Expr syn
      nxe = nxe_Syn_Expr syn
      frs = frs_Syn_Expr syn
  return (res, sub, nxe, frs)
  
exampleLet  = Expr_Let False [] (Expr_IConst 3)
exampleLet2 = Expr_Let False [Decl_Val (PatExpr_Var $ mkName "a") (Expr_IConst 3)] (Expr_Var $ mkName "a")
}