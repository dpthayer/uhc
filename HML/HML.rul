{
{-# LANGUAGE BangPatterns          #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE TypeSynonymInstances  #-}
module HML where

import Control.Monad.Error
import Pretty   
import qualified Data.Map as M
import Control.Monad
import Control.Arrow hiding (app)
import Control.Applicative((<$>), (<|>))

import Data.List
import Data.Maybe hiding (mapMaybe)

import EH8.EH
import EH8.Base.HsName
import EH8.Ty(tyQu_Forall)

import EqHML
import Utils

import EH.Util.Pretty hiding (pp, empty)
import qualified Debug.Trace as D
}
    
data TyQu
  con TyForall
    
data TyExpr
  con Con
    nm        :: HsName
  con App
    func      :: TyExpr
    arg       :: TyExpr
  con AppTop
    tyExpr    :: TyExpr
  con Parens
    tyExpr    :: TyExpr
  con Ann
    ann       :: TyExprAnn
    tyExpr    :: TyExpr
  con Wild
  con Mono
  con Var
    nm        :: HsName
  con VarWild
    mm        :: HsName
  con Quant
    qu        :: TyQu
    tyVar     :: HsName
    tyExpr    :: TyExpr
  con Forall
    qu        :: TyQu
    tyVar     :: [HsName]
    tyExpr    :: TyExpr    
  con Row
    rowTyExpr :: RowTyExpr
    
data TyVar
  con Var
    nm      :: HsName
    
type TyVars : [TyVar]
    
-- Type Index (a1 >= TyQuantifiedScheme)
data TyIndex
  con Group
    varnm   :: HsName
    bounds  :: TyQuantifiedScheme
    
-- -- Quantified type scheme
-- data TyQuantifiedScheme
  -- con Quant
    -- tyIndex  :: TyIndex
    -- tyScheme :: TyScheme
  -- con Bottom
   
-- Type Schemes
data TyScheme
  con Quant
    subst    :: Scheme
    tyExpr   :: TyScheme
  con SystemF
    tyExpr   :: TyExpr
  con Bottom
  -- These next two are just used internally
  con Sugar
     prefix  :: Prefix
     tyExpr  :: TyScheme
  con Forall
     tyQuant :: [HsName]
     tyExpr  :: TyScheme

-- A simple tybound e.f. (a >= phi)
data Scheme
  con Simple
    varnm  :: HsName
    bounds :: TyScheme
  
-- Mono type
data TyMono 
  con Var 
    nm      :: HsName
  con App
    func    :: TyMono
    arg     :: TyMono
  con Con
    nm      :: HsName
  con AppTop
    tyMono  :: TyMono
    
-- Unqualified typed
data TyPoly
  con Var 
    nm      :: HsName
  con App
    func    :: TyPoly
    arg     :: TyPoly
  con Con
    nm      :: HsName
  con SystemF
    tyExpr  :: TyExpr
    
data DataFieldExpr
  con Upd
    dataFieldExpr  :  DataFieldExpr
    nm             :: HsName
    expr           :  Expr
  con Con
    nm             :: HsName
  con Expr
    expr           :  Expr
   
data DataFieldPatExpr
  con Ext
    dataFieldPatExpr  :: DataFieldPatExpr
    nm                :: HsName
    patExpr           :: PatExpr
  con Con
    nm                :: HsName
    
data RecExpr
  con Empty
  con Ext
    recExpr     :  RecExpr
    mbNm        :: (Maybe HsName)
    expr        :  Expr
  con Upd
    recExpr     :  RecExpr
    mbNm        :: HsName
    expr        :  Expr
  con Expr
    expr        :  Expr
    
data RecPatExpr
  con Empty
  con Ext
    recPatExpr  :  RecPatExpr
    mbNm        :: (Maybe HsName)
    patExpr     :: PatExpr
  con Expr
    patExpr     :: PatExpr
    
data RowTyExpr
  con Empty
  con Ext
    rowTyExpr       :: RowTyExpr
    mbNm            :: (Maybe HsName)
    tyExpr          :: TyExpr
    
data KiExpr
  con Con
    nm       :: HsName
  con Var
    nm       :: HsName
  con App
    func     :: KiExpr
    arg      :: KiExpr
  con AppTop
    kiExpr   :: KiExpr
  con Parens
    kiExpr   :: KiExpr
  con Ann
    ann      :: KiExprAnn
    kiExpr   :: KiExpr
    
data Expr
  con IConst
    int           :: Int
  con CConst
    char          :: Char
  con Con
    nm            :: HsName
  con Var
    nm            :: HsName
  con App
    func          :  Expr
    arg           :  Expr
  con Let
    isStrict      :: Bool
    decls         :  Decls
    body          :  Expr
  con Lam
    arg           :: PatExpr
    body          :  Expr
  con AppTop
    expr          :  Expr
  con Parens
    expr          :  Expr
  con TypeAs
    tyExpr        :: TyExpr
    expr          :  Expr
  con Ann
    ann           :: ExprAnn
    expr          :  Expr
  con AppImpred
    func          :  Expr
    arg           :  Expr
  con SConst 
    str           :: String
  con Case
    expr          :  Expr
    alts          :: CaseAlts
    mbCaseIds     :: (Maybe UIDS)
    caseFailS     :: UIDS
    isTupOfArg    :: Bool
  con DataFields
    dataFieldExpr :: DataFieldExpr
  con Rec
    recExpr       :: RecExpr
  con Sel
    expr          :  Expr
    lbl           :: HsName
  con Undefined
  con CaseAltFail 
    caseId        :: UID
    
data PatExpr
  con IConst
    int              :: Int
  con CConst
    char             :: Char
  con Con
    nm               :: HsName
  con Var
    nm               :: HsName
  con VarAs
    nm               :: HsName
    patExpr          :: PatExpr
  con App
    func             :: PatExpr
    arg              :: PatExpr
  con AppTop
    patExpr          :: PatExpr
  con Parens
    patExpr          :: PatExpr
  con Ann
    ann              :: PatExprAnn
    patExpr          :: PatExpr
  con TypeAs
    tyExpr           :: TyExpr
    patExpr          :: PatExpr
  con SConst
    str              :: String
  con Rec
    recPatExpr       :: RecPatExpr
  con DataFields
    dataFieldPatExpr :: DataFieldPatExpr
  con Irrefutable
    patExpr          :: PatExpr
    
data CaseAlt
  con Pat
    patExpr   :: PatExpr
    expr      :  Expr

type CaseAlts : [CaseAlt]
    
data DataConstr
  con Constr
    conNm      :: HsName
    fields     :  DataFields
    
type DataConstrs : [DataConstr]

data DataField
  con Field
    mbLabels     :: (Maybe [HsName])
    tyExpr       :: TyExpr
    
type DataFields : [DataField]
   
data ExprAnn
  con Empty
  
data TyExprAnn
  con Empty

data PatExprAnn
  con Empty
  
data KiExprAnn
  con Empty
  
data Decl
  con TySig
    nm         :: HsName
    tyExpr     :: TyExpr
  con Val
    patExpr    :: PatExpr
    expr       :  Expr
  con Data
    isNewType  :: Bool
    tyNm       :: HsName
    tyVars     :: TyVars
    constrs    :: DataConstrs
  con KiSig
    nm         :: HsName
    kiExpr     :: KiExpr
  con FFI
    callconv   :: FFIWay
    safety     :: String
    impEnt     :: String
    nm         :: HsName
    tyExpr     :: TyExpr
  
type TyExprs : [TyExpr]
type Decls   : [Decl]
  
itf Expr
  visit infer
    inh pre :: Prefix
    inh env :: Gamma
    inh ast :: Expr
    inh exp :: Expr
    inh frs :: Int
    syn nxe :: Prefix
    syn sub :: Env
    syn res :: [TyScheme]
    syn frs :: Int
    
itf DataConstrs
  visit findTypes
    inh ast :: DataConstrs
    inh nm  :: TyExpr
    syn ty  :: [(HsName, TyExpr)]
    
itf DataConstr
  visit findType
    inh ast :: DataConstr
    inh nm  :: TyExpr
    syn ty  :: (HsName, TyExpr)
    
itf DataFields
  visit findTypes
    inh ast :: DataFields
    syn ty  :: TyExprs
    
itf DataField
  visit findType
    inh ast :: DataField
    syn ty  :: TyExpr
    
itf Decls
  visit infer
    inh ast :: Decls
    inh pre :: Prefix
    inh env :: Gamma
    inh frs :: Int
    syn nxe :: Prefix
    syn env :: Gamma
    syn sub :: Env
    syn frs :: Int
    
itf Decl
  visit infer
    inh ast :: Decl
    inh pre :: Prefix
    inh env :: Gamma
    inh frs :: Int
    syn nxe :: Prefix
    syn env :: Gamma -- These declarations can update the gamma in a non-linear way, so we have to return the new one
    syn sub :: Env
    syn frs :: Int
    
itf PatExpr
  visit vars
    inh ast    :: PatExpr
    syn var_nm :: HsName
  visit infer
    inh pre :: Prefix
    inh env :: Gamma
    inh exp :: PatExpr
    inh frs :: Int
    syn nxe :: Prefix
    syn env :: Gamma -- A PatExpr might want to expand the Gamma, so we need to again return it.
    syn sub :: Env
    syn res :: [TyScheme]
    syn frs :: Int
    
datasem DataFields monad IO
  clause Cons
    lhs.ty = hd.ty : tl.ty
  clause Nil
    lhs.ty = []
    
datasem DataField monad IO
  clause Field
    lhs.ty = loc.tyExpr
    
datasem DataConstr monad IO
  clause Constr
    lhs.ty = (loc.conNm, foldr mkArrow lhs.nm fields.ty)
    
datasem DataConstrs monad IO
  clause Cons
    hd.nm = lhs.nm
    tl.nm = lhs.nm
    lhs.ty = hd.ty : tl.ty
  clause Nil
    lhs.ty = []
    
datasem PatExpr monad IO
  clause IConst
    lhs.var_nm = error "IConst not a var"
    
    lhs.res = []
    -- lhs.sub = lhs.env
    lhs.env = lhs.env
    lhs.sub = []
    lhs.nxe = lhs.pre
    lhs.frs = lhs.frs
  clause CConst
    lhs.var_nm = error "CConst not a var"
    
    lhs.res = []
    -- lhs.sub = lhs.env
    lhs.env = lhs.env
    lhs.sub = []
    lhs.nxe = lhs.pre
    lhs.frs = lhs.frs
  clause Con
    lhs.var_nm = error "Constructors not supported"
    
    lhs.res = []
    -- lhs.sub = lhs.env
    lhs.env = lhs.env
    lhs.sub = []
    lhs.nxe = lhs.pre
    lhs.frs = lhs.frs
  clause Var
    lhs.var_nm = loc.nm 
    
    (loc.a, loc.frs1) = fresh lhs.frs
    loc.exp_a  = TyScheme_SystemF $ TyExpr_Var loc.a
    lhs.res    = [loc.exp_a]
    lhs.env    = Gamma $ minsert loc.nm loc.exp_a (unGam lhs.env)
    lhs.sub    = []
    lhs.nxe    = (TyIndex_Group loc.a TyScheme_Bottom):lhs.pre
    lhs.frs    = loc.frs1
  clause VarAs
    lhs.var_nm = loc.nm 
    
    lhs.res = []
    -- lhs.sub = lhs.env
    lhs.env = lhs.env
    lhs.sub = []
    lhs.nxe = lhs.pre
    lhs.frs = lhs.frs
  clause App
    lhs.var_nm = error "App not a var"
    
    lhs.res = []
    -- lhs.sub = lhs.env
    lhs.env = lhs.env
    lhs.sub = []
    lhs.nxe = lhs.pre
    lhs.frs = lhs.frs
  clause AppTop
    lhs.var_nm = error "AppTop not a var"
    
    lhs.res = []
    -- lhs.sub = lhs.env
    lhs.env = lhs.env
    lhs.sub = []
    lhs.nxe = lhs.pre
    lhs.frs = lhs.frs
  clause Parens
    child patExpr : PatExpr
    patExpr.ast = loc.patExpr
    
    patExpr.exp = loc.patExpr
    patExpr.env = lhs.env
    patExpr.frs = lhs.frs
    patExpr.pre = lhs.pre
    
    invoke vars of patExpr
    -- invoke infer of patExpr
    
    lhs.var_nm = patExpr.var_nm
    
    lhs.res = patExpr.res
    lhs.sub = patExpr.sub
    lhs.nxe = patExpr.nxe
    lhs.env = patExpr.env
    lhs.frs = patExpr.frs
  clause Ann
    child patExpr : PatExpr
    patExpr.ast = loc.patExpr
        
    invoke vars of patExpr
    
    patExpr.exp = loc.patExpr
    patExpr.env = lhs.env
    patExpr.frs = lhs.frs
    patExpr.pre = lhs.pre
    
    lhs.var_nm = patExpr.var_nm 
    
    lhs.res = patExpr.res
    lhs.sub = patExpr.sub
    lhs.env = patExpr.env
    lhs.nxe = patExpr.nxe
    lhs.frs = patExpr.frs
  clause TypeAs
    child patExpr : PatExpr
    patExpr.ast = loc.patExpr
    
    invoke vars of patExpr
    
    lhs.var_nm = patExpr.var_nm
    
    loc.ans = TyScheme_SystemF (TyExpr_Parens loc.tyExpr)
    lhs.res = [loc.ans]
    lhs.env = Gamma $ minsert patExpr.var_nm loc.ans (unGam lhs.env)
    lhs.sub = []
    lhs.nxe = lhs.pre
    lhs.frs = lhs.frs
  clause SConst
    lhs.var_nm = error "SConst not a var"
    
    lhs.res = []
    -- lhs.sub = lhs.env
    lhs.sub = []
    lhs.nxe = lhs.pre
    lhs.env = lhs.env
    lhs.frs = lhs.frs
  clause Rec
    lhs.var_nm = error "Rec not a var"
    
    lhs.res = []
    -- lhs.sub = lhs.env
    lhs.sub = []
    lhs.nxe = lhs.pre
    lhs.env = lhs.env
    lhs.frs = lhs.frs
  clause DataFields
    lhs.var_nm = error "DataFields not a var"
    
    lhs.res = []
    -- lhs.sub = lhs.env
    lhs.sub = []
    lhs.nxe = lhs.pre
    lhs.env = lhs.env
    lhs.frs = lhs.frs
  clause Irrefutable 
    lhs.var_nm = error "Irrefutable not a var"
    
    lhs.res = []
    -- lhs.sub = lhs.env
    lhs.sub = []
    lhs.nxe = lhs.pre
    lhs.env = lhs.env
    lhs.frs = lhs.frs
    
datasem Decl monad IO
  default? sub = const []
  -- default? env = last
  clause Val
    match PatExpr.Var@loc = loc.patExpr
    
    expr.pre = lhs.pre
    expr.env = lhs.env
    expr.exp = loc.expr
    expr.frs = lhs.frs

    invoke infer of expr

    lhs.nxe = expr.nxe
    lhs.env = let (Left adjusted) = apply expr.sub lhs.env
              in case expr.res of
                   [] -> error  $ "Inference failed datasem Decl clause Val. No result"
                   x  -> Gamma $ foldr (\a->minsert loc.nm a) (unGam adjusted) x -- update the Gamma
    lhs.frs = expr.frs
  clause TySig
    lhs.nxe = lhs.pre
    lhs.env = Gamma $ minsert loc.nm (TyScheme_SystemF loc.tyExpr) (unGam lhs.env)  -- update the Gamma
    lhs.frs = lhs.frs
  clause Data
     child constrs : DataConstrs
     constrs.ast = loc.constrs
     constrs.nm = let vars = map (\(TyVar_Var x) -> TyExpr_Var x) loc.tyVars
                  in  foldl TyExpr_App (TyExpr_Con loc.tyNm) vars
     
     invoke findTypes of constrs
     
     lhs.env = Gamma $ (foldr (.) id . map (\(k,v)->minsert k (mkQuantified v))) constrs.ty (unGam lhs.env) -- update the Gamma
     lhs.nxe = lhs.pre
     lhs.frs = lhs.frs
  clause FFI
     loc.vars = nub $ ftv loc.tyExpr
     loc.exp = let tyExpr = simplify loc.tyExpr
               in case null loc.vars of
                   True  -> tyExpr
                   False -> foldl (.) id (map (TyExpr_Quant tyQu_Forall) loc.vars) tyExpr
     lhs.env = Gamma $ minsert loc.nm (TyScheme_SystemF loc.exp) (unGam lhs.env) -- update the Gamma
     lhs.nxe = lhs.pre
     lhs.frs = lhs.frs
  clause KiSig
     -- lhs.sub = lhs.env
     lhs.env = lhs.env
     lhs.nxe = lhs.pre
     lhs.frs = lhs.frs
    
datasem Decls monad IO
  default? sub = const []
  -- default? env = last
  -- default? nxe = last
  -- default? frs = last
  clause Cons
    hd.pre     = lhs.pre
    hd.env     = lhs.env
    hd.frs     = lhs.frs
    invoke infer of hd
    
    tl.env     = hd.env
    tl.pre     = hd.nxe
    tl.frs     = hd.frs
    invoke infer of tl
    
    lhs.nxe       = tl.nxe
    lhs.sub       = munion hd.sub tl.sub
    lhs.frs       = tl.frs
    lhs.env       = tl.env
  clause Nil
    -- lhs.sub       = lhs.env
    lhs.nxe       = lhs.pre
    lhs.frs       = lhs.frs
    lhs.env       = lhs.env
       
datasem Expr monad IO
    clause Var
        -- lhs.res = maybe (error "Variable not found in lookup") (:[]) $ M.lookup loc.nm lhs.env
        (lhs.res, loc.frs)
             = case lookup loc.nm (unGam lhs.env) of
                Just a  -> ([promote a lhs.frs], lhs.frs) -- Is this the proper way to get mutual recursion working?
                Nothing -> error $ "Variable '" ++ show loc.nm ++ "' not in scope"
                -- Nothing -> (return . TyScheme_SystemF . TyExpr_Var *** id) (fresh lhs.frs)
        lhs.sub = empty
        lhs.nxe = lhs.pre
        lhs.frs = loc.frs
    clause IConst
       lhs.res = return $ TyScheme_SystemF $ TyExpr_Con $ mkName "Int"
       lhs.sub = empty
       lhs.nxe = lhs.pre
       lhs.frs = lhs.frs
    clause CConst
       lhs.res = return $ TyScheme_SystemF $ TyExpr_Con $ mkName "Char"
       lhs.sub = empty
       lhs.nxe = lhs.pre
       lhs.frs = lhs.frs
    clause Con
       lhs.res = maybe (error "Constructor not found in lookup") (:[]) $ lookup loc.nm (unGam lhs.env)
       lhs.sub = empty
       lhs.nxe = lhs.pre
       lhs.frs = lhs.frs
    clause App
       loc.frs            = lhs.frs
       (loc.a1, loc.frs1) = fresh loc.frs
       (loc.a2, loc.frs2) = fresh loc.frs1
       (loc.b , loc.frs3) = fresh loc.frs2
       
       func.exp = loc.func
       func.frs = loc.frs3
       func.pre = lhs.pre
       func.env = lhs.env
       
       invoke infer of func
       
       (loc.func_nxe, loc.func_res) = explode func.nxe (head func.res)
       -- loc.func_nxe = func.nxe `munion` loc.func_nx
       
       arg.exp = loc.arg
       arg.frs = func.frs
       arg.pre = loc.func_nxe
       arg.env = let (Just e) = appAll func.sub lhs.env
                 in e
       
       invoke infer of arg
       
       (loc.arg_nxe, loc.arg_res) = explode arg.nxe (head arg.res)
       -- loc.arg_nxe = arg.nxe `munion` loc.arg_nx
       
       loc.debug1 = trace ("[App] func -- " ++ sche loc.func_res ++ " # " ++ pp loc.func_res) loc.func_res
       loc.debug2 = trace ("[App] arg  -- " ++ sche loc.arg_res  ++ " # " ++ pp loc.arg_res ) loc.arg_res
       loc.debug3 = trace ("A1: " ++ show loc.a1 ++ ", A2: " ++ show loc.a2 ++ ", B: " ++ show loc.b) loc.arg_res
       
       (loc.temp1, loc.frt1) = extend (loc.arg_nxe, Scheme_Simple loc.a1 (fromJust $ appAll arg.sub loc.func_res), arg.frs) True
       (loc.temp2, loc.frt2) = extend (fst loc.temp1, Scheme_Simple loc.a2 (loc.arg_res), loc.frt1) True
       (loc.temp3, loc.frt3) = extend (fst loc.temp2, Scheme_Simple loc.b  (TyScheme_Bottom), loc.frt2) True
       
       (loc.q2', loc.e2') = (fst loc.temp3, (snd loc.temp1) `munion` (snd loc.temp2) `munion` (snd loc.temp3))
       
       child u : Unify = unify
       u.pre  = trace ("app - unify " ++ pp loc.q2' ++ " -- " ++ pp loc.e2') loc.q2'
       -- unsafe. Needs to be rewritten
       u.exp1 = let c = fromJust $ appAll loc.e2' (TyExpr_Var loc.a1)
                in trace ("Con1: " ++ con c ++ " # " ++ pp c) c
       u.exp2 = let c = (fromJust $ appAll loc.e2' (TyExpr_Var loc.a2)) `mkArrow` (TyExpr_Var loc.b)
                in trace ("Con2: " ++ con c ++ " # " ++ pp c) c
       u.frs  = loc.frt3
       
       invoke unify of u
       
       loc.q3 = u.pre
       loc.e3 = trace ("unify done: " ++ pp u.sub) u.sub
       
       (loc.q4, loc.q5) = curry split loc.q3 (domain lhs.pre)
       -- loc.q4 = loc.func_nx `munion` loc.arg_nx `munion` loc.q4'
    
       lhs.res = let b = TyExpr_Var loc.b
                 in case appAll (loc.e3 `munion` loc.e2') b of
                      Just v  -> let e = return $ ptype $ desugar $ TyScheme_Sugar loc.q5 (TyScheme_SystemF v)
                                 in trace ("^^Type: " ++ pp e) e
                      Nothing -> error "App failed, cannot apply substitution"
       loc.temp_sub = let subs = applyEnv loc.e2' (func.sub `munion` arg.sub)
                      in subs `munion` loc.e3 -- added union
       lhs.sub = loc.temp_sub
       lhs.nxe = loc.q4
       lhs.frs = let d1 = trace ("^^Unify pre: " ++ pp loc.q3)
                     d2 = trace ("^^NXE: " ++ pp loc.q4)
                     d3 = trace ("^^Sub: " ++ pp loc.temp_sub)
                 in d1 $ d2 $ d3 u.frs
    clause Let
        -- | Preprocess the binds to fill the environemnt
        (loc.frs, loc.binds)  = let nms         = getBindLHs loc.decls
                                    (vars, frs) = freshM lhs.frs (length nms)
                                in (frs, zipWith (\a b->(a, mkQVar b)) nms vars)
        loc.env   = Gamma $ foldr (.) id (map (\(k,v)->minsert k v) loc.binds) (unGam lhs.env) -- temporaty update the environment. this will later be updated
        
        decls.pre = lhs.pre
        decls.env = loc.env
        decls.frs = loc.frs

        invoke infer of decls

        body.pre = decls.nxe
        body.env = decls.env
        body.exp = loc.body
        body.frs = decls.frs

        invoke infer of body

        lhs.nxe = body.nxe
        lhs.res = body.res
        lhs.sub = munion decls.sub body.sub
        lhs.frs = body.frs
    clause Lam
        child arg : PatExpr
        arg.ast = loc.arg
        arg.env = lhs.env
        arg.pre = lhs.pre
        arg.exp = loc.arg
        arg.frs = lhs.frs
        
        invoke vars of arg
        invoke infer of arg
    
       loc.frs           = arg.frs
       (TyScheme_SystemF loc.exp_a) = case arg.res of -- error reporting on local variables is off
                                        [x] -> x
                                        _   -> error "No type infered from PatExpr in Lam"
       (loc.b, loc.frs2) = fresh loc.frs
       loc.q'            = arg.nxe
       loc.env'          = arg.env
       
       body.frs = loc.frs2
       body.env = loc.env'
       body.pre = loc.q'
       body.exp = loc.body
       
       invoke infer of body
       
       loc.env_full = munion arg.sub body.sub
       
       loc.tau = let x = appAll loc.env_full loc.exp_a
                 in case x of
                      (Just x') | (isUnQualTy x' || not (isVar loc.arg))
                                       -> x
                      _                -> error "The resulting type is not a Tau type"
       (loc.q2,  loc.q3)  = curry split body.nxe (domain lhs.pre)
       loc.phi1           = case body.res of
                              []  -> error "Inference of Expressions failed in Lam, no type infered for body"
                              [x] -> x
                              _   -> error "Too many options, I only need one"
                              
       (loc.q3_, loc.phi1') = explode loc.q3 loc.phi1
       
       ((loc.q3', loc.e3'), loc.frs') = extend (loc.q3_, (Scheme_Simple loc.b loc.phi1'), body.frs) False
       
       lhs.res = let (Just b')    = appAll loc.e3' (TyExpr_Var loc.b)
                     (Just a')    = appAll body.sub loc.exp_a -- (TyExpr_Var loc.a)
                     arrow = mkArrow a' b'
                 in return $ ptype $ desugar $ TyScheme_Sugar loc.q3' (TyScheme_SystemF arrow)
       lhs.sub = body.sub
       lhs.nxe = loc.q2
       lhs.frs = loc.frs'
    clause AppTop
       expr.pre = lhs.pre
       expr.env = lhs.env
       expr.frs = lhs.frs
       expr.exp = loc.expr
       
       invoke infer of expr
       
       lhs.res = expr.res
       lhs.sub = expr.sub
       lhs.nxe = expr.nxe
       lhs.frs = expr.frs
    clause Parens
       expr.pre = lhs.pre
       expr.env = lhs.env
       expr.frs = lhs.frs
       expr.exp = loc.expr
       
       invoke infer of expr
       
       lhs.res = expr.res
       lhs.sub = expr.sub
       lhs.nxe = expr.nxe
       lhs.frs = expr.frs
    clause TypeAs
       lhs.res = []
       lhs.sub = []
       lhs.nxe = lhs.pre
       lhs.frs = lhs.frs
    clause Ann
       expr.pre = lhs.pre
       expr.env = lhs.env
       expr.frs = lhs.frs
       expr.exp = loc.expr
       
       invoke infer of expr
       
       lhs.res = expr.res
       lhs.sub = expr.sub
       lhs.nxe = expr.nxe
       lhs.frs = expr.frs
    clause   AppImpred
       lhs.res = []
       lhs.sub = [] -- lhs.env
       lhs.nxe = lhs.pre
       lhs.frs = lhs.frs
    clause Case
       lhs.res = []
       lhs.sub = [] -- lhs.env
       lhs.nxe = lhs.pre
       lhs.frs = lhs.frs
    clause CaseAltFail
       lhs.res = []
       lhs.sub = [] -- lhs.env
       lhs.nxe = lhs.pre
       lhs.frs = lhs.frs
    clause DataFields
       lhs.res = []
       lhs.sub = [] -- lhs.env
       lhs.nxe = lhs.pre
       lhs.frs = lhs.frs
    clause Rec
       lhs.res = []
       lhs.sub = [] -- lhs.env
       lhs.nxe = lhs.pre
       lhs.frs = lhs.frs
    clause SConst
       lhs.res = []
       lhs.sub = [] -- lhs.env
       lhs.nxe = lhs.pre
       lhs.frs = lhs.frs
    clause Sel
       lhs.res = []
       lhs.sub = [] -- lhs.env
       lhs.nxe = lhs.pre
       lhs.frs = lhs.frs
    clause Undefined
       (loc.a, loc.frs1) = fresh lhs.frs
       lhs.res = [TyScheme_SystemF $ TyExpr_Var loc.a]
       lhs.sub = [] -- lhs.env
       lhs.nxe = lhs.pre
       lhs.frs = loc.frs1
       
itf Unify
  visit unify
    inh pre  :: Prefix
    inh exp1 :: TyExpr
    inh exp2 :: TyExpr
    inh frs  :: Int
    syn pre  :: Prefix
    syn sub  :: Env
    syn frs  :: Int

itf Subsume
  visit subsume
    inh pre  :: Prefix
    inh exp  :: TyScheme
    inh ty   :: TyScheme
    inh frs  :: Int
    syn pre  :: Prefix
    syn sub  :: Env
    syn frs  :: Int
    
itf UnifyScheme
  visit unifyScheme
    inh pre  :: Prefix
    inh ty1  :: TyScheme
    inh ty2  :: TyScheme
    inh frs  :: Int
    syn pre  :: Prefix
    syn sub  :: Env
    syn ty   :: TyScheme
    syn frs  :: Int

{
unifyScheme = sem unifyScheme : UnifyScheme monad IO
                visit unifyScheme
                  default? pre = last
                  default? frs = last
                  default? sub = const empty
                  clause Main_unifyScheme
                    loc.nfTy = isNf lhs.ty1
                    loc.nfTs = isNf lhs.ty2
                    loc.nf   = True -- loc.nfTy && loc.nfTs
                    internal nf_check
                        loc.b1 = isBottom lhs.ty1
                        loc.b2 = isBottom lhs.ty2
                        clause s_subsume
                          match True       = loc.nf
                          internal bot_check
                            clause first_bottom
                                match True = loc.b1
                                (loc.q, loc.tyx) = splitQuant lhs.ty2
                                lhs.ty     = nf lhs.ty2 -- loc.tyx
                                lhs.pre    = lhs.pre -- munion loc.q lhs.pre
                            clause second_bottom
                                match True = loc.b2
                                (loc.q, loc.tyx) = splitQuant lhs.ty1
                                lhs.ty     = nf lhs.ty1 -- loc.tyx
                                lhs.pre    = lhs.pre -- munion loc.q lhs.pre
                            clause norm
                                match False = loc.b1 || loc.b2
                                match TyScheme.Sugar@exp1 = sugar $ nf lhs.ty1
                                match TyScheme.Sugar@exp2 = sugar $ nf lhs.ty2
                                
                                loc.q = lhs.pre
                                
                                child u : Unify = unify
                                
                                u.pre  = let q = loc.q ++ exp1.prefix ++ exp2.prefix
                                         in trace (";;; Q: " ++ pp q) q
                                u.exp1 = dropScheme exp1.tyExpr
                                u.exp2 = dropScheme exp2.tyExpr
                                u.frs  = lhs.frs
                                
                                invoke unify of u
                                
                                loc.q3 = u.pre
                                loc.e3 = u.sub
                                
                                (loc.q4, loc.q5) = split (loc.q3, domain loc.q)
                                
                                lhs.frs = u.frs
                                lhs.pre = loc.q4
                                lhs.sub = loc.e3
                                lhs.ty  = let (Just ty)  = appAll loc.e3 exp1.tyExpr
                                              ret = TyScheme_Sugar loc.q5 ty
                                          in ptype $ desugar ret
                        clause f_subsume
                          match False                 = loc.nf
                          lhs.ty = error "unifyScheme failure, ty1 or ty2 is not in normal form"

subsume = sem subsume : Subsume monad IO 
             visit subsume
               default? pre = last
               default? frs = last
               clause Main_subsume
                loc.ty   = nf lhs.ty
                loc.nfTy = isNf lhs.exp
                loc.nfTs = isNf loc.ty
                loc.nf   = trace "Subsume NF check" $ loc.nfTy && loc.nfTs
                internal nf_check
                    clause s_subsume
                      match True                  = loc.nf
                      match TyScheme.Sugar@exp    = sugar lhs.exp -- $ mkQuant lhs.exp
                      match TyScheme.Sugar@scheme = sugar loc.ty
                      
                      loc.q  = lhs.pre
                      loc.q2 = scheme.prefix
                      
                      child u : Unify = unify
                      
                      loc.dom = nub $ domain exp.prefix
                      
                      (loc.c, loc.frs1) = trace ("subsume - init " ++ pp (const scheme.prefix exp.tyExpr) ++ " ++ " ++ pp exp.prefix) $ freshM lhs.frs (length $ loc.dom)
                      loc.qq2 = let q = loc.q ++ loc.q2
                                in trace ("subsume -- " ++ pp q) q
                      u.pre  = loc.qq2
                      u.exp1 = case appAll (zipWith (\a b->(a, mkSkolem b)) loc.dom loc.c) exp.tyExpr of
                                 Just a  -> trace ("un1: " ++ sche a) (const (dropScheme a) scheme.prefix)
                                 Nothing -> error "Subsume failure, substitution failed"
                      u.exp2 = let f = dropScheme scheme.tyExpr
                               in trace ("un2: " ++ con f) (const f exp.tyExpr)
                      u.frs  = loc.frs1
                      
                      invoke unify of u
                      
                      loc.q1 = u.pre
                      loc.e1 = u.sub
                      
                      (loc.q3, loc.q4) = split (loc.q1, domain loc.q)
                      loc.e2 = let x = nub (domain loc.q4)
                               in trace (   "Removing domain: " ++ pp x 
                                           ++ "\n\t&&> " ++ pp loc.e1
                                           ++ "\n\t&&> " ++ pp (loc.e1 `remove` x)) $ loc.e1 `remove` x
                      
                      loc.check =  any (flip elem (codomain loc.e2 ++ codomain loc.q3)) loc.c
                      
                      internal skol_check
                        clause succeeded
                          match False  = loc.check
                          lhs.pre = loc.q3
                          lhs.sub = trace ("Subscheme result: " ++ pp loc.e2) loc.e2
                          lhs.frs = u.frs
                        clause failed
                          match (loc.bla, True) = ((), loc.check)
                          lhs.sub = const (error "Subsume failure, a skolem variable has leaked to the env.") loc.bla
                    
                    clause wild_subsume
                      match True                  = loc.nf
                      match (loc.fo, TyScheme.Bottom@l)     = ((), sugar lhs.ty)
                      lhs.sub = trace "Wild subsume" (const empty loc.fo)
                      -- lhs.pre = let new = case lhs.exp of
                                            -- TyExpr_Var a -> [TyIndex_Group a TyScheme_Bottom]
                                            -- _           -> []
                                -- in lhs.pre `munion` new
                      
                    clause f_subsume
                      match (loc.bla, False) = ((), loc.nf)
                      lhs.sub = const (error $ "Subsume failure, the given type is not in normal form.") loc.bla

unify = sem unify : Unify monad IO    
          visit unify
             default? pre = last
             default? frs = last
             default? sub = const (error "Generic Unify failure")
             clause Main_unify
               loc.nfTy1 = isNf lhs.exp1
               loc.nfTy2 = isNf lhs.exp2
               loc.nf    = loc.nfTy1 && loc.nfTy2
               internal nf_check
                 clause s_unify
                   match True  = loc.nf
                   internal ty_check
                     clause LeftTop
                       match TyExpr.AppTop@app = lhs.exp1
                       
                       child u : Unify = unify
                       
                       u.pre  = lhs.pre
                       u.frs  = lhs.frs
                       u.exp2 = lhs.exp2
                       u.exp1 = trace ("AppTop Stripped. # " ++ con app.tyExpr) app.tyExpr
                       
                       invoke unify of u
                       
                       lhs.frs = u.frs
                       lhs.pre = u.pre
                       lhs.sub = u.sub
                     clause RightTop
                       match TyExpr.AppTop@app = lhs.exp2
                       
                       child u : Unify = unify
                       
                       u.pre  = lhs.pre
                       u.frs  = lhs.frs
                       u.exp1 = lhs.exp1
                       u.exp2 = trace ("AppTop Stripped. # " ++ con app.tyExpr) app.tyExpr
                       
                       invoke unify of u
                       
                       lhs.frs = u.frs
                       lhs.pre = u.pre
                       lhs.sub = u.sub
                     clause LeftParens
                       match TyExpr.Parens@app = lhs.exp1
                       
                       child u : Unify = unify
                       
                       u.pre  = lhs.pre
                       u.frs  = lhs.frs
                       u.exp2 = lhs.exp2
                       u.exp1 = trace ("Parens Stripped. # " ++ con app.tyExpr) app.tyExpr
                       
                       invoke unify of u
                       
                       lhs.frs = u.frs
                       lhs.pre = u.pre
                       lhs.sub = u.sub
                     clause RightParens
                       match TyExpr.Parens@app = lhs.exp2
                       
                       child u : Unify = unify
                       
                       u.pre  = lhs.pre
                       u.frs  = lhs.frs
                       u.exp1 = lhs.exp1
                       u.exp2 = trace ("Parens Stripped. # " ++ con app.tyExpr) app.tyExpr
                       
                       invoke unify of u
                       
                       lhs.frs = u.frs
                       lhs.pre = u.pre
                       lhs.sub = u.sub
                     clause vars
                       match TyExpr.Var@var1 = lhs.exp1
                       match TyExpr.Var@var2 = lhs.exp2
                       
                       internal case_check
                         clause eq_vars
                           match True = var1.nm == var2.nm
                           lhs.sub = trace "Variable match" empty
                         clause rest_vars
                           loc.q  = lhs.pre
                           loc.p1 = loc.q `contains` var1.nm
                           loc.p2 = loc.q `contains` var2.nm
                           internal var_check
                             loc.isJust    = isJust loc.p1 && isJust loc.p2
                             clause pure_var
                               match False = loc.isJust
                               lhs.sub = empty 
                             clause ty_var
                               match True  = loc.isJust
                               loc.phi1 = fromJust loc.p1
                               loc.phi2 = fromJust loc.p2
                               -- loc.exists = let v1 = (loc.q `elide` loc.phi1) `contains` var1.nm
                                                -- v2 = (loc.q `elide` loc.phi2) `contains` var2.nm
                                            -- in isJust v1 || isJust v2
                               loc.exists = let v1 = occursCheck var1.nm loc.q (toScheme loc.phi2)
                                                v2 = occursCheck var2.nm loc.q (toScheme loc.phi1)
                                            in v1 || v2
                               internal dom_check
                                 clause s_dom_check
                                   match True  = loc.exists
                                   lhs.sub = error "Domain check failed in Unify"
                                 clause f_dom_check
                                   match False = loc.exists
                                   
                                   child s : UnifyScheme = unifyScheme
                                   
                                   s.pre = loc.q
                                   s.frs = lhs.frs
                                   s.ty1 = let ty = dropQuant loc.phi1
                                           in trace (";;; ty2 = " ++ pp ty ++" -- " ++ pp loc.phi1) ty
                                   s.ty2 = let ty = dropQuant loc.phi2
                                           in trace (";;; ty2 = " ++ pp ty) ty
                                   
                                   invoke unifyScheme of s
                                   
                                   loc.q1  = s.pre
                                   loc.e1  = s.sub
                                   loc.phi = s.ty
                                   
                                   (loc.q2, loc.e2) = update (loc.q1, Right (var1.nm, TyScheme_SystemF $ TyExpr_Var var2.nm))
                                   (loc.q3, loc.e3) = update (loc.q2, Left (Scheme_Simple var2.nm loc.phi)) 
                                   
                                   lhs.frs = s.frs
                                   lhs.pre = loc.q3
                                   lhs.sub = let x = loc.e3 `munion` loc.e2 `munion` loc.e1
                                                 d0 = trace ("++ q3 [" ++ pp var2.nm ++ "]= " ++ pp loc.q3)
                                                 dx = trace ("++ q2 = " ++ pp loc.q2)
                                                 di = trace ("++ q1 = " ++ pp loc.q2)
                                                 dj = trace ("++ ty = " ++ pp loc.phi)
                                                 d1 = trace ("++ e3 = " ++ pp loc.e3)
                                                 d2 = trace ("++ e2 = " ++ pp loc.e2)
                                                 d3 = trace ("++ e1 = " ++ pp loc.e1)
                                             in di $ dj $ dx $ d0 $ d1 $ d2 $ d3 $ trace ("++ unifyScheme + unify done: " ++ pp x) x
                     clause cons
                       match TyExpr.Con@var1 = lhs.exp1
                       match TyExpr.Con@var2 = lhs.exp2
                       
                       loc.eq = var1.nm == var2.nm
                       
                       internal con_check
                          clause succeeded1
                            match True  = loc.eq
                            lhs.sub     = empty
                          clause failed1
                            match False = loc.eq
                            lhs.sub = error $ "Type mismatch, expected '" ++ show var1.nm ++ "' but got '" ++ show var2.nm ++ "'"
                     clause apptype
                       match TyExpr.App@app1 = lhs.exp1
                       match TyExpr.App@app2 = lhs.exp2
                       
                       loc.fake =(const . const) "" app1.func app2.func
                       
                       child uf : Unify = unify
                       
                       uf.frs  = trace "-- Unify App --" lhs.frs
                       uf.pre  = lhs.pre
                       uf.exp1 = trace ("Func1L: " ++ con app1.func ++ loc.fake) app1.func
                       uf.exp2 = trace ("Func2L: " ++ con app2.func ++ loc.fake) app2.func
                       
                       invoke unify of uf
                       
                       child ua : Unify = unify
                       
                       ua.frs  = uf.frs
                       ua.pre  = uf.pre
                       ua.exp1 = let (Just arg) = appAll uf.sub app1.arg
                                     d1 = trace ("&Pref: " ++ pp uf.pre ++ "\n&Sub:  " ++ pp uf.sub)
                                 in d1 $ trace ("Func1R: " ++ con arg) arg
                       ua.exp2 = let (Just arg) = appAll uf.sub app2.arg
                                 in trace ("Func2R: " ++ con arg) arg
                       
                       invoke unify of ua
                       
                       lhs.pre = ua.pre
                       lhs.sub = uf.sub `munion` ua.sub
                       
                     clause vartype
                       -- hopefully clauses are tried in-order, or else this would be a problem  
                           
                       internal varchoice
                         clause leftvar
                           match TyExpr.Var@var1 = lhs.exp1
                           loc.expr  = lhs.exp2
                           loc.varnm = var1.nm
                           -- | code duplication, bah, the graph reordering is screwed up
                           loc.q = trace ("unify - leftvar " ++ show (domain lhs.pre)) lhs.pre
                           loc.phi = loc.q `contains` loc.varnm
                           
                           internal occurs_check
                             clause valid
                               match False = occursCheck loc.varnm loc.q (TyScheme_SystemF loc.expr)
                               loc.phi' = fromJust loc.phi
                               
                               loc.p = TyScheme_SystemF loc.expr
                               
                               child s : Subsume = subsume
                               
                               s.pre = loc.q
                               s.exp = loc.p
                               s.frs = trace ("Left: " ++ sche loc.p ++ " - " ++ pp loc.p) lhs.frs
                               s.ty  = let c = dropQuant loc.phi'
                                       in trace ("Ty: " ++ sche c ++ " - " ++ pp c) c
                               
                               invoke subsume of s
                               
                               (loc.q2, loc.e2) = case trace "--> subsume end" $ appAll s.sub loc.expr of
                                                    Nothing -> error "Application failed in unify"
                                                    Just a  -> let sub = (loc.varnm, TyScheme_SystemF $ mkTop a) 
                                                               in trace ("!!! " ++ pp sub) $ update (s.pre, Right sub)
                               
                               lhs.pre = loc.q2
                               loc.ret = loc.e2 `munion` s.sub
                               lhs.sub = trace ("updating prefix: " ++ pp s.sub
                                               ++ " \n\t# " ++ pp s.pre 
                                               ++ " \n\t> " ++ pp loc.q2 
                                               ++ " \n\t("  ++ pp loc.expr ++ " => " ++ pp loc.ret ++ ")") loc.ret
                               lhs.frs = trace "unify - ***leftvar***" s.frs  
                             clause invalid
                               match True = isJust loc.phi
                               lhs.sub = empty
                               -- lhs.sub = error $ "Unable to execute unification on '"
                                              -- ++ pp lhs.exp1 ++ "' and '"++ pp lhs.exp2 ++ "', occurs check failed in prefix: "
                                              -- ++ pp lhs.pre
                         clause rightvar
                           match TyExpr.Var@var2 = lhs.exp2
                           loc.expr  = lhs.exp1
                           loc.varnm = var2.nm
                           -- | code duplication, bah, the graph reordering is screwed up
                           loc.q = trace ("unify - rightvar " ++ show (domain lhs.pre)) lhs.pre
                           loc.phi = loc.q `contains` loc.varnm
                           
                           internal occurs_check
                             clause valid2
                               match False = occursCheck loc.varnm loc.q (TyScheme_SystemF loc.expr)
                               loc.phi' = fromJust loc.phi
                               
                               loc.p = TyScheme_SystemF loc.expr
                               
                               child s : Subsume = subsume
                               
                               s.pre = loc.q
                               s.exp = loc.p
                               s.frs = trace ("Right: " ++ sche loc.p ++ " - " ++ pp loc.p) lhs.frs
                               s.ty  = let c = dropQuant loc.phi'
                                       in trace ("Ty: " ++ sche c ++ " - " ++ pp c) c
                               
                               invoke subsume of s
                               
                               (loc.q2, loc.e2) = case trace "--> subsume end" $ appAll s.sub loc.expr of
                                                    Nothing -> error "Application failed in unify"
                                                    Just a  -> let sub = (loc.varnm, TyScheme_SystemF $ mkTop a) 
                                                               in trace ("!!! " ++ pp sub) $ update (s.pre, Right sub)
                               
                               lhs.pre = loc.q2
                               loc.ret = loc.e2 `munion` s.sub
                               lhs.sub = trace ("updating prefix: " ++ pp s.sub
                                               ++ " \n\t# " ++ pp s.pre 
                                               ++ " \n\t> " ++ pp loc.q2 
                                               ++ " \n\t("  ++ pp loc.expr ++ " => " ++ pp loc.ret ++ ")") loc.ret
                               lhs.frs = trace "unify - ***rightvar***" s.frs  
                             clause invalid2
                               match True = isJust loc.phi
                               lhs.sub = empty
                               -- lhs.sub = error $ "Unable to execute unification on '"
                                              -- ++ pp lhs.exp1 ++ "' and '"++ pp lhs.exp2 ++ "', occurs check failed in prefix: "
                                              -- ++ pp lhs.pre
                     clause quant
                       match TyExpr.Quant@var1 = lhs.exp1
                       match TyExpr.Quant@var2 = lhs.exp2
                       
                       child u : Unify = unify
                       
                       (loc.c, loc.frs1) = fresh lhs.frs
                       loc.varc = mkSkolem loc.c
                       u.frs  = loc.frs1
                       u.pre  = trace (  "[App] - Quant =>"
                                        ++ "\n\t(1) [" ++ pp var1.tyVar ++ ":=" ++ pp loc.varc ++ "] " ++ pp var1.tyExpr
                                        ++ "\n\t(2) [" ++ pp var2.tyVar ++ ":=" ++ pp loc.varc ++ "] " ++ pp var2.tyExpr) $ lhs.pre
                       u.exp1 = maybe (error "App failed in unify - exp1") id $ app (var1.tyVar, loc.varc) var1.tyExpr
                       u.exp2 = maybe (error "App failed in unify - exp2") id $ app (var2.tyVar, loc.varc) var2.tyExpr
                       
                       invoke unify of u
                       
                       loc.q1 = u.pre
                       loc.e1 = u.sub
                       
                       loc.check = loc.c `elem` (codomain loc.e1 ++ codomain loc.q1)
                       
                       internal skol_check
                          clause succeeded
                            match False  = loc.check
                            lhs.pre = loc.q1
                            lhs.sub = loc.e1
                            lhs.frs = u.frs
                          clause failed
                            match (loc.bla, True) = ((), loc.check)
                            lhs.sub = const (error "Subsume failure, A skolem constant has leaked outside") loc.bla
                     -- clause explicit_quant_left
                       -- match TyExpr.Quant@var1 = lhs.exp1
                       
                       -- child u : Unify = unify
                       
                       -- (loc.c, loc.frs1) = fresh lhs.frs
                       -- loc.varc = mkVar loc.c
                       
                       -- u.frs = loc.frs1
                       -- u.pre = trace ("Expanding Environment, Adding Universally quantified variable - " ++ pp loc.c) 
                                  -- $ lhs.pre ++ [TyIndex_Group loc.c TyQuantifiedScheme_Bottom]
                       -- u.exp2 = lhs.exp2
                       -- u.exp1 = case app (var1.tyVar, loc.varc) var1.tyExpr of
                                  -- Nothing -> error "Explicit quantification failed in app"
                                  -- Just a  -> a
                                  
                       -- invoke unify of u
                       
                       -- lhs.pre = u.pre
                       -- lhs.sub = u.sub
                     -- clause explicit_quant_right
                       -- match TyExpr.Quant@var1 = lhs.exp2
                       
                       -- child u : Unify = unify
                       
                       -- (loc.c, loc.frs1) = fresh lhs.frs
                       -- loc.varc = mkVar loc.c
                       
                       -- u.frs = loc.frs1
                       -- u.pre = trace ("Expanding Environment, Adding Universally quantified variable" ++ pp loc.c) 
                                  -- $ lhs.pre ++ [TyIndex_Group loc.c TyQuantifiedScheme_Bottom]
                       -- u.exp1 = lhs.exp1
                       -- u.exp2 = case app (var1.tyVar, loc.varc) var1.tyExpr of
                                  -- Nothing -> error "Explicit quantification failed in app"
                                  -- Just a  -> a
                                  
                       -- invoke unify of u
                       
                       -- lhs.pre = u.pre
                       -- lhs.sub = u.sub
                     clause mismatch
                       lhs.sub = error $   "Could not match expected type '" 
                                        ++ pp (clean lhs.exp1) ++ "' with inferred type '" 
                                        ++ pp (clean lhs.exp2) ++ "'" -- under Prefix: " 
                                        -- ++ pp lhs.pre
                 clause f_unify
                   match (loc.bla, False) = ((), loc.nf)
                   lhs.sub = const (error "Unify failure, one or both of the TyExpr are not in normal form.") loc.bla
 
typeCheck ::  Expr -> IO ([TyScheme], Env, Prefix, Int)
typeCheck exp = do
  let inh = Inh_Expr_infer { exp_Inh_Expr = exp
                           , env_Inh_Expr = Gamma empty
                           , pre_Inh_Expr = []
                           , ast_Inh_Expr = exp
                           , frs_Inh_Expr = 1
                           }
  syn <- invoke_Expr_infer dnt_Expr inh
  let res = res_Syn_Expr syn
      sub = sub_Syn_Expr syn
      nxe = nxe_Syn_Expr syn
      frs = frs_Syn_Expr syn
  return (res, sub, nxe, frs)
  
exampleLet  = Expr_Let False [] (Expr_IConst 3)
exampleLet2 = Expr_Let False [Decl_Val (PatExpr_Var $ mkName "a") (Expr_IConst 3)] (Expr_Var $ mkName "a")
}