{
{-# LANGUAGE BangPatterns, MultiParamTypeClasses #-}
module HML where

import Control.Monad.Error
-- import Pretty   
import qualified Data.Map as M
import Control.Monad
import Control.Arrow hiding (app)

import Data.List
import Data.Maybe

import EH8.EH
import EH8.Base.HsName

import EH.Util.Pretty
import qualified Debug.Trace as D

mkName :: String -> HsName
mkName = mkHNmBase -- id

-- type Prefix  = [TyIndex]
-- type HsName  = String
-- type Env     = M.Map HsName TyScheme
type Sub     = (HsName, TyScheme)
type ErrorMessage = String

-- | Get the domain of a Prefix
domain :: Prefix -> [HsName]
domain = map (\(TyIndex_Group a _)-> a)

-- | Split domains
split :: (Prefix, [HsName]) -> (Prefix, Prefix)
split ([], _)      = ([], [])
split ((p@(TyIndex_Group var phi):q), vars) 
 = case var `elem` vars of
     True  -> let (TyQuantifiedScheme_Quant _ phi') = phi 
                  (q1, q2) = split (q, (var `delete` vars) ++ ftv phi')
              in (p:q1, q2)
     False -> let (q1, q2) = split (q, vars)
              in (q1, p:q2)

-- | Apply a set of substitution to an environment
apply :: Env -> Env -> Either Env [ErrorMessage]
apply sub env 
  = let subs = M.toList sub
        lst  = map (M.mapMaybe . app) subs
        set  = foldl' (.) id lst
    in Left (set env)
    
-- | Apply a substitution
createMask :: Sub -> (TyExpr -> Maybe TyExpr)
createMask (nm, ty) = mask
 where rep :: TyExpr -> Maybe TyExpr
       rep val = case isTyVar val nm of
                   False -> return val
                   True  -> let ty' = strip ty
                            in return ty'
                   
       strip :: TyScheme -> TyExpr
       strip (TyScheme_SystemF  a) = a
       strip (TyScheme_Quant  _ a) = strip a
       strip (TyScheme_Sugar  _ a) = strip a
       strip (TyScheme_Forall _ a) = strip a
       strip TyScheme_Bottom       = error "A value of Bottom cannot be stripped."
                   
       mask :: TyExpr -> Maybe TyExpr
       mask val = case val of
                    TyExpr_App a b -> 
                      do a' <- mask a
                         b' <- mask b
                         return $ TyExpr_App a' b'
                    TyExpr_AppTop a ->
                      do a' <- mask a
                         return $ TyExpr_AppTop a'
                    TyExpr_Parens a ->
                      do a' <- mask a
                         return $ TyExpr_Parens a'
                    TyExpr_Ann a b ->
                      do b' <- mask b
                         return $ TyExpr_Ann a b'
                    TyExpr_Quant a b c ->
                      do c' <- mask c
                         return $ TyExpr_Quant a b c'
                    var@(TyExpr_Var{}) ->
                      do rep var
                    x -> rep x
       
class Normal a where
  nf :: a -> a
  
class Util a => Apply a where
  app    :: Sub -> a -> Maybe a
  appAll :: Env -> a -> Maybe a
  appAll env a = let values = M.toList env
                 in foldl (>=>) return (map app values) a
  
class Util a where
  ftv  :: a -> [HsName]
  vars :: a -> [HsName]
  
  isTyVar :: a -> HsName -> Bool
  isTyVar _ _ = False
  
  isUnQualTy :: a -> Bool
  isUnQualTy = const False
  
instance Apply TyExpr where
    app = createMask
  
instance Util TyExpr where
    ftv (TyExpr_App     a b) = ftv a ++ ftv b
    ftv (TyExpr_AppTop    a) = ftv a
    ftv (TyExpr_Parens    a) = ftv a
    ftv (TyExpr_Ann     _ a) = ftv a
    ftv (TyExpr_Var       a) = [a]
    ftv (TyExpr_VarWild   a) = [a]
    ftv (TyExpr_Quant _ a b) = (nub $ ftv b) \\ [a]
    ftv                    _ = []
    
    vars (TyExpr_App     a b) = vars a ++ vars b
    vars (TyExpr_AppTop    a) = vars a
    vars (TyExpr_Parens    a) = vars a
    vars (TyExpr_Ann     _ a) = vars a
    vars (TyExpr_Var       a) = [a]
    vars (TyExpr_VarWild   a) = [a]
    vars (TyExpr_Quant _ a b) = (nub $ vars b)
    vars                    _ = []

    isTyVar (TyExpr_Var nm) hsnm = hsnm == nm
    isTyVar _ _                  = False
    
    isUnQualTy (TyExpr_Quant{}) = False
    isUnQualTy _                = True 
  
instance Apply TyScheme where
    app tp@(x1,x2) = mask
         where                           
           mask :: TyScheme -> Maybe TyScheme
           mask val = case val of
                        TyScheme_Quant a b -> 
                          do b' <- app tp b
                             return $ TyScheme_Quant a b'
                        TyScheme_SystemF a ->
                          do a' <- app tp a
                             return $ TyScheme_SystemF a'
                        TyScheme_Forall a b -> -- This will only work top level
                          do b' <- app tp b
                             return $ TyScheme_Forall (sort $ replace (x1,head $ ftv x2) a) b'
                        _                  -> return val
                        
-- | Replace every occurence of a value in a list with another value. Preserving ordering
replace :: Eq a => (a,a) -> [a] -> [a]
replace   (_,_) [] = []
replace p@(a,b) (x:xs) |  a == x   = b:replace p xs
                       | otherwise = x:replace p xs
                        
instance Util TyScheme where
    ftv TyScheme_Bottom       = []
    ftv (TyScheme_SystemF  a) = ftv a
    ftv (TyScheme_Quant  a b) = (nub $ ftv b) \\ (ftv a)
    ftv (TyScheme_Sugar  _ b) = ftv b
    ftv (TyScheme_Forall a b) = (ftv b) \\ a
    
    vars TyScheme_Bottom       = []
    vars (TyScheme_SystemF  a) = vars a
    vars (TyScheme_Quant  a b) = nub $ vars b
    vars (TyScheme_Sugar  _ b) = vars b
    vars (TyScheme_Forall a b) = vars b

    isTyVar (TyScheme_SystemF a) hnm = isTyVar a hnm
    isTyVar  _ _                     = False
    
    isUnQualTy (TyScheme_SystemF a) = isUnQualTy a
    isUnQualTy _                    = False  

instance Util Scheme where
    ftv (Scheme_Simple a b) = a : ftv b
    vars (Scheme_Simple a b) = a : vars b
  
instance Normal TyScheme where
  nf (TyScheme_Quant (Scheme_Simple a phi1) phi2)
       | a `notElem` (ftv phi2) = nf phi2
       | isTyVar (nf phi2) a    = nf phi1
       | isUnQualTy (nf phi1)   = let x = app (a, TyScheme_SystemF phi1') phi2
                                      (TyScheme_SystemF phi1') = nf phi1
                                  in maybe (error "Substitution failed in Normal for UnQualTy") nf x
       | otherwise              = TyScheme_Quant (Scheme_Simple a (nf phi1)) (nf phi2)
  nf a = a 

-- | Extending a Prefix with a Scheme
extend :: (Prefix, Scheme) -> (Prefix, Env)
extend (q, scheme@(Scheme_Simple var phi))
 = let p = nf phi
   in case p of
        TyScheme_SystemF p'  -> (q, M.fromList [(var, p)])
        _                    -> ((TyIndex_Group var (promote phi)):q, M.empty)
      
-- | Promote/Convert a Type Scheme to a quantified type scheme. 
--   This greatly influences the types. Might need to be reconsidered and checked 
--   to see if we can simplify the types generates
promote :: TyScheme -> TyQuantifiedScheme
promote TyScheme_Bottom                            = TyQuantifiedScheme_Bottom
promote (TyScheme_Quant (Scheme_Simple nm ty) ty') = TyQuantifiedScheme_Quant (TyIndex_Group nm (promote ty)) ty'
promote phi@(TyScheme_SystemF{})                   
  = let vars = ftv phi
    in compact vars phi
   where compact (x:xs) p = TyQuantifiedScheme_Quant (TyIndex_Group x (compact xs p)) p
         compact []     p = TyQuantifiedScheme_Bottom
promote (TyScheme_Sugar{})                         = error "TyScheme_Sugar cannot be promoted. It's purely syntaxtical sugar. Please call desugar before that"

-- | Generate a fresh variable and increase the counter
fresh :: Int -> (HsName, Int)
fresh x = (mkName $ "a" ++ show x, x+1)

-- | Creates an arrow between two types.
--   e.g given type a and b returns the type a -> b or (-> b) a rather
mkArrow :: TyExpr -> TyExpr -> TyExpr
mkArrow a b = TyExpr_App a (TyExpr_App (TyExpr_Con $ mkName "->") b)

-- | Desugar a forall Q.phi to (a>=phi1).(b>=phi2).phi etc
--   basically unfolds the type
desugar :: TyScheme -> TyScheme
desugar (TyScheme_Sugar q t) = let bounds = [TyScheme_Quant (Scheme_Simple nm (toScheme b)) | (TyIndex_Group nm b) <- q] 
                               in foldr (.) id bounds t
  where toScheme :: TyQuantifiedScheme -> TyScheme
        toScheme TyQuantifiedScheme_Bottom                             = TyScheme_Bottom
        toScheme (TyQuantifiedScheme_Quant (TyIndex_Group nm bound) t) = TyScheme_Quant (Scheme_Simple nm (toScheme bound)) t
desugar x = x

-- | Fully quantify a type based on the type variable it contains.
--   e.g. List a becomes forall (a>=_|_). List a
mkQuantified :: TyExpr -> TyScheme
mkQuantified exp 
  = let vars = [TyScheme_Quant (Scheme_Simple x TyScheme_Bottom) | x <- nub (ftv exp)]
    in  if null vars
           then TyScheme_SystemF exp
           else foldl' (.) id vars (TyScheme_SystemF exp)
           
class Simplify a where
  simplify :: a -> a
  
-- | A strong but inefficient alpha renamer (for 
alpha_rename :: TyScheme -> TyScheme
alpha_rename ty 
 = let nvars = map (TyScheme_SystemF . TyExpr_Var . mkName) $ (map (:[]) ['a'..'z']) ++ liftM2 (\b a -> a : show b) [1..] ['a'..'z']
       fvars = nub $ vars ty
       env   = zip fvars nvars
   in  maybe ty id $ appAll (M.fromList env) ty
  
instance Simplify TyScheme where           
    -- | Simplify a type scheme for presentation, dropping trivial quantifications
    --   e.g. (a>=_|_) to a, and expanding types.
    --   simplify :: TyScheme -> TyScheme
    simplify s@(TyScheme_Quant scheme ty) 
     = case scheme of
        Scheme_Simple a TyScheme_Bottom -> let next = simplify ty
                                           in case next of
                                                TyScheme_Forall x ty' -> TyScheme_Forall (nub $ a:x) ty'
                                                z                     -> TyScheme_Forall [a] z
        Scheme_Simple a bounds          -> let newb = simplify bounds
                                           in  case app (a, newb) ty of
                                                 Nothing -> s
                                                 Just x  -> let next = simplify x
                                                                newv = nub $ ftv next
                                                            in case next of
                                                                 TyScheme_Forall x' ty' -> TyScheme_Forall (nub $ newv++x') ty'
                                                                 z                      -> TyScheme_Forall newv z
    simplify s@(TyScheme_Sugar{})   = simplify (desugar s)
    simplify (TyScheme_SystemF exp) = TyScheme_SystemF (simplify exp)
    simplify scheme                 = scheme
    
instance Simplify TyExpr where
    -- | Simplify a type expression for presentation. This version just drops superflous parenthesis
    --   simplify :: TyExpr -> TyExpr
    simplify = simpl True
      where simpl :: Bool -> TyExpr -> TyExpr
            simpl True    (TyExpr_Parens    a) = a
            simpl False p@(TyExpr_Parens{}   ) = p
            simpl _       (TyExpr_App     a b) = TyExpr_App       (simpl True a) (simpl True b)
            simpl f       (TyExpr_AppTop    a) = TyExpr_AppTop    (simpl f a)
            simpl f       (TyExpr_Ann     a b) = TyExpr_Ann a     (simpl f b)
            simpl f       (TyExpr_Quant a b c) = TyExpr_Quant a b (simpl f c)   
            simpl _ a                          = a
            
-- | Checks to see if a pattern expression is a variable or something else
isVar :: PatExpr -> Bool
isVar (PatExpr_Var{}) = True
isVar _               = False
}
    
data TyQu
  con TyForall
    
data TyExpr
  con Con
    nm        :: HsName
  con App
    func      :: TyExpr
    arg       :: TyExpr
  con AppTop
    tyExpr    :: TyExpr
  con Parens
    tyExpr    :: TyExpr
  con Ann
    ann       :: TyExprAnn
    tyExpr    :: TyExpr
  con Wild
  con Mono
  con Var
    nm        :: HsName
  con VarWild
    mm        :: HsName
  con Quant
    qu        :: TyQu
    tyVar     :: HsName
    tyExpr    :: TyExpr
  con Row
    rowTyExpr :: RowTyExpr
    
data TyVar
  con Var
    nm      :: HsName
    
type TyVars : [TyVar]
    
-- Type Index (a1 >= TyQuantifiedScheme)
data TyIndex
  con Group
    varnm   :: HsName
    bounds  :: TyQuantifiedScheme
    
-- Quantified type scheme
data TyQuantifiedScheme
  con Quant
    tyIndex  :: TyIndex
    tyScheme :: TyScheme
  con Bottom
   
-- Type Schemes
data TyScheme
  con Quant
    subst    :: Scheme
    tyExpr   :: TyScheme
  con SystemF
    tyExpr   :: TyExpr
  con Bottom
  con Sugar
     prefix  :: Prefix
     tyExpr  :: TyScheme
  con Forall
     tyQuant :: [HsName]
     tyExpr  :: TyScheme
  
-- A simple tybound e.f. (a >= phi)
data Scheme
  con Simple
    varnm  :: HsName
    bounds :: TyScheme
  
-- Mono type
data TyMono 
  con Var 
    nm      :: HsName
  con App
    func    :: TyMono
    arg     :: TyMono
  con Con
    nm      :: HsName
  con AppTop
    tyMono  :: TyMono
    
-- Unqualified typed
data TyPoly
  con Var 
    nm      :: HsName
  con App
    func    :: TyPoly
    arg     :: TyPoly
  con Con
    nm      :: HsName
  con SystemF
    tyExpr  :: TyExpr
    
data DataFieldExpr
  con Upd
    dataFieldExpr  :  DataFieldExpr
    nm             :: HsName
    expr           :  Expr
  con Con
    nm             :: HsName
  con Expr
    expr           :  Expr
   
data DataFieldPatExpr
  con Ext
    dataFieldPatExpr  :: DataFieldPatExpr
    nm                :: HsName
    patExpr           :: PatExpr
  con Con
    nm                :: HsName
    
data RecExpr
  con Empty
  con Ext
    recExpr     :  RecExpr
    mbNm        :: (Maybe HsName)
    expr        :  Expr
  con Upd
    recExpr     :  RecExpr
    mbNm        :: HsName
    expr        :  Expr
  con Expr
    expr        :  Expr
    
data RecPatExpr
  con Empty
  con Ext
    recPatExpr  :  RecPatExpr
    mbNm        :: (Maybe HsName)
    patExpr     :: PatExpr
  con Expr
    patExpr     :: PatExpr
    
data RowTyExpr
  con Empty
  con Ext
    rowTyExpr       :: RowTyExpr
    mbNm            :: (Maybe HsName)
    tyExpr          :: TyExpr
    
data KiExpr
  con Con
    nm       :: HsName
  con Var
    nm       :: HsName
  con App
    func     :: KiExpr
    arg      :: KiExpr
  con AppTop
    kiExpr   :: KiExpr
  con Parens
    kiExpr   :: KiExpr
  con Ann
    ann      :: KiExprAnn
    kiExpr   :: KiExpr
    
data Expr
  con IConst
    int           :: Int
  con CConst
    char          :: Char
  con Con
    nm            :: HsName
  con Var
    nm            :: HsName
  con App
    func          :  Expr
    arg           :  Expr
  con Let
    isStrict      :: Bool
    decls         :  Decls
    body          :  Expr
  con Lam
    arg           :: PatExpr
    body          :  Expr
  con AppTop
    expr          :  Expr
  con Parens
    expr          :  Expr
  con TypeAs
    tyExpr        :: TyExpr
    expr          :  Expr
  con Ann
    ann           :: ExprAnn
    expr          :  Expr
  con AppImpred
    func          :  Expr
    arg           :  Expr
  con SConst 
    str           :: String
  con Case
    expr          :  Expr
    alts          :: CaseAlts
    mbCaseIds     :: (Maybe UIDS)
    caseFailS     :: UIDS
    isTupOfArg    :: Bool
  con DataFields
    dataFieldExpr :: DataFieldExpr
  con Rec
    recExpr       :: RecExpr
  con Sel
    expr          :  Expr
    lbl           :: HsName
  con Undefined
  con CaseAltFail 
    caseId        :: UID
    
data PatExpr
  con IConst
    int              :: Int
  con CConst
    char             :: Char
  con Con
    nm               :: HsName
  con Var
    nm               :: HsName
  con VarAs
    nm               :: HsName
    patExpr          :: PatExpr
  con App
    func             :: PatExpr
    arg              :: PatExpr
  con AppTop
    patExpr          :: PatExpr
  con Parens
    patExpr          :: PatExpr
  con Ann
    ann              :: PatExprAnn
    patExpr          :: PatExpr
  con TypeAs
    tyExpr           :: TyExpr
    patExpr          :: PatExpr
  con SConst
    str              :: String
  con Rec
    recPatExpr       :: RecPatExpr
  con DataFields
    dataFieldPatExpr :: DataFieldPatExpr
  con Irrefutable
    patExpr          :: PatExpr
    
data CaseAlt
  con Pat
    patExpr   :: PatExpr
    expr      :  Expr

type CaseAlts : [CaseAlt]
    
data DataConstr
  con Constr
    conNm      :: HsName
    fields     :  DataFields
    
type DataConstrs : [DataConstr]

data DataField
  con Field
    mbLabels     :: (Maybe [HsName])
    tyExpr       :: TyExpr
    
type DataFields : [DataField]
   
data ExprAnn
  con Empty
  
data TyExprAnn
  con Empty

data PatExprAnn
  con Empty
  
data KiExprAnn
  con Empty
  
data Decl
  con TySig
    nm         :: HsName
    tyExpr     :: TyExpr
  con Val
    patExpr    :: PatExpr
    expr       :  Expr
  con Data
    isNewType  :: Bool
    tyNm       :: HsName
    tyVars     :: TyVars
    constrs    :: DataConstrs
  con KiSig
    nm         :: HsName
    kiExpr     :: KiExpr
  con FFI
    callconv   :: FFIWay
    safety     :: String
    impEnt     :: String
    nm         :: HsName
    tyExpr     :: TyExpr
  
type TyExprs : [TyExpr]
type Decls   : [Decl]
  
itf Expr
  visit infer
    inh pre :: Prefix
    inh env :: Env
    inh ast :: Expr
    inh exp :: Expr
    inh frs :: Int
    syn nxe :: Prefix
    syn sub :: Env
    syn res :: [TyScheme]
    syn frs :: Int
    
itf DataConstrs
  visit findTypes
    inh ast :: DataConstrs
    inh nm  :: TyExpr
    syn ty  :: [(HsName, TyExpr)]
    
itf DataConstr
  visit findType
    inh ast :: DataConstr
    inh nm  :: TyExpr
    syn ty  :: (HsName, TyExpr)
    
itf DataFields
  visit findTypes
    inh ast :: DataFields
    syn ty  :: TyExprs
    
itf DataField
  visit findType
    inh ast :: DataField
    syn ty  :: TyExpr
    
itf Decls
  visit infer
    inh ast :: Decls
    inh pre :: Prefix
    inh env :: Env
    inh frs :: Int
    syn nxe :: Prefix
    syn sub :: Env
    syn frs :: Int
    
itf Decl
  visit infer
    inh ast :: Decl
    inh pre :: Prefix
    inh env :: Env
    inh frs :: Int
    syn nxe :: Prefix
    syn sub :: Env
    syn frs :: Int
    
itf PatExpr
  visit vars
    inh ast    :: PatExpr
    syn var_nm :: HsName
  visit infer
    inh pre :: Prefix
    inh env :: Env
    inh exp :: PatExpr
    inh frs :: Int
    syn nxe :: Prefix
    syn sub :: Env
    syn res :: [TyScheme]
    syn frs :: Int
    
datasem DataFields monad IO
  clause Cons
    lhs.ty = hd.ty : tl.ty
  clause Nil
    lhs.ty = []
    
datasem DataField monad IO
  clause Field
    lhs.ty = loc.tyExpr
    
datasem DataConstr monad IO
  clause Constr
    lhs.ty = (loc.conNm, foldr mkArrow lhs.nm fields.ty)
    
datasem DataConstrs monad IO
  clause Cons
    hd.nm = lhs.nm
    tl.nm = lhs.nm
    lhs.ty = hd.ty : tl.ty
  clause Nil
    lhs.ty = []
    
datasem PatExpr monad IO
  clause IConst
    lhs.var_nm = const (error "IConst not a var") loc.int
    
    lhs.res = []
    lhs.sub = lhs.env
    lhs.nxe = lhs.pre
    lhs.frs = lhs.frs
  clause CConst
    lhs.var_nm = const (error "CConst not a var") loc.char
    
    lhs.res = []
    lhs.sub = lhs.env
    lhs.nxe = lhs.pre
    lhs.frs = lhs.frs
  clause Con
    lhs.var_nm = const (error "Constructors not supported") loc.nm
    
    lhs.res = []
    lhs.sub = lhs.env
    lhs.nxe = lhs.pre
    lhs.frs = lhs.frs
  clause Var
    lhs.var_nm = loc.nm 
    
    (loc.a, loc.frs1) = fresh lhs.frs
    loc.exp_a  = TyScheme_SystemF $ TyExpr_Var loc.a
    lhs.res    = [loc.exp_a]
    lhs.sub    = M.insert loc.nm loc.exp_a lhs.env
    lhs.nxe    = (TyIndex_Group loc.a TyQuantifiedScheme_Bottom):lhs.pre
    lhs.frs    = loc.frs1
  clause VarAs
    lhs.var_nm = loc.nm 
    
    lhs.res = []
    lhs.sub = lhs.env
    lhs.nxe = lhs.pre
    lhs.frs = lhs.frs
  clause App
    lhs.var_nm = const (error "App not a var") loc.func
    
    lhs.res = []
    lhs.sub = lhs.env
    lhs.nxe = lhs.pre
    lhs.frs = lhs.frs
  clause AppTop
    lhs.var_nm = const (error "AppTop not a var") loc.patExpr
    
    lhs.res = []
    lhs.sub = lhs.env
    lhs.nxe = lhs.pre
    lhs.frs = lhs.frs
  clause Parens
    child patExpr : PatExpr
    patExpr.ast = loc.patExpr
    
    patExpr.exp = loc.patExpr
    patExpr.env = lhs.env
    patExpr.frs = lhs.frs
    patExpr.pre = lhs.pre
    
    invoke vars of patExpr
    -- invoke infer of patExpr
    
    lhs.var_nm = patExpr.var_nm
    
    lhs.res = patExpr.res
    lhs.sub = patExpr.sub
    lhs.nxe = patExpr.nxe
    lhs.frs = patExpr.frs
  clause Ann
    child patExpr : PatExpr
    patExpr.ast = loc.patExpr
        
    invoke vars of patExpr
    
    patExpr.exp = loc.patExpr
    patExpr.env = lhs.env
    patExpr.frs = lhs.frs
    patExpr.pre = lhs.pre
    
    lhs.var_nm = patExpr.var_nm 
    
    lhs.res = patExpr.res
    lhs.sub = patExpr.sub
    lhs.nxe = patExpr.nxe
    lhs.frs = patExpr.frs
  clause TypeAs
    child patExpr : PatExpr
    patExpr.ast = loc.patExpr
    
    invoke vars of patExpr
    
    lhs.var_nm = patExpr.var_nm
    
    loc.ans = TyScheme_SystemF (TyExpr_Parens loc.tyExpr)
    lhs.res = [loc.ans]
    lhs.sub = M.insert patExpr.var_nm loc.ans lhs.env
    lhs.nxe = lhs.pre
    lhs.frs = lhs.frs
  clause SConst
    lhs.var_nm = const (error "SConst not a var") loc.str
    
    lhs.res = []
    lhs.sub = lhs.env
    lhs.nxe = lhs.pre
    lhs.frs = lhs.frs
  clause Rec
    lhs.var_nm = const (error "Rec not a var") loc.recPatExpr
    
    lhs.res = []
    lhs.sub = lhs.env
    lhs.nxe = lhs.pre
    lhs.frs = lhs.frs
  clause DataFields
    lhs.var_nm = const (error "DataFields not a var") loc.dataFieldPatExpr
    
    lhs.res = []
    lhs.sub = lhs.env
    lhs.nxe = lhs.pre
    lhs.frs = lhs.frs
  clause Irrefutable 
    lhs.var_nm = const (error "Irrefutable not a var") loc.patExpr
    
    lhs.res = []
    lhs.sub = lhs.env
    lhs.nxe = lhs.pre
    lhs.frs = lhs.frs
    
datasem Decl monad IO
  clause Val
    match PatExpr.Var@loc = loc.patExpr

    expr.pre = lhs.pre
    expr.env = lhs.env
    expr.exp = loc.expr
    expr.frs = lhs.frs

    invoke infer of expr

    lhs.nxe = expr.nxe
    lhs.sub = let (Left adjusted) = apply expr.sub lhs.env
              in case expr.res of
                   [] -> error  $ "Inference failed datasem Decl clause Val. No result"
                   x  -> foldr (\a->M.insert loc.nm a) adjusted x
    lhs.frs = expr.frs
  clause TySig
    lhs.nxe = lhs.pre
    lhs.sub = M.insert loc.nm (TyScheme_SystemF loc.tyExpr) lhs.env
    lhs.frs = lhs.frs
  clause Data
     child constrs : DataConstrs
     constrs.ast = loc.constrs
     constrs.nm = let vars = map (\(TyVar_Var x) -> TyExpr_Var x) loc.tyVars
                  in  foldl TyExpr_App (TyExpr_Con loc.tyNm) vars
     
     invoke findTypes of constrs
     
     lhs.sub = (foldr (.) id . map (\(k,v)->M.insert k (mkQuantified v))) constrs.ty lhs.env
     lhs.nxe = lhs.pre
     lhs.frs = lhs.frs
  clause FFI
     lhs.sub = M.insert loc.nm (TyScheme_SystemF loc.tyExpr) lhs.env
     lhs.nxe = lhs.pre
     lhs.frs = lhs.frs
  clause KiSig
     lhs.sub = lhs.env
     lhs.nxe = lhs.pre
     lhs.frs = lhs.frs
    
datasem Decls monad IO
  clause Cons
    hd.pre = lhs.pre
    hd.env = lhs.env
    hd.frs = lhs.frs
    invoke infer of hd
    
    tl.env = hd.sub
    tl.pre = hd.nxe
    tl.frs = hd.frs
    invoke infer of tl
    
    lhs.nxe = tl.nxe
    lhs.sub = tl.sub
    lhs.frs = tl.frs
  clause Nil
    lhs.sub = lhs.env
    lhs.nxe = lhs.pre
    lhs.frs = lhs.frs
    
datasem Expr monad IO
    clause Var
        -- lhs.res = maybe (error "Variable not found in lookup") (:[]) $ M.lookup loc.nm lhs.env
        (lhs.res, loc.frs)
             = case M.lookup loc.nm lhs.env of
                Just a  -> ([a], lhs.frs) -- Is this the proper way to get mutual recursion working?
                Nothing -> (return . TyScheme_SystemF . TyExpr_Var *** id) (fresh lhs.frs)
        lhs.sub = M.empty
        lhs.nxe = lhs.pre
        lhs.frs = loc.frs
    clause IConst
       lhs.res = return $ TyScheme_SystemF $ TyExpr_Con $ mkName "Int"
       lhs.sub = M.empty
       lhs.nxe = lhs.pre
       lhs.frs = lhs.frs
    clause CConst
       lhs.res = return $ TyScheme_SystemF $ TyExpr_Con $ mkName "Char"
       lhs.sub = M.empty
       lhs.nxe = lhs.pre
       lhs.frs = lhs.frs
    clause Con
       lhs.res = maybe (error "Constructor not found in lookup") (:[]) $ M.lookup loc.nm lhs.env
       lhs.sub = M.empty
       lhs.nxe = lhs.pre
       lhs.frs = lhs.frs
    clause App
       loc.frs            = lhs.frs
       (loc.a1, loc.frs1) = fresh loc.frs
       (loc.a2, loc.frs2) = fresh loc.frs1
       (loc.b , loc.frs3) = fresh loc.frs2
       
       func.exp = loc.func
       func.frs = loc.frs3
       func.pre = lhs.pre
       func.env = lhs.env
       
       invoke infer of func
       
       arg.exp = loc.arg
       arg.frs = func.frs
       arg.pre = func.nxe
       arg.env = func.sub `M.union` lhs.env
       
       invoke infer of arg
       
       loc.temp1 = curry extend arg.nxe $ Scheme_Simple loc.a1 (fromJust $ appAll arg.sub (head func.res))
       loc.temp2 = curry extend (fst loc.temp1) $ Scheme_Simple loc.a2 (head arg.res)
       loc.temp3 = curry extend (fst loc.temp2) $ Scheme_Simple loc.b  (TyScheme_Bottom)
       
       (loc.q2', loc.e2') = (fst loc.temp3, (snd loc.temp1) `M.union` (snd loc.temp2) `M.union` (snd loc.temp3))
       (loc.q3, loc.e3) = const undefined loc.q2' -- temporary placeholder. Unification needs to be implemented to finish this
       (loc.q4, loc.q5) = curry split loc.q3 (domain lhs.pre)
    
       lhs.res = let b = TyScheme_SystemF (TyExpr_Var loc.b)
                 in return $ desugar $ TyScheme_Sugar loc.q5 (fromJust $ appAll loc.e3 b)
       lhs.sub = func.sub `M.union` arg.sub `M.union` loc.e3
       lhs.nxe = loc.q4
       lhs.frs = arg.frs
    clause Let        
        decls.pre = lhs.pre
        decls.env = lhs.env
        decls.frs = lhs.frs

        invoke infer of decls

        body.pre = decls.nxe
        body.env = decls.sub
        body.exp = loc.body
        body.frs = decls.frs

        invoke infer of body

        lhs.nxe = body.nxe
        lhs.res = body.res
        lhs.sub = M.union decls.sub body.sub
        lhs.frs = body.frs
    clause Lam
        child arg : PatExpr
        arg.ast = loc.arg
        arg.env = lhs.env
        arg.pre = lhs.pre
        arg.exp = loc.arg
        arg.frs = lhs.frs
        
        invoke vars of arg
        invoke infer of arg
    
       loc.frs           = arg.frs
       (TyScheme_SystemF loc.exp_a) = case arg.res of -- error reporting on local variables is off
                                        [x] -> x
                                        _   -> error "No type infered from PatExpr in Lam"
       (loc.b, loc.frs2) = fresh loc.frs
       loc.q'            = arg.nxe
       loc.env'          = arg.sub
       
       body.frs = loc.frs2
       body.env = loc.env'
       body.pre = loc.q'
       body.exp = loc.body
       
       invoke infer of body
       
       loc.tau = let x = appAll body.sub loc.exp_a
                 in case x of
                      (Just x') | (isUnQualTy x' || not (isVar loc.arg))
                                       -> x
                      _                -> error "The resulting type is not a Tau type"
       (loc.q2,  loc.q3)  = curry split body.nxe (domain lhs.pre)
       loc.phi1           = case body.res of
                              []  -> error "Inference of Expressions failed in Lam"
                              [x] -> x
                              _   -> error "Too many options, I only need one"
       (loc.q3', loc.e3') = curry extend loc.q3 (Scheme_Simple loc.b loc.phi1)
       
       lhs.res = let (Just b')    = appAll loc.e3' (TyExpr_Var loc.b)
                     (Just a')    = appAll body.sub loc.exp_a -- (TyExpr_Var loc.a)
                     arrow = mkArrow a' b'
                 in return $ desugar $ TyScheme_Sugar loc.q3' (TyScheme_SystemF arrow)
       lhs.sub = body.sub
       lhs.nxe = loc.q2
       lhs.frs = body.frs
    clause AppTop
       expr.pre = lhs.pre
       expr.env = lhs.env
       expr.frs = lhs.frs
       expr.exp = loc.expr
       
       invoke infer of expr
       
       lhs.res = expr.res
       lhs.sub = expr.sub
       lhs.nxe = expr.nxe
       lhs.frs = expr.frs
    clause Parens
       expr.pre = lhs.pre
       expr.env = lhs.env
       expr.frs = lhs.frs
       expr.exp = loc.expr
       
       invoke infer of expr
       
       lhs.res = expr.res
       lhs.sub = expr.sub
       lhs.nxe = expr.nxe
       lhs.frs = expr.frs
    clause TypeAs
       lhs.res = []
       lhs.sub = lhs.env
       lhs.nxe = lhs.pre
       lhs.frs = lhs.frs
    clause Ann
       expr.pre = lhs.pre
       expr.env = lhs.env
       expr.frs = lhs.frs
       expr.exp = loc.expr
       
       invoke infer of expr
       
       lhs.res = expr.res
       lhs.sub = expr.sub
       lhs.nxe = expr.nxe
       lhs.frs = expr.frs
    clause AppImpred
       lhs.res = []
       lhs.sub = lhs.env
       lhs.nxe = lhs.pre
       lhs.frs = lhs.frs
    clause Case
       lhs.res = []
       lhs.sub = lhs.env
       lhs.nxe = lhs.pre
       lhs.frs = lhs.frs
    clause CaseAltFail
       lhs.res = []
       lhs.sub = lhs.env
       lhs.nxe = lhs.pre
       lhs.frs = lhs.frs
    clause DataFields
       lhs.res = []
       lhs.sub = lhs.env
       lhs.nxe = lhs.pre
       lhs.frs = lhs.frs
    clause Rec
       lhs.res = []
       lhs.sub = lhs.env
       lhs.nxe = lhs.pre
       lhs.frs = lhs.frs
    clause SConst
       lhs.res = []
       lhs.sub = lhs.env
       lhs.nxe = lhs.pre
       lhs.frs = lhs.frs
    clause Sel
       lhs.res = []
       lhs.sub = lhs.env
       lhs.nxe = lhs.pre
       lhs.frs = lhs.frs
    clause Undefined
       (loc.a, loc.frs1) = fresh lhs.frs
       lhs.res = [TyScheme_SystemF $ TyExpr_Var loc.a]
       lhs.sub = lhs.env
       lhs.nxe = lhs.pre
       lhs.frs = loc.frs1
{
typeCheck ::  Expr -> IO ([TyScheme], Env, Prefix, Int)
typeCheck exp = do
  let inh = Inh_Expr_infer { exp_Inh_Expr = exp
                           , env_Inh_Expr = M.empty
                           , pre_Inh_Expr = []
                           , ast_Inh_Expr = exp
                           , frs_Inh_Expr = 1
                           }
  syn <- invoke_Expr_infer dnt_Expr inh
  let res = res_Syn_Expr syn
      sub = sub_Syn_Expr syn
      nxe = nxe_Syn_Expr syn
      frs = frs_Syn_Expr syn
  return (res, sub, nxe, frs)
  
exampleLet  = Expr_Let False [] (Expr_IConst 3)
exampleLet2 = Expr_Let False [Decl_Val (PatExpr_Var $ mkName "a") (Expr_IConst 3)] (Expr_Var $ mkName "a")
}