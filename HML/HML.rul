{
{-# LANGUAGE BangPatterns, MultiParamTypeClasses #-}
module HML where

import Control.Monad.Error
import {-# SOURCE #-} Pretty   
import qualified Data.Map as M
import Control.Monad

import Data.List
import Data.Maybe

mkName :: String -> HsName
mkName = id


type Prefix  = [TyIndex]
type HsName  = String
type Env     = M.Map HsName TyScheme
type Sub     = (HsName, TyScheme)
type ErrorMessage = String

-- | Get the domain of a Prefix
domain :: Prefix -> [HsName]
domain = map varnm_TyIndex_Group

-- | Split domains
split :: (Prefix, [HsName]) -> (Prefix, Prefix)
split ([], _)      = ([], [])
split ((p@(TyIndex_Group var phi):q), vars) 
 = case var `elem` vars of
     True  -> let (TyQuantifiedScheme_Quant _ phi') = phi 
                  (q1, q2) = split (q, (var `delete` vars) ++ ftv phi')
              in (p:q1, q2)
     False -> let (q1, q2) = split (q, vars)
              in (q1, p:q2)

-- | Apply a set of substitution to an environment
apply :: Env -> Env -> Either Env [ErrorMessage]
apply sub env 
  = let subs = M.toList sub
        lst  = map (M.mapMaybe . app) subs
        set  = foldl' (.) id lst
    in Left (set env)
    
-- | Apply a substitution
createMask :: Sub -> (TyExpr -> Maybe TyExpr)
createMask (nm, ty) = mask
 where rep :: TyExpr -> Maybe TyExpr
       rep val = case isTyVar val nm of
                   False -> return val
                   True  -> let (TyScheme_SystemF ty') = ty
                            in return ty'
                   
       mask :: TyExpr -> Maybe TyExpr
       mask val = case val of
                    TyExpr_App a b -> 
                      do a' <- rep a
                         b' <- rep b
                         return $ TyExpr_App a' b'
                    TyExpr_AppTop a ->
                      do a' <- rep a
                         return $ TyExpr_AppTop a'
                    TyExpr_Parens a ->
                      do a' <- rep a
                         return $ TyExpr_Parens a'
                    TyExpr_Ann a b ->
                      do b' <- rep b
                         return $ TyExpr_Ann a b'
                    TyExpr_Quant a b c ->
                      do c' <- rep c
                         return $ TyExpr_Quant a b c'
                    x -> rep x
       
class Normal a where
  nf :: a -> a
  
class Util a => Apply a where
  app    :: Sub -> a -> Maybe a
  appAll :: Env -> a -> Maybe a
  appAll env a = let values = M.toList env
                 in foldl1 (>=>) (map app values) a
  
class Util a where
  ftv :: a -> [HsName]
  
  isTyVar :: a -> HsName -> Bool
  isTyVar _ _ = False
  
  isUnQualTy :: a -> Bool
  isUnQualTy = const False
  
instance Apply TyExpr where
    app = createMask
  
instance Util TyExpr where
    ftv (TyExpr_App     a b) = ftv a ++ ftv b
    ftv (TyExpr_AppTop    a) = ftv a
    ftv (TyExpr_Parens    a) = ftv a
    ftv (TyExpr_Ann     _ a) = ftv a
    ftv (TyExpr_Var       a) = [a]
    ftv (TyExpr_VarWild   a) = [a]
    ftv (TyExpr_Quant _ a b) = (nub $ ftv b) \\ [a]
    ftv                    _ = []

    isTyVar (TyExpr_Var nm) hsnm = hsnm == nm
    isTyVar _ _                   = False
    
    isUnQualTy (TyExpr_Quant{}) = False
    isUnQualTy _                = True 
  
instance Apply TyScheme where
    app tp = mask
         where                           
           mask :: TyScheme -> Maybe TyScheme
           mask val = case val of
                        TyScheme_Quant a b -> 
                          do b' <- app tp b
                             return $ TyScheme_Quant a b'
                        TyScheme_SystemF a ->
                          do a' <- app tp a
                             return $ TyScheme_SystemF a'
                        _                  -> return val
                        

instance Util TyScheme where
    ftv TyScheme_Bottom      = []
    ftv (TyScheme_SystemF a) = ftv a
    ftv (TyScheme_Quant a b) = (nub $ ftv b) \\ (ftv a)

    isTyVar (TyScheme_SystemF a) = isTyVar a
    
    isUnQualTy (TyScheme_SystemF a) = isUnQualTy a
    isUnQualTy _                    = True  

instance Util Scheme where
    ftv (Scheme_Simple a b) = a : ftv b
  
instance Normal TyScheme where
  nf (TyScheme_Quant (Scheme_Simple a phi1) phi2)
       | a `notElem` (ftv phi2) = nf phi2
       | isTyVar (nf phi2) a    = nf phi1
       | isUnQualTy (nf phi1)   = let x = app (a, TyScheme_SystemF phi1') phi2
                                      (TyScheme_SystemF phi1') = nf phi1
                                  in maybe (error "Substitution failed in Normal for UnQualTy") nf x
       | otherwise              = TyScheme_Quant (Scheme_Simple a (nf phi1)) (nf phi2)
  nf a = a 

extend :: (Prefix, Scheme) -> (Prefix, Env)
extend (q, scheme@(Scheme_Simple var phi))
 = let p = nf phi
   in case p of
        TyScheme_SystemF p'  -> (q, M.fromList [(var, p)])
        _                    -> ((TyIndex_Group var (promote phi)):q, M.empty)
        
promote phi = let vars = ftv phi
             in case vars of
                   [var'] -> TyQuantifiedScheme_Quant
                                (TyIndex_Group var' TyQuantifiedScheme_Bottom)
                                phi
                   _      -> error $ "could not promote value to prefix using '[redacted]'"
                   
fresh :: Int -> (HsName, Int)
fresh x = ("a" ++ show x, x+1)
}
    
data TyQu
  con TyForall
    
data TyExpr
  con Con
    nm      :: HsName
  con App
    func    :: TyExpr
    arg     :: TyExpr
  con AppTop
    tyExpr  :: TyExpr
  con Parens
    tyExpr  :: TyExpr
  con Ann
    ann     :: TyExprAnn
    tyExpr  :: TyExpr
  con Wild
  con Mono
  con Var
    nm      :: HsName
  con VarWild
    mm      :: HsName
  con Quant
    qu      :: TyQu
    tyVar   :: HsName
    tyExpr  :: TyExpr
    
-- Type Index (a1 >= TyQuantifiedScheme)
data TyIndex
  con Group
    varnm   :: HsName
    bounds  :: TyQuantifiedScheme
    
-- Quantified type scheme
data TyQuantifiedScheme
  con Quant
    tyIndex  :: TyIndex
    tyScheme :: TyScheme
  con Bottom
   
-- Type Schemes
data TyScheme
  con Quant
    subst   :: Scheme
    tyExpr  :: TyScheme
  con SystemF
    tyExpr  :: TyExpr
  con Bottom
  
-- A simple tybound e.f. (a >= phi)
data Scheme
  con Simple
    vannm  :: HsName
    bounds :: TyScheme
  
-- Mono type
data TyMono 
  con Var 
    nm      :: HsName
  con App
    func    :: TyMono
    arg     :: TyMono
  con Con
    nm      :: HsName
  con AppTop
    tyMono  :: TyMono
    
-- Unqualified typed
data TyPoly
  con Var 
    nm      :: HsName
  con App
    func    :: TyPoly
    arg     :: TyPoly
  con Con
    nm      :: HsName
  con SystemF
    tyExpr  :: TyExpr
    
data Expr
  con IConst
    int     :: Int
  con CConst
    char    :: Char
  con Con
    nm      :: HsName
  con Var
    nm      :: HsName
  con App
    func    :: Expr
    arg     :: Expr
  con Let
    decls   :  Decls
    body    :: Expr
  con Lam
    arg     :: PatExpr
    body    :: Expr
  con AppTop
    expr    :: Expr
  con Parens
    expr    :: Expr
  con TypeAs
    tyExpr  :: TyExpr
    expr    :: Expr
  con Ann
    ann     :: ExprAnn
    expr    :: Expr
  con AppImpred
    func    :: Expr
    arg     :: Expr
    
data PatExpr
  con IConst
    int     :: Int
  con CConst
    char    :: Char
  con Con
    nm      :: HsName
  con Var
    nm      :: HsName
  con VarAs
    nm      :: HsName
    patExpr :: PatExpr
  con App
    func    :: PatExpr
    arg     :: PatExpr
  con AppTop
    patExpr :: PatExpr
  con Parens
    patExpr :: PatExpr
  con Ann
    ann     :: PatExprAnn
    patExpr :: PatExpr
  con TypeAs
    tyExpr  :: TyExpr
    patExpr :: PatExpr
    
data ExprAnn
  con Empty
  
data TyExprAnn
  con Empty

data PatExprAnn
  con Empty
  
data Decl
  con TySig
    nm      :: HsName
    tyExpr  :: TyExpr
  con Val
    patExpr :: PatExpr
    expr    :: Expr
  
type TyExprs : [TyExpr]
type Decls   : [Decl]
  
itf Expr
  visit infer
    inh pre :: Prefix
    inh env :: Env
    inh exp :: Expr
    inh ast :: Expr
    inh frs :: Int
    syn nxe :: Prefix
    syn sub :: Env
    syn res :: [TyScheme]
    syn frs :: Int
    
itf Decls
  visit infer
    inh ast :: Decls
    inh pre :: Prefix
    inh env :: Env
    inh frs :: Int
    syn nxe :: Prefix
    syn sub :: Env
    syn frs :: Int
    
itf Decl
  visit infer
    inh pre :: Prefix
    inh env :: Env
    inh ast :: Decl
    inh frs :: Int
    syn nxe :: Prefix
    syn sub :: Env
    syn frs :: Int
    
itf PatExpr
  visit vars
    inh ast    :: PatExpr
    syn var_nm :: HsName
    
datasem PatExpr
  clause IConst
    lhs.var_nm = error "IConst not a var" 
  clause CConst
    lhs.var_nm = error "CConst not a var" 
  clause Con
    lhs.var_nm = error "Constructors not supported" 
  clause Var
    lhs.var_nm = loc.nm 
  clause VarAs
    lhs.var_nm = loc.nm 
  clause App
    lhs.var_nm = error "App not a var" 
  clause AppTop
    lhs.var_nm = error "AppTop not a var" 
  clause Parens
    child patExpr : PatExpr
    patExpr.ast = undefined
    
    invoke vars of patExpr
    
    lhs.var_nm = patExpr.var_nm
  clause Ann
    child patExpr : PatExpr
    patExpr.ast = undefined
        
    invoke vars of patExpr
    
    lhs.var_nm = patExpr.var_nm 
  clause TypeAs
    child patExpr : PatExpr
    patExpr.ast = undefined
        
    invoke vars of patExpr
    
    lhs.var_nm = patExpr.var_nm 
    
datasem Decl
  clause Val
    match PatExpr.Var@loc = loc.patExpr

    child expr : Expr

    expr.pre = lhs.pre
    expr.env = lhs.env
    expr.exp = loc.expr
    expr.frs = lhs.frs
    expr.ast = undefined

    invoke infer of expr

    lhs.nxe = expr.nxe
    lhs.sub = let (Left adjusted) = apply expr.sub lhs.env
              in case expr.res of
                   [] -> error $ "Inference failed datasem Decl clause Val."
                   x  -> foldr (\a->M.insert loc.nm a) adjusted x
    lhs.frs = expr.frs
  clause TySig
    lhs.nxe = lhs.pre
    lhs.sub = M.insert loc.nm (TyScheme_SystemF loc.tyExpr) lhs.env
    lhs.frs = lhs.frs
    
datasem Decls
  clause Cons
    hd.pre = lhs.pre
    hd.env = lhs.env
    hd.frs = lhs.frs
    invoke infer of hd
    
    tl.env = hd.sub
    tl.pre = hd.nxe
    tl.frs = hd.frs
    invoke infer of tl
    
    lhs.nxe = tl.nxe
    lhs.sub = tl.sub
    lhs.frs = tl.frs
  clause Nil
    lhs.sub = M.empty
    lhs.nxe = lhs.pre
    lhs.frs = lhs.frs
    
datasem Expr
    clause Var
        lhs.res = maybeToList $ M.lookup loc.nm lhs.env
        lhs.sub = M.empty
        lhs.nxe = lhs.pre
        lhs.frs = lhs.frs
    clause IConst
       lhs.res = return $ TyScheme_SystemF $ TyExpr_Con "Int"
       lhs.sub = M.empty
       lhs.nxe = lhs.pre
       lhs.frs = lhs.frs
    clause CConst
       lhs.res = return $ TyScheme_SystemF $ TyExpr_Con "Char"
       lhs.sub = M.empty
       lhs.nxe = lhs.pre
       lhs.frs = lhs.frs
    clause Con
       lhs.res = error $ "Constructors are not supported at this time due to no datatype support yet"
       lhs.sub = M.empty
       lhs.nxe = lhs.pre
       lhs.frs = lhs.frs
    clause App
       lhs.res = []
       lhs.sub = lhs.env
       lhs.nxe = lhs.pre
       lhs.frs = lhs.frs
    clause Let
        -- child decls : Decls
        child body  : Expr
        
        decls.pre = lhs.pre
        decls.env = lhs.env
        decls.frs = lhs.frs
        -- decls.ast = loc.decls

        invoke infer of decls

        body.pre = decls.nxe
        body.env = decls.sub
        body.exp = loc.body
        body.frs = decls.frs
        body.ast = undefined

        invoke infer of body

        lhs.nxe = body.nxe
        lhs.res = body.res
        lhs.sub = M.union decls.sub body.sub
        lhs.frs = body.frs
    clause Lam
        child arg : PatExpr
        arg.ast = undefined
        invoke vars of arg
    
        loc.frs          = lhs.frs
       (loc.a, loc.frs1) = fresh loc.frs
       loc.exp_a         = TyScheme_SystemF $ TyExpr_Var loc.a -- error reporting on local variables is off
       (loc.b, loc.frs2) = fresh loc.frs1
       loc.q'            = (TyIndex_Group loc.a TyQuantifiedScheme_Bottom):lhs.pre
       loc.env'          = M.insert arg.var_nm loc.exp_a lhs.env
       
       child body : Expr
       body.ast = undefined
       body.frs = loc.frs2
       body.env = loc.env'
       body.pre = loc.q'
       body.exp = loc.body
       
       invoke infer of body
       
       loc.tau = let x = appAll body.sub loc.exp_a
                 in case x of
                      (Just x') | isUnQualTy x' -> x
                      _                         -> error "The resulting type is not a Tau type"
       (loc.q2,  loc.q3)  = curry split body.nxe (domain lhs.pre)
       loc.phi1           = case body.res of
                              [] -> error "Inference of Expressions failed in Lam"
                              [TyScheme_SystemF a] -> TyScheme_SystemF a
                              _ -> error "Too many options, I only need one"
       (loc.q3', loc.e3') = curry extend loc.q3 (Scheme_Simple loc.b loc.phi1)
       
       lhs.res = let (Just b')    = appAll loc.e3' (TyExpr_Var loc.b)
                     (Just a')    = appAll body.sub (TyExpr_Var loc.a)
                     arrow = TyExpr_App a' b'
                 in [] -- TyExpr_Quant TyQu_TyForall 
       lhs.sub = body.sub
       lhs.nxe = loc.q2
       lhs.frs = body.frs
    clause AppTop
       lhs.res = []
       lhs.sub = lhs.env
       lhs.nxe = lhs.pre
       lhs.frs = lhs.frs
    clause Parens
       lhs.res = []
       lhs.sub = lhs.env
       lhs.nxe = lhs.pre
       lhs.frs = lhs.frs
    clause TypeAs
       lhs.res = []
       lhs.sub = lhs.env
       lhs.nxe = lhs.pre
       lhs.frs = lhs.frs
    clause Ann
       lhs.res = []
       lhs.sub = lhs.env
       lhs.nxe = lhs.pre
       lhs.frs = lhs.frs
    clause AppImpred
       lhs.res = []
       lhs.sub = lhs.env
       lhs.nxe = lhs.pre
       lhs.frs = lhs.frs
{
-- infer = sem infer : Infer monad IO 
          -- visit infer
            -- clause varbind
              -- match Expr.Var@loc = lhs.exp
              -- lhs.res = M.lookup loc.nm lhs.env
              -- lhs.sub = M.empty
              -- lhs.nxe = lhs.pre
            
            -- clause letbind
              -- match Expr.Let@loc = lhs.exp
                            
              -- child decls : Decls = infer
              -- child body  : Infer = infer
              
              -- decls.pre = lhs.pre
              -- decls.env = lhs.env
              -- decls.ast = loc.decls
              
              -- invoke infer of decls
              
              -- body.pre = decls.nxe
              -- body.env = decls.sub
              -- body.exp = loc.body
              
              -- invoke infer of body
              
              -- lhs.nxe = body.nxe
              -- lhs.res = body.res
              -- lhs.sub = M.union decls.sub body.sub 
}