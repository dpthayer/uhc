% $Id: EHC.lag 199 2004-05-12 19:11:13Z andres $

%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell importable interface to Code's GRIN gen
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs import(Maybe,FiniteMap,UU.Pretty,EHCommon,EHCore,EHTy,GrinCode,Char) export(cmodGrin)
%%]

%%[8.WRAPPER import(EHCoreAbsSyn,EHCoreCommonLev)
WRAPPER CodeAGItf
%%]

%%[8 hs
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell itf
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs
cmodGrin :: UID -> CModule -> GrModule
cmodGrin uniq cmod
  =  let  t = wrap_CodeAGItf  (sem_CodeAGItf (CodeAGItf_AGItf cmod))
                              (Inh_CodeAGItf {gUniq_Inh_CodeAGItf = uniq})
     in   grMod_Syn_CodeAGItf t
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Unique
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR AllCodeNT [ | gUniq: UID | ]
ATTR CodeAGItf [ gUniq: UID | | ]

SEM CExpr
  | Var         (lhs.gUniq,loc.lUniq)       =   mkNewLevUID @lhs.gUniq
  | App         (func.gUniq,loc.lUniq)      =   mkNewLevUID @lhs.gUniq
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Context: strict yes/no, rhs of lam yes/no
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR CExpr AllAlt AllBind [ isStrict, isLamBody: Bool | | ]

SEM CModule
  | Mod         expr        .   isStrict    =   True
                            .   isLamBody   =   False

SEM CBind
  | Bind        expr        .   isStrict    =   @lhs.isStrict || not (null @expr.grLamArgL)

SEM CPatBind
  | Bind        offset      .   isStrict    =   True
                            .   isLamBody   =   False
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Known function arity
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs
type LamInfoMp = FiniteMap HsName Int
%%]

%%[8
ATTR AllCodeNT [ lamMp: LamInfoMp | | ]

SEM CodeAGItf
  | AGItf       module      .   lamMp       =   emptyFM
%%]

%%[8
ATTR AllBind [ | | bindLamMp USE {`plusFM`} {emptyFM}: LamInfoMp ]

SEM CBind
  | Bind        lhs         .   bindLamMp   =   if @expr.isLam
                                                then @nm `unitFM` length @expr.grLamArgL
                                                else emptyFM
  | FFI         loc         .   (argTyL,resTy)
                                            =   tyArrowArgsRes @ty
                lhs         .   bindLamMp   =   @nm `unitFM` length @argTyL

SEM CExpr
  | Let         loc         .   lamMp       =   @lhs.lamMp `plusFM` @binds.bindLamMp
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Grin code
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs
grE2V :: GrExpr -> Maybe GrVal
grE2V e = case e of {GrExpr_Unit v -> Just v; _ -> Nothing}

grV2HNm :: GrVal -> Maybe HsName
grV2HNm v = case v of {GrVal_Var n -> Just n; _ -> Nothing}

emptyGrExpr = GrExpr_Unit GrVal_Empty

mbMkStrict :: UID -> Bool -> GrVal -> GrExpr
mbMkStrict u isStrict v
  =  if isStrict
     then  let  n = uidHNm u
           in   GrExpr_Seq (GrExpr_Unit v) (GrPat_Var n) (GrExpr_Eval n)
     else  GrExpr_Unit v

retStrict :: Bool -> GrVal -> GrExpr
retStrict isStrict = if isStrict then GrExpr_Unit else GrExpr_Store
%%]

%%[8 hs
mkNdPApp :: HsName -> Int -> GrValL -> GrVal
mkNdPApp f nMiss argL = GrVal_Node (GrTag_Lit (GrTagPApp nMiss) 0 (HNm "papply")) (GrVal_Var f : argL)

mkNdApp :: HsName -> GrValL -> GrVal
mkNdApp f argL = GrVal_Node (GrTag_Lit GrTagApp 0 (HNm "apply")) (GrVal_Var f : argL)

mkSq :: GrExpr -> HsName -> GrExpr -> GrExpr
mkSq e1 p e2 = GrExpr_Seq e1 (GrPat_Var p) e2
%%]

%%[8
ATTR CodeAGItf CModule [ | | grMod: GrModule ]

SEM CModule
  | Mod         lhs         .   grMod       =   GrModule_Mod (HNm @baseName) (@expr.grBindL ++ [GrBind_Bind (HNm "main") [] @expr.grLetBody])
%%]

%%[8
ATTR CExpr   [ | | grExpr: GrExpr ]
ATTR CExpr   [ | | grBindL USE {++} {[]}: GrBindL ]

SEM CExpr
  | Let         (loc.grExpr,lhs.grBindL,binds.isStrict)
                                            =   if @lhs.lev == cLevOuter
                                                then  (emptyGrExpr
                                                      ,let  
                                                       in   case @categ of
                                                              CBindRec     ->  [GrBind_Rec @binds.grBindL] ++ @body.grBindL
                                                              _            ->  @binds.grBindL ++ @body.grBindL
                                                      ,True
                                                      )
                                                else  (case @categ of
                                                          CBindRec     ->  mkSt (map (\(GrBind_Bind n _ _) -> n) @binds.grBindL)
                                                                           . mkVs @binds.grBindL
                                                                           $ @body.grExpr
                                                                           where  h             = GrVal_Node (GrTag_Lit GrTagHole 0 hsnUnknown) []
                                                                                  mkSt nmL e    = foldr (\n e -> GrExpr_Seq (GrExpr_Store h) (GrPat_Var n) e) e nmL
                                                                                  mkV b n n' n'' e
                                                                                                = GrExpr_Seq b (GrPat_Var n')
                                                                                                    (GrExpr_Seq (GrExpr_Fetch n' Nothing) (GrPat_Var n'')
                                                                                                        (GrExpr_Seq (GrExpr_Update n (GrVal_Var n'')) GrPat_Empty e))
                                                                                  mkVs bs e     = foldr (\(GrBind_Bind n _ v) e -> mkV v n (hsnPrefix "_" n) (hsnPrefix "__" n) e) e bs
                                                          _            ->  foldr  (\(GrBind_Bind n _ v) e -> GrExpr_Seq v (GrPat_Var n) e)
                                                                                  @body.grExpr @binds.grBindL
                                                      ,[]
                                                      ,@categ == CBindStrict
                                                      )
  | Case        loc         .   grExpr      =   GrExpr_Case @expr.grVal @alts.grAltL
  | App         loc         .   grExpr      =   let  argL = reverse @grAppArgL
                                                     apArity = length argL
                                                     funNm = @grAppFun
                                                     mkE  = retStrict @lhs.isStrict
                                                     (n:nL) = map uidHNm . mkNewUIDL (apArity + 1) $ @lUniq
                                                     (argL',wrapGr)
                                                            = foldr  (\(n,a) (aL,wG)
                                                                        ->  case a of
                                                                                GrVal_Var v | isJust mbArity
                                                                                    -> (GrVal_Var n : aL,mkSq a' n . wG)
                                                                                    where mbArity = lookupFM @lhs.lamMp v
                                                                                          a' = GrExpr_Store (mkNdPApp v (fromJust mbArity) [])
                                                                                GrVal_Node _ _
                                                                                    -> (GrVal_Var n : aL,mkSq (GrExpr_Store a) n . wG)
                                                                                _   -> (a:aL,wG)
                                                                     )
                                                                     ([],id)
                                                            $ zip nL argL
                                                in   case @func.mbTupApp of
                                                        Just t
                                                            ->  let  v  =  case t of
                                                                             CTagNone  -> GrVal_Node grRecTag argL'
                                                                             CTag t l  -> GrVal_Node (GrTag_Lit GrTagCon t l) argL'
                                                                in   wrapGr (mkE v)
                                                        Nothing
                                                            ->  let  ap = case lookupFM @lhs.lamMp funNm of
                                                                             Just arity
                                                                               | arity == apArity && @lhs.isStrict
                                                                                   -> GrExpr_Call funNm argL'
                                                                               | arity == apArity
                                                                                   -> GrExpr_Store (GrVal_Node (GrTag_Lit GrTagFun 0 funNm) argL')
                                                                               | arity > apArity
                                                                                   -> mkE (mkNdPApp funNm (arity - apArity) argL')
                                                                               | arity < apArity && @lhs.isStrict
                                                                                   -> mkSq (GrExpr_Call funNm (take arity argL')) n (GrExpr_App n (drop arity argL'))
                                                                               | otherwise
                                                                                   -> mkSq (GrExpr_Store (mkNdPApp funNm 0 (take arity argL'))) n (GrExpr_Store (mkNdApp n (drop arity argL')))
                                                                             Nothing
                                                                               | @lhs.isStrict
                                                                                   -> mkSq (GrExpr_Eval funNm) n (GrExpr_App n argL')
                                                                               | otherwise
                                                                                   -> GrExpr_Store (mkNdApp funNm argL')
                                                                in   wrapGr ap
  | Var         loc         .   grExpr      =   mbMkStrict @lUniq @lhs.isStrict @grVal
  | Tup Int Char
                loc         .   grExpr      =   retStrict @lhs.isStrict @grVal
  | * - Let App Case Var Tup Int Char
                loc         .   grExpr      =   GrExpr_Unit @grVal
%%]

%%[8
ATTR CExpr   [ | | grVal USE {`const`} {GrVal_Empty}: GrVal ]

SEM CExpr
  | Tup         loc         .   grVal       =   ctag GrVal_Empty (\t l -> GrVal_Node (GrTag_Lit GrTagCon t l) []) @tag
  | Var         loc         .   grVal       =   GrVal_Var @nm
  | Int         loc         .   grVal       =   grBox hsnInt (GrVal_LitInt @int)
  | Char        loc         .   grVal       =   grBox hsnChar (GrVal_LitInt (ord @char))
  | * - Int Char Var Tup
                loc         .   grVal       =   GrVal_Empty
%%]

%%[8
ATTR CBind CBindL  [ | | grBindL USE {++} {[]}: GrBindL ]

SEM CBind
  | Bind        lhs         .   grBindL     =   [GrBind_Bind @nm @expr.grLamArgL @expr.grLamBody]
  | FFI         loc         .   (nmRes,nmArgL,nmArgPatL)
                                            =   let  (nmRes:nmArgL) = take (length @argTyL + 1) grLclNmSupplyL
                                                     nmArgPatL = map (hsnPrefix "_") nmArgL
                                                in   (nmRes,nmArgL,nmArgPatL)
                lhs         .   grBindL     =   let  mkPat ty n
                                                       =  case tyConNm ty of
                                                            t | t == hsnInt -> GrPat_Node (GrTag_Lit GrTagCon 0 t) [n]
                                                            _               -> GrPat_Var n
                                                     mkRes ty v
                                                       =  case tyConNm ty of
                                                            t | t == hsnInt -> \e -> GrExpr_Seq e (GrPat_Var @nmRes) (GrExpr_Unit (grBox t (GrVal_Var v)))
                                                            _               -> id
                                                in   [GrBind_Bind @nm @nmArgL
                                                        (foldr  (\(n,p) e -> GrExpr_Seq (GrExpr_Eval n) p e)
                                                                (mkRes @resTy @nmRes (GrExpr_FFI @impEnt @nmArgPatL))
                                                        . zip @nmArgL
                                                        . zipWith mkPat @argTyL
                                                        $ @nmArgPatL
                                                        )
                                                     ]
%%]

%%[8
ATTR CAlt    [ | | grAlt: GrAlt ]
ATTR CAltL   [ | | grAltL: GrAltL ]

SEM CAlt
  | Alt         lhs         .   grAlt       =   GrAlt_Alt (head @pats.grPatL) @expr.grExpr

SEM CAltL
  | Cons        lhs         .   grAltL      =   @hd.grAlt : @tl.grAltL
  | Nil         lhs         .   grAltL      =   []
%%]

%%[8
ATTR CPat    [ | | patNm: HsName ]

SEM CPat
  | Var Con     loc         .   patNm       =   cpatNmEither id id @pnm
  | Undef       loc         .   patNm       =   hsnUnknown
%%]

%%[8
ATTR CPat    [ | | grPat: GrPat ]
ATTR CPatL   [ | | grPatL: GrPatL ]

SEM CPat
  | Var         lhs         .   grPat       =   GrPat_Var @patNm
  | Con         lhs         .   grPat       =   GrPat_Node (ctag grRecTag (GrTag_Lit GrTagCon) @tag) @binds.patBindL
  | Undef       lhs         .   grPat       =   GrPat_Empty

SEM CPatL
  | Cons        lhs         .   grPatL      =   @hd.grPat : @tl.grPatL
  | Nil         lhs         .   grPatL      =   []
%%]

%%[8
ATTR CPatBind CPatBindL [ | | patBindL USE {++} {[]}: {[HsName]} ]

SEM CPatBind
  | Bind        lhs         .   patBindL    =   [@pat.patNm]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Let body
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR CExpr [ | | grLetBody: GrExpr ]

SEM CExpr
  | Let         lhs         .   grLetBody   =   @body.grLetBody
  | * - Let     lhs         .   grLetBody   =   @grExpr
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Lam arg/body info
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR CExpr [ | | grLamArgL: {[HsName]} ^^ grLamBody: GrExpr ]

SEM CExpr
  | Lam         lhs         .   grLamArgL   =   @arg : @body.grLamArgL
  | * - Lam     lhs         .   grLamArgL   =   []
                            .   grLamBody   =   @grExpr
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% App func/args info
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR CExpr [ | | grAppFun: HsName ^^ grAppArgL: GrValL ]

SEM CExpr
  | App         loc         .   grAppFun    =   @func.grAppFun
                            .   grAppArgL   =   @arg.grVal : @func.grAppArgL
  | * - App     lhs         .   grAppFun    =   maybe hsnUnknown id . grV2HNm $ @grVal
                            .   grAppArgL   =   []
%%]

