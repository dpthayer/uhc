% $Id: EHC.lag 199 2004-05-12 19:11:13Z andres $

%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Fully lazy code
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs import(Maybe,Set,List,FiniteMap,EHCommon,EHCore,EHTy) export(cmodTrfLamLift)
%%]

%%[8 hs import(EHDebug)
%%]

%%[8.WRAPPER import(EHCoreAbsSyn,EHCoreCommonLev,EHCoreTrfCommonFv,EHCoreTrfCommonLev)
WRAPPER CodeAGItf
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell itf
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs
cmodTrfLamLift :: CModule -> CModule
cmodTrfLamLift cmod
  =  let  t = wrap_CodeAGItf  (sem_CodeAGItf (CodeAGItf_AGItf cmod))
                              (Inh_CodeAGItf)
     in   cTrf_Syn_CodeAGItf t
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Unique
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR AllCodeNT [ | gUniq: Int | ]

SEM CodeAGItf
  | AGItf       module      .   gUniq       =   0
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Level
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
SEM CExpr
  | Let         binds       .   lev         =   @lhs.lev + 1
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Which id's are functions resp values
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR AllBind [ | | bindVarS, bindLamS USE {`Set.union`} {emptySet}: FvS ]

SEM CBind
  | Bind        lhs         .   (bindVarS,bindLamS)
                                            =   if @expr.isLam
                                                then (emptySet,unitSet @nm)
                                                else (unitSet @nm,emptySet)
  | FFI         lhs         .   bindVarS    =   unitSet @nm
%%]

%%[8
ATTR AllCodeNT [ varS, lamS: FvS | | ]

SEM CodeAGItf
  | AGItf       module      .   varS        =   emptySet
                            .   lamS        =   emptySet

SEM CExpr
  | Let         loc         .   varS        =   @lhs.varS `Set.union` @binds.bindVarS
                            .   lamS        =   @lhs.lamS `Set.union` @binds.bindLamS
  | Lam         loc         .   varS        =   @lhs.varS `addToSet` @arg

SEM CAlt
  | Alt         expr        .   varS        =   @lhs.varS `Set.union` mkSet @pats.nmL
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Free var of lam's for which arg lifting is done
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs
startFvSLamMp :: FvS -> FvS -> FvS -> FvSMp -> FvSMp -> (FvSMp,FvSMp)
startFvSLamMp bLamS lamS varS fvm bFvm
  =  let  bFvm2    =  filterFM (\n _ -> n `elementOf` bLamS) bFvm
          fvlam  s =  lamS `Set.intersect` s
          fvvar  s =  varS `Set.intersect` s
          fv     s =  fvvar s `Set.union`
                        (unionManySets . map (lookupWithDefaultFM fvm emptySet) . setToList . fvlam $ s)
     in   (mapFM (\_ s -> fv s) bFvm2,mapFM (\_ s -> s `Set.intersect` bLamS) bFvm2)

iterFvSLamMp :: FvSMp -> FvSMp -> FvSMp
iterFvSLamMp frLamMp frVarMp
  =  let  frVarMp2 = mapFM (\n s -> s `Set.union` (unionManySets . map (fromJust . lookupFM frVarMp) . setToList . fromJust . lookupFM frLamMp $ n)) frVarMp
          sz = sum . map cardinality . eltsFM
     in   if sz frVarMp2 > sz frVarMp
          then iterFvSLamMp frLamMp frVarMp2
          else frVarMp
%%]

%%[8
ATTR AllCodeNT [ fvSLamMp: FvSMp | | ]

SEM CodeAGItf
  | AGItf       module      .   fvSLamMp    =   emptyFM

SEM CExpr
  | Let         loc         .   fvSLamMp    =   @lhs.fvSLamMp `plusFM`
                                                    (let  start varS = startFvSLamMp @binds.bindLamS @lhs.lamS varS @lhs.fvSLamMp @binds.fvSMp
                                                     in   case @categ of
                                                            CBindRec  ->  let  (m,lm)  = start (@lhs.varS `Set.union` @binds.bindVarS)
                                                                          in   iterFvSLamMp lm m
                                                            _         ->  let  (m,_)   = start @lhs.varS
                                                                          in   m
                                                    )
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Has a strict let inside
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR CExpr [ | | hasStrict: Bool ]

SEM CExpr
  | Let         lhs         .   hasStrict   =   @categ == CBindStrict || @body.hasStrict
  | * - Let     lhs         .   hasStrict   =   False
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Mapping of argument names
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR AllCodeNT [ argSubst: {FiniteMap HsName HsName} | | ]

SEM CodeAGItf
  | AGItf       module      .   argSubst    =   emptyFM

SEM CBind
  | Bind        expr        .   argSubst    =   @lhs.argSubst `plusFM` @argMp
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Adding parameters to lam call sites
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs
type LamArgMp = FiniteMap HsName [HsName]
%%]

%%[8
ATTR AllBind [ | | bindLamArgMp USE {`plusFM`} {emptyFM}: LamArgMp ]
ATTR AllCodeNT [ lamArgMp: LamArgMp | | ]

SEM CodeAGItf
  | AGItf       module      .   lamArgMp    =   emptyFM

SEM CExpr
  | Let         loc         .   lamArgMp    =   @lhs.lamArgMp `plusFM` @binds.bindLamArgMp
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Transformation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs
type LamBindSq = Seq (CBindCateg,CBindL)

fvLAsArg :: LevMp -> FvS -> AssocL HsName Int
fvLAsArg levMp fvS
  =  sortOn snd . filter (\(_,l) -> l > cLevOuter)
     . map (\n -> (n,fvLev levMp n)) . setToList $ fvS

mkFvNm :: Int -> HsName -> HsName
mkFvNm i n = hsnSuffix n ("~" ++ show i)

fvLArgRepl :: Int -> AssocL HsName Int -> ([HsName],[HsName],FiniteMap HsName HsName)
fvLArgRepl uniq argLevL
  =  let  argOL = assocLKeys argLevL
          argNL = zipWith (\u n -> mkFvNm u n) [uniq..] argOL
     in   (argOL,argNL,listToFM (zip argOL argNL))
%%]

%%[8
ATTR AllCodeNT [ | | cTrf: SELF ]
ATTR CodeAGItf [ | | cTrf: CModule ]

ATTR AllCodeNT [ | | lamBindSq USE {<+>} {emptySeq}: LamBindSq ]
ATTR AllBind [ | | bindLamBindL, bindCAFBindL, bindVarBindL USE {++} {[]}: CBindL ]

SEM CBind
  | Bind        (expr.gUniq,loc.argMp,loc.bindLamBindL,loc.bindCAFBindL,loc.bindVarBindL,loc.bindLamArgMp)
                                            =   if @expr.isLam
                                                then  let  argLevL = fvLAsArg @lhs.levMp . fromJust . lookupFM @lhs.fvSLamMp $ @nm
                                                           (argOL,argNL,argONMp) = fvLArgRepl @lhs.gUniq argLevL
                                                      in   (@lhs.gUniq + length argOL,argONMp
                                                           ,[CBind_Bind @nm (mkCExprLam argNL @expr.cTrf)],[],[]
                                                           ,@nm `unitFM` argOL
                                                           )
                                                else  if @expr.isLet
                                                then  let  argLevL = fvLAsArg @lhs.levMp @expr.fvS
                                                           cafLamNm = mkFvNm @lhs.gUniq @nm
                                                           (argOL,argNL,argONMp) = fvLArgRepl (@lhs.gUniq + 1) argLevL
                                                      in   if null argLevL
                                                           then  (@lhs.gUniq,emptyFM,[],[@cTrf],[],emptyFM)
                                                           else  (@lhs.gUniq + 1 + length argOL,argONMp
                                                                 ,[CBind_Bind cafLamNm (mkCExprLam argNL @expr.cTrf)]
                                                                 ,[]
                                                                 ,[CBind_Bind @nm (mkCExprApp (CExpr_Var cafLamNm) (map CExpr_Var argOL))]
                                                                 ,emptyFM
                                                                 )
                                                else  (@lhs.gUniq,emptyFM,[],[],[@cTrf],emptyFM)
  | FFI         loc         .   bindVarBindL=   [@cTrf]

SEM CExpr
  | Var         lhs         .   cTrf        =   let  r n = maybe (CExpr_Var n) CExpr_Var . lookupFM @lhs.argSubst $ n
                                                     v1 = r @nm
                                                     v2 = maybe v1 (mkCExprApp v1 . map r) . lookupFM @lhs.lamArgMp $ @nm
                                                in   v2
  | Let         (loc.hereBindSq,lhs.lamBindSq)
                                            =   let  b1      = @binds.lamBindSq
                                                     b2l     = unitSeq (@categ,@binds.bindLamBindL)
                                                     b2c     = unitSeq (@categ,@binds.bindCAFBindL)
                                                     b2v     = unitSeq (@categ,@binds.bindVarBindL)
                                                     b12lcv  = unitSeq (@categ,(concat . map snd . seqToList $ b1)
                                                                                ++ @binds.bindLamBindL ++ @binds.bindCAFBindL ++ @binds.bindVarBindL)
                                                     b3      = @body.lamBindSq
                                                in   if @lhs.lev == cLevOuter
                                                     then  (b12lcv <+> b3,emptySeq)
                                                     else  (b2v,b1 <+> b2l <+> b2c <+> b3)
                lhs         .   cTrf        =   foldr (\(c,b) e -> mkCExprLet c b e) @body.cTrf . seqToList $ @hereBindSq
%%]

