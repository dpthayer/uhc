%include lhs2TeX.fmt
%include forSubText.fmt

%{

%format < 		= "{\langle}"
%format > 		= "{\rangle}"

Attribute grammars can be mapped onto functional programs
\cite{kuiper86ag-fp,johnsson87attr-as-fun,bird84circ-traverse}.
Vice versa, the class of functional programs
(catamorphisms \cite{swierstra99comb-lang})
mapped onto can be described by attribute grammars.
The AG system exploits this correspondence by providing a notation (attribute grammar)
which allows
program fragments to be described separately.
The AG compiler gathers these fragments, combines these fragments, and generates a corresponding
Haskell program.

In this AG tutorial we start with a small example Haskell program (of the right form) to
show how the computation described by this program can be expressed in the AG notation and how
the resulting Haskell program generated by the AG compiler can be used.
The `repmin' problem \cite{bird84circ-traverse} is used for this purpose.
A second example describing a `pocket calculator' (that is, expressions) focusses on
more advanced features and typical AG usage patterns.

\paragraph{Repmin a la Haskell.}
Repmin stands for ``replacing the integer valued leaves of a tree by the minimal integer value found in the leaves''.
The solution to this problem requires two passes over a tree structure,
computing the miminum and computing
a new tree with the minimum as its leaves respectively.
It is often used as the typical example of a circular program which lends itself well to be described by the
AG notation.
When described in Haskell it is expressed as a computation over a tree structure:

\chunkCmdUse{RepminHS.1.data}

The computation itself simultaneously computes the minimum of all integers found in the leaves of the tree and
the new tree with this minimum value.
The result is returned as a tuple computed by function |r|:

\chunkCmdUse{RepminHS.1.repmin}

The computation of the new tree requires the minimum.
This minimum is passed as a parameter |m| to |r| at the root of the tree by extracting it from the result of |r|.
It looks as if this is indeed a circular program because the minimum required for the result of |r|
seems to depend on the result of |r| itself.
However, the real dependency is not on the tupled result of |r| but on its fields.
The fields are not cyclically dependent so Haskell's laziness prevents
a too eager computation of the fields of the tuple which might otherwise have caused a cycle.

Finally, we can use this function in some setting, for example:

\chunkCmdUse{RepminHS.1.main}

\paragraph{Repmin a la AG.}
The structure of |repmin| is similar to the structure required by a compiler.
A compiler uses an \IxAsDef{abstract syntax tree} (\IxAsDef{AST}) and performs several computations over this tree, for example a type
and code for a target machine.
This corresponds to the |Tree| structure used by |repmin| and the tupled results.
In the context of attribute grammars the fields of this tuple are called \IxAsDef{attribute}'s.
Occasionaly the word \IxAsDef{aspect} is used as well but an aspect may also mean a group of attributes usually associated with
one particular feature of the AST/language/problem at hand.
To be more precise, these fields then called \IxAsDef{synthesized} attributes.
A compiler also requires information known only higher in an AST to be available for use lower in an AST.
This corresponds to the |m| parameter passed to |r| in |repmin|.
In the context of attribute grammars this is called an \IxAsDef{inherited} \IxAsDef{attribute}.

Using AG notation we first define the AST of the problem
(for which the complete compilable solution can be found in \figRef{ag-primer-full-repmin}):

\chunkCmdUse{RepminAG.1.data1}

\begin{Figure}{Full AG specification of repmin}{ag-primer-full-repmin}
\savecolumns
\chunkCmdUse{RepminAG.1.data1}
\restorecolumns
\chunkCmdUse{RepminAG.1.min}
\restorecolumns
\chunkCmdUse{RepminAG.1.repmin}
\restorecolumns
\chunkCmdUse{RepminAG.1.data2}
\restorecolumns
\chunkCmdUse{RepminAG.1.repminroot}
\restorecolumns
\chunkCmdUse{RepminAG.1.tree}
\restorecolumns
\chunkCmdUse{RepminAG.1.show}
\restorecolumns
\chunkCmdUse{RepminAG.1.main}
\end{Figure}



The |DATA| keyword is used to introduce the equivalent of Haskell's |data| type.
The introduced |DATA| is sometimes called a \IxAsDef{node} and the alternatives are called
\IxAsDef{variant} or \IxAsDef{production}.

The keyword |ATTR| is used to declare an attribute for a node, here the synthesized attribute |min|:

\chunkCmdUse{RepminAG.1.min}

An attribute is declared for the nonempty whitespace separated list of nodes after |DATA|.
The attribute declaration is placed inside the square brackets at one or more of three different possible places.
All attributes before the first vertical bar | || | are inherited, after the last bar synthesized, and in between both
inherited and synthesized.
Attribute |min| is a result and therefore as a synthesized attribute positioned after the last bar.

Each attribute declaration introduces the name and type of the attribute.
The type may only be a monomorphic Haskell type.
Lexicographically it may be a single capitalized identifier (as all Haskell type constants).
More complex types consisting of multiple identifiers must be delimited by curly braces |{| and |}|.

Rules relating an attribute to its value are introduced using the keyword |SEM|.
Rules relate attributes from a \IxAsDef{parent} node to the attributes of its
\IxAsDef{child}ren nodes.
Synthesized attributes must be defined for the parent, inherited for the children.

The computation for a synthesized attribute for a node
has to be defined for each variant individually as
it usually will differ between variants.
Each rule of the form | || <variant> <node> . <attr> = <Haskell expr>|.
For now |<node>| is equal to the keyword |lhs| indicating that the value is defined for the left hand side or parent
of the production, or said more simply, there is only one way to go for a synthesized attribute namely upwards in
the AST.
If multiple rules are declared for a |<variant>| of a node, the |<variant>| part may be omitted.
The same holds for multiple rules for a |<node>|.

The text representing the computation for an attribute is assumed to be a Haskell expression.
Currently this is not checked.
Only the presence of a use of an attributes, indicated by |@|, has meaning to the AG system.
The text, possibly stretching over multiple lines,
is assumed to be not less indented than its first line.
If not, it should be delimited by curly braces.

The use of an attribute\Ix{attribute use} is indicated by |@|.
Its basic form is |@ <node> . <attr>| referring to a synthesized attribute |<attr>| of child node |<node>|.
For example, |@lt.min| refers to the synthesized attribute |min| of child |lt| of the |Bin| variant of node |Tree|.

The |<node> .| part of |@ <node> . <attr>| may be omitted.
For example, |min| for the |Leaf| alternative is defined in terms of |@int|.
In that case |@ <attr>| refers to a locally (to a variant for a node) declared attribute, or to
the value with the same name as defined in the |DATA| definition for that variant.
This is the case for the |Leaf| variant's |int|.
We will postpone the discussion of locally declared attributes.

The minimum value of |repmin| passed as a porameter corresponds to an inherited attribute |rmin|:

\chunkCmdUse{RepminAG.1.repmin}

An inherited attribute is referred to by |@lhs. <attr>|; similar to |@ <node> . <attr>| for synthesized attributes
but with |<node> == lhs|.
Also the other way around is the |<node>| in an attribute rule | || <variant> <node> . <attr> = <Haskell expr>|
which now explicitly must specify to which child an attribute value is passed further down the AST.
For the |rmin| attribute this is the |lt| as well as the |rt| child of the |Bin| variant of node |Tree|.

The value of |rmin| is straightforwardly copied to its children.
This ``simply copy'' behavior occurs so often that we may omit its specification.
The AG system uses so called copy rules to automically incorporate code for copying
if the value of an attribute is not specified explicitly.
This is to prevent clutter and thus allow the programmer to focus on programming
the exception instead of the usual.
We will come back to this later, for now it suffices to mention that the rules for |rmin|
might well have been omitted.

The original |repmin| function did pass the minimum value coming out |r| back into |r| itself.
This did happen at the top of the tree.
Similarly we define a |Root| node sitting on top of a |Tree|:

\chunkCmdUse{RepminAG.1.data2}

At the root the |min| attribute is passed back into the tree via attribute |rmin|:

\chunkCmdUse{RepminAG.1.repminroot}

The value of |rmin| is used to construct a new tree:

\chunkCmdUse{RepminAG.1.tree}

The AG compiler also generates for each |DATA| a corresponding Haskell |data| type declaration.
For each node |<node>| a data type with the same name |<node>| is generated.
Each constructor of the data type has a name of the form |<node>_<variant>|.
The constructed new tree is returned as the one and only attribute of |Root| and can be shown as
in the Haskell version of |repmin| if we tell the AG compiler to make the generated data type an
instance of class |Show|:

\chunkCmdUse{RepminAG.1.show}

Similarly to the Haskell version of |repmin| we can now show the result of the attribute computation as a plain Haskell value:

\chunkCmdUse{RepminAG.1.main}

Because this part is Haskell code it has to be delimited by curly braces.
The AG compiler copies it unchanged to the generated Haskell program.

In order to understand what is happening here we have to look at the Haskell code as generated by the AG compiler,
because this code is used from the Haskell world to compute the synthesized attributes we are interested in.
For the above example the following code will be generated (edited to remove clutter):

\begin{TT}
data Root = Root_Root (Tree)
-- semantic domain
type T_Root = ( (Tree))
-- cata
sem_Root :: (Root) -> (T_Root)
sem_Root ((Root_Root (_tree)))
  = (sem_Root_Root ((sem_Tree (_tree))))
sem_Root_Root :: (T_Tree) -> (T_Root)
sem_Root_Root (tree_) =
    let ( _treeImin,_treeItree) = (tree_ (_treeOrmin))
        (_treeOrmin) = _treeImin
        (_lhsOtree) = _treeItree
    in  ( _lhsOtree)

data Tree = Tree_Bin (Tree) (Tree)
          | Tree_Leaf (Int)
          deriving ( Show)
-- semantic domain
type T_Tree = (Int) -> ( (Int),(Tree))
-- cata
sem_Tree :: (Tree) -> (T_Tree)
sem_Tree ((Tree_Bin (_lt) (_rt)))
  = (sem_Tree_Bin ((sem_Tree (_lt))) ((sem_Tree (_rt))))
sem_Tree ((Tree_Leaf (_int))) = (sem_Tree_Leaf (_int))
sem_Tree_Bin :: (T_Tree) -> (T_Tree) -> (T_Tree)
sem_Tree_Bin (lt_) (rt_) =
    \ _lhsIrmin ->
        let ( _ltImin,_ltItree) = (lt_ (_ltOrmin))
            ( _rtImin,_rtItree) = (rt_ (_rtOrmin))
            (_lhsOmin) = _ltImin `min` _rtImin
            (_rtOrmin) = _lhsIrmin
            (_ltOrmin) = _lhsIrmin
            (_lhsOtree) = Tree_Bin   _ltItree _rtItree
        in  ( _lhsOmin,_lhsOtree)
sem_Tree_Leaf :: (Int) -> (T_Tree)
sem_Tree_Leaf (int_) =
    \ _lhsIrmin ->
        let (_lhsOmin) = int_
            (_lhsOtree) = Tree_Leaf  _lhsIrmin
        in  ( _lhsOmin,_lhsOtree)
\end{TT}

In general, generated code is not the most pleasant of prose to look at, but we will have to use the generated
functions in order to access the AG computations of attributes from the Haskell world.
The following observations should be kept in mind when doing so:
\begin{itemize}
\item
For node |<node>| also a type |T_<node>| is generated, describing the function type computing attribute values.
This type corresponds one-to-one to the attributes defined for |<node>|: inherited attributes to parameters, synthesized attributes
to fields of the result tuple (or single type if only one synthesized attribute is defined).
\item
Computation of attribute values is done by semantic functions with a name of the form |sem_<node>_<variant>|.
These functions have exactly the same type as their constructor counterpart of the generated data type.
The only difference lies in the parameters which are of the same type as their constructor counterpart, but
prefixed with |T_|.
For example, data constructor |Tree_Bin :: Tree -> Tree -> Tree| corresponds to the semantic function
|sem_Tree_Bin :: (T_Tree) -> (T_Tree) -> (T_Tree)|.
\item
A mapping from the Haskell |data| type to the corresponding semantic function is available with
the name |sem_<node>|.
There is no way back.
\end{itemize}

In the Haskell world one now can follow the different routes to compute the attributes:
\begin{itemize}
\item
First construct a Haskell value of type |<node>|, then apply |sem_<node>| to this value and additionally required inherited attributes values.
The given function |main| from AG variant of repmin takes this approach.
\item
Circumvent the construction of Haskell values of type |<node>| by using the semantic functions |sem_<node>_<variant>|
directly instead of the data constructor |<node>_<variant>|.
\end{itemize}

In both cases a tuple holding all synthesized attributes is returned.
The order of the fields in the tuple is unspecified.
For now, this is not a problem as |sem_Root| will only return one value, a |Tree|.
Later we will see the use of wrapper functions to pass inherited attributes and extract synthesized attributes
via additional wrapper data types holding attributes via labeled fields.

\paragraph{Parsing directly to semantic functions.}
The given |main| function uses the first approach: construct a |Tree|, wrap it inside a |Root|, and
apply |sem_Root| to it.
The following example takes the second approach; it parses some input text describing the structure of a tree and
directly invokes the semantic functions:

\chunkCmdUse{RepminAG.2.parser}

The parser recognises the letter '@B@' as a |Bin| alternative and a single digit as a |Leaf|.
\FigRef{parser-combinators} gives an overview of the parser combinators which are used \cite{??}.
The parser is invoked from an alternative |main|:

\chunkCmdUse{RepminAG.2.main}

We will not discuss this alternative further nor will we discuss this particular variant of
parser combinators.
However, this approach is taken in the rest of \thispaper\ wherever parsing is required.

\begin{Figure}{Parser combinators}{parser-combinators}
\begin{tabular}{lll}
\ParserCombTableHead
\ParserCombTableA
\ParserCombTableB
\end{tabular}
\end{Figure}

\paragraph{More features and typical use: a pocket calculator.}
We will continue with looking at a more complex example, a pocket calculator which accepts expressions.
The calculator prints a pretty printed version of the entered expression, its computed value and some statistics
(the number of additions performed).
An interactive terminal session of the pocket calculator looks as follows:

\begin{TT}
$ build/bin/expr
Enter expression: 3+4
Expr='3 + 4', val=7, add count=1
Enter expression: [a=3+4:a+a]
Expr='let a=3 + 4 in a + a', val=14, add count=3
Enter expression: ^Cexpr: interrupted
$
\end{TT}

This rudimentary calculator allows integer values, their addition and binding to identifiers.
Parsing is character based, no scanner is used transform raw text into tokens.
No whitespace may occur and a |let| expression is syntactically denoted by @[<nm>=<expr>:<expr>]@.

The example will allow us to discuss more AG features as well as typical use of AG.
We start with integer constants, addition, and the an attribute computation for the pretty printing:

\chunkCmdUse{Expr.1.data}

The root of the tree is now called |AGItf| to indicate (as a naming convention)
that this is the place where interfacing between the Haskell world
and the AG world takes place.

The definition also demonstrates the use of the |SET| keyword which allows the naming of a group of nodes.
This name can later be used to declare attributes for the named group of nodes.

The computation of a pretty printed representation follows the same pattern as the computation of |min| and |tree|
in the |repmin| example because of its compositional and bottom-up nature.
The synthesized attribute |pp| is synthesized from the values of the |pp| attribute of the children of a node:

\chunkCmdUse{Expr.1.pp}

The pretty printing uses a pretty printing library not further discussed here; an overview of some of
the available combinators can be found in \figRef{pretty-printing-combinators}.

\begin{Figure}{Pretty printing combinators}{pretty-printing-combinators}
\begin{center}
\begin{tabular}{ll}
Combinator & Result
\\ \hline
|p1 >||< p2| & |p1| besides |p2|, |p2| at the right \\
|p1 `ppBesideSp` p2| & same as |>||<| but with an additional space in between \\
|p1 >-< p2| & |p1| above |p2| \\
|pp_parens p| & |p| inside parentheses \\
|text s| & string |s| as |PP_Doc| \\
|pp x| & pretty print |x| (assuming instance |PP x|) resulting in a |PP_Doc| \\
\end{tabular}
\end{center}
\end{Figure}

The following step is to add |let| expressions and the use of identifiers.
This demonstrates an important feature of the AG system, namely to extend a previously defined AST
with new alternatives for a |<node>| as well as to add new attribute computations independently.
We first add new AST alternatives for |Expr|:

\chunkCmdUse{Expr.1.letdata}

One should keep in mind that the exensibility offered is simplistic of nature but surprisingly flexible at the same time.
The idea is that node variants, attribute declarations and attribute rules for node variants can all be textually separated.
The AG compiler gathers all definitions, combines them, performs several checks (e.g. are attribute rules missing), and generates
the corresponding Haskell code.
Text can reside in different text files to be included with a |INCLUDE| directive (not discussed any further).
However, no module mechanism is offered nor any encapsulation mechanism for attributes.
This may change in the future.

Any addition of new AST node variants requires also the definition of already declared attributes:

\chunkCmdUse{Expr.1.letpp}

The use of variables also requires us to keep an administration of the values bound to variables.
An association list is used to provide this environmental and scoped information:

\chunkCmdUse{Expr.1.env}

The scope is enforced by extending the inherited attribute |env| top-down in the AST.
The |Let| variant adds a new entry on top of the environment.
This solution is also an often occurring one whenever contextual and scoped information needs to
be made available in lower parts of the AST.
The environment |env| is queried when the value of an expression is computed:

\chunkCmdUse{Expr.1.val}

The attribute |val| holds this computed value.
Because its value is needed in the `outside' Haskell world it is passed through |AGItf| (as part of |SET AllNT|)
as a synthesized attribute.
This is also the case for the previously introduced |pp| attribute as well as the following |count| attribute
holding the number of additions performed.
The |count| attribute however is also passed as an inherited attribute.
Being both inherited and synthesized it is defined between the two vertical bars in the
|ATTR| declaration for |count|:

\chunkCmdUse{Expr.1.count}

The attribute |count| is said to be \IxAsDef{threaded} through the AST,
the AG solution to a global variable.
This is a result of the attribute being inherited as well as synthesized and
the copy rules.

\IxAsDef{Copy rule}s are attribute rules inserted by the AG system if a rule for an attribute |<attr>|
in a production of |<node>| is missing.
The attribute may be synthesized in which case its rule should have the form |lhs . <attr> = ...|
or inherited with form |<child> . <attr> = ...|.
AG inserts a rule to copy the value of another attribute |<attr'>| if this other attribute has the same name,
and can be found (in this order) among the following available attributes (with the same name):

\begin{enumerate}
\item
Local attributes.
\item
The synthesized attribute of the rightmost child at the left of the child for which an inherited |<attr>| is to be defined.
A synthesized |<attr>| of a parent is considered to be at the right of any child's |<attr'>|.
\item
Inherited attributes (of the parent).
\end{enumerate}

In our example the effect is that for the |Let| variant of |Expr|

\begin{itemize}
\item
(inherited) |@lhs.count| is copied to (inherited) |@val.count|,
\item
(synthesized) |@val.count| is copied to (inherited) |@body.count|,
\item
(synthesized) |@body.count| is copied to (synthesized) |@lhs.count|.
\end{itemize}

Similar copy rules are inserted for the other variants.
Only for variant |Add| of |Expr| a different rule for |@lhs.count| is explicitly specified.

Automatic copy rule insertion can be both a blessing and curse.
A blessing because it takes a lot of otherwise tedious work out of the hands of a programmer and minimises clutter
in the AG source text.
On the other hand it can be a curse because a programmer may have forgotten an otherwise required rule. If a copy rule can be inserted
the programmer will not be warned about the missing rule.

As with our previous example we can let a parser map input text to the invocation of semantic functions.
For completeness this source text has been included in \figRef{ag-primer-parser-expr}.
The result of parsing combined with the invocation of semantic functions will be function taking inherited attributes
to a tuple holding all synthesized attributes.
However, the order in which these attributes can be found in the result tuple is not specified.
This is a direct consequence of the freedom to specify AG fragments in any order (textually) independently of eachother.
The AG system can be instructed to create a wrapper function which knows how to extract the attributes out of the
result tuple:

\chunkCmdUse{Expr.1.wrapper}

The attribute values are stored in a data type with labeled fields for each attribute.
The attributes can be accessed with labels of the form |<attr>_Syn_<node>|.
The name of the wrapper is of the form |wrap_<node>|; the wrapper function is passed the result of the semantic function
and a data type holding inherited attributes:

\chunkCmdUse{Expr.1.main}

The order in which inherited attributes need to be passed to the semantic function is also unspecified.
Inherited attributes are passed to the wrapper function via a data type with name |Inh_<node>| and one constructor with the same name.
Its fields have labels of the form |<attr>_Inh_<node>|.
The |count| attribute is an example of an attribute which must be passed as an inherited attribute as well
as extracted as a synthesized attribute.

\paragraph{The rest...}
This concludes our introduction to the AG system.
However, some topics have either not been mentioned at all or only shortly touched upon.
We provide a list of those topics together with a reference to its first use later in \thispaper.
Each of these items is marked with |AGFeature| to indicate that it is about the AG system.

\begin{itemize}
\item
Set notation for variant names in rules (see \secPageRef{ag-set-notation}).
\item
Local attributes (see \secPageRef{ag-loc-attr}).
\item
Additional copy rule via |USE| (see \secPageRef{ag-use-attr}).
\item
Additional copy rule via |SELF| (see \secPageRef{ag-self-attr}).
\item
Rule redefinition via |:=|.
\item
Typical use/pattern: decomposition.
\item
Typical use/pattern: gathering.
\item
Typical use/pattern: unique number generation.
\item
Caveat: cycles.
\end{itemize}

We will come back to the AG system itself in our conclusion.

\begin{Figure}{Parser for calculator example}{ag-primer-parser-expr}
\chunkCmdUse{Expr.1.parser}
\end{Figure}

%}