%%[abstract
This document describes the design of a bytecode virtual machine for GRIN.
The reader is assumed to be familiar with the EH project
\cite{dijkstra05phd,dijkstra04ehc-web} and its overall design.
Although we intend this document primarily to be for the understanding by EHC developers,
we provide some introductory notes and background before delving into the internals of
the machinery.

%%]

%%[defs
%format CSBase      = "C"
%format CSGetFld    = "F"
%format CSEnv       = Gamma
%format <<          = "{\llbracket}"
%format >>          = "{\rrbracket}"

%format angle(x)     = "\langle{" x "}\rangle"

%format unit        = "\mathbf{unit}"
%format store        = "\mathbf{store}"
%format eval        = "\mathbf{eval}"
%format ild(i)(rd)(rs)(x)        = "\mathsf{l}\langle{" i "}\rangle\langle{" rd "}\rangle\langle{" rs "}\rangle" ^^ x
%format ist(i)(rd)(rs)(x)       = "\mathsf{s}\langle{" i "}\rangle\langle{" rd "}\rangle\langle{" rs "}\rangle" ^^ x
%format icp(i)(rs)(x)         = "\mathsf{cp}\langle{" i "}\rangle\langle{" rs "}\rangle" ^^ x
%format iop(ot)(dt)(i)(rd)(rs)(x)       = "\mathsf{o}\langle{" ot "}\rangle\langle{" dt "}\rangle\langle{" i "}\rangle\langle{" rd "}\rangle\langle{" rs "}\rangle" ^^ x
%format iaddi(rd)(x)         = "\mathsf{addi}\langle{" rd "}\rangle" ^^ x
%format icall(rs)         = "\mathsf{call}\langle{" rs "}\rangle"
%format itailcall(rs)(n)(m)(r)         = "\mathsf{tailcall}\langle{" rs "}\rangle" ^^ n ^^ m ^^ r
%format ildg(m)(t)(o)         = "\mathsf{ldg}" ^^ m ^^ t ^^ o
%format iretcall(n)(m)(r)         = "\mathsf{retcall}" ^^ n ^^ m ^^ r
%format iretcase(n)(r)(c)         = "\mathsf{retcase}" ^^ n ^^ r ^^ c
%format icasecall         = "\mathsf{casecall}"
%format ieval(rs)         = "\mathsf{eval}\langle{" rs "}\rangle"
%format itaileval(rs)(m)(r)         = "\mathsf{taileval}\langle{" rs "}\rangle" ^^ m ^^ r
%format iapply(rs)       = "\mathsf{apply}\langle{" rs "}\rangle"
%format ialloc(rs)         = "\mathsf{alloc}\langle{" rs "}\rangle"
%format iallocstore(rs)         = "\mathsf{allocstore}\langle{" rs "}\rangle"
%format istore(rs)         = "\mathsf{store}\langle{" rs "}\rangle"
%format ifetch(rs)         = "\mathsf{fetch}\langle{" rs "}\rangle"
%format icallc(n)         = "\mathsf{callc}" ^^ n
%format tailcall         = "\mathsf{tailcall}"
%format taileval         = "\mathsf{taileval}"
%format fetchupd         = "\mathsf{fetchupd}"
%format applycont         = "\mathsf{applycont}"
%format evappcont         = "\mathsf{evappcont}"
%format papplycont         = "\mathsf{papplycont}"
%format retcall         = "\mathsf{retcall}"
%format retcase         = "\mathsf{retcase}"
%format call         = "\mathsf{call}"
%format callc         = "\mathsf{callc}"
%format alloc         = "\mathsf{alloc}"
%format stores         = "\mathsf{store}"
%format allocstore         = "\mathsf{allocstore}"
%format fetcht         = "\mathsf{fetch}"
%format evupdcont         = "\mathsf{GB_Ins_EvalUpdCont}"
%format casecall         = "\mathsf{casecall}"
%format evalt         = "\mathsf{eval}"
%format applyt        = "\mathsf{apply}"
%format nop         = "\mathsf{nop}"
%format ldl         = "\mathsf{ldl}"
%format ldc         = "\mathsf{ldc}"
%format ldi         = "\mathsf{ldi}"
%format ldg         = "\mathsf{ldg}"
%format l1tt        = "\mathsf{l1tt}"
%format l0ti        = "\mathsf{l0ti}"
%format l0tt        = "\mathsf{l0tt}"
%format sts         = "\mathsf{sts}"
%format s1tt        = "\mathsf{s1tt}"

%format **          = "**"

%format sv          = "s_v"
%format an          = "a_n"
%format cn          = "c_n"
%format bm          = "b_m"
%format fm          = "f_m"
%format bk          = "b_k"

%format xpos        = "x^{+}"
%format Enc(x)      = "\overline{" x "}"
%format Frac(x)(y)  = "\frac{" x "}{" y "}"

%format gcode       = "\textit{is}"
%format gstack      = "\textit{st}"
%format gheap       = "\textit{hp}"
%format greg        = "\textit{r}"
%format gpc         = "\textit{pc}"

%format (ixx1(x)(f))    = x "_{" f "}"
%format (ixx(x)(f)(t))  = x "_{" f "} .. " x "_{" t "}"
%format (ixxjuxt(x)(f)(t))  = x "_{" f "}" x "_{" t "}"
%format (pow2(p))   = "2^{" p "}"

\newenvironment{GrinCS}{%
\begin{tabular}{p{.35\linewidth}@@{\hspace{.5ex}=\hspace{.5ex}}p{.45\linewidth}}
}{%
\end{tabular}
}

\newcommand{\GriniStateBefore}[5]{%
#1 &
#2 &
#3 &
#4 &
#5
}

\newcommand{\GriniStateAfter}[5]{%
$\Longrightarrow$ &
#2 &
#3 &
#4 &
#5
}

\newcommand{\GriniStep}[2]{%
\begin{tabular}{lllll}
\hline
& Code & Stack & Heap & Reg \\
\hline
#1 \\ #2 \\
\hline
\end{tabular}
}

\newenvironment{GrinEncoding}[1]{%
\begin{tabular}{lllll}
\hline
#1 & byte 0 & byte 1 & byte 2 & byte 3 \\
\hline
}{%
\hline
\end{tabular}
}

%%]


%%[intro
The Grin Bytecode Machine (GBM) is a virtual machine for the Graph Reduction Intermediate Notation (GRIN)
\cite{boquist99phd-optim-lazy,boquist96grin-optim}.
GRIN is an intermediate representation for functional programs where all lazy and higher order constructs have been made
explicit.
This is accomplished by the following:
\begin{Itemize}
\item
  Computation is done imperatively, that is the order in which computations are performed is made explicit.
\item
  Computation is non-lazy and always yields a result.
  Whenever lazy behavior is desired, an appropriate datastructure is build to represent the delayed computation.
  Computation of such a structure is enforced by an explicit evaluation.
\end{Itemize}

For example, the following program:

%%[[wrap=code
id x = x
v = id 3
main = v
%%]]

translates to the following GRIN program:

%%[[wrap=code
{  id x
     =  {  unit x ; \x' ->
           eval x'
        } 
;  v 
     =  {  store (#0 ^ / ^ C ^ / ^ Int ^^ 3) ; \x ->
           id x
        } 
;  main 
     =  {  unit v ; \v' ->
           eval v'
        } 
}
%%]]

Both |main| and |v| are CAF's. Computation is triggered by the context (a runtime system) requesting for the evaluation of |main|.
The body of |main| is then invoked, requesting for the evaluation of |v|.
|v| then heap allocates a boxed integer which is then passed to |id|, which evaluates and returns its parameter.
The builtin function |eval| checks whether a stored node represents a delayed computation and then proceeds to compute it.

The primary use of GRIN is to represent a whole program with it, and then analyse this complete self contained program.
The most important assumption for such an analysis is that the program is closed, no other code will be invoked,
nor will any part of the program be invoked by outside code.
This allows the most important source of inefficiency, the builtin |eval|, to be analysed for its use, inlined, specialised for its specific use at
each call site.
This analysis is done as part of EH (ehc variant 8) and described elsewhere \cite{boquist99phd-optim-lazy}.

\paragraph{Why a Grin Bytecode Machine?}
Although GRIN is intended as a notation allowing whole program analysis, it also represents a program which can directly be interpreted.
At this place the Grin Bytecode Machine (GBM) steps in.
There are a couple of reasons as why to do this:

\begin{Itemize}
\item
  It is yet unclear how whole program analysis scales.
  Although it promises highly optimised code, where the price for laziness no longer has to be paid when laziness is not used,
  its analysis and optimisation techniques are not yet sorted out completely, may be too resource expensive,
  and inhibits fast compilation turn around times.
\item
  It is yet unclear how practical language features like exceptions, modules, and threads
  interact with GRIN and whole program analysis.
\end{Itemize}

An interpreter circumvents these problems by avoiding whole program analysis, 
and interpreting the 'optimized away' constructs like |eval| instead.
In the context of EH there are also other benefits to using an interpretive technique in addition to full program analysis:

\begin{Itemize}
\item
  Two implementations, one based on highly optimised code, one based on interpretation, allow correctness checks of eachother by
  comparing test output.
\item
  Because GRIN already makes explicit much of the laziness, its interpretation may well turn out to be fast enough to be of real practical use.
\item
  It allows research into hybrid techniques where part is fully optimised, part is interpreted.
\end{Itemize}

\Paragraph{An example of GBM code}

We present the translation of the example into GBM code to give the reader an intuition of what the GBM does:

%%[[wrap=code
{  id x
     =  {  unit x ; \x' ->
                ldl         x                   -- load parameter x
           eval x'                             
                ldl         x'                  -- load x' (alias for x)
                taileval                        -- tail evaluate
        } 
;  v 
     =  {  store (#0 ^ / ^ C ^ / ^ Int ^^ 3) ; \x ->
                ldi         3                   -- load (unboxed) int 3
                ldl         x                   -- load x (alias for 3)
                ldg         id                  -- load global id
           id x
                tailcall                        -- tail call
        } 
;  main 
     =  {  unit v ; \v' ->
                ldg         v                   -- load global v
                ldl         v'                  -- load v' (alias for v)
           eval v'
                taileval                        -- tail evaluate
        } 
}
%%]]

Note that the GBM follows quite literally, that is unoptimised, the corresponding GRIN.
Also note that int's are treated in unboxed for, thereby avoiding the need to allocate storage for a boxed representation.

%%]


%%[grin2GrinB
\emph{This section is left here for later rewrite.}

\begin{GrinCS}
|CSBase<< unit v ; \w -> e >> CSEnv|
&
|CSBase<< e >> ^^ CSEnv ^ [w :-> CSEnv v]| 
\end{GrinCS}

\begin{GrinCS}
|CSBase<< unit v ; \(C ^^ Vec(w)) -> e >> CSEnv|
&
|Vec(ldl v : lda o) : CSBase<< e >> ^^ CSEnv ^ Vec([w :-> gstack])| 
\end{GrinCS}

\begin{GrinCS}
|CSBase<< unit (C ^^ Vec(v)) ; \(C ^^ Vec(w)) -> e >> CSEnv|
&
|CSBase<< e >> ^^ CSEnv ^ Vec([w :-> CSEnv v])| 
\end{GrinCS}

\begin{GrinCS}
|CSBase<< store (C ^^ Vec(v)) ; \w -> e >> CSEnv|
&
|alloc ||Vec(v)|| : CSBase<< e >> ^^ CSEnv ^ [w :-> gstack]| 
\end{GrinCS}

%%]

%%[grinBSemantics
%%]

%%[grinBMemoryModel

\Paragraph{Memory}
GBM uses:

\begin{Itemize}
\item
  A stack, growing downwards, a register |gstack| points to the top.
\item
  A heap, referred to by |gheap|.
\item
  A single register |greg|.
\end{Itemize}

Currently the general purpose |greg| is not used, but the GBM design allows future use. It is also unclear whether the availability of
such a register benefits the speed of the interpreter.
It also requires the GBM code generation to be aware of this register.

The heap currently is either non-garbagecollected, or under control of the Boehm garbage collector \cite{boehm88gc-c,boehm06gc-www},
depending on configuration.

Memory consists of words, either 32 bits or 64 bits, depending on the platform.
A word is guaranteed to be able to hold a pointer.

\Paragraph{Nodes and tagging}
Nodes reside in the heap, and occupies at least 1 word.
A node consists of a header (a word) + zero or more words.

The following is the layout for a 32 bits header, a 64 bits header spends its available space on the |size| and |tag| field.
%%[[wrap=code
size            16  bits                                -- nr of words, incl header
needsEval       1   bit                                 -- 1 == possibly needs eval
tagCateg        2   bits                                -- eval == 0: {C,P}, eval == 1: {F,A,I,B}
gc              2   bits                                -- reserved for future use by garbage collecting
tag             11  bits                                -- also used for size info for P, A
%%]]

A bit |needsEval| is reserved to indicate whether the node possibly needs evaluation.
This is the case for saturated function closures (|tagCateg = F|),
general application nodes (|tagCateg = A|),
indirection nodes (|tagCateg = I|),
and black holes (|tagCateg = H|).
Data constructors (|tagCateg = C|) and partial applications (|tagCateg = P|) need no further evaluation.

Tag categories summary:
%%[[wrap=code
F               00              -- function closure
A               01              -- general application
I               10              -- indirection
B               11              -- black hole

C               00              -- constructor
P               01              -- partial app
%%]]

\Paragraph{Node pointers and Int's}
A word represents a pointer to a node or an integer.
A pointer is required to have its least significant bit set to 0, for an integer this is 1.
The encoding for an integer equals the original integer value shifted left |sh| positions
plus the int tag value |t|.
Currently |sh = 1, t = 1|,
which means that the encoding |Enc(x)| of |x| is defined as follows, with |s = pow2(1)| (see Leroy \cite{leroy90zinc-ml-impl}):

%%[[wrap=code
Enc(x)          =   x * s + t
Enc(x1+x2)      =   (x1+x2) * s + t
                =   x1 * s + t + x2 * s + t - t
                =   Enc(x1) + Enc(x2) - t
Enc(x1-x2)      =   (x1-x2) * s + t
                =   x1 * s + t - x2 * s - t + t
                =   Enc(x1) - Enc(x2) + t
Enc(x1*x2)      =   (x1*x2) * s + t
                =   (x1 * s) * (x2 * s) / s + t
                =   (x1 * s + t - t) * (x2 * s + t - t) / s + t         ^
                =   (Enc(x1) - t) * (Enc(x2) - t) / s + t
                =   (Enc(x1) - t) * (Enc(x2) / s) + t                   ^ -- t/s shifts out
Enc(x1/x2)      =   (x1/x2) * s + t
                =   Frac(x1 * s)(x2 * s) * s + t
                =   Frac(x1 * s + t - t)(x2 * s + t - t) * s + t
                =   Frac(Enc(x1) - t)(Enc(x2) - t) * s + t
%%]]
%                =   Frac(Enc(x1) - t)(Enc(x2) / s - t / s) + t
%                =   Frac(Enc(x1) - t)(Enc(x2) / s) + t                  ^ -- t/s shifts out

Assuming a word size of 32 bits, for signed ints |x| in the range |- pow2(32-sh-1) <= x < pow2(32-sh-1)|, |32-sh| bits are used.

\Paragraph{Constant values (like Strings)}
String constants are encoded in a platform dependent manner with a wrapper function constructing the expected node based representation.
Constants are stored in a separate table, to be accessed by a specialised instruction |ldg| for accessing global values,
together with runtime linking functionality.

\Paragraph{Platform dependencies}
GBM is dependent on
\begin{Itemize}
\item \textbf{Word size.}
  Word size may be 32 or 64 bits.
  Some instruction depend on this parameter.
  For example, the load global |ldg| instruction refers to a global via a pointer, which has the size of a word and is inlined in the instruction stream.
\item \textbf{Endianness.}
  The encoding of literal integer values is done in the encoding used by the platform.
\end{Itemize}

GBM is not designed to be platform independent.
For a platform independent encoding of instructions a choice between these dependencies would have to be made.

\Paragraph{Modules}
\emph{This paragraph is left here for later rewrite.}

Incoming and outgoing references need to be resolved during initialization time with the help of some tables
\begin{itemize}
\item
  Imported modules, mapping module names to global module numbers assigned during linking time.
\item
\end{itemize}

\Paragraph{Initialization}
Initialization takes places in the following order, possible referring to module |angle(m)|.
\begin{itemize}
\item
  Stack, heap are set up.
\item
  Resolve imported modules for |angle(m)|.
  Each |angle(m)| is assigned a unique number, also referred to as |angle(m)|.
\item
  Each module |angle(m)| initializes itself, via a call to function |angle(m)_initialize|.
\item
  Resolve exported entrypoints for |angle(m)| (is this necessary?).
\end{itemize}

\Paragraph{Table summary}
\emph{This paragraph is left here for later rewrite.}

The following tables are used, |angle(m)| is the module nr, starting at |1|, global tables have module nr |0|.
Format is |table : table nr :: functionality :: actual C encoding|.

%%[[wrap=code
bytecode                :   angle(m).0  ::  PC -> Instr             ::  Instr[]                 -- per module
strings                 :   angle(m).1  ::  Offset -> String        ::  char[][]                -- per module
imported modules        :   angle(m).2  ::  ModNm -> Module         ::  Node[]                  -- per module, filled at link time
exported entrypoints    :   angle(m).3  ::  Module                  ::  PC[]                    -- mem locations, filled at link time
CAF entrypoints         :   angle(m).4  ::  PC                      ::  PC[]                    -- mem locations, filled at link time
all modules             :   0.0         ::  ModNm -> Module         ::  Node[]                  -- 
CAF                     :   0.1         ::
%%]]

%%]

%%[grinBMetavarEncoding
Although only a few instructions are required for the interpretation of GRIN by GBM,
the design of the instruction set has been made as general as possible.
We first describe the notation used to describe instruction variation.
With each individual instruction the implemented and used variants are listed.

\subsubsection{Load source, store destination: extended variant}
%%[[wrap=code
angle(rd), angle(rs)  =  i  -- immediate constant
                      |  p  -- program counter relative
                      |  t  -- top of stack relative
                      |  r  -- scratch register relative
%%]]

%%[[wrap=code
t  =  00
r  =  01
i  =  10
p  =  11
%%]]

Store destinations can only be |s| or |r|, hence the encoding omits the most significant bit in store instructions.

\subsubsection{Load destination, store source: basic variant}
%%[[wrap=code
angle(rd), angle(rs)  =  t  -- top of stack, with push/pop side effect
                      |  r  -- scratch register
%%]]

%%[[wrap=code
t  =  0
r  =  1
%%]]

\subsubsection{Operator destination: operand variant}
%%[[wrap=code
angle(od)  =  t  -- top of stack, with push/pop side effect
           |  r  -- scratch register
           |  s  -- stack pointer register
           |  p  -- program counter register
%%]]

%%[[wrap=code
t  =  00
r  =  01
s  =  10
p  =  11
%%]]

\subsubsection{Operator type}
%%[[wrap=code
angle(ot)  =  a  -- add
           |  s  -- subtract
           |  m  -- multiply
           |  d  -- divide+modulo
%%]]

%%[[wrap=code
a  =  00
s  =  01
m  =  10
d  =  11
%%]]

\subsubsection{Data type}
%%[[wrap=code
angle(dt)  =  i1  -- 32bits int
           |  i2  -- 64bits int
           |  f1  -- 32bits float
           |  f2  -- 64bits float
           |  iw  -- word
           |  ii  -- unlimited integer precision
%%]]

%%[[wrap=code
i1  =  000
i2  =  001
f1  =  010
f2  =  011
iw  =  100
ii  =  101
%%]]

\subsubsection{Immediate signed int constant size}
%%[[wrap=code
angle(is)  =  08, b  -- byte, 8 bits
           |  16, s  -- short, 16 bits
           |  32, w  -- word, 32 bits
           |  64, d  -- double, 64 bits
%%]]

%%[[wrap=code
08, b  =  00
16, s  =  01
32, w  =  10
64, d  =  11
%%]]

\subsubsection{Indirection level}
%%[[wrap=code
angle(i)  =  0      -- as is, use itself (don't follow as address)
          |  1      -- use content pointed to (do follow as address)
          |  2      -- and another time
          |  3, i   -- use as int, that is yield tagged int representation
%%]]

Level 0 is only used for a source, in that case encoding equals the encoding for |i - 1|.

A level 3 represents a variation on level 0 with an implicit conversion to int encoding |Enc(x)|.

\subsubsection{Instruction prefixes/categories}

Instructions occupy 1 byte, plus additional immediate (inlined) parameters.
Instructions are grouped, based on common functionality.
Each group shares an initial bitsequence, that is their higher significant bits are equal.
For example, all loading instructions start with |0|.

Currently the following categories are used.
Those without comment are not yet used.

%{
%format <<  = "{\ll}"
%%[[wrap=code
0           ^^  0x00        ^^  0x00        -- loading
100         ^^  0x04 << 5   ^^  0x80        -- storing
101         ^^  0x05 << 5   ^^  0x82        -- arithmetic
1100  0     ^^  0x18 << 3   ^^  0xC0        -- calling, case
1100  0111
1100  1     
1101
1110  0     ^^  0x1C << 3   ^^  0xE0        -- eval/apply
1110  1     ^^  0x1D << 3   ^^  0xE8        -- heap: node alloc/fetch
1111  0     ^^  
1111  1     ^^              ^^  0xF8        -- 'standalone': extend prefix, nop, ...
%%]]
%}

%%]

%%[grinBConstants
Constants may appear as part of an instruction, after its initial bytecode.
These immediate constants may be of 8, 16, 32 or 64 bits size.

\begin{GrinEncoding}{instruction with |x=c|}
|- pow2(7) <= c < pow2(7), angle(is) = b | &
|.. ^ ixxjuxt(is)(1)(0) ..| &
|ixx(c)(7)(0)| &
&
\\
|- pow2(15) <= c < pow2(15), angle(is) = s | &
|.. ^ ixxjuxt(is)(1)(0) ..| &
|ixx(c)(7)(0)| &
|ixx(c)(15)(8)| &
\\
etc.
\\
\end{GrinEncoding}

Whenever a constant |x| is referred to from the instruction encoding,
its two bits |ixxjuxt(x)(1)(0)| refer to the above encoded size information.

%%]

%%[grinBMovingData

\subsubsection{Loading}

\begin{GrinEncoding}{|ild(i)(rd)(rs)(x)|}
 &
|0 ^ ixxjuxt(i)(1)(0) ^ ixx1(rd)(0) ^ ixxjuxt(rs)(1)(0) ^ ixxjuxt(x)(1)(0)| &
... &
&
\\
\end{GrinEncoding}

\textbf{Semantics}\\

%%[[wrap=code
ild(i)(rd)(rs)(x)
  =  case angle(i) of
       0  ->  d  :=  s
       1  ->  d  :=  *s
       2  ->  d  :=  **s
       i  ->  d  :=  Enc(s)
%%@TopicGrinBytecode.grinBLoadSrc
         d  <-  case ^^ angle(rd) of
                  t  ->  gstack := [gstack]-1
                         *(gstack + x)
                  r  ->  greg
%%]]

\textbf{Abbreviations}\\

%%[[wrap=code
ldl d       =   l1tt  d            -- push content displacement d relative to tos on stack
ldc c       =   l0ti  c            -- push constant c on stack
ldi i       =   liti  c            -- push constant c in int encoding on stack
%%]]

\textbf{|ldl|: load local from stack}\\

\GriniStep{%
 \GriniStateBefore{%
 }{%
  |ldl v : gcode|
 }{%
  |s0 : ... : sv : gstack|
 }{%
  |gheap|
 }{
  |greg|
 }
}{%
 \GriniStateAfter{%
 }{%
  |gcode|
 }{%
  |sv : s0 : ... : sv : gstack|
 }{%
  |gheap|
 }{
  |greg|
 }{}
}

\subsubsection{Load global}

\emph{This section is left here for later rewrite, |ldg| depends on additional linking tables}

\begin{GrinEncoding}{|ildg(m)(t)(o)|}
 &
|1111 ^^ 1100| &
 &
 &
\\
\end{GrinEncoding}

Load from module |m| (16 bits), table |t| (16 bits), offset |o| (32 bits).
This info is stored in a separate link entry table, and patched during runtime initialization
with the proper location.

\subsubsection{Storing}

\emph{No store instructions are required; storing is handled by node related instructions.}

\begin{GrinEncoding}{|ist(i)(rd)(rs)(x)|}
 &
|100 ^ ixx1(i)(0) ^ ixx1(rd)(0) ^ ixx1(rs)(0) ^ ixxjuxt(x)(1)(0)| &
... &
&
\\
\end{GrinEncoding}

\textbf{Semantics}\\

%%[[wrap=code
ist(i)(rd)(rs)(x)
  =  case angle(i) of
       0  ->  *d         :=  s
       1  ->  **d        :=  s
  where  d  <-  case ^^ angle(rd) of
                  t  -> gstack + x
                  r  -> greg + x
         s  <-  case ^^ angle(rs) of
                  t  ->  s = gstack
                         gstack := [gstack]+1
                         *s
                  r  ->  greg
%%]]

\textbf{Abbreviations}\\

%%[[wrap=code
sts d       =   s1tt   d            -- pop tos content into displacement d relative to tos on stack
%%]]

%%]

%%[grinBLoadSrc
  where  s  <-  case ^^ angle(rs) of
                  t  -> gstack + x
                  r  -> greg + x
                  p  -> gpc + x        -- after instruction fetch
                  i  -> x
%%]

%%[grinBLoadSrc2
  where  s  <-  case ^^ angle(rs) of
                  t  -> gstack + xpos
                  r  -> greg + xpos
                  p  -> gpc + xpos        -- after instruction fetch
                  i  -> xpos
%%]

%%[grinBArithmetic

\subsubsection{Immediate constant addition}

\emph{No arithmetic instructions are required; arithmetic is currently handled by primitives.}

\begin{GrinEncoding}{|iaddi(od)(x)|}
 &
|1010 ^ ixxjuxt(od)(1)(0) ^ ixxjuxt(x)(1)(0)| &
... &
&
\\
\end{GrinEncoding}

\subsubsection{General operators}

\emph{No arithmetic instructions are required; arithmetic is currently handled by primitives.}

\begin{GrinEncoding}{|iop(ot)(dt)(i)(od)(rs)(x)|}
 &
|1011 ^ ixxjuxt(ot)(1)(0) ^ ixxjuxt(od)(1)(0)| &
|ixx(dt)(2)(0) ^ ixx1(i)(0) ^ ixxjuxt(rs)(1)(0) ^ ixxjuxt(x)(1)(0)| &
... &
\\
\end{GrinEncoding}

%%]

%%[grinBControl
\subsubsection{Call}

\begin{GrinEncoding}{|icall(rs)|}
 &
|1100 ^^ 000 ^ ixx1(rs)(0)| &
... &
 &
\\
\end{GrinEncoding}

\GriniStep{%
 \GriniStateBefore{%
 }{%
  |call : gcode|
 }{%
  |d : gstack|
 }{%
  |gheap|
 }{
  |greg|
 }
}{%
 \GriniStateAfter{%
 }{%
  |d|
 }{%
  |gcode : gstack|
 }{%
  |gheap|
 }{
  |greg|
 }{}
}


\subsubsection{Tail call}

\begin{GrinEncoding}{|itailcall(rs)(n)(m)(r)|}
 &
|1100 ^^ 001 ^ ixx1(rs)(0)| &
|00 ^ ixxjuxt(n)(1)(0) ^ ixxjuxt(m)(1)(0) ^ ixxjuxt(r)(1)(0)| &
... &
\\
\end{GrinEncoding}

where |n, m, r :: angle(is)|

\GriniStep{%
 \GriniStateBefore{%
 }{%
  |tailcall n m r : _|
 }{%
  |d : a1 : .. : an : .. : Sup(c)(r) : b1 : .. : bm : gstack|
 }{%
  |gheap|
 }{
  |greg|
 }
}{%
 \GriniStateAfter{%
 }{%
  |d|
 }{%
  |Sup(c)(r) : a1 : .. : an : gstack|
 }{%
  |gheap|
 }{
  |greg|
 }{}
}


\subsubsection{Return from call}

\begin{GrinEncoding}{|iretcall(n)(m)(r)|}
 &
|1100 ^^ 0100| &
|00 ^ ixxjuxt(n)(1)(0) ^ ixxjuxt(m)(1)(0) ^ ixxjuxt(r)(1)(0)| &
... &
\\
\end{GrinEncoding}

where |n, m, r :: angle(is)|

\GriniStep{%
 \GriniStateBefore{%
 }{%
  |retcall n m r : _|
 }{%
  |a1 : .. : an : .. : Sup(c)(r) : b1 : .. : bm : gstack|
 }{%
  |gheap|
 }{
  |greg|
 }
}{%
 \GriniStateAfter{%
 }{%
  |Sup(c)(r)|
 }{%
  |a1 : .. : an : gstack|
 }{%
  |gheap|
 }{
  |greg|
 }{}
}


\subsubsection{Return from case}

\begin{GrinEncoding}{|iretcase(n)(r)(c)|}
 &
|1100 ^^ 0101| &
|00 ^ ixxjuxt(n)(1)(0) ^ ixxjuxt(r)(1)(0)| &
|n|, |r|, code location |c| &
... \\
\end{GrinEncoding}

where |n, r:: angle(is)|

\GriniStep{%
 \GriniStateBefore{%
 }{%
  |retcase n r c : _|
 }{%
  |a1 : .. : an : .. : Sub(s)(r) : gstack|
 }{%
  |gheap|
 }{
  |greg|
 }
}{%
 \GriniStateAfter{%
 }{%
  |c|
 }{%
  |a1 : .. : an : Sub(s)(r) : gstack|
 }{%
  |gheap|
 }{
  |greg|
 }{}
}


\subsubsection{Case 'call'}

\begin{GrinEncoding}{|icasecall|}
 &
|1100 ^^ 0110| &
|n| locations &
... &
\\
\end{GrinEncoding}

|n| offsets, each off same size (i.e. nr of bytes) as |n|, relative to |gpc| after each location.
During runtime initialization the offsets are patched to their absolute addresses.
Return is handled by |retcase|.
|n| is omitted from code.

\GriniStep{%
 \GriniStateBefore{%
 }{%
  |casecall n : c1 : .. : cn : _|
 }{%
  |p : gstack|
 }{%
  |[ p :-> (t : f1 : .. : fm) ] `elem` gheap|
 }{
  |greg|
 }
}{%
 \GriniStateAfter{%
 }{%
  |Sub(c)(t)|
 }{%
  |p : gstack|
 }{%
  |gheap|
 }{
  |greg|
 }{}
}

\subsubsection{Call C function}

\begin{GrinEncoding}{|icallc(n)|}
 &
|1100 ^^ 0111| &
|0000 ^^ 00 ^ ixxjuxt(n)(1)(0)| &
... &
\\
\end{GrinEncoding}

\GriniStep{%
 \GriniStateBefore{%
 }{%
  |callc n : gcode|
 }{%
  |f : a1 .. an : gstack|
 }{%
  |gheap|
 }{
  |greg|
 }
}{%
 \GriniStateAfter{%
 }{%
  |gcode|
 }{%
  |(f a1 .. an) : gstack|
 }{%
  |gheap|
 }{
  |greg|
 }{}
}




\subsubsection{Eval}

\begin{GrinEncoding}{|ieval(rs)|}
 &
|1110 ^^ 000 ^ ixx1(rs)(0)| &
 &
 &
\\
\end{GrinEncoding}

A saturated function call closure:

\GriniStep{%
 \GriniStateBefore{%
 }{%
  |evalt : gcode|
 }{%
  |p : gstack|
 }{%
  |[ p :-> (F : f : a1 : .. : an) ] `elem` gheap|
 }{
  |greg|
 }
}{%
 \GriniStateAfter{%
 }{%
  |call : GB_Ins_EvalUpdCont|
 }{%
  |f : a1 : .. : an : gcode : p : gstack|
 }{%
  |gheap|
 }{
  |greg|
 }{}
}

Special case, apply closure:

\GriniStep{%
 \GriniStateBefore{%
 }{%
  |evalt : gcode|
 }{%
  |p : gstack|
 }{%
  |[ p :-> (A : f : a1 .. an) ] `elem` gheap|
 }{
  |greg|
 }
}{%
 \GriniStateAfter{%
 }{%
  |evalt : evappcont|
 }{%
  |f : gcode : p : gstack|
 }{%
  |gheap|
 }{
  |greg|
 }{}
}

An indirection is just followed:

\GriniStep{%
 \GriniStateBefore{%
 }{%
  |evalt : gcode|
 }{%
  |p : gstack|
 }{%
  |[ p :-> (I : p') ] `elem` gheap|
 }{
  |greg|
 }
}{%
 \GriniStateAfter{%
 }{%
  |evalt : gcode|
 }{%
  |p' : gstack|
 }{%
  |gheap|
 }{
  |greg|
 }{}
}

Nodes which require no evaluation are left as is, e.g. constructors and partial applications:

\GriniStep{%
 \GriniStateBefore{%
 }{%
  |evalt : gcode|
 }{%
  |p : gstack|
 }{%
  |[ p :-> (C/P : _) ] `elem` gheap|
 }{
  |greg|
 }
}{%
 \GriniStateAfter{%
 }{%
  |gcode|
 }{%
  |p : gstack|
 }{%
  |gheap|
 }{
  |greg|
 }{}
}


\subsubsection{Eval Update continuation}

\begin{GrinEncoding}{|GB_Ins_EvalUpdCont|}
 &
|1111 ^^ 1101| &
 &
 &
\\
\end{GrinEncoding}

Updating only is done as part of |evalt|, hence is not generated/called directly.

\GriniStep{%
 \GriniStateBefore{%
 }{%
  |GB_Ins_EvalUpdCont : _|
 }{%
  |p' : gcode : p : gstack|
 }{%
  |[p' :-> x] `elem` gheap|
 }{
  |greg|
 }
}{%
 \GriniStateAfter{%
 }{%
  |gcode|
 }{%
  |p' : gstack|
 }{%
  |gheap[ p :-> (x || (I : p')) ]|
 }{
  |greg|
 }{}
}

|p| is updated either with the content of |p'|, if it fits, or an indirection pointer, if it does not fit.
Evaluation follows the indirection.


\subsubsection{Eval Apply continuation}

\begin{GrinEncoding}{|evappcont|}
 &
|1111 ^^ 1010| &
 &
 &
\\
\end{GrinEncoding}

Only is done as part of |evalt|, hence is not generated/called directly.

\GriniStep{%
 \GriniStateBefore{%
 }{%
  |evappcont : _|
 }{%
  |f : gcode : p : gstack|
 }{%
  |[f :-> (P m, _) : _, p :-> (A : f : a1 .. an) ] `elem` gheap|
 }{
  |greg|
 }
}{%
 \GriniStateAfter{%
 }{%
  |applyt : gcode|
 }{%
  |f : n : a1 .. an : gstack|
 }{%
  |gheap|
 }{
  |greg|
 }{}
}



\subsubsection{Tail eval}

\begin{GrinEncoding}{|itaileval(rs)(m)(r)|}
 &
|1110 ^^ 010 ^ ixx1(rs)(0)| &
|0000 ^ ixxjuxt(m)(1)(0) ^ ixxjuxt(r)(1)(0)|  &
... &
\\
\end{GrinEncoding}

\GriniStep{%
 \GriniStateBefore{%
 }{%
  |taileval m r : _|
 }{%
  |p : .. : Sup(c)(r) : b1 : .. : bm : gstack|
 }{%
  |gheap|
 }{
  |greg|
 }
}{%
 \GriniStateAfter{%
 }{%
  |evalt : Sup(c)(r)|
 }{%
  |p : gstack|
 }{%
  |gheap|
 }{
  |greg|
 }{}
}



\subsubsection{Apply}

\begin{GrinEncoding}{|iapply(rs)|}
 &
|1110 ^^ 001 ^ ixx1(rs)(0)| &
 &
 &
\\
\end{GrinEncoding}

When |m<n|, i.e. more parameters |Sub(a)(i)| than are missing:

\GriniStep{%
 \GriniStateBefore{%
 }{%
  |applyt : gcode|
 }{%
  |p : n : a1 .. an : gstack|
 }{%
  |[p :-> (P m, f) : b1 .. bk] `elem` gheap|
 }{
  |greg|
 }
}{%
 \GriniStateAfter{%
 }{%
  |call : papplycont|
 }{%
  |f : b1 .. bk : a1 .. Sub(a)(m) : gcode : (n-m) : Sub(a)(1+m) .. an : gstack|
 }{%
  |gheap|
 }{
  |greg|
 }{}
}

When |m = n|, i.e. exactly the number of missing parameters |Sub(a)(i)|:

\GriniStep{%
 \GriniStateBefore{%
 }{%
  |applyt : gcode|
 }{%
  |p : n : a1 .. an : gstack|
 }{%
  |[p :-> (P m, f) : b1 .. bk] `elem` gheap|
 }{
  |greg|
 }
}{%
 \GriniStateAfter{%
 }{%
  |call : gcode|
 }{%
  |f : b1 .. bk : a1 .. an : gstack|
 }{%
  |gheap|
 }{
  |greg|
 }{}
}

When |m > n|, still missing parameters:

\GriniStep{%
 \GriniStateBefore{%
 }{%
  |applyt : gcode|
 }{%
  |p : n : a1 .. an : gstack|
 }{%
  |[p :-> (P m, f) : b1 .. bk] `elem` gheap|
 }{
  |greg|
 }
}{%
 \GriniStateAfter{%
 }{%
  |gcode|
 }{%
  |p' : gstack|
 }{%
  |gheap[p' :-> (P (m-n), f) : b1 .. bk : a1 .. an]|
 }{
  |greg|
 }{}
}


\subsubsection{Partial Apply continuation}

\begin{GrinEncoding}{|papplycont|}
 &
|1111 ^^ 1011| &
 &
 &
\\
\end{GrinEncoding}

Apply continuation only is done as part of |applyt|, hence is not generated/called directly.
The saved return address of the apply and result are shuffled to be ready for the next apply.

\GriniStep{%
 \GriniStateBefore{%
 }{%
  |papplycont : _|
 }{%
  |p : gcode : n : a1 : .. : an : gstack|
 }{%
  |gheap|
 }{
  |greg|
 }
}{%
 \GriniStateAfter{%
 }{%
  |applyt : gcode|
 }{%
  |p : n : a1 : .. : an : gstack|
 }{%
  |gheap|
 }{
  |greg|
 }{}
}


%%]

%%[grinBStorage
\subsubsection{Alloc}

\emph{No individual |alloc| is required; handled by |allocstore|.}

\begin{GrinEncoding}{|ialloc(rs)|}
 &
|1110 ^^ 100 ^ ixx1(rs)(0)| &
 &
 &
\\
\end{GrinEncoding}

\subsubsection{Store}

\emph{No individual |store| is required; handled by |allocstore|.}

\begin{GrinEncoding}{|istore(rs)|}
 &
|1110 ^^ 101 ^ ixx1(rs)(0)| &
 &
 &
\\
\end{GrinEncoding}

\subsubsection{Alloc + Store}

\begin{GrinEncoding}{|iallocstore(rs)|}
 &
|1110 ^^ 110 ^ ixx1(rs)(0)| &
 &
 &
\\
\end{GrinEncoding}

Size in bytes, including tag.

\GriniStep{%
 \GriniStateBefore{%
 }{%
  |allocstore : gcode|
 }{%
  |s : t : f1 : .. : Sub(f)(s-1) : gstack|
 }{%
  |gheap|
 }{
  |greg|
 }
}{%
 \GriniStateAfter{%
 }{%
  |gcode|
 }{%
  |p : gstack|
 }{%
  |gheap[ p :-> (t : f1 : .. : Sub(f)(s-1)) ]|
 }{
  |greg|
 }{}
}


\subsubsection{Fetch}

\begin{GrinEncoding}{|ifetch(rs)|}
 &
|1110 ^^ 111 ^ ixx1(rs)(0)| &
 &
 &
\\
\end{GrinEncoding}

\GriniStep{%
 \GriniStateBefore{%
 }{%
  |fetcht : gcode|
 }{%
  |p : gstack|
 }{%
  |[ p :-> ((t,s) : f1 : .. : Sub(f)(s-1)) ] `elem` gheap|
 }{
  |greg|
 }
}{%
 \GriniStateAfter{%
 }{%
  |gcode|
 }{%
  |(t,s) : f1 : .. : Sub(f)(s-1) : gstack|
 }{%
  |gheap|
 }{
  |greg|
 }{}
}


\subsubsection{Fetch + Update}

\begin{GrinEncoding}{|fetchupd|}
 &
|1111 ^^ 1001| &
 &
 &
\\
\end{GrinEncoding}

To tie the knot for mutual recursive structures on a non-global level (linking solves this for global mutual references).

\GriniStep{%
 \GriniStateBefore{%
 }{%
  |fetchupd : gcode|
 }{%
  |p' : p : gstack|
 }{%
  |[p :-> (H : _) ] `elem` gheap|
 }{
  |greg|
 }
}{%
 \GriniStateAfter{%
 }{%
  |gcode|
 }{%
  |gstack|
 }{%
  |gheap[p :-> (I : p') ]|
 }{
  |greg|
 }{}
}



%%]

%%[grinBRest

\subsubsection{Nop}

\begin{GrinEncoding}{|nop|}
 &
|1111 ^^ 1111| &
 &
 &
\\
\end{GrinEncoding}


\subsubsection{Extension prefix}

\begin{GrinEncoding}{|xxx|}
 &
|1111 ^^ 1110| &
|ixx(xxx)(7)(0)| &
... &
\\
\end{GrinEncoding}
%%]

%%[grinBExampleTranslations
%%[[wrap=code
; $x2 
    =  {  store (#0/C/$Int 5) ; \$10_0_42_1 ->
            ldc         5
            ldc         #0/C/$Int       ^
            ldc         2
            allocstore                  CSEnv ^ [$10_0_42_1 :-> offset ...]
          $$+ $x1 $10_0_42_1
            ldl         $10_0_42_1
            ldg         $x1
            ldg         $$+
            tailcall    2 0 ..
       }
%%]]

%%[[wrap=code
; $x4 
    =  {    unit $x3 ; \$10_0_55_0 ->
                                                    ^               ^               CSEnv ^ [$10_0_55_0 :-> global $x3]
            eval $10_0_55_0 ; \$1_289_0!__26_0 ->
                                                    ldg             $x3
                                                    evalt
            case $1_289_0!__26_0 of
                                                    casecall        2
                                                    [l3,l1,l2]
                                                l1:
              {  (#0/C/$$: $x__27_2 $1_298_0__27_4)
                                                    fetcht                          CSEnv ^ [$x__27_2, ... :-> offset ...]
                    ->  {    unit $1_298_0__27_4 ; \$10_0_59_0 ->
                             eval $10_0_59_0 ; \$1_298_0!__28_0 ->
                                                    ldl             $10_0_59_0      ^
                                                    evalt
                                                    casecall        2               ^
                                                    [l6,l4,l5]
                             case $1_298_0!__28_0 of
                                                l4:
                               {  (#0/C/$$: $___29_4 $___29_4)
                                                    fetcht                          CSEnv ^ [$___29_4, ... :-> offset ...]
                                     ->  {  unit $undefined ; \$10_0_63_0 ->
                                                    ldg             $undefined
                                            eval $10_0_63_0
                                                    evalt
                                                    retcall         1 1 3           ^
                                         } 
                                                l5:
                               ;  (#1/C/$[])
                                     ->  {  unit $x__27_2 ; \$10_0_65_0 ->
                                                    ldl             $x__27_2
                                            eval $10_0_65_0
                                                    evalt
                                                    retcall         1 1 1
                                         } 
                               }
                                                l6:
                                                    
                                                    retcall         1 1 3
                        }
                                                l2:
              ;  (#1/C/$[])
                    ->  { unit (#0/C/$Int 4)} 
                                                    ldi             4
                                                    ldc             #0/C/$Int
                                                    ldc             2
                                                    allocstore
                                                    retcall         1 1 1
              } 
                                                l3:
                                                    retcall         1 1 1
        } 
%%]]

%%]

%%[oldStuff

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Block copy}

\begin{GrinEncoding}{|icp(i)(rs)(x)|}
 &
|1111 ^ 1110| &
|11 ^ ixxjuxt(i)(1)(0) ^ ixxjuxt(rs)(1)(0) ^ ixxjuxt(x)(1)(0)| &
... &
\\
\end{GrinEncoding}

Is this instruction necessary?

\textbf{Semantics}\\

%%[[wrap=code
icp(i)(rs)(x)
  =  (*(gstack+1))[0..sz-1]  :=  (*(gstack))[0..sz-1]
%%@TopicGrinBytecode.grinBLoadSrc2
         sz <-  case angle(i) of
                  0  ->  s
                  1  ->  *s
                  2  ->  **s
%%]]

Behavior in case of overlap of src/dst is unpredictable.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Sign}

%%[[wrap=code
angle(sg)  =  +  -- positive
           |     -- positive
           |  -  -- negative (2's complement)
%%]]

%%[[wrap=code
+  =  0
-  =  1
%%]]

\subsubsection{Immediate constant}
%%[[wrap=code
angle(c)  =  ci  -- constant in instruction
          |  cf  -- constant following instruction
%%]]

%%[[wrap=code
ci  =  0
cf  =  1
%%]]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Signed int constants are denoted with |x|, unsigned (positive) int constants with |xpos|.

Byte at a time encoding, signed:

\begin{GrinEncoding}{instruction with |x=angle(sg)c|}
|0 <= c < pow2(1) | &
|.. ^ ci ^^ ixx1(c)(0) ..| &
&
&
\\
|- pow2(7) <= c < pow2(7) | &
|.. ^ cf ^^ sg ..| &
|0 ^ ixx(c)(6)(0)| &
&
\\
|- pow2(14) <= c < pow2(14) | &
|.. ^ cf ^^ sg ..| &
|1 ^ ixx(c)(13)(7)| &
|0 ^ ixx(c)(6)(0)| &
\\
|- pow2(21) <= c < pow2(21) | &
|.. ^ cf ^^ sg ..| &
|1 ^ ixx(c)(20)(14)| &
|1 ^ ixx(c)(13)(7)| &
|0 ^ ixx(c)(6)(0)|
\\
etc.
\\
\end{GrinEncoding}

Byte at a time encoding, unsigned:

\begin{GrinEncoding}{instruction with |xpos=c|}
|0 <= c < pow2(1) | &
|.. ^ ci ^^ ixx1(c)(0) ..| &
&
&
\\
|0 <= c < pow2(8) | &
|.. ^ cf ^^ ixx1(c)(7) ..| &
|0 ^ ixx(c)(6)(0)| &
&
\\
|0 <= c < pow2(15) | &
|.. ^ cf ^^ ixx1(c)(14) ..| &
|1 ^ ixx(c)(13)(7)| &
|0 ^ ixx(c)(6)(0)| &
\\
|0 <= c < pow2(22) | &
|.. ^ cf ^^ ixx1(c)(21) ..| &
|1 ^ ixx(c)(20)(14)| &
|1 ^ ixx(c)(13)(7)| &
|0 ^ ixx(c)(6)(0)|
\\
etc.
\\
\end{GrinEncoding}



%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

