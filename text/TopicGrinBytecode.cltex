%%[defs
%format CSBase      = "C"
%format CSGetFld    = "F"
%format CSEnv       = Gamma
%format <<          = "{\llbracket}"
%format >>          = "{\rrbracket}"

%format angle(x)     = "\langle{" x "}\rangle"

%format unit        = "\mathbf{unit}"
%format store        = "\mathbf{store}"
%format ild(i)(rd)(rs)(x)        = "\mathsf{l}\langle{" i "}\rangle\langle{" rd "}\rangle\langle{" rs "}\rangle" ^^ x
%format ist(i)(rd)(rs)(x)       = "\mathsf{s}\langle{" i "}\rangle\langle{" rd "}\rangle\langle{" rs "}\rangle" ^^ x
%format icp(i)(rs)(x)         = "\mathsf{cp}\langle{" i "}\rangle\langle{" rs "}\rangle" ^^ x
%format iop(ot)(dt)(i)(rd)(rs)(x)       = "\mathsf{o}\langle{" ot "}\rangle\langle{" dt "}\rangle\langle{" i "}\rangle\langle{" rd "}\rangle\langle{" rs "}\rangle" ^^ x
%format iaddi(rd)(x)         = "\mathsf{addi}\langle{" rd "}\rangle" ^^ x
%format icall(rs)         = "\mathsf{call}\langle{" rs "}\rangle"
%format itailcall(rs)(n)(m)(r)         = "\mathsf{tailcall}\langle{" rs "}\rangle" ^^ n ^^ m ^^ r
%format iretcall(n)(m)(r)         = "\mathsf{retcall}" ^^ n ^^ m ^^ r
%format icase(n)(c)         = "\mathsf{case}" ^^ n ^^ c
%format ieval(rs)         = "\mathsf{eval}\langle{" rs "}\rangle"
%format iapply(rs)         = "\mathsf{apply}\langle{" rs "}\rangle"
%format ialloc(rs)         = "\mathsf{alloc}\langle{" rs "}\rangle"
%format iallocstore(rs)         = "\mathsf{allocstore}\langle{" rs "}\rangle"
%format istore(rs)         = "\mathsf{store}\langle{" rs "}\rangle"
%format ifetch(rs)         = "\mathsf{fetch}\langle{" rs "}\rangle"
%format tailcall         = "\mathsf{tailcall}"
%format retcall         = "\mathsf{retcall}"
%format call         = "\mathsf{call}"
%format alloc         = "\mathsf{alloc}"
%format stores         = "\mathsf{store}"
%format fetchs         = "\mathsf{fetch}"
%format cases         = "\mathsf{case}"
%format eval         = "\mathsf{eval}"
%format apply         = "\mathsf{apply}"
%format nop         = "\mathsf{nop}"
%format lds         = "\mathsf{lds}"
%format ldc         = "\mathsf{ldc}"
%format lda         = "\mathsf{lda}"
%format l1tt        = "\mathsf{l1tt}"
%format l0ti        = "\mathsf{l0ti}"
%format l0tt        = "\mathsf{l0tt}"
%format sts         = "\mathsf{sts}"
%format s1tt        = "\mathsf{s1tt}"

%format **          = "**"

%format sv          = "s_v"
%format an          = "a_n"
%format cn          = "c_n"
%format bm          = "b_m"
%format fm          = "f_m"

%format xpos        = "x^{+}"
%format Enc(x)      = "\overline{" x "}"
%format Frac(x)(y)  = "\frac{" x "}{" y "}"

%format gcode       = "\textit{is}"
%format gstack      = "\textit{st}"
%format gheap       = "\textit{hp}"
%format greg        = "\textit{r}"
%format gpc         = "\textit{pc}"

%format (ixx1(x)(f))    = x "_{" f "}"
%format (ixx(x)(f)(t))  = x "_{" f "} .. " x "_{" t "}"
%format (ixxjuxt(x)(f)(t))  = x "_{" f "}" x "_{" t "}"
%format (pow2(p))   = "2^{" p "}"

\newenvironment{GrinCS}{%
\begin{tabular}{p{.35\linewidth}@@{\hspace{.5ex}=\hspace{.5ex}}p{.45\linewidth}}
}{%
\end{tabular}
}

\newcommand{\GriniStateBefore}[5]{%
#1 &
#2 &
#3 &
#4 &
#5
}

\newcommand{\GriniStateAfter}[5]{%
$\Longrightarrow$ &
#2 &
#3 &
#4 &
#5
}

\newcommand{\GriniStep}[2]{%
\begin{tabular}{lllll}
\hline
& Code & Stack & Heap & Reg \\
\hline
#1 \\ #2 \\
\hline
\end{tabular}
}

\newenvironment{GrinEncoding}[1]{%
\begin{tabular}{lllll}
\hline
#1 & byte 0 & byte 1 & byte 2 & byte 3 \\
\hline
}{%
\hline
\end{tabular}
}

%%]

%%[grin2GrinB
\begin{GrinCS}
|CSBase<< unit v ; \w -> e >> CSEnv|
&
|CSBase<< e >> ^^ CSEnv ^ [w :-> CSEnv v]| 
\end{GrinCS}

\begin{GrinCS}
|CSBase<< unit v ; \(C ^^ Vec(w)) -> e >> CSEnv|
&
|Vec(lds v : lda o) : CSBase<< e >> ^^ CSEnv ^ Vec([w :-> gstack])| 
\end{GrinCS}

\begin{GrinCS}
|CSBase<< unit (C ^^ Vec(v)) ; \(C ^^ Vec(w)) -> e >> CSEnv|
&
|CSBase<< e >> ^^ CSEnv ^ Vec([w :-> CSEnv v])| 
\end{GrinCS}

\begin{GrinCS}
|CSBase<< store (C ^^ Vec(v)) ; \w -> e >> CSEnv|
&
|alloc ||Vec(v)|| : CSBase<< e >> ^^ CSEnv ^ [w :-> gstack]| 
\end{GrinCS}

%%]

%%[grinBSemantics

\subsection{Memory model and module admin}

\Paragraph{Stack}
Stack, indexed by |gstack|, grows downwards/
Positive offsets are used to refer to values in allocated part of stack.

\Paragraph{Registers}
Registers: programcounter |gpc|, general purpose register |greg|.

\Paragraph{Nodes and tagging}
Node representation: size (16 bits), tag (16 bits), fields (3x), extension ptr (1x)

Tagged data. Pointer values have lower 2 bits set to 0, direct (non pointer) values have these bits set to a non zero tag.
For signed ints |x| in the range |- pow2(29) <= x < pow2(29)|, |30| bits are used, with the following encoding |Enc(x)|.
The encoding consists of a shift left with |sh| positions (notated as a shift |<< s| or multiplication |* pow2(s)|), and addition of tag |t|.
For now, |sh = 1 (s = pow2(1)), t = 1| would suffice.

\Paragraph{Int encoding}
Int's are tagged values:
%%[[wrap=code
Enc(x)          =   x * s + t
Enc(x1+x2)      =   (x1+x2) * s + t
                =   x1 * s + t + x2 * s + t - t
                =   Enc(x1) + Enc(x2) - t
Enc(x1-x2)      =   (x1-x2) * s + t
                =   x1 * s + t - x2 * s - t + t
                =   Enc(x1) - Enc(x2) + t
Enc(x1*x2)      =   (x1*x2) * s + t
                =   (x1 * s) * (x2 * s) / s + t
                =   (x1 * s + t - t) * (x2 * s + t - t) / s + t         ^
                =   (Enc(x1) - t) * (Enc(x2) - t) / s + t
                =   (Enc(x1) - t) * (Enc(x2) / s) + t                   ^ -- t/s shifts out
Enc(x1/x2)      =   (x1/x2) * s + t
                =   Frac(x1 * s)(x2 * s) * s + t
                =   Frac(x1 * s + t - t)(x2 * s + t - t) * s + t
                =   Frac(Enc(x1) - t)(Enc(x2) - t) * s + t
                =   Frac(Enc(x1) - t)(Enc(x2) / s - t / s) + t
                =   Frac(Enc(x1) - t)(Enc(x2) / s) + t                  ^ -- t/s shifts out
%%]]

\Paragraph{Strings}
String constants are stored in a separate table, to be referred to by |ldg|.

\Paragraph{Modules}
Incoming and outgoing references need to be resolved during initialization time with the help of some tables
\begin{itemize}
\item
  Imported modules, mapping module names to global module numbers assigned during linking time.
\item
\end{itemize}

\Paragraph{Initialization}
Initialization takes places in the following order, possible referring to module |angle(m)|.
\begin{itemize}
\item
  Stack, heap are set up.
\item
  Resolve imported modules for |angle(m)|.
  Each |angle(m)| is assigned a unique number, also referred to as |angle(m)|.
\item
  Each module |angle(m)| initializes itself, via a call to function |angle(m)_initialize|.
\item
  Resolve exported entrypoints for |angle(m)| (is this necessary?).
\end{itemize}

\Paragraph{Table summary}
The following tables are used, |angle(m)| is the module nr, starting at |1|, global tables have module nr |0|.
Format is |table : table nr :: functionality :: actual C encoding|.

%%[[wrap=code
bytecode                :   angle(m).0  ::  PC -> Instr             ::  Instr[]                 -- per module
strings                 :   angle(m).1  ::  Offset -> String        ::  char[][]                -- per module
imported modules        :   angle(m).2  ::  ModNm -> Module         ::  Node[]                  -- per module, filled at link time
exported entrypoints    :   angle(m).3  ::  Module                  ::  PC[]                    -- mem locations, filled at link time
CAF entrypoints         :   angle(m).4  ::  PC                      ::  PC[]                    -- mem locations, filled at link time
all modules             :   0.0         ::  ModNm -> Module         ::  Node[]                  -- 
CAF                     :   0.1         ::
%%]]

%%]

%%[grinBMetavarEncoding
\subsubsection{Load source, store destination}
\begin{code}
angle(rd), angle(rs)  =  i  -- immediate constant
                      |  p  -- program counter relative
                      |  t  -- top of stack relative
                      |  r  -- scratch register relative
\end{code}

\begin{code}
t  =  00
r  =  01
i  =  10
p  =  11
\end{code}

Store destinations can only be |s| or |r|, hence the encoding omits the most significant bit in store instructions.

\subsubsection{Load destination, store source}
\begin{code}
angle(rd), angle(rs)  =  t  -- top of stack, with push/pop side effect
                      |  r  -- scratch register
\end{code}

\begin{code}
t  =  0
r  =  1
\end{code}

\subsubsection{Operator destination}
\begin{code}
angle(od)  =  t  -- top of stack, with push/pop side effect
           |  r  -- scratch register
           |  s  -- stack pointer register
           |  p  -- program counter register
\end{code}

\begin{code}
t  =  00
r  =  01
s  =  10
p  =  11
\end{code}

\subsubsection{Operator type}
\begin{code}
angle(ot)  =  a  -- add
           |  s  -- subtract
           |  m  -- multiply
           |  d  -- divide+modulo
\end{code}

\begin{code}
a  =  00
s  =  01
m  =  10
d  =  11
\end{code}

\subsubsection{Data type}
\begin{code}
angle(dt)  =  i1  -- 32bits int
           |  i2  -- 64bits int
           |  f1  -- 32bits float
           |  f2  -- 64bits float
\end{code}

\begin{code}
i1  =  00
i2  =  01
f1  =  10
f2  =  11
\end{code}

\subsubsection{Immediate signed int constant size}
\begin{code}
angle(is)  =  08, b  -- byte, 8 bits
           |  16, s  -- short, 16 bits
           |  32, w  -- word, 32 bits
           |  64, d  -- double, 64 bits
\end{code}

\begin{code}
08, b  =  00
16, s  =  01
32, w  =  10
64, d  =  11
\end{code}

\subsubsection{Sign}

\begin{code}
angle(sg)  =  +  -- positive
           |     -- positive
           |  -  -- negative (2's complement)
\end{code}

\begin{code}
+  =  0
-  =  1
\end{code}

\subsubsection{Immediate constant}
\begin{code}
angle(c)  =  ci  -- constant in instruction
          |  cf  -- constant following instruction
\end{code}

\begin{code}
ci  =  0
cf  =  1
\end{code}

\subsubsection{Indirection level}
\begin{code}
angle(i)  =  0  -- as is, use itself (don't follow as address)
          |  1  -- use content pointed to (do follow as address)
          |  2  -- and another time
\end{code}

Level 0 is only used for a source, in that case encoding equals the encoding for |i - 1|.

A level 3 represents a variation on level 0 with an implicit conversion int encoding |Enc(x)|.

\subsubsection{Instruction prefixes/categories}
\begin{code}
0           loading
100         storing
101         arithmetic
1100  0     calling, case
1101
1110  0     eval/apply
1110  1     node alloc/fetch
1111  0
1111  110   extension prefix
\end{code}

\subsubsection{Misc notation}

In the context of evaluation steps:

%%[[wrap=code
Sup(c)(r)       --  value c at offset r from top of stack
%%]]

%%]

%%[grinBConstants
Signed int constants are denoted with |x|, unsigned (positive) int constants with |xpos|.

Byte at a time encoding, signed:

\begin{GrinEncoding}{instruction with |x=angle(sg)c|}
|0 <= c < pow2(1) | &
|.. ^ ci ^^ ixx1(c)(0) ..| &
&
&
\\
|- pow2(7) <= c < pow2(7) | &
|.. ^ cf ^^ sg ..| &
|0 ^ ixx(c)(6)(0)| &
&
\\
|- pow2(14) <= c < pow2(14) | &
|.. ^ cf ^^ sg ..| &
|1 ^ ixx(c)(13)(7)| &
|0 ^ ixx(c)(6)(0)| &
\\
|- pow2(21) <= c < pow2(21) | &
|.. ^ cf ^^ sg ..| &
|1 ^ ixx(c)(20)(14)| &
|1 ^ ixx(c)(13)(7)| &
|0 ^ ixx(c)(6)(0)|
\\
etc.
\\
\end{GrinEncoding}

Byte at a time encoding, unsigned:

\begin{GrinEncoding}{instruction with |xpos=c|}
|0 <= c < pow2(1) | &
|.. ^ ci ^^ ixx1(c)(0) ..| &
&
&
\\
|0 <= c < pow2(8) | &
|.. ^ cf ^^ ixx1(c)(7) ..| &
|0 ^ ixx(c)(6)(0)| &
&
\\
|0 <= c < pow2(15) | &
|.. ^ cf ^^ ixx1(c)(14) ..| &
|1 ^ ixx(c)(13)(7)| &
|0 ^ ixx(c)(6)(0)| &
\\
|0 <= c < pow2(22) | &
|.. ^ cf ^^ ixx1(c)(21) ..| &
|1 ^ ixx(c)(20)(14)| &
|1 ^ ixx(c)(13)(7)| &
|0 ^ ixx(c)(6)(0)|
\\
etc.
\\
\end{GrinEncoding}

Byte/short/word/double encoding, signed, little endian:

\begin{GrinEncoding}{instruction with |x=c|}
|- pow2(7) <= c < pow2(7), angle(is) = b | &
|.. ^ ixxjuxt(is)(1)(0) ..| &
|ixx(c)(7)(0)| &
&
\\
|- pow2(15) <= c < pow2(15), angle(is) = s | &
|.. ^ ixxjuxt(is)(1)(0) ..| &
|ixx(c)(7)(0)| &
|ixx(c)(15)(8)| &
\\
etc.
\\
\end{GrinEncoding}

Whenever a constant |x| is referred to from the instruction encoding,
its two bits |ixxjuxt(x)(1)(0)| refer to the above encoded size information.

Big vs little endian:
\begin{itemize}
\item In memory: take host platform endianness
\item In a file, in a persistent format (not under further consideration here): take any, probably little endian as the Intel platform is quite dominant.
\end{itemize}

%%]

%%[grinBMovingData

\subsubsection{Loading}

\begin{GrinEncoding}{|ild(i)(rd)(rs)(x)|}
 &
|0 ^ ixxjuxt(i)(1)(0) ^ ixx1(rd)(0) ^ ixxjuxt(rs)(1)(0) ^ ixxjuxt(x)(1)(0)| &
... &
&
\\
\end{GrinEncoding}

\textbf{Semantics}\\

%%[[wrap=code
ild(i)(rd)(rs)(x)
  =  case angle(i) of
       0  ->  d  :=  s
       1  ->  d  :=  *s
       2  ->  d  :=  **s
       3  ->  d  :=  Enc(s)
%%@TopicGrinBytecode.grinBLoadSrc
         d  <-  case ^^ angle(rd) of
                  t  ->  gstack := [gstack]-1
                         *(gstack + x)
                  r  ->  greg
%%]]

\textbf{Abbreviations}\\

%%[[wrap=code
lds d       =   l1tt  d            -- push content displacement d relative to tos on stack
ldc c       =   l0ti  c            -- push constant c on stack
lda d       =   l0tt  d            -- push address displacement d relative to tos on stack
%%]]

\textbf{|lds|: load from stack}\\

\GriniStep{%
 \GriniStateBefore{%
 }{%
  |lds v : gcode|
 }{%
  |s0 : ... : sv : gstack|
 }{%
  |gheap|
 }{
  |greg|
 }
}{%
 \GriniStateAfter{%
 }{%
  |gcode|
 }{%
  |sv : s0 : ... : sv : gstack|
 }{%
  |gheap|
 }{
  |greg|
 }{}
}

\subsubsection{Storing}

\begin{GrinEncoding}{|ist(i)(rd)(rs)(x)|}
 &
|100 ^ ixx1(i)(0) ^ ixx1(rd)(0) ^ ixx1(rs)(0) ^ ixxjuxt(x)(1)(0)| &
... &
&
\\
\end{GrinEncoding}

\textbf{Semantics}\\

%%[[wrap=code
ist(i)(rd)(rs)(x)
  =  case angle(i) of
       0  ->  *d         :=  s
       1  ->  **d        :=  s
  where  d  <-  case ^^ angle(rd) of
                  t  -> gstack + x
                  r  -> greg + x
         s  <-  case ^^ angle(rs) of
                  t  ->  s = gstack
                         gstack := [gstack]+1
                         *s
                  r  ->  greg
%%]]

\textbf{Abbreviations}\\

%%[[wrap=code
sts d       =   s1tt   d            -- pop tos content into displacement d relative to tos on stack
%%]]

\subsubsection{Block copy}

\begin{GrinEncoding}{|icp(i)(rs)(x)|}
 &
|1111 ^ 1110| &
|11 ^ ixxjuxt(i)(1)(0) ^ ixxjuxt(rs)(1)(0) ^ ixxjuxt(x)(1)(0)| &
... &
\\
\end{GrinEncoding}

Is this instruction necessary?

\textbf{Semantics}\\

%%[[wrap=code
icp(i)(rs)(x)
  =  (*(gstack+1))[0..sz-1]  :=  (*(gstack))[0..sz-1]
%%@TopicGrinBytecode.grinBLoadSrc2
         sz <-  case angle(i) of
                  0  ->  s
                  1  ->  *s
                  2  ->  **s
%%]]

Behavior in case of overlap of src/dst is unpredictable.

%%]

%%[grinBLoadSrc
  where  s  <-  case ^^ angle(rs) of
                  t  -> gstack + x
                  r  -> greg + x
                  p  -> gpc + x        -- after instruction fetch
                  i  -> x
%%]

%%[grinBLoadSrc2
  where  s  <-  case ^^ angle(rs) of
                  t  -> gstack + xpos
                  r  -> greg + xpos
                  p  -> gpc + xpos        -- after instruction fetch
                  i  -> xpos
%%]

%%[grinBArithmetic

\subsubsection{Immediate constant addition}

\begin{GrinEncoding}{|iaddi(od)(x)|}
 &
|1010 ^ ixxjuxt(od)(1)(0) ^ ixxjuxt(x)(1)(0)| &
... &
&
\\
\end{GrinEncoding}

\subsubsection{General operators}

\begin{GrinEncoding}{|iop(ot)(dt)(i)(od)(rs)(x)|}
 &
|1011 ^ ixxjuxt(ot)(1)(0) ^ ixxjuxt(od)(1)(0)| &
|ixx(dt)(2)(0) ^ ixx1(i)(0) ^ ixxjuxt(rs)(1)(0) ^ ixxjuxt(x)(1)(0)| &
... &
\\
\end{GrinEncoding}

\textbf{Semantics}\\

%%[[wrap=code
iop(ot)(dt)(i)(rd)(rs)(x)
  =  
%%]]

\textbf{Abbreviations}\\

%%[[wrap=code
addi        =   oaiss  0         -- on tos addition
%%]]

%%]

%%[grinBControl
\subsubsection{Call}

\begin{GrinEncoding}{|icall(rs)|}
 &
|1100 ^^ 000 ^ ixx1(rs)(0)| &
... &
 &
\\
\end{GrinEncoding}

\GriniStep{%
 \GriniStateBefore{%
 }{%
  |call : gcode|
 }{%
  |d : gstack|
 }{%
  |gheap|
 }{
  |greg|
 }
}{%
 \GriniStateAfter{%
 }{%
  |d|
 }{%
  |gcode : gstack|
 }{%
  |gheap|
 }{
  |greg|
 }{}
}


\subsubsection{Tail call}

\begin{GrinEncoding}{|itailcall(rs)(n)(m)(r)|}
 &
|1100 ^^ 001 ^ ixx1(rs)(0)| &
|00 ^ ixxjuxt(n)(1)(0) ^ ixxjuxt(m)(1)(0) ^ ixxjuxt(r)(1)(0)| &
... &
\\
\end{GrinEncoding}

where |n, m, r :: angle(is)|

\GriniStep{%
 \GriniStateBefore{%
 }{%
  |tailcall n m r : _|
 }{%
  |d : a1 : .. : an : .. : Sup(c)(r) : b1 : .. : bm : gstack|
 }{%
  |gheap|
 }{
  |greg|
 }
}{%
 \GriniStateAfter{%
 }{%
  |d|
 }{%
  |c : a1 : .. : an : gstack|
 }{%
  |gheap|
 }{
  |greg|
 }{}
}


\subsubsection{Return from call}

\begin{GrinEncoding}{|iretcall(n)(m)(r)|}
 &
|1100 ^^ 0100| &
|00 ^ ixxjuxt(n)(1)(0) ^ ixxjuxt(m)(1)(0) ^ ixxjuxt(r)(1)(0)| &
... &
\\
\end{GrinEncoding}

where |n, m, r :: angle(is)|

\GriniStep{%
 \GriniStateBefore{%
 }{%
  |retcall n m r : _|
 }{%
  |a1 : .. : an : .. : Sup(c)(r) : b1 : .. : bm : gstack|
 }{%
  |gheap|
 }{
  |greg|
 }
}{%
 \GriniStateAfter{%
 }{%
  |c|
 }{%
  |a1 : .. : an : gstack|
 }{%
  |gheap|
 }{
  |greg|
 }{}
}


\subsubsection{Case 'call'}

\begin{GrinEncoding}{|icase(n)(c)|}
 &
|1100 ^^ 011 ^ ixx1(rs)(0)| &
|0000 ^ ixxjuxt(n)(1)(0) ^ ixxjuxt(c)(1)(0)| &
... + |n| offsets &
\\
\end{GrinEncoding}

|n| offsets, each off same size (i.e. nr of bytes) as |n|, relative to |gpc| after end of offset table.

\GriniStep{%
 \GriniStateBefore{%
 }{%
  |case n c : c1 : .. : cn : .. : c|
 }{%
  |p : gstack|
 }{%
  |[ p :-> (t : f1 : .. : fm) ] `elem` gheap|
 }{
  |greg|
 }
}{%
 \GriniStateAfter{%
 }{%
  |Sub(c)(t)|
 }{%
  |c : p : gstack|
 }{%
  |gheap|
 }{
  |greg|
 }{}
}



\subsubsection{Eval}

\begin{GrinEncoding}{|ieval(rs)|}
 &
|1110 ^^ 001 ^ ixx1(rs)(0)| &
 &
 &
\\
\end{GrinEncoding}

\subsubsection{Apply}

\begin{GrinEncoding}{|iapply(rs)|}
 &
|1110 ^^ 010 ^ ixx1(rs)(0)| &
 &
 &
\\
\end{GrinEncoding}

\subsubsection{Nop}

\begin{GrinEncoding}{|nop|}
 &
|1111 ^^ 1111| &
 &
 &
\\
\end{GrinEncoding}
%%]

%%[grinBStorage
\subsubsection{Alloc}

\begin{GrinEncoding}{|ialloc(rs)|}
 &
|1110 ^^ 100 ^ ixx1(rs)(0)| &
 &
 &
\\
\end{GrinEncoding}

\subsubsection{Store}

\begin{GrinEncoding}{|istore(rs)|}
 &
|1110 ^^ 101 ^ ixx1(rs)(0)| &
 &
 &
\\
\end{GrinEncoding}

\subsubsection{Alloc + Store}

\begin{GrinEncoding}{|iallocstore(rs)|}
 &
|1110 ^^ 110 ^ ixx1(rs)(0)| &
 &
 &
\\
\end{GrinEncoding}

\subsubsection{Fetch}

\begin{GrinEncoding}{|ifetch(rs)|}
 &
|1110 ^^ 111 ^ ixx1(rs)(0)| &
 &
 &
\\
\end{GrinEncoding}

%%]

%%[grinBRest
\subsubsection{Extension prefix}

\begin{GrinEncoding}{|xxx|}
 &
|1111 ^^ 1110| &
|ixx(xxx)(7)(0)| &
... &
\\
\end{GrinEncoding}
%%]

%%[grinBExampleTranslations
%%[[wrap=code
; $x2 
    =  {  store (#0/C/$Int 5) ; \$10_0_42_1 ->
            ldc         5
            ldc         #0/C/$Int       ^
            ldc         2
            allocstore                  CSEnv ^ [$10_0_42_1 :-> offset ...]
          $$+ $x1 $10_0_42_1
            lds         $10_0_42_1
            ldg         $x1
            ldg         $$+
            tailcall    2 0 ..
       }
%%]]

%%[[wrap=code
; $x4 
    =  {    unit $x3 ; \$10_0_55_0 ->
                                                    ^               ^               CSEnv ^ [$10_0_55_0 :-> global $x3]
            eval $10_0_55_0 ; \$1_289_0!__26_0 ->
                                                    ldg             $x3
                                                    eval
            case $1_289_0!__26_0 of
                                                    cases           2 l3
                                                    [l1,l2]
                                                l1:
              {  (#0/C/$$: $x__27_2 $1_298_0__27_4)
                                                    fetchs          2               CSEnv ^ [$x__27_2, ... :-> offset ...]
                    ->  {    unit $1_298_0__27_4 ; \$10_0_59_0 ->
                             eval $10_0_59_0 ; \$1_298_0!__28_0 ->
                                                    lds             $10_0_59_0      ^
                                                    eval
                                                    cases           2 l6            ^
                                                    [l4,l5]
                             case $1_298_0!__28_0 of
                                                l4:
                               {  (#0/C/$$: $___29_4 $___29_4)
                                                    fetchs          2               CSEnv ^ [$___29_4, ... :-> offset ...]
                                     ->  {  unit $undefined ; \$10_0_63_0 ->
                                                    ldg             $undefined
                                            eval $10_0_63_0
                                                    eval
                                                    retcall         1 1 3           ^
                                         } 
                                                l5:
                               ;  (#1/C/$[])
                                     ->  {  unit $x__27_2 ; \$10_0_65_0 ->
                                                    lds             $x__27_2
                                            eval $10_0_65_0
                                                    eval
                                                    retcall         1 1 1
                                         } 
                               }
                                                l6:
                                                    
                                                    retcall         1 1 3
                        }
                                                l2:
              ;  (#1/C/$[])
                    ->  { unit (#0/C/$Int 4)} 
                                                    ldc             4
                                                    ldc             #0/C/$Int
                                                    allocstore      2
                                                    retcall         1 1 1
              } 
                                                l3:
                                                    retcall         1 1 1
        } 
%%]]

%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

