%%[defs
%format CSBase      = "C"
%format CSGetFld    = "F"
%format CSEnv       = Gamma
%format <<          = "{\llbracket}"
%format >>          = "{\rrbracket}"

%format angle(x)     = "\langle{" x "}\rangle"

%format unit        = "\mathbf{unit}"
%format store        = "\mathbf{store}"
%format ild(i)(rd)(rs)(x)        = "\mathsf{l}\langle{" i "}\rangle\langle{" rd "}\rangle\langle{" rs "}\rangle" ^^ x
%format ist(i)(rd)(rs)(x)       = "\mathsf{s}\langle{" i "}\rangle\langle{" rd "}\rangle\langle{" rs "}\rangle" ^^ x
%format icp(i)(rs)(x)         = "\mathsf{cp}\langle{" i "}\rangle\langle{" rs "}\rangle" ^^ x
%format iop(ot)(dt)(i)(rd)(rs)(x)       = "\mathsf{o}\langle{" ot "}\rangle\langle{" dt "}\rangle\langle{" i "}\rangle\langle{" rd "}\rangle\langle{" rs "}\rangle" ^^ x
%format iaddi(rd)(x)         = "\mathsf{addi}\langle{" rd "}\rangle" ^^ x
%format icall(rs)         = "\mathsf{call}\langle{" rs "}\rangle"
%format itailcall(rs)(n)(m)(r)         = "\mathsf{tailcall}\langle{" rs "}\rangle" ^^ n ^^ m ^^ r
%format ildg(m)(t)(o)         = "\mathsf{ldg}" ^^ m ^^ t ^^ o
%format iretcall(n)(m)(r)         = "\mathsf{retcall}" ^^ n ^^ m ^^ r
%format iretcase(n)(r)(c)         = "\mathsf{retcase}" ^^ n ^^ r ^^ c
%format icasecall(n)         = "\mathsf{casecall}" ^^ n
%format ieval(rs)         = "\mathsf{eval}\langle{" rs "}\rangle"
%format iapply(rs)         = "\mathsf{apply}\langle{" rs "}\rangle"
%format ialloc(rs)         = "\mathsf{alloc}\langle{" rs "}\rangle"
%format iallocstore(rs)         = "\mathsf{allocstore}\langle{" rs "}\rangle"
%format istore(rs)         = "\mathsf{store}\langle{" rs "}\rangle"
%format ifetch(rs)         = "\mathsf{fetch}\langle{" rs "}\rangle"
%format tailcall         = "\mathsf{tailcall}"
%format retcall         = "\mathsf{retcall}"
%format retcase         = "\mathsf{retcase}"
%format call         = "\mathsf{call}"
%format alloc         = "\mathsf{alloc}"
%format stores         = "\mathsf{store}"
%format allocstore         = "\mathsf{allocstore}"
%format fetchs         = "\mathsf{fetch}"
%format casecall         = "\mathsf{casecall}"
%format eval         = "\mathsf{eval}"
%format apply         = "\mathsf{apply}"
%format nop         = "\mathsf{nop}"
%format ldl         = "\mathsf{ldl}"
%format ldc         = "\mathsf{ldc}"
%format ldi         = "\mathsf{ldi}"
%format ldg         = "\mathsf{ldg}"
%format l1tt        = "\mathsf{l1tt}"
%format l0ti        = "\mathsf{l0ti}"
%format l0tt        = "\mathsf{l0tt}"
%format sts         = "\mathsf{sts}"
%format s1tt        = "\mathsf{s1tt}"

%format **          = "**"

%format sv          = "s_v"
%format an          = "a_n"
%format cn          = "c_n"
%format bm          = "b_m"
%format fm          = "f_m"

%format xpos        = "x^{+}"
%format Enc(x)      = "\overline{" x "}"
%format Frac(x)(y)  = "\frac{" x "}{" y "}"

%format gcode       = "\textit{is}"
%format gstack      = "\textit{st}"
%format gheap       = "\textit{hp}"
%format greg        = "\textit{r}"
%format gpc         = "\textit{pc}"

%format (ixx1(x)(f))    = x "_{" f "}"
%format (ixx(x)(f)(t))  = x "_{" f "} .. " x "_{" t "}"
%format (ixxjuxt(x)(f)(t))  = x "_{" f "}" x "_{" t "}"
%format (pow2(p))   = "2^{" p "}"

\newenvironment{GrinCS}{%
\begin{tabular}{p{.35\linewidth}@@{\hspace{.5ex}=\hspace{.5ex}}p{.45\linewidth}}
}{%
\end{tabular}
}

\newcommand{\GriniStateBefore}[5]{%
#1 &
#2 &
#3 &
#4 &
#5
}

\newcommand{\GriniStateAfter}[5]{%
$\Longrightarrow$ &
#2 &
#3 &
#4 &
#5
}

\newcommand{\GriniStep}[2]{%
\begin{tabular}{lllll}
\hline
& Code & Stack & Heap & Reg \\
\hline
#1 \\ #2 \\
\hline
\end{tabular}
}

\newenvironment{GrinEncoding}[1]{%
\begin{tabular}{lllll}
\hline
#1 & byte 0 & byte 1 & byte 2 & byte 3 \\
\hline
}{%
\hline
\end{tabular}
}

%%]

%%[grin2GrinB
\begin{GrinCS}
|CSBase<< unit v ; \w -> e >> CSEnv|
&
|CSBase<< e >> ^^ CSEnv ^ [w :-> CSEnv v]| 
\end{GrinCS}

\begin{GrinCS}
|CSBase<< unit v ; \(C ^^ Vec(w)) -> e >> CSEnv|
&
|Vec(ldl v : lda o) : CSBase<< e >> ^^ CSEnv ^ Vec([w :-> gstack])| 
\end{GrinCS}

\begin{GrinCS}
|CSBase<< unit (C ^^ Vec(v)) ; \(C ^^ Vec(w)) -> e >> CSEnv|
&
|CSBase<< e >> ^^ CSEnv ^ Vec([w :-> CSEnv v])| 
\end{GrinCS}

\begin{GrinCS}
|CSBase<< store (C ^^ Vec(v)) ; \w -> e >> CSEnv|
&
|alloc ||Vec(v)|| : CSBase<< e >> ^^ CSEnv ^ [w :-> gstack]| 
\end{GrinCS}

%%]

%%[grinBSemantics

\subsection{Memory model and module admin}

\Paragraph{Offsets in instructions}
All offset relative to registers are in bytes, that is, already take size of word into account.
Together with hardcoded endianness this makes the bytecode representation not platform independent,
but execution speed should be better.

\Paragraph{Stack}
Stack, indexed by |gstack|, grows downwards/
Positive offsets are used to refer to values in allocated part of stack.

\Paragraph{Registers}
Registers: programcounter |gpc|, general purpose register |greg|.

\Paragraph{Nodes and tagging}
Node representation: header (1 word) + content (nr of field words)

Node header should (for now) fit in 32 bits, 64 bits sizes under consideration:
%%[[wrap=code
size            16  bits                                -- nr of words, incl header
needsEval       1   bit                                 -- 1 == possibly needs eval
tagCateg        2   bits                                -- eval == 0: {C,P}, eval == 1: {F,A,I,B}
tag             13  bits                                -- also used for size info for P, A
%%]]

Tag categories:
%%[[wrap=code
F               00              -- function closure
A               01              -- general application
I               10              -- indirection
B               11              -- black hole

C               00              -- constructor
P               01              -- partial app
%%]]

Tagged data. Pointer values have lower 2 bits set to 0, direct (non pointer) values have these bits set to a non zero tag.
For signed ints |x| in the range |- pow2(29) <= x < pow2(29)|, |30| bits are used, with the following encoding |Enc(x)|.
The encoding consists of a shift left with |sh| positions (notated as a shift |<< s| or multiplication |* pow2(s)|), and addition of tag |t|.
For now, |sh = 1 (s = pow2(1)), t = 1| would suffice.

\Paragraph{Int encoding}
Int's are tagged values:
%%[[wrap=code
Enc(x)          =   x * s + t
Enc(x1+x2)      =   (x1+x2) * s + t
                =   x1 * s + t + x2 * s + t - t
                =   Enc(x1) + Enc(x2) - t
Enc(x1-x2)      =   (x1-x2) * s + t
                =   x1 * s + t - x2 * s - t + t
                =   Enc(x1) - Enc(x2) + t
Enc(x1*x2)      =   (x1*x2) * s + t
                =   (x1 * s) * (x2 * s) / s + t
                =   (x1 * s + t - t) * (x2 * s + t - t) / s + t         ^
                =   (Enc(x1) - t) * (Enc(x2) - t) / s + t
                =   (Enc(x1) - t) * (Enc(x2) / s) + t                   ^ -- t/s shifts out
Enc(x1/x2)      =   (x1/x2) * s + t
                =   Frac(x1 * s)(x2 * s) * s + t
                =   Frac(x1 * s + t - t)(x2 * s + t - t) * s + t
                =   Frac(Enc(x1) - t)(Enc(x2) - t) * s + t
                =   Frac(Enc(x1) - t)(Enc(x2) / s - t / s) + t
                =   Frac(Enc(x1) - t)(Enc(x2) / s) + t                  ^ -- t/s shifts out
%%]]

\Paragraph{Strings}
String constants are stored in a separate table, to be referred to by |ldg|.

\Paragraph{Modules}
Incoming and outgoing references need to be resolved during initialization time with the help of some tables
\begin{itemize}
\item
  Imported modules, mapping module names to global module numbers assigned during linking time.
\item
\end{itemize}

\Paragraph{Initialization}
Initialization takes places in the following order, possible referring to module |angle(m)|.
\begin{itemize}
\item
  Stack, heap are set up.
\item
  Resolve imported modules for |angle(m)|.
  Each |angle(m)| is assigned a unique number, also referred to as |angle(m)|.
\item
  Each module |angle(m)| initializes itself, via a call to function |angle(m)_initialize|.
\item
  Resolve exported entrypoints for |angle(m)| (is this necessary?).
\end{itemize}

\Paragraph{Table summary}
The following tables are used, |angle(m)| is the module nr, starting at |1|, global tables have module nr |0|.
Format is |table : table nr :: functionality :: actual C encoding|.

%%[[wrap=code
bytecode                :   angle(m).0  ::  PC -> Instr             ::  Instr[]                 -- per module
strings                 :   angle(m).1  ::  Offset -> String        ::  char[][]                -- per module
imported modules        :   angle(m).2  ::  ModNm -> Module         ::  Node[]                  -- per module, filled at link time
exported entrypoints    :   angle(m).3  ::  Module                  ::  PC[]                    -- mem locations, filled at link time
CAF entrypoints         :   angle(m).4  ::  PC                      ::  PC[]                    -- mem locations, filled at link time
all modules             :   0.0         ::  ModNm -> Module         ::  Node[]                  -- 
CAF                     :   0.1         ::
%%]]

%%]

%%[grinBMetavarEncoding
\subsubsection{Load source, store destination: extended variant}
%%[[wrap=code
angle(rd), angle(rs)  =  i  -- immediate constant
                      |  p  -- program counter relative
                      |  t  -- top of stack relative
                      |  r  -- scratch register relative
%%]]

%%[[wrap=code
t  =  00
r  =  01
i  =  10
p  =  11
%%]]

Store destinations can only be |s| or |r|, hence the encoding omits the most significant bit in store instructions.

\subsubsection{Load destination, store source: basic variant}
%%[[wrap=code
angle(rd), angle(rs)  =  t  -- top of stack, with push/pop side effect
                      |  r  -- scratch register
%%]]

%%[[wrap=code
t  =  0
r  =  1
%%]]

\subsubsection{Operator destination: operand variant}
%%[[wrap=code
angle(od)  =  t  -- top of stack, with push/pop side effect
           |  r  -- scratch register
           |  s  -- stack pointer register
           |  p  -- program counter register
%%]]

%%[[wrap=code
t  =  00
r  =  01
s  =  10
p  =  11
%%]]

\subsubsection{Operator type}
%%[[wrap=code
angle(ot)  =  a  -- add
           |  s  -- subtract
           |  m  -- multiply
           |  d  -- divide+modulo
%%]]

%%[[wrap=code
a  =  00
s  =  01
m  =  10
d  =  11
%%]]

\subsubsection{Data type}
%%[[wrap=code
angle(dt)  =  i1  -- 32bits int
           |  i2  -- 64bits int
           |  f1  -- 32bits float
           |  f2  -- 64bits float
%%]]

%%[[wrap=code
i1  =  00
i2  =  01
f1  =  10
f2  =  11
%%]]

\subsubsection{Immediate signed int constant size}
%%[[wrap=code
angle(is)  =  08, b  -- byte, 8 bits
           |  16, s  -- short, 16 bits
           |  32, w  -- word, 32 bits
           |  64, d  -- double, 64 bits
%%]]

%%[[wrap=code
08, b  =  00
16, s  =  01
32, w  =  10
64, d  =  11
%%]]

\subsubsection{Sign}

%%[[wrap=code
angle(sg)  =  +  -- positive
           |     -- positive
           |  -  -- negative (2's complement)
%%]]

%%[[wrap=code
+  =  0
-  =  1
%%]]

\subsubsection{Immediate constant}
%%[[wrap=code
angle(c)  =  ci  -- constant in instruction
          |  cf  -- constant following instruction
%%]]

%%[[wrap=code
ci  =  0
cf  =  1
%%]]

\subsubsection{Indirection level}
%%[[wrap=code
angle(i)  =  0      -- as is, use itself (don't follow as address)
          |  1      -- use content pointed to (do follow as address)
          |  2      -- and another time
          |  3, i   -- use as int, that is yield tagged int representation
%%]]

Level 0 is only used for a source, in that case encoding equals the encoding for |i - 1|.

A level 3 represents a variation on level 0 with an implicit conversion to int encoding |Enc(x)|.

\subsubsection{Instruction prefixes/categories}

Prefixes without comment are unused.

%{
%format <<  = "{\ll}"
%%[[wrap=code
0           0x00        0x00        loading
100         0x04 << 5   0x80        storing
101         0x05 << 5   0x82        arithmetic
1100  0     0x18 << 3   0xC0        calling, case
1100  0111
1100  1     
1101
1110  00    0x38 << 2   0xE0        eval/apply
1110  01    
1110  1     0x1D << 3   0xE8        heap: node alloc/fetch
1111  0
1111  10
1111  11                0xFC        'standalone': extend prefix, nop, ...
%%]]
%}

\subsubsection{Misc notation}

In the context of evaluation steps:

%%[[wrap=code
Sup(c)(r)       --  value c at offset r from top of stack
%%]]

%%]

%%[grinBConstants
Signed int constants are denoted with |x|, unsigned (positive) int constants with |xpos|.

Byte at a time encoding, signed:

\begin{GrinEncoding}{instruction with |x=angle(sg)c|}
|0 <= c < pow2(1) | &
|.. ^ ci ^^ ixx1(c)(0) ..| &
&
&
\\
|- pow2(7) <= c < pow2(7) | &
|.. ^ cf ^^ sg ..| &
|0 ^ ixx(c)(6)(0)| &
&
\\
|- pow2(14) <= c < pow2(14) | &
|.. ^ cf ^^ sg ..| &
|1 ^ ixx(c)(13)(7)| &
|0 ^ ixx(c)(6)(0)| &
\\
|- pow2(21) <= c < pow2(21) | &
|.. ^ cf ^^ sg ..| &
|1 ^ ixx(c)(20)(14)| &
|1 ^ ixx(c)(13)(7)| &
|0 ^ ixx(c)(6)(0)|
\\
etc.
\\
\end{GrinEncoding}

Byte at a time encoding, unsigned:

\begin{GrinEncoding}{instruction with |xpos=c|}
|0 <= c < pow2(1) | &
|.. ^ ci ^^ ixx1(c)(0) ..| &
&
&
\\
|0 <= c < pow2(8) | &
|.. ^ cf ^^ ixx1(c)(7) ..| &
|0 ^ ixx(c)(6)(0)| &
&
\\
|0 <= c < pow2(15) | &
|.. ^ cf ^^ ixx1(c)(14) ..| &
|1 ^ ixx(c)(13)(7)| &
|0 ^ ixx(c)(6)(0)| &
\\
|0 <= c < pow2(22) | &
|.. ^ cf ^^ ixx1(c)(21) ..| &
|1 ^ ixx(c)(20)(14)| &
|1 ^ ixx(c)(13)(7)| &
|0 ^ ixx(c)(6)(0)|
\\
etc.
\\
\end{GrinEncoding}

Byte/short/word/double encoding, signed, little endian:

\begin{GrinEncoding}{instruction with |x=c|}
|- pow2(7) <= c < pow2(7), angle(is) = b | &
|.. ^ ixxjuxt(is)(1)(0) ..| &
|ixx(c)(7)(0)| &
&
\\
|- pow2(15) <= c < pow2(15), angle(is) = s | &
|.. ^ ixxjuxt(is)(1)(0) ..| &
|ixx(c)(7)(0)| &
|ixx(c)(15)(8)| &
\\
etc.
\\
\end{GrinEncoding}

Whenever a constant |x| is referred to from the instruction encoding,
its two bits |ixxjuxt(x)(1)(0)| refer to the above encoded size information.

Big vs little endian:
\begin{itemize}
\item In memory: take host platform endianness
\item In a file, in a persistent format (not under further consideration here): take any, probably little endian as the Intel platform is quite dominant.
\end{itemize}

%%]

%%[grinBMovingData

\subsubsection{Loading}

\begin{GrinEncoding}{|ild(i)(rd)(rs)(x)|}
 &
|0 ^ ixxjuxt(i)(1)(0) ^ ixx1(rd)(0) ^ ixxjuxt(rs)(1)(0) ^ ixxjuxt(x)(1)(0)| &
... &
&
\\
\end{GrinEncoding}

\textbf{Semantics}\\

%%[[wrap=code
ild(i)(rd)(rs)(x)
  =  case angle(i) of
       0  ->  d  :=  s
       1  ->  d  :=  *s
       2  ->  d  :=  **s
       i  ->  d  :=  Enc(s)
%%@TopicGrinBytecode.grinBLoadSrc
         d  <-  case ^^ angle(rd) of
                  t  ->  gstack := [gstack]-1
                         *(gstack + x)
                  r  ->  greg
%%]]

\textbf{Abbreviations}\\

%%[[wrap=code
ldl d       =   l1tt  d            -- push content displacement d relative to tos on stack
ldc c       =   l0ti  c            -- push constant c on stack
ldc i       =   liti  c            -- push constant c as int on stack
lda d       =   l0tt  d            -- push address displacement d relative to tos on stack
%%]]

\textbf{|ldl|: load local from stack}\\

\GriniStep{%
 \GriniStateBefore{%
 }{%
  |ldl v : gcode|
 }{%
  |s0 : ... : sv : gstack|
 }{%
  |gheap|
 }{
  |greg|
 }
}{%
 \GriniStateAfter{%
 }{%
  |gcode|
 }{%
  |sv : s0 : ... : sv : gstack|
 }{%
  |gheap|
 }{
  |greg|
 }{}
}

\subsubsection{Storing}

\begin{GrinEncoding}{|ist(i)(rd)(rs)(x)|}
 &
|100 ^ ixx1(i)(0) ^ ixx1(rd)(0) ^ ixx1(rs)(0) ^ ixxjuxt(x)(1)(0)| &
... &
&
\\
\end{GrinEncoding}

\textbf{Semantics}\\

%%[[wrap=code
ist(i)(rd)(rs)(x)
  =  case angle(i) of
       0  ->  *d         :=  s
       1  ->  **d        :=  s
  where  d  <-  case ^^ angle(rd) of
                  t  -> gstack + x
                  r  -> greg + x
         s  <-  case ^^ angle(rs) of
                  t  ->  s = gstack
                         gstack := [gstack]+1
                         *s
                  r  ->  greg
%%]]

\textbf{Abbreviations}\\

%%[[wrap=code
sts d       =   s1tt   d            -- pop tos content into displacement d relative to tos on stack
%%]]

\subsubsection{Block copy}

\begin{GrinEncoding}{|icp(i)(rs)(x)|}
 &
|1111 ^ 1110| &
|11 ^ ixxjuxt(i)(1)(0) ^ ixxjuxt(rs)(1)(0) ^ ixxjuxt(x)(1)(0)| &
... &
\\
\end{GrinEncoding}

Is this instruction necessary?

\textbf{Semantics}\\

%%[[wrap=code
icp(i)(rs)(x)
  =  (*(gstack+1))[0..sz-1]  :=  (*(gstack))[0..sz-1]
%%@TopicGrinBytecode.grinBLoadSrc2
         sz <-  case angle(i) of
                  0  ->  s
                  1  ->  *s
                  2  ->  **s
%%]]

Behavior in case of overlap of src/dst is unpredictable.

%%]

%%[grinBLoadSrc
  where  s  <-  case ^^ angle(rs) of
                  t  -> gstack + x
                  r  -> greg + x
                  p  -> gpc + x        -- after instruction fetch
                  i  -> x
%%]

%%[grinBLoadSrc2
  where  s  <-  case ^^ angle(rs) of
                  t  -> gstack + xpos
                  r  -> greg + xpos
                  p  -> gpc + xpos        -- after instruction fetch
                  i  -> xpos
%%]

%%[grinBArithmetic

\subsubsection{Immediate constant addition}

\begin{GrinEncoding}{|iaddi(od)(x)|}
 &
|1010 ^ ixxjuxt(od)(1)(0) ^ ixxjuxt(x)(1)(0)| &
... &
&
\\
\end{GrinEncoding}

\subsubsection{General operators}

\begin{GrinEncoding}{|iop(ot)(dt)(i)(od)(rs)(x)|}
 &
|1011 ^ ixxjuxt(ot)(1)(0) ^ ixxjuxt(od)(1)(0)| &
|ixx(dt)(2)(0) ^ ixx1(i)(0) ^ ixxjuxt(rs)(1)(0) ^ ixxjuxt(x)(1)(0)| &
... &
\\
\end{GrinEncoding}

\textbf{Semantics}\\

%%[[wrap=code
iop(ot)(dt)(i)(rd)(rs)(x)
  =  
%%]]

\textbf{Abbreviations}\\

%%[[wrap=code
addi        =   oaiss  0         -- on tos addition
%%]]

%%]

%%[grinBControl
\subsubsection{Call}

\begin{GrinEncoding}{|icall(rs)|}
 &
|1100 ^^ 000 ^ ixx1(rs)(0)| &
... &
 &
\\
\end{GrinEncoding}

\GriniStep{%
 \GriniStateBefore{%
 }{%
  |call : gcode|
 }{%
  |d : gstack|
 }{%
  |gheap|
 }{
  |greg|
 }
}{%
 \GriniStateAfter{%
 }{%
  |d|
 }{%
  |gcode : gstack|
 }{%
  |gheap|
 }{
  |greg|
 }{}
}


\subsubsection{Tail call}

\begin{GrinEncoding}{|itailcall(rs)(n)(m)(r)|}
 &
|1100 ^^ 001 ^ ixx1(rs)(0)| &
|00 ^ ixxjuxt(n)(1)(0) ^ ixxjuxt(m)(1)(0) ^ ixxjuxt(r)(1)(0)| &
... &
\\
\end{GrinEncoding}

where |n, m, r :: angle(is)|

\GriniStep{%
 \GriniStateBefore{%
 }{%
  |tailcall n m r : _|
 }{%
  |d : a1 : .. : an : .. : Sup(c)(r) : b1 : .. : bm : gstack|
 }{%
  |gheap|
 }{
  |greg|
 }
}{%
 \GriniStateAfter{%
 }{%
  |d|
 }{%
  |Sup(c)(r) : a1 : .. : an : gstack|
 }{%
  |gheap|
 }{
  |greg|
 }{}
}


\subsubsection{Return from call}

\begin{GrinEncoding}{|iretcall(n)(m)(r)|}
 &
|1100 ^^ 0100| &
|00 ^ ixxjuxt(n)(1)(0) ^ ixxjuxt(m)(1)(0) ^ ixxjuxt(r)(1)(0)| &
... &
\\
\end{GrinEncoding}

where |n, m, r :: angle(is)|

\GriniStep{%
 \GriniStateBefore{%
 }{%
  |retcall n m r : _|
 }{%
  |a1 : .. : an : .. : Sup(c)(r) : b1 : .. : bm : gstack|
 }{%
  |gheap|
 }{
  |greg|
 }
}{%
 \GriniStateAfter{%
 }{%
  |Sup(c)(r)|
 }{%
  |a1 : .. : an : gstack|
 }{%
  |gheap|
 }{
  |greg|
 }{}
}


\subsubsection{Return from case}

\begin{GrinEncoding}{|iretcase(n)(r)(c)|}
 &
|1100 ^^ 0101| &
|00 ^ ixxjuxt(n)(1)(0) ^ ixxjuxt(r)(1)(0)| &
|n|, |r|, code location |c| &
... \\
\end{GrinEncoding}

where |n, r:: angle(is)|

\GriniStep{%
 \GriniStateBefore{%
 }{%
  |retcase n r c : _|
 }{%
  |a1 : .. : an : .. : Sub(s)(r) : gstack|
 }{%
  |gheap|
 }{
  |greg|
 }
}{%
 \GriniStateAfter{%
 }{%
  |c|
 }{%
  |a1 : .. : an : Sub(s)(r) : gstack|
 }{%
  |gheap|
 }{
  |greg|
 }{}
}


\subsubsection{Case 'call'}

\begin{GrinEncoding}{|icasecall(n)|}
 &
|1100 ^^ 0110| &
|0000 ^^ 00 ^ ixxjuxt(n)(1)(0)| &
|n|, |n+1| locations &
... \\
\end{GrinEncoding}

|n| offsets, each off same size (i.e. nr of bytes) as |n|, relative to |gpc| immediately after each |n|.
During runtime initialization the offsets are patched to their absolute addresses.

\GriniStep{%
 \GriniStateBefore{%
 }{%
  |casecall n : c : c1 : .. : cn : .. : c|
 }{%
  |p : gstack|
 }{%
  |[ p :-> (t : f1 : .. : fm) ] `elem` gheap|
 }{
  |greg|
 }
}{%
 \GriniStateAfter{%
 }{%
  |Sub(c)(t)|
 }{%
  |c : p : gstack|
 }{%
  |gheap|
 }{
  |greg|
 }{}
}



\subsubsection{Eval}

\begin{GrinEncoding}{|ieval(rs)|}
 &
|1110 ^^ 000 ^ ixx1(rs)(0)| &
 &
 &
\\
\end{GrinEncoding}

\GriniStep{%
 \GriniStateBefore{%
 }{%
  |eval : gcode|
 }{%
  |p : gstack|
 }{%
  |[ p :-> (t : f1 : .. : fm) ] `elem` gheap|
 }{
  |greg|
 }
}{%
 \GriniStateAfter{%
 }{%
  |gcode|
 }{%
  |p : gstack|
 }{%
  |gheap, not p->needsEval|
 }{
  |greg|
 }{}
}


\subsubsection{Apply}

\begin{GrinEncoding}{|iapply(rs)|}
 &
|1110 ^^ 001 ^ ixx1(rs)(0)| &
 &
 &
\\
\end{GrinEncoding}

\subsubsection{Upd}

\begin{GrinEncoding}{|update|}
 &
|1111 ^^ 1101| &
 &
 &
\\
\end{GrinEncoding}

\subsubsection{Load global}

\begin{GrinEncoding}{|ildg(m)(t)(o)|}
 &
|1111 ^^ 1100| &
 &
 &
\\
\end{GrinEncoding}

Load from module |m| (16 bits), table |t| (16 bits), offset |o| (32 bits).
This info is stored in a separate link entry table, and patched during runtime initialization
with the proper location.

\subsubsection{Nop}

\begin{GrinEncoding}{|nop|}
 &
|1111 ^^ 1111| &
 &
 &
\\
\end{GrinEncoding}
%%]

%%[grinBStorage
\subsubsection{Alloc}

\begin{GrinEncoding}{|ialloc(rs)|}
 &
|1110 ^^ 100 ^ ixx1(rs)(0)| &
 &
 &
\\
\end{GrinEncoding}

\subsubsection{Store}

\begin{GrinEncoding}{|istore(rs)|}
 &
|1110 ^^ 101 ^ ixx1(rs)(0)| &
 &
 &
\\
\end{GrinEncoding}

\subsubsection{Alloc + Store}

\begin{GrinEncoding}{|iallocstore(rs)|}
 &
|1110 ^^ 110 ^ ixx1(rs)(0)| &
 &
 &
\\
\end{GrinEncoding}

Size in words, including tag.

\GriniStep{%
 \GriniStateBefore{%
 }{%
  |allocstore : gcode|
 }{%
  |s : t : f1 : .. : Sub(f)(s-1) : gstack|
 }{%
  |gheap|
 }{
  |greg|
 }
}{%
 \GriniStateAfter{%
 }{%
  |gcode|
 }{%
  |p : gstack|
 }{%
  |gheap[ p :-> (t : f1 : .. : Sub(f)(s-1)) ]|
 }{
  |greg|
 }{}
}


\subsubsection{Fetch}

\begin{GrinEncoding}{|ifetch(rs)|}
 &
|1110 ^^ 111 ^ ixx1(rs)(0)| &
 &
 &
\\
\end{GrinEncoding}

\GriniStep{%
 \GriniStateBefore{%
 }{%
  |fetch : gcode|
 }{%
  |p : gstack|
 }{%
  |[ p :-> ((t,s) : f1 : .. : Sub(f)(s-1)) ] `elem` gheap|
 }{
  |greg|
 }
}{%
 \GriniStateAfter{%
 }{%
  |gcode|
 }{%
  |(t,s) : f1 : .. : Sub(f)(s-1) : gstack|
 }{%
  |gheap|
 }{
  |greg|
 }{}
}


%%]

%%[grinBRest
\subsubsection{Extension prefix}

\begin{GrinEncoding}{|xxx|}
 &
|1111 ^^ 1110| &
|ixx(xxx)(7)(0)| &
... &
\\
\end{GrinEncoding}
%%]

%%[grinBExampleTranslations
%%[[wrap=code
; $x2 
    =  {  store (#0/C/$Int 5) ; \$10_0_42_1 ->
            ldc         5
            ldc         #0/C/$Int       ^
            ldc         2
            allocstore                  CSEnv ^ [$10_0_42_1 :-> offset ...]
          $$+ $x1 $10_0_42_1
            ldl         $10_0_42_1
            ldg         $x1
            ldg         $$+
            tailcall    2 0 ..
       }
%%]]

%%[[wrap=code
; $x4 
    =  {    unit $x3 ; \$10_0_55_0 ->
                                                    ^               ^               CSEnv ^ [$10_0_55_0 :-> global $x3]
            eval $10_0_55_0 ; \$1_289_0!__26_0 ->
                                                    ldg             $x3
                                                    eval
            case $1_289_0!__26_0 of
                                                    casecall        2
                                                    [l3,l1,l2]
                                                l1:
              {  (#0/C/$$: $x__27_2 $1_298_0__27_4)
                                                    fetchs          2               CSEnv ^ [$x__27_2, ... :-> offset ...]
                    ->  {    unit $1_298_0__27_4 ; \$10_0_59_0 ->
                             eval $10_0_59_0 ; \$1_298_0!__28_0 ->
                                                    ldl             $10_0_59_0      ^
                                                    eval
                                                    casecall        2               ^
                                                    [l6,l4,l5]
                             case $1_298_0!__28_0 of
                                                l4:
                               {  (#0/C/$$: $___29_4 $___29_4)
                                                    fetchs          2               CSEnv ^ [$___29_4, ... :-> offset ...]
                                     ->  {  unit $undefined ; \$10_0_63_0 ->
                                                    ldg             $undefined
                                            eval $10_0_63_0
                                                    eval
                                                    retcall         1 1 3           ^
                                         } 
                                                l5:
                               ;  (#1/C/$[])
                                     ->  {  unit $x__27_2 ; \$10_0_65_0 ->
                                                    ldl             $x__27_2
                                            eval $10_0_65_0
                                                    eval
                                                    retcall         1 1 1
                                         } 
                               }
                                                l6:
                                                    
                                                    retcall         1 1 3
                        }
                                                l2:
              ;  (#1/C/$[])
                    ->  { unit (#0/C/$Int 4)} 
                                                    ldi             4
                                                    ldc             #0/C/$Int
                                                    ldc             2
                                                    allocstore
                                                    retcall         1 1 1
              } 
                                                l3:
                                                    retcall         1 1 1
        } 
%%]]

%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

