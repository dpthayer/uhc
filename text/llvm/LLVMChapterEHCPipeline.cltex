%%[chapter
\chapter{EHC}
\label{cha:ehc}
A compiler consists of more than a code generator, such as a parser, type-checker, and optimizer. We choose the Essential Haskell Compiler (EHC) project as the compiler in which we embed a Low Level Virtual Machine(LLVM) assembly code generator, because EHC is designed to be extended (see \refS{sec:ehc-extending}). In EHC, the code generator is placed at the tail of the compiler pipeline, generating code based on output of previous stages. The EHC frontend targets Graph Reduction Intermediate Notation~\cite{boquist:99} (GRIN) instead of the well known Spineless Tagless G-machine~\cite{jones:92} (STG) model to avoid indirect jumps. This choice influences the generated code heavily. In this chapter, we discuss the EHC compiler pipeline stages (\refS{sec:ehc-pipeline}) by showing the intermediate representations of stages, and the transformations performed by them.

\section{Extending EHC}
\label{sec:ehc-extending}
\todo{Check this, and refer to paper of Jeroen.}
The EHC project constructs a sequence of compilers. The first compiler of the sequence, called version 1, only accepts an explicitly typed lambda calculus. Its successor extends version 1 by adding type inference. Each compiler extends its predecessor with a feature from the Haskell language and each one is buildable out of the repository. The sequence of compilers continuous until all features of the Haskell language and some extentsions are implemented. This design to control the complexity of the EHC compiler makes experimenting with non-standard features easier, as one can choose a subset of Haskell to work with.

A compiler is generated from source files which contain chunks. Each chunk is annotated with a version number, indicating from which version the chunk should be included in the compiler. Furthermore chunks can have names, allowing them to overwrite chunks of predecessors with the same name. All chunks for a version are extracted by the Shuffle tool, generating a source file which is compiled by a regular compiler.

\section{The EHC Pipeline}
\label{sec:ehc-pipeline}
A compilation process can be modeled as a pipeline. The start of the pipeline is the input of the source program and the final stage is the produced executable. In between the source program and the executable are the intermediate intermediate representations of the program. The EHC pipeline is shown in \refF{fig:ehc-pipeline} and has the following stages:

\begin{figure}[htbp]
  \centering
    \includegraphics[width=0.95\textwidth]{ehc-pipeline}
  \caption{Dataflow in the EHC pipeline.}
  \label{fig:ehc-pipeline}
\end{figure}

\begin{enumerate}
  \item First, the Haskell input parsed and desugared to \emph{Essential Haskell}. Essential Haskell was the original input language of EHC and is still accepted by the compiler as input language.
  \item The Essential Haskell code is type inferred and if found type correct, transformed to \emph{Core}. The Core language is a lambda calculus with some extensions, where expressions are lambda lifted and type classes are translated to dictionaries. In contrast to several other Haskell compilers' intermediate languages, such as the Glasgow Haskell Compilers (GHC) Core~\cite{tolmach} and Henk~\cite{jones:97}, the Core language is not typed. This is due to practical reasons, as transformations on typed code imply transformations on types.
  \item \emph{GRIN} is the first intermediate representation that is part of the EHC backend. The language is a untyped first order strict functional language that makes the sequential order of a Haskell program explicit. In contrast to the Spineless Tagless G-machine (STG), GRIN uses the eval/apply model~\cite{marlow:04}. Together with tagging of closures, this reduces the amount of costly indirect jumps~\cite{fog:07}~\cite{marlow:07} in the generated code. EHC includes a GRIN interpreter to execute the program.
  \item The Simple imperative language (\emph{Silly}) transforms the GRIN tree to a more imperative form with assignments, statements and expressions. The purpose of Silly is to act as a base for imperative languages. 
  \item Silly constructs map directly on C and the Silly tree is pretty printed as a C program. This program is compiled with an external compiler and produces the native executable. 
\end{enumerate}

The LLVM Assembly language benefits from the preparations performed by Silly, thus we embed the LLVM code generator after Silly in the pipeline. The external LLVM Assembly compiler then compiles the program to a native executable.

In the following sections, we discuss the Core, GRIN, and Silly phases in more detail because they heavily influence the code generated by the LLVM code generator. Please note that we aim to give enough information of each language to understand the generated code and not try to describe each detail of the languages.  

\subsection{Running Example}
In this chapter, we illustrate the EHC pipeline by threading the program shown in \refF{fig:fib-hs} through the pipeline. The program computes the 33$^{th}$ Fibonacci number (3,524,578) in an inefficient direct recursive translation. The example is small and uses only simple arithmetic on |Int| data types for the sake of simplicity. By refraining from the use of the |Float| data type, type classes and the |IO| monad, the restricted EHC version 8 can be used.

\begin{figure}[htbp]
	\hsbox{
%include build/llvm/Fib.lhs
    }
	\caption{The Haskell source for computing a Fibonacci number.}
	\label{fig:fib-hs}
\end{figure}

\subsection{The EHC Frontend: Essential Haskell and Core}
\begin{figure}[htbp]
  \lstinputlisting[style={figureLstFootnote}, language={[Core]Haskell}]{FibExe.core}
  \caption{The Core code for the Haskell program of \refF{fig:fib-hs}}
  \label{fig:fib-core}
\end{figure}
We group together the first two stages of the EHC pipeline, Essential Haskell and Core, in the EHC frontend. The frontend focuses on the features of the Haskell language in contrast to the backend, which focuses on generating code. Typical tasks of the frontend are parsing, desugaring, lambda lifting, and type checking. 

The frontend produces the Core code that is shown in \refF{fig:fib-core} for the Haskell input from \refF{fig:fib-hs}. The 5 lines of Haskell explode to 63 lines of Core code. The explosion is caused by the explicit inclusion of mathematical operators, the generation of constructor functions and the desugaring from guards to case statements. Although the code is quite verbose, it still resembles the Haskell input, but with some differences:

\begin{itemize}
  \item All top level functions are transformed to a nested let expression. This let expression evaluates to the value of the variable \inlCode{[Core]Haskell}{\$main} if the module is executable. Higher versions of EHC than the version we discuss here provide a module system and thus modules without a main function. The Core code for these non-executable modules is a nested let expression without a resulting value.
  \item There are 4 types of bindings in a let expression. Lazy, non recursive bindings are unannotated, while the recursive variant adds the keyword rec. Bindings for foreign functions are annotated with the foreign keyword. This distinction of foreign functions is needed later in the pipeline, as parameters to these functions are evaluated before passed to the function. Finally strict let bindings are annotated with '!'. The strictness annotation is currently only used for forcing the evaluation of the scrutinee in case expressions but it is a generally usable. For example a strictness analysis can use the annotation to force strict evaluation of some expressions.
  \item Case expressions have a default case if a pattern match failure occurs. This default arm is defined with the value \inlCode{[Core]Haskell}{\$undefined}, but this is not equal to the Haskell prelude value of undefined. Instead, backends are free to implement this default case they way they see fit.
  \item Data constructors are explicitly bound to functions as is shown with the bindings to \inlCode{[Core]Haskell}{\$True} and \inlCode{[Core]Haskell}{\$False}. These functions are needed because in EHC data constructors cannot be applied partially. By encapsulating data constructing in functions, the regular currying mechanism is used to partially apply data constructors. In the code example, the bindings are not needed, as both constructors do not expect parameters. EHC relies on optimizers further in the pipeline to remove the unneeded functions.
  \item Types are only available for data constructors and foreign functions. The pipeline stages that follow have to be untyped or re-type the program.
\end{itemize}

\subsection{GRIN}
The GRIN language is the first intermediate language of the EHC backend. Boquist developed GRIN as alternative for the STG~\cite{jones:92} language as adopted by GHC. The main difference between the two models is the strategy for evaluating closures. The STG language evaluates closures by jumping to the evaluation code in the info table of the closure. After a closure is evaluated, the evaluation code is overwritten with code that directly returns. This strategy is elegant, as suspended functions and evaluated values are treated equal. A disadvantage of the strategy is the resulting object code. The object code contains many branches to staticly unknown targets because the address of closures and thus their evaluation code is not known staticly. These so called indirect branches are very inefficient on modern superscalar processors as an indirect branch confuses the branch predictor.

With GRIN, Boquist eliminates the use of indirect branches in generated object code. In the eval / apply model, a huge case expression evaluates a closure by scrutizing the tag of the closure. The tag of the closure determines which evaluation code, if needed, is executed. By itself, this does not eliminate indirect branches, as big case expressions are often faster implement with a jumptable instead of a serie of conditional branches. But when combined with inlining of these case statements and elimination of impossible branches, the amount of branches are often reduced enough that a jumptable can be omitted.

The GRIN language is a small language and only has a few expressions and one combinator. In contrast with the source language Haskell, GRIN is an impure functional language. Impure expressions are store, fetch, and update expressions, which put and retrieve nodes to and from the heap. The pure expressions in GRIN are function calls, case expressions, and the unit expressions. Unit expressions can be seen as an monadic return, the value of the expression is the value of the parameter.

\begin{figure}[htbp]
  \lstinputlisting[style={figureLstFootnote}, language={grin}]{FibExe.grin}
  \caption{The GRIN code for the Haskell program of \refF{fig:fib-hs}}
  \label{fig:fib-grin}
\end{figure}

GRIN expressions are combined with the sequence combinator. The syntax of the sequence combinator shows resemblance with the monadic bind (|>>=|) in Haskell, but the semantics are more like an imperative assignment operator. A sequence is of the form \inlCode{grin}{\$expr1; \$pat1 -> \$expr2}. This results in the assignment of \inlCode{grin}{\$expr1} to \inlCode{grin}{\$pat1} in the same way a scrutinee of a haskell case expression is bound to a pattern. Variables in the pattern are bound to the value of the expression and concrete tags in the pattern are checked against the value of the expression. After the binding, the sequence combinator returns the value of \inlCode{grin}{\$expr2}, which can use the bindings defined in \inlCode{grin}{\$pat1}.

\subsubsection{Generated GRIN code}
\refF{fig:fib-grin} shows the GRIN code generated for the Haskell program  shown in \refF{fig:fib-hs}, before any GRIN transformation is applied. This code is a straight forward translation from the Core code shown earlier (\refF{fig:fib-core}) and quite similar to it. There are several code conventions for the GRIN code:
\begin{enumerate}
  \item There are 3 type of nodes in GRIN; constructed values, suspended functions and partial applications. In this example, tags for constructed values are prefixed with an 'C', e.g. CInt, CTrue. The tag prefix for suspended functions is 'F', resulting in tags as Ffib and FprimSubInt. Finally there are the partial applied functions. Their tags are prefixed with an 'P', although those are not generated for the fib example.
  \item There are different type of variables in GRIN; nodes, pointers, literals and tags. In the example, the variable name shows the type of the variable. Variables that contain nodes are prefixed with '\$n', pointers with '\$p', literal integers with '\$i', and tags with '\$t'.
  \item When a pattern match defines bindings that are never used, the variable is replaced by an underscore.
\end{enumerate}

In the generated GRIN code one function is not a direct mapping from the Core code. The eval function is responsible for evaluating closures to weak-head normal form. The function consists of a big case expressions with an arm for each possible closure type. The arms for constructed values and partial applied functions just return the node passed to the eval function because they are already in weak-head normal form. More interesting is the code in the arms for suspended functions. The code evaluates the function via a function call and than updates the node with the value returned from it.
Although the eval function is shown in the code in \refF{fig:fib-grin}, in reality it is never generated in this form. Actual generation of the full eval function is a waste of time, as the eval function is inlined at each occurrence. Still it is included in the example for clarity.

\begin{figure}[tbhp]
  \begin{centering}
    \input{GRIN_Fib_Tree.tex}
    \caption{A tree of closures as build by the \$fib function of \refF{fig:fib-grin}}
    \label{fig:fib-grin-tree}
  \end{centering}
\end{figure}

GRIN is the first language of the EHC pipeline which makes the creation and order of evaluation of closures explicit. A good example of the generated evaluation order can be seen in the function \$fib. The two equality tests for the base cases are implemented by creating a suspended function call to \$primEqInt and directly evaluating it. If both tests return false, \$fib enters the recursive branch. This translates to GRIN code that creates an closure for each expression in the Haskell expression |fib(n-1) + fib(n-2)|,  resulting in the tree of closures illustrated in \refF{fig:fib-grin-tree}. Directly after creating the tree, it is evaluated with a call to \inlCode{grin}{\$eval}. Because the tree is not in weak-head normal form, there is a suspended function node at the root of the tree, the evaluation of the tree will result in a call to \$primAddInt. The function \$primAddInt is strict in both arguments because it calls \$eval on both parameters. First, the parameter pointing to the left sub-tree is evaluated, which is a suspended \$fib function. This results in a tree equal to the top level evaluation of \$fib. The unfolding continuous until the base case of \$fib is hit; then the fully unfolded sub-tree is folded again to an integer node. The right sub-tree is evaluated in the same way as the left sub-tree. When both sub-trees are evaluated and reduced to an integer node, the addition of both integers is performed and the program exits after printing the computed value.

The code generated for the three primitive functions illustrates how EHC interfaces with foreign functions. The arguments of the function are evaluated before the call and reduced to a native type. For example, the CInt nodes that are returned by the \$eval function are reduced to a bare machine register integer by selecting the integer field from the node. After each parameter is untagged, the foreign function is called. The return value of the foreign function is either a tag or an untagged value. Tag values can be returned as tag if the node has no payload, while unboxed values need to be wrapped before returned.     

\subsubsection{GRIN optimizations}
The code shown in \refF{fig:fib-grin} is very naive. Complete nodes are fetched if only the tag is needed, small functions are not inlined and some nodes are allocated and directly evaluated instead of an direct function call. This is a design choice in GRIN, opting to generate naive code followed by applying small and simple optimizing transformations. The static single assignment form of the GRIN program makes optimization easier, as the program can be analyzed without worrying about alias problems.

The effect of the optimization transformations is illustrated in \refF{fig:fib-grin-tree-opt}. The figure shows the code generated for the recursive branch of the \$fib function. The function \$primAddInt is inlined in this branch and give the opportunity to eliminate the allocation of the suspended function nodes FprimAddInt node and Ffib because they are evaluated later in this branch. \refF{fig:fib-grin-tree} shows the closures build by the optimized code. This reduces the memory allocation by fib with 41\%.

\begin{figure}[htbp]
  \lstinputlisting[style={figureLstFootnote}, language={grin}]{FibExe-opt.grin}
  \caption{Optimized GRIN code for the recursive branch of \refF{fig:fib-hs}.}
  \label{fig:fib-grin-opt}
\end{figure}

\begin{figure}[tbhp]
  \begin{centering}
    \input{GRIN_Fib_Tree_Opt.tex}
    \caption{Closures build by the optimized version of \$fib}
    \label{fig:fib-grin-tree-opt}
  \end{centering}
\end{figure}

\subsection{Silly}
The next step in the EHC pipeline is the Silly language. Silly is the first language that abandons the functional world and is a imperative language. The goal of Silly is to ease the translation of GRIN to an imperative programming language that can be used for the generation of executables. The language contains of basic statements as assignments, switch statements and if-then-else statements. The expressions in the language can be either function calls, variables, constants, and comparisons. All these constructs have a direct counterpart in most well-known imperative languages, such as C and Java.

The translation of GRIN to Silly again removes abstractions and concretsizes the code more. In order to do so, it performs the following abstractions and optimizations:
\begin{itemize}
  \item In GRIN code, updating closures is hidden behind the \inlCode{grin}{update} expression. It was left unspecified if an update means updating the closure with a new node or with a redirection to a fresh allocated node. Silly allocates enough memory for a closure to store each possible evaluation result of the closure. This strategy allows updates to overwrite the values of the evaluated closure and thus can be removed to simple assignments to the fields of the closure.
  \item Each function is annotated with the property if it tail calls or not.
  \item A Constant Applicative Form (CAF) is a top level function without parameters. The lack of parameters implies that each closure created for a CAF is equal and evaluates to the same value. To reduce the amount of allocations and optimize the application of CAFs, Silly creates global variable which points to a closure for the CAF. Each application of the CAF uses this closure and thus it is evaluated and updated only once.
  \item Local variables are made explicit in Silly. Local variables are introduced for values that are given different values in arms of an switch statement and for caching of a field fetch from a node. Silly optimizes local variables by looking if an variable is used more than once. If it is, it is assigned to a local variable. Local variables are declared at the start of each function, so that there is known how much memory to allocate.
  \item To accommodate for target languages that do not support tail calling natively, the generation of an explicit stack is an option in Silly. Local variables are stored on this stack as are labels which can be used as return addresses. Indeed, this option is used to generate tail calls for the C code generation backend. For the generation of LLVM code, we disable this option and use the C stack, as LLVM Assembly natively supports tail calling.
  \item Returning nodes from functions is explicit in Silly by assigning to the global node RP. The RP node is large enough to contain each possible node that can be returned and is allocated at the beginning of the program, at the same time the CAF global nodes are initialized. This allows target languages without support for multiple return values to return nodes. 
\end{itemize} 

\begin{figure}[hbtp]
  \lstinputlisting[style={figureLstFootnote}, language={C}]{FibExe.sil}
  \caption{Silly code for the recursive branch of \refF{fig:fib-hs}.}
  \label{fig:fib-silly}
\end{figure}

The Silly code generated for the recursive branch of fib is shown in \refF{fig:fib-silly}. The annotation (between curly brackets) of the function shows that the function is a regular function and does not tail call. The function header is followed by the declaration of a list of local variables. Most variables are inherited from the GRIN variables and use the same naming standard. Thus the variables which are prefixed with 'p' stores a pointer to a node, while a 't' refers to a tag, and 'i' refers to an untagged integer. Local variables prefixed with an 'x' are added during the transformation of GRIN to Silly and contain arbitrary types of values.

The creation of a closure in Silly is a sequence of allocating memory for the closure and assigning values to the fields. In the example code, four closures are created: 2 closures of 3 cells for a suspended call to primSubInt and 2 for boxed integers, equivalent with the GRIN code shown in \refF{fig:fib-grin-opt}. The allocation requests are annotated as garbage collection managed. This annotation is safe to be ignored by the code generator, if it applies memory management without garbage collection.

The example code also shows some optimizations performed by the Silly language. After the first recursive call to fib, the value of RP[1] is stored in a local variable. This is needed because the second recursive call to fib overwrites the RP node with the node it returns. The return value of the second recursive call to fib is not clobbered by another function call before it is used as parameter of primAddInt. Therefor the assignment to a local variable is omitted and the return value is inlined.  

\section{Synopsis}
This chapter demonstrated the EHC pipeline. Each stage in the pipeline introduced a small language in which an abstraction of the input is made explicit and give rise to different optimizations. The input of the pipeline was a simple Haskell program and the result was a Silly program with explicit allocations, assignments and an explicit construction for multiple return values.  

The language Silly is the predecessor for the new stage that we add to the EHC pipeline. The output of the stage is the LLVM Assembly language, discussed in \refC{cha:llvm}, which is compiled to an executable. The translation from Silly to LLVM Assembly is discussed in \refC{cha:naive}. 
%%]
