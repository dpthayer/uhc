%%[title
\begin{frame}
\titlepage
\end{frame}

%%]

%%[intro
%%]

%%[pipeline
%%]

%%[toolsAG
%%]

%%[aspectsAndVariants
\begin{frame}
\frametitle{Variants and aspects}

Variant: a step in the stepwise growth in language features

Aspect: a set of attributes and its resulting computation

E.g. aspect \textit{typing} for the first variants of UHC:

\begin{itemize}
\item variant {\color{uured}1}: simply typed |lambda|-calculus

%%[[wrap=safecode
i  ::  Int
i  =   5
%%]]

\item<2-> variant {\color{uured}3}: polymorphic type inference
\visible<2->{

%%[[wrap=safecode
id x  =   x
%%]]

infers |id :: forall ^ a . a -> a|
}

\item<3-> variant {\color{uured}4}: higher ranked types
\visible<3->{

%%[[wrap=safecode
f :: (forall ^ a . a -> a) -> (Char,Int)
f i = (i 'x', i 5)

v = f id
%%]]

allows polymorphic use of argument |i| inside |f|
}


\end{itemize}

\end{frame}


\begin{frame}
\frametitle{Variants}

In UHC

\begin{enumerate}
\item[~]<2-> \makebox[50mm][l]{{\color{uured}plain Haskell}}                  {\color{uured}experiments}
\item<1-> \makebox[50mm][l]{$\lambda$-calculus, type checking}
\item<1-> \makebox[50mm][l]{type inference}
\item<1-> \makebox[50mm][l]{polymorphism}
\item<1-> \makebox[50mm][l]{}                                  \visible<2->{higher ranked types, existentials}
\item<1-> \makebox[50mm][l]{data types}
\item<3-> \makebox[50mm][l]{kind inference}                    kind signatures
\item<3-> \makebox[50mm][l]{records}                           tuples as records
\item<3-> \makebox[50mm][l]{code generation}                   full program analysis
\item<3-> \makebox[50mm][l]{classes, type-synonyms}            extensible records
\setcounter{enumi}{19}
\item<4-> \makebox[50mm][l]{modules}
\setcounter{enumi}{94}
\item<4-> \makebox[50mm][l]{`deriving'}                      exceptions
\setcounter{enumi}{98}
\item<4-> \makebox[50mm][l]{prelude, I/O}
\end{enumerate}

\end{frame}



\begin{frame}
\frametitle{Variants and aspects}

\begin{itemize}
\item Two dimensions for partitioning the description of UHC
\item Combination of variant and aspects can be build as a compiler
 \begin{itemize}
 \item Isolation of language feature and aspect
 \item For debugging, experimentation, explanation
 \end{itemize}
\item Code is partitioned in small chunks
 \begin{itemize}
 \item Tagged with variant number and aspect name
 \item Processed by tool (Shuffle) to generate AG and/or Haskell input
 \end{itemize}
\item Last variant + all aspects = UHC
\end{itemize}

\end{frame}



\begin{frame}
\frametitle{Variants and aspects}

\begin{center}
\begin{tikzpicture}
  [minimum height=1.5em,
   column 1/.style={anchor=east},
   column 2/.style={anchor=east},
   column 3/.style={minimum width=4em},
   column 4/.style={minimum width=4em},
   column 5/.style={minimum width=4em},
   column 6/.style={minimum width=7em},
   row 10/.style={anchor=north},
   row 11/.style={anchor=north},
   row 12/.style={anchor=north},
   block/.style={rectangle,  fill=uured!20, text centered},
   valida/.style={rectangle,  fill=uured!20, text centered},
   validb/.style={rectangle,  fill=uured!40, text centered},
  ]

\def\valid{\node<4->[valida]{\(\checkmark\)}}
\def\valida{\node<4>[valida]{\(\checkmark\)}}
\def\validb####1{\node<5>(####1)[validb]{\(\checkmark\)}}
\matrix[ampersand replacement=\&]
{

    \& \node[red]{\textit{variants}} ;
    \& 
    \&
    \&
    \& \node(topright){} ;
\\
\node{99:} ;
    \& \node(topleft){libraries} ;
    \& \valid ;
    \& \valid ;
    \& \node<2->[block](uhc){UHC} ;
    \&
\\
%% \node{\(\cdots\)} ;
    \& \node{\(\cdots\)} ;
    \& \valid ;
    \& \valid ;
    \& \valid ;
    \&
\\
\node{20:} ;
    \& \node{modules} ;
    \& \valid ;
    \& \valid ;
    \& \valid ;
    \&
\\
%% \node{\(\cdots\)} ;
    \& \node{\(\cdots\)} ;
    \& \valid ;
    \& \valid ;
    \& \valid ;
    \&
\\
\node{9:} ;
    \& \node{classes} ;
    \& \valid ;
    \& \valid ;
    \& \valid ;
    \& \node<3->[block]{Ext Recs} ;
\\
\node(variantx){8:} ;
    \& \node{primitives} ;
    \& \valid ;
    \& \valid ;
    \& \valida ; \validb{calloutaloc} ; % node<5>(calloutaloc)[validb]{\(\checkmark\)} ;
    \&
\\
%% \node{\(\cdots\)} ;
    \& \node{\(\cdots\)} ;
    \& \valid ;
    \& \valid ;
    \&
    \&
\\
\node{1:} ;
    \& \node{|lambda|-calculus} ; 
    \& \valid ;
    \& 
    \&
    \&
\\

    \& \node(botleft)[anchor=north east]{} ;
    \& \node{parsing} ;
    \& \node{typing} ;
    \& \node(aspectx){codegen} ;
    \& \node(botright){experiment} ;
\\

    \& 
    \& 
    \& 
    \&
    \& \node[red]{\textit{aspects}} ;
\\

    \& 
    \& 
    \& 
    \&
    \& \node[red]{\textit{(accumulative)}} ;
\\
};
\draw [thick]
  (botleft.north east) -- (topleft.north east)
  (botleft.north east) -- (botright.north east);
%% \node<2->[anchor=south] at (uhc.north) {bla} ;

\node<5>(callouta)[anchor=north east,rectangle callout, drop shadow, fill=black!15, callout absolute pointer={(calloutaloc)}] at (topright.north east) {\parbox{.235\linewidth}{
\begin{verbatim}
%%%[(8 typing codegen)
...
%%%]
\end{verbatim}
}} ;
%\draw<5>[->] (callouta) -- (variantx) ;
%\draw<5>[->] (callouta) -- (aspectx) ;

\end{tikzpicture}
\end{center}

\end{frame}



%%]

%%[conclusions

\begin{frame}
\def\hsColor{yellow!50}
\def\agColor{green!50}
\def\cColor{blue!30}
\gdef\bar####1(####2)(####3){\draw[black,fill=####1] (####2) rectangle (####3)}
\gdef\barHS(####1)(####2){\bar{\hsColor}(####1)(####2)}
\gdef\barAG(####1)(####2){\bar{\agColor}(####1)(####2)}
\gdef\barC(####1)(####2){\bar{\cColor}(####1)(####2)}
\frametitle{Statistics: Lines of Code (LOC)}

\global\newcounter{yyaccum}
%\global\def\yaccum{0}

\begin{center}
\begin{tikzpicture}
  [yscale=0.2,xscale=0.7]
%\draw [help lines] grid (11,30);
\foreach \x/\lbl/\ys in
   {0/Utility/{1.7,18.3,0},
    1/Haskell/{6.7,3.3,0},
    2/EH/{11.2,0.6,0},
    3/Typing/{8.0,7.5,0},
    4/Core/{7.1,1.0,0},
    5/ByteCode/{2.1,0,0},
    6/Grin/{11.3,1.6,0},
    7/Silly/{2.8,0,0},
    8/Exp Backends/{2.5,0.4,0},
    9/Runtime/{0,0,8.1},
    10/GC/{0,0,6.0,}}
 {
  \pgfmathsetcounter{yyaccum}{0};
  %\pgfmathsetmacro{yaccum}{0}
  \foreach \y in \ys
  {
   %\draw (\x,\y) circle (0.1cm);
   %\pgfmathsetmacro{yaccum}{\y + \yaccum}
   %\pgfmathaddtocounter{yyaccum}{1};
  } ;
  \node[rotate=-45,anchor=north west] at (\x+0.4,0) {\lbl} ;
 } ;

\foreach \y/\lbl in {0/0,5/5000,10/10000,15/15000,20/20000}
 {
  \node[anchor=east] at (0,\y) {\lbl} ;
 };

%%% 0:
\barAG(0,0)(1,1.7) ;
\barHS(0,1.7)(1,20) ;

%%% 1:
\barAG(1,0)(2,6.7) ;
\barHS(1,6.7)(2,10) ;

%%% 2:
\barAG(2,0)(3,11.2) ;
\barHS(2,11.2)(3,11.8) ;

%%% 3:
\barAG(3,0)(4,8.0) ;
\barHS(3,8.0)(4,15.5) ;

%%% 4:
\barAG(4,0)(5,7.1) ;
\barHS(4,7.1)(5,8.1) ;

%%% 5:
\barAG(5,0)(6,2.1) ;

%%% 6:
\barAG(6,0)(7,11.3) ;
\barHS(6,11.3)(7,12.9) ;

%%% 7:
\barAG(7,0)(8,2.8) ;

%%% 8:
\barAG(8,0)(9,2.5) ;
\barHS(8,2.5)(9,2.9) ;

%%% 9:
\barC(9,0)(10,8.1) ;

%%% 10:
\barC(10,0)(11,6) ;

\matrix[ampersand replacement=\&, anchor=north west] at (11,21)
{
\node[black,fill=\agColor] {AG}; \& \node{53.4\%};  \\
\node[black,fill=\hsColor] {HS}; \& \node{32.5\%};  \\
\node[black,fill=\cColor] {C}; \& \node{14.1\%};  \\
};

\end{tikzpicture}
\end{center}

%% \begin{tabular}{l||rrrr||rr}
%% subsystem    & \multicolumn{4}{c||}{All variants and aspects}    & \multicolumn{2}{c}{UHC only} \\
%%              &    AG      &    HS      &     C      &    total   &    total   &  fract.  \\\hline
%% utility/general&   1.7    &    18.3    &            &    20.0    &    14.0    &    70\%  \\
%% Haskell      &     6.7    &     3.3    &            &     9.9    &     6.9    &    70\%  \\
%% EH           &    11.2    &     0.6    &            &    11.8    &     6.7    &    57\%  \\
%% EH typing    &     8.0    &     7.5    &            &    15.5    &     7.0    &    45\%  \\
%% Core         &     7.1    &     1.0    &            &     8.0    &     4.7    &    58\%  \\
%% ByteCode     &     2.1    &            &            &     2.1    &     1.7    &    82\%  \\
%% Grin         &    11.3    &     1.6    &            &    12.9    &     8.5    &    66\%  \\
%% Silly        &     2.8    &            &            &     2.8    &     2.6    &    93\%  \\
%% exp.backends &     2.5    &     0.4    &            &     2.9    &     0.8    &    26\%  \\
%% runtime system&           &            &     8.1    &     8.1    &     6.2    &    77\%  \\
%% garb.collector&           &            &     6.0    &     6.0    &     0.7    &    11\%  \\\hline
%% total        &    53.4    &    32.5    &    14.1    &   100.0    &    59.8    &    60\%  \\
%% \end{tabular}

\end{frame}


\begin{frame}
\frametitle{Conclusions}

Use of {\color{uured} Attribute Grammar} is essential for dealing with description \& coding complexity:

\begin{itemize}
\item Much boilerplate code for treewalks is avoided
\item Aspects can be described separately
\item Separately described aspects are combined by the AG compiler
\item AG compiler takes care of plumbing all code as one fold and ordering of attribute computations
\item Scales up in the number of combined aspects
\end{itemize}

But

\begin{itemize}
\item You have to learn it  %%%, and other used domain specific languages as well
\end{itemize}

\end{frame}


\begin{frame}
\frametitle{Conclusions}

Use of {\color{uured} variants and aspects} is essential for dealing with design complexity:

\begin{itemize}
\item Language features are isolated in a variant
\end{itemize}

But

\begin{itemize}
\item Inherent language \& implementation complexity is not decreased, only made more manageable
\item Chosen partitioning into variants is difficult to adapt
\end{itemize}

\end{frame}



\begin{frame}
\frametitle{Conclusions}

{\color{uured} include this????}

Use of {\color{uured} domain specific languages} and {\color{uured} generation} is essential for dealing with maintenance complexity:

\begin{itemize}
\item Avoids duplicates consistency pitfall by generating from shared description
\end{itemize}

But

\begin{itemize}
\item More complex build system
\end{itemize}

\end{frame}



%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]
