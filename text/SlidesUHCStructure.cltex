%%[title
\begin{frame}
\titlepage
\end{frame}

%%]

%%[intro
%%]

%%[pipeline




\begin{frame}
\frametitle{UHC pipeline}
\begin{center}
\begin{tikzpicture}
  [ blok/.style={rectangle, draw=black, line width=0.6pt, minimum height=5mm, text centered},
    eenbreed/.style={minimum width=12mm},
    tweebreed/.style={minimum width=26mm},
    bron/.style={fill=green!50},
    lib/.style={fill=green!50},
    uitvoer/.style={fill=yellow!50},
    doel/.style={fill=yellow!80},
  ]
\matrix[ampersand replacement=\& , row sep={4mm,between borders}, column sep={2mm,between borders}]
{      
    \&
    \& 
    \& \node[blok,bron,eenbreed](hs1){HS};
    \& \node[blok,bron,eenbreed](hs2){HS};
    \& 
    \& 
    \& 
\\
    \&
    \& 
    \& \node[blok,uitvoer,eenbreed](eh1){EH};
    \& \node[blok,uitvoer,eenbreed](eh2){EH};
    \& 
    \& 
    \& 
\\
    \&
    \& 
    \& \node[blok,uitvoer,eenbreed](core1){Core};
    \& \node[blok,uitvoer,eenbreed](core2){Core};
    \& 
    \& 
    \& 
\\
    \& \node[blok,uitvoer,eenbreed](core0){Core};
    \& 
    \& 
    \& 
    \& 
    \& \node[blok,uitvoer,eenbreed](jvm1){Jvm};
    \& \node[blok,uitvoer,eenbreed](jvm2){Jvm};
\\
    \& \node[blok,uitvoer,eenbreed](grin0){Grin};
    \& 
    \& \node[blok,uitvoer,eenbreed](grin1){Grin}; 
    \& \node[blok,uitvoer,eenbreed](grin2){Grin};  
    \& 
    \&
    \&
\\
    \& \node[blok,uitvoer,eenbreed](silly0){Silly};
    \& 
    \& \node[blok,uitvoer,eenbreed](bc1){BC}; 
    \& \node[blok,uitvoer,eenbreed](bc2){BC};  
    \& 
    \&
    \&
\\     %\invisible{\node[blok,uitvoer,eenbreed]{...}};
    \& \node[blok,uitvoer,eenbreed](c0){C};
    \& \node[blok,lib,eenbreed](crts){C}; 
    \& \node[blok,uitvoer,eenbreed](c1){C}; 
    \& \node[blok,uitvoer,eenbreed](c2){C};  
    \& \node[blok,lib,eenbreed](cbci){C}; 
    \&
    \&
\\
    \& \node[blok,doel,eenbreed](exe0){Exe};
    \&
    \&
    \& \node[blok,doel,eenbreed](exe1){Exe};
    \&
    \& \node[blok,doel,eenbreed](jar1){Jar};
    \&
\\
};


\node[blok,uitvoer,tweebreed, anchor=east](core00) at (core0.east) {Core};
\node[blok,uitvoer,tweebreed, anchor=east](grin00) at (grin0.east) {Grin};
\node[blok,uitvoer,tweebreed, anchor=east](silly00) at (silly0.east) {Silly};
\node[blok,uitvoer,minimum width=18mm, anchor=east](c00) at (c0.east) {C};
\node[blok,uitvoer,minimum width=6mm, anchor=east, xshift=-2mm](cil) at (c00.west) {...};


\node[blok,doel,minimum width=18mm, anchor=east](exe00) at (exe0.east) {Exe};
\node[blok,doel,minimum width=25mm, anchor=west](exe000) at (exe00.west) {Exe};
\node[blok,doel,minimum width=33mm, anchor=east](exe11) at (exe1.east) {Exe};
\node[blok,doel,minimum width=41mm, anchor=west](exe111) at (exe11.west) {Exe};
\node[blok,doel,minimum width=26mm, anchor=west](jar11) at (jar1.west) {Jar};
\node[blok,lib,minimum width=12mm, anchor=west, xshift=9mm](java) at (cbci.east) {Java};

\node[anchor=south east, yshift=-1mm] at (crts.north east) {{\tiny\shortstack[r]{runtime\\system}}};
\node[anchor=south west, yshift=-1mm] at (cbci.north west) {{\tiny\shortstack[l]{bytecode\\interpreter}}};
\node[anchor=south, yshift=-1mm] at (java.north) {{\tiny\shortstack{graph\\interpreter}}};

\path [draw, line width=1.5pt, -> ] (hs1.south) -- (eh1.north) ;
\path [draw, line width=1.5pt, -> ] (hs2.south) -- (eh2.north) ;
\path [draw, line width=1.5pt, -> ] (eh1.south) -- (core1.north);
\path [draw, line width=1.5pt, -> ] (eh2.south) -- (core2.north);

\path [draw, line width=1.5pt, -> ] (core1) edge [in=180,out=150,loop] (core1) ;
\path [draw, line width=1.5pt, <- ] (core2) edge [in=0,out=30,loop] (core2) ;

\path [draw, line width=1.5pt, -> ] (core1.south) -- (grin1.north);
\path [draw, line width=1.5pt, -> ] (core2.south) -- (grin2.north);

\path [draw, line width=1.5pt, -> ] (grin1) edge [in=195,out=165,loop] (grin1) ;
\path [draw, line width=1.5pt, <- ] (grin2) edge [in=345,out=15,loop] (grin2) ;
\path [draw, line width=1.5pt, -> ] (grin0) edge [in=345,out=15,loop] (grin0) ;
\path [draw, line width=1.5pt, -> ] (silly0) edge [in=345,out=15,loop] (silly0) ;

\path [draw, line width=1.5pt, -> ] (grin1.south) -- (bc1.north);
\path [draw, line width=1.5pt, -> ] (grin2.south) -- (bc2.north);
\path [draw, line width=1.5pt, -> ] (bc1.south) -- (c1.north);
\path [draw, line width=1.5pt, -> ] (bc2.south) -- (c2.north);


\path [draw, line width=1.5pt, -> ] (core1.235) -- (core0.north east);
\path [draw, line width=1.5pt, -> ] (core2.235) -- (core0.north east);

\path [draw, line width=1.5pt, -> ] (core1.305) -- (jvm1.north west);
\path [draw, line width=1.5pt, -> ] (core2.305) -- (jvm2.north west);

\path [draw, line width=1.5pt, -> ] (core00.south) -- (grin00.north);
\path [draw, line width=1.5pt, -> ] (grin00.south) -- (silly00.north);
\path [draw, line width=1.5pt, -> ] (silly00.south) -- +(down:4mm);
\path [draw, line width=1.5pt, -> ] (c00.south) -- +(down:4mm);
\path [draw, line width=1.5pt, <- ] (cil.north) -- +(up:4mm);

\path [draw, line width=1.5pt, -> ] (crts.225) -- +(down:4mm);
\path [draw, line width=1.5pt, -> ] (crts.315) -- +(down:4mm);
\path [draw, line width=1.5pt, -> ] (c1.south) -- +(down:4mm);
\path [draw, line width=1.5pt, -> ] (c2.south) -- +(down:4mm);
\path [draw, line width=1.5pt, -> ] (cbci.225) -- +(down:4mm);

\path [draw, line width=1.5pt, -> ] (jvm1.235) -- +(down:33mm);
\path [draw, line width=1.5pt, -> ] (jvm2.305) -- +(down:33mm);

\path [draw, line width=1.5pt, -> ] (java.south) -- +(down:4mm);



\end{tikzpicture}
\end{center}
\end{frame}









%%]

%%[toolsAG
%%]

%%[agInUHC

\begin{frame}
\frametitle{AG applied in UHC}
Desired Core transformation:

\begin{center}
\begin{tikzpicture}
\matrix[ampersand replacement=\&,column sep=1em]
{ \node(from){
   \begin{minipage}{.25\linewidth}
%%[[wrap=safecode
let  y  =  z  in
let  x  =  y  in
     x + y
%%]]
   \end{minipage}
  } ; \&
  \node(to){
   \begin{minipage}{.25\linewidth}
%%[[wrap=safecode
let  y  =  z  in
let  x  =  y  in
     redOn ^ z ^ blackOn ^ + redOn ^ z ^ blackOn
%%]]
   \end{minipage}
  } ; \\
} ;
\draw [->,thick] (from.east) -- (to.west) ;
\end{tikzpicture}
\end{center}

Eliminate name aliases

\uncover<2->{
\begin{itemize}
\item Gather introduced bindings bottom up
\item Distribute gathered bindings top down
\item Compute transformed tree bottom up, \\variable occurrences possibly replaced
\end{itemize}
}

\end{frame}

\begin{frame}
\frametitle{AG applied in UHC}
\begin{itemize}
\item
AG tree structure for Core:

%%[[wrap=safecode
DATA Expr
  | Let         binds           :  BindL            ^^ ^^ body            : Expr
  | Var         nm              :  String
  | App         func            :  Expr             ^^ ^^ arg             : Expr
  ...

DATA Bind
  | Bind        nm              :  String           ^^ ^^ expr            : Expr

TYPE BindL      =   [Bind]
%%]]

\item<2>
Auxiliary Haskell types for gathering and distributing bindings:

%%[[wrap=safecode
type N2E = Map String Expr
%%]]
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{AG applied in UHC}
%%[[wrap=safecode
ATTR Bind BindL [ | | n2eG USE {`union`} {empty}: N2E ]

SEM Bind
  | Bind        lhs         .   n2eG        =   maybe empty (@nm ^^ `singleton`) @expr.mvTrf
%%]]

\uncover<2->{
%%[[wrap=safecode
ATTR Expr [ | | mvTrf: {Maybe Expr} ]

SEM Expr
  | Var         lhs         .   mvTrf       =   Just @trf
  | * - Var     lhs         .   mvTrf       =   Nothing
%%]]
}

\uncover<3->{
%%[[wrap=safecode
ATTR Expr Bind BindL [ n2e: N2E | | ]

SEM Expr
  | Let         loc         .   n2e'        =   map  (\t@(Expr_Var n)
                                                       -> findWithDefault t n @lhs.n2e)
                                                     @binds.n2eG
                            .   n2e         =   @n2e' `union` @lhs.n2e
%%]]
}

\uncover<4->{
%%[[wrap=safecode
ATTR Expr Bind BindL [ | | trf: SELF ]

SEM Expr  | Var         lhs         .   trf         =   findWithDefault @trf @nm @lhs.n2e
%%]]
}
\end{frame}

%%]

%%[aspectsAndVariants
\begin{frame}
\frametitle{Variants and aspects}

Variant: a step in the stepwise growth in language features

Aspect: a set of attributes and its resulting computation

E.g. aspect \textit{typing} for the first variants of UHC:

\begin{itemize}
\item variant {\color{uured}1}: simply typed |lambda|-calculus

%%[[wrap=safecode
i  ::  Int
i  =   5
%%]]

\item<2-> variant {\color{uured}3}: polymorphic type inference
\visible<2->{

%%[[wrap=safecode
id x  =   x
%%]]

infers |id :: forall ^ a . a -> a|
}

\item<3-> variant {\color{uured}4}: higher ranked types
\visible<3->{

%%[[wrap=safecode
f :: (forall ^ a . a -> a) -> (Char,Int)
f i = (i 'x', i 5)

v = f id
%%]]

allows polymorphic use of argument |i| inside |f|
}


\end{itemize}

\end{frame}


\begin{frame}
\frametitle{Variants}

In UHC

\begin{enumerate}
\item[~]<2-> \makebox[50mm][l]{{\color{uured}plain Haskell}}                  {\color{uured}experiments}
\item<1-> \makebox[50mm][l]{$\lambda$-calculus, type checking}
\item<1-> \makebox[50mm][l]{type inference}
\item<1-> \makebox[50mm][l]{polymorphism}
\item<1-> \makebox[50mm][l]{}                                  \visible<2->{higher ranked types, existentials}
\item<1-> \makebox[50mm][l]{data types}
\item<3-> \makebox[50mm][l]{kind inference}                    kind signatures
\item<3-> \makebox[50mm][l]{records}                           tuples as records
\item<3-> \makebox[50mm][l]{code generation}                   full program analysis
\item<3-> \makebox[50mm][l]{classes, type-synonyms}            extensible records
\setcounter{enumi}{19}
\item<4-> \makebox[50mm][l]{modules}
\setcounter{enumi}{94}
\item<4-> \makebox[50mm][l]{`deriving'}                      exceptions
\setcounter{enumi}{98}
\item<4-> \makebox[50mm][l]{prelude, I/O}
\end{enumerate}

\end{frame}



\begin{frame}
\frametitle{Variants and aspects}

\begin{itemize}
\item Two dimensions for partitioning the description of UHC
\item Combination of variant and aspects can be build as a compiler
 \begin{itemize}
 \item Isolation of language feature and aspect
 \item For debugging, experimentation, explanation
 \end{itemize}
\item Code is partitioned in small chunks
 \begin{itemize}
 \item Tagged with variant number and aspect name
 \item Processed by tool (Shuffle) to generate AG and/or Haskell input
 \end{itemize}
\item Last variant + all aspects = UHC
\end{itemize}

\end{frame}



\begin{frame}
\frametitle{Variants and aspects}

\begin{center}
\begin{tikzpicture}
  [minimum height=1.5em,
   column 1/.style={anchor=east},
   column 2/.style={anchor=east},
   column 3/.style={minimum width=4em},
   column 4/.style={minimum width=4em},
   column 5/.style={minimum width=4em},
   column 6/.style={minimum width=7em},
   row 10/.style={anchor=north},
   row 11/.style={anchor=north},
   row 12/.style={anchor=north},
   block/.style={rectangle,  fill=uured!20, text centered},
   valida/.style={rectangle,  fill=uured!20, text centered},
   validb/.style={rectangle,  fill=uured!40, text centered},
  ]

\def\valid{\node<4->[valida]{\(\checkmark\)}}
\def\valida{\node<4>[valida]{\(\checkmark\)}}
\def\validb####1{\node<5>(####1)[validb]{\(\checkmark\)}}
\matrix[ampersand replacement=\&]
{

    \& \node[red]{\textit{variants}} ;
    \& 
    \&
    \&
    \& \node(topright){} ;
\\
\node{99:} ;
    \& \node(topleft){libraries} ;
    \& \valid ;
    \& \valid ;
    \& \node<2->[block](uhc){UHC} ;
    \&
\\
%% \node{\(\cdots\)} ;
    \& \node{\(\cdots\)} ;
    \& \valid ;
    \& \valid ;
    \& \valid ;
    \&
\\
\node{20:} ;
    \& \node{modules} ;
    \& \valid ;
    \& \valid ;
    \& \valid ;
    \&
\\
%% \node{\(\cdots\)} ;
    \& \node{\(\cdots\)} ;
    \& \valid ;
    \& \valid ;
    \& \valid ;
    \&
\\
\node{9:} ;
    \& \node{classes} ;
    \& \valid ;
    \& \valid ;
    \& \valid ;
    \& \node<3->[block]{Ext Recs} ;
\\
\node(variantx){8:} ;
    \& \node{primitives} ;
    \& \valid ;
    \& \valid ;
    \& \valida ; \validb{calloutaloc} ; % node<5>(calloutaloc)[validb]{\(\checkmark\)} ;
    \&
\\
%% \node{\(\cdots\)} ;
    \& \node{\(\cdots\)} ;
    \& \valid ;
    \& \valid ;
    \&
    \&
\\
\node{1:} ;
    \& \node{|lambda|-calculus} ; 
    \& \valid ;
    \& 
    \&
    \&
\\

    \& \node(botleft)[anchor=north east]{} ;
    \& \node{parsing} ;
    \& \node{typing} ;
    \& \node(aspectx){codegen} ;
    \& \node(botright){experiment} ;
\\

    \& 
    \& 
    \& 
    \&
    \& \node[red]{\textit{aspects}} ;
\\

    \& 
    \& 
    \& 
    \&
    \& \node[red]{\textit{(accumulative)}} ;
\\
};
\draw [thick]
  (botleft.north east) -- (topleft.north east)
  (botleft.north east) -- (botright.north east);
%% \node<2->[anchor=south] at (uhc.north) {bla} ;

\node<5>(callouta)[anchor=north east,rectangle callout, drop shadow, fill=black!15, callout absolute pointer={(calloutaloc)}] at (topright.north east) {\parbox{.235\linewidth}{
\begin{verbatim}
%%%[(8 typing codegen)
...
%%%]
\end{verbatim}
}} ;
%\draw<5>[->] (callouta) -- (variantx) ;
%\draw<5>[->] (callouta) -- (aspectx) ;

\end{tikzpicture}
\end{center}

\end{frame}



%%]

%%[conclusions

\begin{frame}
\def\hsColor{yellow!50}
\def\agColor{green!50}
\def\cColor{blue!30}
\gdef\bar####1(####2)(####3){\draw[black,fill=####1] (####2) rectangle (####3)}
\gdef\barHS(####1)(####2){\bar{\hsColor}(####1)(####2)}
\gdef\barAG(####1)(####2){\bar{\agColor}(####1)(####2)}
\gdef\barC(####1)(####2){\bar{\cColor}(####1)(####2)}
\frametitle{Statistics: Lines of Code (LOC)}

\global\newcounter{yyaccum}
%\global\def\yaccum{0}

\begin{center}
\begin{tikzpicture}
  [yscale=0.2,xscale=0.7]
%\draw [help lines] grid (11,30);
\foreach \x/\lbl/\ys in
   {0/Utility/{1.7,18.3,0},
    1/Haskell/{6.7,3.3,0},
    2/EH/{11.2,0.6,0},
    3/Typing/{8.0,7.5,0},
    4/Core/{7.1,1.0,0},
    5/ByteCode/{2.1,0,0},
    6/Grin/{11.3,1.6,0},
    7/Silly/{2.8,0,0},
    8/Exp Backends/{2.5,0.4,0},
    9/Runtime/{0,0,8.1},
    10/GC/{0,0,6.0,}}
 {
  \pgfmathsetcounter{yyaccum}{0};
  %\pgfmathsetmacro{yaccum}{0}
  \foreach \y in \ys
  {
   %\draw (\x,\y) circle (0.1cm);
   %\pgfmathsetmacro{yaccum}{\y + \yaccum}
   %\pgfmathaddtocounter{yyaccum}{1};
  } ;
  \node[rotate=-45,anchor=north west] at (\x+0.4,0) {\lbl} ;
 } ;

\foreach \y/\lbl in {0/0,5/5000,10/10000,15/15000,20/20000}
 {
  \node[anchor=east] at (0,\y) {\lbl} ;
 };

%%% 0:
\barAG(0,0)(1,1.7) ;
\barHS(0,1.7)(1,20) ;

%%% 1:
\barAG(1,0)(2,6.7) ;
\barHS(1,6.7)(2,10) ;

%%% 2:
\barAG(2,0)(3,11.2) ;
\barHS(2,11.2)(3,11.8) ;

%%% 3:
\barAG(3,0)(4,8.0) ;
\barHS(3,8.0)(4,15.5) ;

%%% 4:
\barAG(4,0)(5,7.1) ;
\barHS(4,7.1)(5,8.1) ;

%%% 5:
\barAG(5,0)(6,2.1) ;

%%% 6:
\barAG(6,0)(7,11.3) ;
\barHS(6,11.3)(7,12.9) ;

%%% 7:
\barAG(7,0)(8,2.8) ;

%%% 8:
\barAG(8,0)(9,2.5) ;
\barHS(8,2.5)(9,2.9) ;

%%% 9:
\barC(9,0)(10,8.1) ;

%%% 10:
\barC(10,0)(11,6) ;

\matrix[ampersand replacement=\&, anchor=north west] at (11,21)
{
\node[black,fill=\agColor] {AG}; \& \node{53.4\%};  \\
\node[black,fill=\hsColor] {HS}; \& \node{32.5\%};  \\
\node[black,fill=\cColor] {C}; \& \node{14.1\%};  \\
};

\end{tikzpicture}
\end{center}

%% \begin{tabular}{l||rrrr||rr}
%% subsystem    & \multicolumn{4}{c||}{All variants and aspects}    & \multicolumn{2}{c}{UHC only} \\
%%              &    AG      &    HS      &     C      &    total   &    total   &  fract.  \\\hline
%% utility/general&   1.7    &    18.3    &            &    20.0    &    14.0    &    70\%  \\
%% Haskell      &     6.7    &     3.3    &            &     9.9    &     6.9    &    70\%  \\
%% EH           &    11.2    &     0.6    &            &    11.8    &     6.7    &    57\%  \\
%% EH typing    &     8.0    &     7.5    &            &    15.5    &     7.0    &    45\%  \\
%% Core         &     7.1    &     1.0    &            &     8.0    &     4.7    &    58\%  \\
%% ByteCode     &     2.1    &            &            &     2.1    &     1.7    &    82\%  \\
%% Grin         &    11.3    &     1.6    &            &    12.9    &     8.5    &    66\%  \\
%% Silly        &     2.8    &            &            &     2.8    &     2.6    &    93\%  \\
%% exp.backends &     2.5    &     0.4    &            &     2.9    &     0.8    &    26\%  \\
%% runtime system&           &            &     8.1    &     8.1    &     6.2    &    77\%  \\
%% garb.collector&           &            &     6.0    &     6.0    &     0.7    &    11\%  \\\hline
%% total        &    53.4    &    32.5    &    14.1    &   100.0    &    59.8    &    60\%  \\
%% \end{tabular}

\end{frame}


\begin{frame}
\frametitle{Conclusions}

Use of {\color{uured} Attribute Grammar} is essential for dealing with description \& coding complexity:

\begin{itemize}
\item Much boilerplate code for treewalks is avoided
\item Aspects can be described separately
\item Separately described aspects are combined by the AG compiler
\item AG compiler takes care of plumbing all code as one fold and ordering of attribute computations
\item Scales up in the number of combined aspects
\end{itemize}

But

\begin{itemize}
\item You have to learn it  %%%, and other used domain specific languages as well
\end{itemize}

\end{frame}


\begin{frame}
\frametitle{Conclusions}

Use of {\color{uured} variants and aspects} is essential for dealing with design complexity:

\begin{itemize}
\item Language features are isolated in a variant
\end{itemize}

But

\begin{itemize}
\item Inherent language \& implementation complexity is not decreased, only made more manageable
\item Chosen partitioning into variants is difficult to adapt
\end{itemize}

\end{frame}



\begin{frame}
\frametitle{Conclusions}

{\color{uured} include this????}

Use of {\color{uured} domain specific languages} and {\color{uured} generation} is essential for dealing with maintenance complexity:

\begin{itemize}
\item Avoids duplicates consistency pitfall by generating from shared description
\end{itemize}

But

\begin{itemize}
\item More complex build system
\end{itemize}

\end{frame}



%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]
