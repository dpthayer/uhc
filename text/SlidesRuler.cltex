%%[title
\frame<presentation>{\titlepage}
%%]

%%[problem
\frame<presentation>
{
\frametitle{Motivation}
\begin{itemize}
\item Programming language design and implementation where many features are combined
\begin{itemize}
\item Essential Haskell (EHC project)
\end{itemize}
\item Example experiment: exploitation of type signatures
%%[[wrap=safecode
%%@[file:test/4-impred-demo1.eh%%]
%%]
\item Our desire: combine such features with others (like class system)
\begin{itemize}
\item \emph{and} keep the implementation maintainable, understandable
\end{itemize}
\end{itemize}
}

\frame<presentation>
{
\frametitle{The problem}
\begin{itemize}
\item Features can be dealt with in isolation in a cleanroom situation
\begin{itemize}
\item but how do they interact in combination?
\end{itemize}
\item The combination of features easily leads to entanglement in description and implementation
\begin{itemize}
\item but how do we achieve separation across specification and implementation?
\end{itemize}
\item Specification, explanation and implementation can be described separately
\begin{itemize}
\item but how do we achieve mutual consistency?
\end{itemize}
\end{itemize}
}

\frame<presentation>
{
\frametitle{Motivational example}
\begin{itemize}
\item Suppose you have a language
\begin{tabular}%
%%@AppxNotation.termTableFormat
%%@AppxNotation.rulerExpr
\end{tabular}
\item With a type system specification (partially given)
\[
\rulerCmdUse{rulerDemo.E.expr.base.e.var}
\quad
\rulerCmdUse{rulerDemo.E.expr.base.e.app}
\]
\end{itemize}
}

\frame<presentation>
{
\frametitle{Motivational example}
\begin{itemize}
\item With an Attribute Grammar implementation (partially given)
%%[[wrap=safecode
DATA Expr
  | Var  i : {String}

%%@rulerDemoAG.3.expr.ATTR

%%@rulerDemoAG.3.expr.e.var
%%]
\item Its mutual consistency is relatively easy to see
\end{itemize}
}

\frame<presentation>
{
\frametitle{Motivational example}
The problem is complexity, arising with feature combination
\begin{itemize}
\item EHC: impredicativity propagation algorithm (for application)
\begin{eqnarray*}
&& \fbox{\rulerCmdUse{rules3.I2.expr.base.scheme}}
\\
&& \rulerCmdUse{rules3.I2.expr.base.e.app}
\end{eqnarray*}
\end{itemize}
}

\frame<presentation>
{
(Just for the idea)
{\footnotesize
%%@EHRulerRules.42.expr.e.app wrap=safecode
}
}

%%]

%%[issues
\section{Issues}

\frame<presentation>
{
\frametitle{The question}
How can you be sure the implementation really implements the type system?
\begin{itemize}
\item Prove it (after the construction of both)
\begin{itemize}
\item proving correctness of programs is difficult
\end{itemize}
\item Prove correctness of type system against a simple model,
then generate the implementation
\begin{itemize}
\item real languages are still too complex to be mechanically proven correct
\item lack of full specification of real languages
\end{itemize}
\item Ruler: describe type rules such that pretty printed version and implementation can be generated
\begin{itemize}
\item not proven correct, but at least consistent
\end{itemize}
\end{itemize}
}

\frame<presentation>
{
\frametitle{Ruler}
\begin{itemize}
\item Ruler system
\begin{itemize}
\item domain specific language for specifying type rules
\item support for separate and incremental type rule specifications
\end{itemize}
\item We want to check
\begin{itemize}
\item have judgements in a rule the right structure (similar to type checking for expressions)
\item are identifiers defined before used (when specifying the algorithmic part)
\item ... more in the future
\end{itemize}
\item We want to generate
\begin{itemize}
\item \LaTeX\ pretty printed version (to include in a description)
\item Attribute Grammar fragments (to include in an implementation)
\end{itemize}
\end{itemize}
}

\frame<presentation>
{
\frametitle{Ruler}
\begin{itemize}
\item Is
\begin{itemize}
\item a system supporting a mutually consistent description and implementation of a multiple feature programming language
\item born from a real/practical need as a solution to this particular problem
\end{itemize}
\item Is not
\begin{itemize}
\item a system proving the usual type system properties
\item nor any other holy grail
\end{itemize}
\item But
\begin{itemize}
\item Ruler can be extended to generate input for other tools
\end{itemize}
\end{itemize}
}

%%]

%%[content
\frame<presentation>
{
\frametitle{Content of remainder of talk}
\begin{itemize}
\item Overall design of Ruler
\item Hindley-Milner (HM) type system as a case study
\item Description partitioned in three views/steps (declarative, algorithmic, AG)
\item How to specify this using Ruler
\item Aspects (work in progress)
\item Conclusion
\end{itemize}
}

%%]

%%[overview
\frame<presentation>
{
\frametitle{Ruler within context}
\FigCenterXFigTex{ruler-overview}
}

\frame<presentation>
{
\frametitle{Ruler concepts}
\begin{itemize}
\item Scheme
 \begin{itemize}
 \item judgement structure: holes + template (for specification and output generation)
 \end{itemize}
\item Views
 \begin{itemize}
 \item hierarchy of views, a view is built on top of previous view
 \end{itemize}
\item Views of a scheme
 \begin{itemize}
 \item each scheme has views, views differ in holes + template
 \end{itemize}
\item Template, or Judgement shape
 \begin{itemize}
 \item the shape used to specify/pretty-print an instance of a scheme (a judgement)
 \end{itemize}
\item Rule
 \begin{itemize}
 \item premise judgements + conclusion judgement
 \item judgement binds its scheme holes to expressions
 \end{itemize}
\item Views of a rule
\item Rule judgement
 \begin{itemize}
 \item each rule judgement has views, parallel to views of its scheme
 \end{itemize}
\end{itemize}
}

\frame<presentation>
{
\frametitle{Ruler `dimensions'}
\begin{itemize}
\item Views allow incremental extension of a language
\item Schemes allow ``by aspect'' organisation by treating holes and associated rules together
\item Ruler
 \begin{itemize}
 \item combines views in a hierarchical, inheriting manner
 \item combines schemes into new schemes
 \item combine |===| overwrite (of hole bindings)
 \end{itemize}
\end{itemize}
}

\frame<presentation>
{
\frametitle{Ruler `dimensions'}
\begin{itemize}
\item In EHC:
\FigCenterPDF{ag-ast-asp}
\end{itemize}
}

\frame<presentation>
{
\frametitle{Syntactic structure}
{\footnotesize
%%@TopicRuler.rulerSrcTemplate wrap=safecode
}
}
%%]

%%[shortBody
\frame<presentation>
{
\frametitle{Views}
\begin{itemize}
\item Specify subsequent views, building on top of eachother, starting with the first:
\[
\rulerCmdUse{rulerDemo.E.expr.base.e.var}
\]
\item And then the differences relative to the previous
\[
\rulerCmdUse{rulerDemo.A.expr.base.e.var}
\]
\end{itemize}
}

\frame<presentation>
{
\frametitle{Specification}
\begin{itemize}
\item Structure/scheme for judgements
%%[[wrap=safecode
%%@rulerDemoRL.1.expr.scm 
%%@rulerDemoRL.1.expr.scm.E
%%@rulerDemoRL.2.expr.scm.A
%%]
\end{itemize}
}

\frame<presentation>
{
\frametitle{Judgements in rules}
\begin{itemize}
\item Instantiation of scheme
%%[[wrap=safecode
%%@rulerDemoRL.1.expr.base.rls
%%@rulerDemoRL.1.rl.e.var
%%@rulerDemoRL.1.rl.e.var.E
%%@rulerDemoRL.2.rl.e.var.A
%%]
\end{itemize}
}

\frame<presentation>
{
\frametitle{AG code generation}
\begin{itemize}
\item Translation to AG
%%[[wrap=safecode
%%@rulerDemoAG.3.expr.e.var
%%]
\item (With additional specification for freshness and lookup)
\end{itemize}
}
%%]

%%[basicsAndViews
\frame<presentation>
{
\frametitle{Views}
\begin{itemize}
\item Views are ordered
\item Start with specifying the first view on a rule (say, \ruleRef{e.var})
\[
\rulerCmdUse{rulerDemo.E.expr.base.e.var}
\]
 \begin{itemize}
 \item equational/declarative view |E| (in Hindley-Milner type system)
 \end{itemize}
\item Then specify the differences relative to previous view
\[
\rulerCmdUse{rulerDemo.A.expr.base.e.var}
\]
 \begin{itemize}
 \item algorithmic view |A| (in Hindley-Milner type system)
 \item use of colors, grey |===| unchanged, blue |===| changed
 \end{itemize}
\end{itemize}
}

\frame<presentation>
{
\frametitle{Step 1: equational view |E|, |expr| scheme}
\begin{itemize}
\item Structure/scheme for judgements
%%[[wrap=safecode
%%@rulerDemoRL.1.expr.scm 
%%@rulerDemoRL.1.expr.scm.E
%%]
\item Type (|ty: Ty|):
\begin{tabular}%
%%@AppxNotation.termTableFormat
%%@AppxNotation.rulerTy
\end{tabular}
\item Environment (|gam: Gam|):
%%[[wrap=safecode
Gamma   ::=  Vec(i :-> sigma)
%%]
\end{itemize}
}

\frame<presentation>
{
\frametitle{Ruleset}
\begin{itemize}
\item Set of rules of a scheme
%%[[wrap=safecode
%%@rulerDemoRL.1.expr.base.rls
%%@rulerDemoRL.1.rl.e.app
%%@rulerDemoRL.1.rl.e.app.E
%%]
 \begin{itemize}
 \item ruleset displays as a figure (not shown here)
 \end{itemize}
\item \LaTeX\ rendering (via |lhs2TeX|)
\[
\rulerCmdUse{rulerDemo.E.expr.base.e.app}
\]
\end{itemize}
}

\frame<presentation>
{
\frametitle{Relation}
\begin{itemize}
\item Arbitrary conditions
%%[[wrap=safecode
%%@rulerDemoRL.1.rl.e.var
%%@rulerDemoRL.1.rl.e.var.E
%%]
\item \LaTeX\ rendering
\[
\rulerCmdUse{rulerDemo.E.expr.base.e.var}
\]
\item Relation
%%[[wrap=safecode
%%@rulerDemoRL.1.gamLookupIdTy
%%]
\end{itemize}
}

\frame<presentation>
{
\frametitle{Step 2: algorithmic view |A|}
\begin{itemize}
\item On top of view |E|
\item View hierarchy
%%[[wrap=safecode
%%@rulerDemoRL.1.viewhierarchy
%%]
 \begin{itemize}
 \item may be tree like hierarchy
 \end{itemize}
\item Algorithmic view
 \begin{itemize}
 \item use of constraints/substitution
%%[[wrap=safecode
Cnstr   ::=  Vec(tvarv :-> tau)
%%]
 \item computation has direction
 \end{itemize}
\end{itemize}
}

\frame<presentation>
{
\frametitle{Direction of computation}
\begin{itemize}
\item Holes
 \begin{itemize}
 \item specify direction (similar to AG's attributes)
 \end{itemize}
%%[[wrap=safecode
%%@rulerDemoRL.1.expr.scm
%%@rulerDemoRL.2.expr.scm.A
%%]
 \begin{itemize}
 \item may be tree like hierarchy
 \end{itemize}
\item Algorithmic view
 \begin{itemize}
 \item use of constraints/substitution
%%[[wrap=safecode
Cnstr   ::=  Vec(tvarv :-> tau)
%%]
 \item computation has direction
 \end{itemize}
\end{itemize}
}

\frame<presentation>
{
\frametitle{View |A| on |App|}
\begin{itemize}
\item Specify the differences (for rule e.app)
\item Previous
\[
\rulerCmdUse{rulerDemo.E.expr.base.e.app}
\]
\item New
\[
\rulerCmdUse{rulerDemo.A.expr.base.e.app}
\]
\end{itemize}
}

\frame<presentation>
{
\frametitle{View |A| on |App|}
\begin{itemize}
\item New:
%%[[wrap=safecode
%%@rulerDemoRL.2.rl.e.app.A
%%]
\end{itemize}
}

\frame<presentation>
{
\frametitle{Step 3: AG translation view |AG|}
\begin{itemize}
\item Building on top of view |A|
\item Mapping holes to attributes
 \begin{itemize}
 \item either value construction or deconstruction
 \end{itemize}
\item Fresh type variables
 \begin{itemize}
 \item threading unique value
 \end{itemize}
\item Error handling
 \begin{itemize}
 \item `side effect': error messages in hidden attribute
 \end{itemize}
\item The rest
 \begin{itemize}
 \item parsing, pretty printing, ...
 \end{itemize}
\end{itemize}
}

\frame<presentation>
{
\frametitle{View |AG| on |App|}
\[
\rulerCmdUse{rulerDemo.AG.expr.base.e.app}
\]

%%[[wrap=safecode
%%@rulerDemoAG.3.expr.e.app
%%]
}

\frame<presentation>
{
\frametitle{Fresh type variable}
\begin{itemize}
\item Relation is inlined
%%[[wrap=safecode
%%@rulerDemoRL.2.tvFresh
%%]
\item Keyword |unique|
 \begin{itemize}
 \item insertion of |rulerMk1Uniq|
 \item translated to |uniq1|
 \end{itemize}
\item Type structure (supporting code)
%%[[wrap=safecode
%%@RulerDemoUtils.3.Ty
%%]
\end{itemize}
}

\frame<presentation>
{
\frametitle{Rewriting |Ruler| expressions}
\begin{itemize}
\item |Ruler| expression
 \begin{itemize}
 \item |ty.a -> ty| pretty prints as |taua -> tau|
 \item but requires rewriting for AG
 \end{itemize}
\item Rewrite rule
%%[[wrap=safecode
rewrite ag def  a -> r = (a) `Ty_Arr` (r)
%%]
 \begin{itemize}
 \item target: |ag|
 \item when value is |def|ined (constructed) for further use
 \end{itemize}
\item Constraining rewrite rule using |Ruler| (sort of) types
%%[[wrap=safecode
%%@rulerDemoRL.3.rw.TyArr
%%]
\item Formatting identifiers (for target |ag|)
%%[[wrap=safecode
%%@rulerDemoRL.3.fmt
%%]
\end{itemize}
}

\frame<presentation>
{
\frametitle{Error handling}
\begin{itemize}
\item Relation |match| is inlined
%%[[wrap=safecode
%%@rulerDemoRL.2.match
%%]
\item Returns extra value: error messages (if any)
\item Type matching (supporting code)
%%[[wrap=safecode
%%@RulerDemoUtils.3.match.A
...
%%]
\end{itemize}
}

%%]

%%[aspectCombination
\frame<presentation>
{
\frametitle{Aspects}
\begin{itemize}
\item Example from EHC: expression application
\begin{eqnarray*}
&& \fbox{\rulerCmdUse{rules4.I1.expr.base.scheme}}
\\
&& \rulerCmdUse{rules4.I1.expr.base.e.app}
\end{eqnarray*}
\end{itemize}
}

\frame<presentation>
{
\frametitle{Aspects}
\begin{itemize}
\item Separate aspect: extraction of quantified types
\begin{eqnarray*}
&& \fbox{\rulerCmdUse{rules4.I2.expr.impr.scheme}}
\\
&& \rulerCmdUse{rules4.I2.expr.impr.e.app}
\end{eqnarray*}
\end{itemize}
}

\frame<presentation>
{
\frametitle{Aspects}
\begin{itemize}
\item Combination
\begin{eqnarray*}
&& \fbox{\rulerCmdUse{rules4.I2.expr.base.scheme}}
\\
&& \rulerCmdUse{rules4.I2.expr.base.e.app}
\end{eqnarray*}
\end{itemize}
}

\frame<presentation>
{
\frametitle{Aspect combination}
\begin{itemize}
\item Defined in terms of scheme combination and rule combination
\item Scheme combination:
%%[[wrap=safecode
scheme expr =
  view E =
    holes [ node e: Expr, valGam: ValGam | ty: Ty | ]
        | scheme expr.invisible
  ...
  view I1 = ...
  view I2 = holes scheme expr.impr

scheme expr.impr =
  view I2 =
    holes [ extern valGam: ValGam, ... | ... | ity: Ty ]
%%]
\end{itemize}
}

\frame<presentation>
{
\frametitle{Rule combination}
%%[[wrap=safecode
ruleset expr.base scheme expr =
  rule e.app =
    view E =
      judge F : expr = valGam :- eFun : (ty.a -> (ty|Ty))
      judge A : expr = valGam :- eArg : ty.a
      -
      judge R : expr = valGam :- (eFun ^^ eArg) : ty
    ...
    view I2 = ruleset expr.impr rule e.app

ruleset expr.impr scheme expr.impr =
  rule e.app =
    view I2 =
      judge F : expr.impr = ...
      ...
      -
      judge R : expr.impr = ...
%%]
}
%%]

%%[conclusion
\section{Conclusion}

\frame<presentation>
{
\frametitle{Conclusion}
\begin{itemize}
\item Lightweight solution to two problems
\begin{itemize}
\item Consistency between type rules and (AG) implementation
\item Understandability by stepwise construction
\end{itemize}
\item Related work
\begin{itemize}
\item TinkerType, TWELF, AG alike systems
\end{itemize}
\end{itemize}
}


%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

