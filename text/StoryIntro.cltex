%%[introPHD
This thesis contains a description of an implementation of an extended subset of the programming language Haskell.
At the same time it is an experiment in merging the description with the actual code
of the implementation,
thus guaranteeing some form of consistency.
The thesis is also about making description and implementation understandable,
so that it can be used as a means for education and (Haskell) programming language research.
In this thesis we take a stepwise approach to both description and implementation,
which starts with a simple version of Haskell and then, step by step, we extend this simple version towards
an extended version of Haskell.

The reason to set out on this journey lies in the observation that Haskell
\cite{peytonjones03has98-rev-rep}
has become a complex language.
Haskell includes many productivity increasing features, some of which are of a more experimental nature.
Although also intended as a research platform, realistic compilers for Haskell \cite{www04ghc}
have grown over the years
and understanding and experimenting with
those compilers is not easy.
Experimentation on a smaller scale is usually based upon relatively simple and restricted implementations
\cite{jones99thih}, often focusing only on a particular aspect of
the language and/or its implementation.

A second reason is that experimenting with Haskell,
or language design in general,
usually expresses itself in a theoretical setting,
with a focus on the proof of formal properties.
Experimentation also takes place in a practical setting, but often it is not at all obvious how
theory and practice of an experiment relate.
We feel that a description of a Haskell implementation
which focusses on a joint presentation of the implementation
and its formal representation (by means of type rules),
and their mutual consistency, helps to bridge the gap between theory and practice.

The complexities of Haskell and its interaction with experimental features cannot be avoided;
even more, it is desirable, as Haskell plays an important role in programming language research.
Some of those experimental features turn into useful language constructs,
increasing the language complexity as a consequence.
The complexity can be made more manageable by looking at features individually,
while not loosing
sight of the context with which such a feature has to coexist.
This thesis aims at walking somewhere between this complexity and simplicity by describing
features individually,
as separate aspects of a more complex whole.

In the following section we first give an overview of our goals,
the overall organisation of the road to their realisation,
and the organisation of this thesis.
The remainder of the introduction takes the reader on a short tour through
the languages for which this thesis describes implementations.

\subsection{Overview}

\Paragraph{Holy and less holy grails}
\label{sec-intro-holygrail}
The holy grail of the EHC project \cite{dijkstra04ehc-web}, described by this thesis,
is to create the following:

\begin{Itemize}
\item
A compiler for Haskell plus extensions.
The goal is a compiler that can be used, and is not `just' a toy.
\item
A description of the compiler.
The goal is to offer understanding of the implementation
so it can be used for teaching, be a basis for experimentation,
and be a bridge between (type) theory and practice.
\end{Itemize}

Unlike a holy grail, we intend to reach our goal,
but we do not expect this to happen overnight.
However, our inspiration comes from \TeX,
for which documented source code constitutes a stable point of reference
\cite{knuth86tex-program}.
We also draw inspiration from the combination of type theory and implementation
in Pierce's book \cite{typing:types-prog-lang:pierce}.

On a less ambitious scale,
this thesis can be read with the following, somewhat overlapping,
viewpoints in mind;
each viewpoint comes with its own goal and design starting point:

\begin{Itemize}
\item
The thesis offers an explanation of the implementation of a Hindley-Milner type system
(\chapterRef{ehc1} through \chapterRef{ehc3}).
The explanation is expressed and explained in terms of type rules,
attribute grammar implementation for those type rules,
and additional infrastructure (encoded in Haskell) to extend it to a full compiler.
\item
The thesis offers experiments in combining explicitly specified type information (by the programmer),
and implicitly inferred type information (by the system) (\chapterRef{ehc4} through \chapterRef{ehc-partial-sig-quant-guess}).
The design starting point here is to let programmer and system jointly specify (the types in)
a program,
instead of the programmer fighting the system's limitations.
This starting point is inspired by the observation that systems purely based on
type inference hinder a programmer,
because such a system does not allow the programmer to specify what the system cannot infer.
\item
The thesis offers an experiment in the description of a compiler,
the required mechanisms to do such a job, and the tools to implement those mechanisms
(\chapterRef{secAGTut}, \chapterRef{ruler}, and other tools).
The design starting point is to partition the whole system into a sequence of steps,
each representing a standalone language and implementation.
Each step extends a previous step by adding some features.
All our tools therefore somehow need to be aware of the notion of separate steps 
(or views, versions).
\item
The thesis offers an experiment in creating a maintainable and explainable compiler.
The design starting point is that these aspects are best served by consistency,
and consistency between artefacts is best implemented by avoiding the inconsistency created
by duplication of shared material in the first place.
The code presented in the thesis and used for the construction of different versions of the compiler are
generated from common source code
(\appRef{appx-shuffle}).
The same holds for (the major part of) the type rules and their attribute grammar implementation
(\chapterRef{ruler}).
\end{Itemize}

Our work complements Pierce's book \cite{typing:types-prog-lang:pierce}
in the sense that we bring together type rules and their implementation,
instead of treating these separately.
On the other hand, Pierce provides proofs for various properties,
we don't.


\Paragraph{Thesis overview}
We assume the reader is familiar with Haskell.
We do not assume familiarity with the Attribute Grammar system (AG) used throughout
this thesis.
An AG tutorial is included (\chapterRef{agtut}),
but can safely be skipped if the reader is already familiar with the AG system
(see the roadmap in \figRef{fig-roadmap}).
For the remainder of this thesis we assume familiarity with type systems;
we informally introduce the necessary concepts,
but, as we focus on their implementation, the formalities of type systems are not discussed
in this thesis.

\FigureXFigTex{roadmap}{Thesis roadmap}{fig-roadmap}

\chapterRef{ehc1} through \chapterRef{ehc4C} are to be read in the proper order,
as they describe development steps of the first four of our series of compilers.
\chapterRef{ehc4B} has a more experimental character as it is not (yet) integrated into the
last compiler version,
so this part can be skipped.
\chapterRef{ehc-partial-sig-quant-guess} describes how we can make the specification of a type signature easier;
this subject is relatively independent of the previous chapters.
\chapterRef{ehc9} and \chapterRef{ruler} can be read in isolation,
as these chapters are based on (submitted) articles.

Throughout the description of the series of compilers we gradually shift from AG based
explanation to type rule based explanation combined with examples.
The code which implements those type rules is still referred to from the main text.
In the paper version of this thesis we refer to the electronic version
\cite{dijkstra04ehc-web} by means of \raisebox{-.3ex}{\WWWlogo} in the margin (\chunkHideRefWWW{intro-thesis-overview-www-pg}like here);
in the electronic version we refer to the proper appendix with a margin reference
\label{intro-thesis-overview-www-pg}
(\chunkHideRefAppx{intro-thesis-overview-www-pg}like this current page reference).
We will come back to this in our conclusion (\chapterRef{ehcConcl}).

\Paragraph{System overview}
The core of this thesis consists of a sequence of compilers, together named the Essential Haskell project,
abbreviated by EH.
The construction of these compilers and this thesis is accomplished by the use of several tools
(\figRef{system-fig-overview}):

\begin{Itemize}
\item
Fragment administration and combination (of source text)
is managed by a tool called
%if targetForPaper
|Shuffle|\chunkHideRefWWW{appx-shuffle}.
%else
|Shuffle| (\appRef{appx-shuffle}).
%endif
|Shuffle| has the same responsibility as weaving and tangling in literate programming \cite{www05litprog},
but allows a more flexible recombination of source fragments.
Because of its great resemblance to similar tools we will not discuss |Shuffle|.
\item
The |Ruler| system (\chapterRef{ruler}) generates a visual rendering for inclusion in this thesis,
and an AG implementation.
\item
The specification of the (remaining parts of the) implementation is expressed by an Attribute Grammar (AG) and
Haskell code.
\end{Itemize}

The partitioning into multiple steps, called \IxAsDef{views} in the remainder of this thesis,
influences the tools used.
A view extends another view by adding new material or replacing old material.
Either a tool manages views itself, or is unaware of views.
For example, the |Ruler| system manages named views on type rules.
However, Haskell compilers are not aware of our idea of views,
so |Shuffle| takes care of properly generating source code for views.

\FigurePDF{system-overview}{System overview}{system-fig-overview}

\Paragraph{Context of this thesis, project status}
This thesis represents a snapshot of the description of an ongoing project, the Essential Haskell (EH) project.
From the www site \cite{dijkstra04ehc-web} of the EH project both the source code and the electronic version of the
thesis can be downloaded;
the electronic version of the thesis includes more material than the paper version,
and will be updated regularly.
\figRef{eh-intro-implstatus} presents an overview of the features which are described in this thesis,
and which features are present in GHC (version 6.4 \cite{www04ghc});
the many features present in GHC but not in EH have not been included.
We have described the most informative parts:
the first chapters provide the basic structure of EH,
presenting type rules, and AG implementation side by side.
Remaining chapters describe experiments with explicit and implicit (type) information,
and the |Ruler| tool.

\begin{TabularCenterFigure}{Implementation status}{eh-intro-implstatus}{lp{.25\linewidth}llp{.25\linewidth}}
EH  & Feature(s) & Implemented & Chapter & In GHC \\
\hline
1	&	type checking	&	+	&	\myRef{ehc1}	&	+
\\
2	&	type inference	&	+	&	\myRef{ehc2}	&	+
\\
3	&	Hindley-Milner
		type inference	&	+	&	\myRef{ehc3}	&	+
\\
4	&	higher-ranked
		types, existential types
						&	+	&	\myRef{ehc4}, \myRef{ehc4B}, \myRef{ehc4C}
													&	+, existential types tied to data types
\\
5	&	data types		&	+	&	-				&	+
\\
6	&	kind inference,
		kind polymorphism
						&	+	&	-				&	+/-, no kind polymorphism
\\
7	&	records (non-extensible)
						&	+	&	-				&	+/-, tied to data types
\\
8	&	code-generation
						&	+/-	&	-				&	+
\\
9	&	class system,
		explicit implicit params
						&	+	&	\myRef{ehc9}	&	+/-, class system only
\\
10	&	records (extensible)
						&	+	&	-				&	-
\\
2 -	&	partial type signatures
						&	+	&	\myRef{ehc-partial-sig-quant-guess}
													&	-
\\
\end{TabularCenterFigure}

The source code presented in this thesis is exactly the same code as used for
the implementation.
Although the source code forms the core around which the thesis has been constructed,
only the first chapters of this thesis have incorporated source code.
Later chapters involve more complex issues,
which, we feel,
are better presented using examples and type rules.

Much of the type rule related AG code is generated directly from the type rules
by |Ruler| (\chapterRef{ruler}).
This is not (yet) done for all type rules (in particular, not for \chapterRef{ehc9});
\appRef{appx-genbyruler} provides a list of the type rules for which AG code is generated.
The use of |Ruler| allows us to focus on type rules,
but work still needs to be done (see also the conclusion, \chapterRef{ehcConcl}) to allow even more AG code to
be replaced by |Ruler| generated AG code.

Omitted source code is available via the EH project website \cite{dijkstra04ehc-web}.
Part of the code has been included as appendix-like material,
that is, it has been included, but outside the main story line
\footnote{References to non-inlined code have not yet been completely included;
the final version of this thesis is intended to be complete in this respect.}.

Between \chapterRef{ehc4C} and \chapterRef{ehc9} data types, kind inference/checking,
code generation for GRIN \cite{boquist96grin-optim,boquist99phd-optim-lazy},
and extensible records appear (\figRef{eh-intro-implstatus}).
Most of these features are required for the implementation of \chapterRef{ehc9};
their description will be included in later versions of the full description of EH,
to appear after the publication of this thesis.

Parts of this thesis have been published in an earlier version
or submitted to a conference\footnote{Acceptance will be known when this thesis goes to print.}
in a different form: \chapterRef{secIntro} through \chapterRef{ehc3} are updated from
an AFP (Advanced Functional Programming) tutorial 
\cite{dijkstra04thag}, and \chapterRef{ehc9} and \chapterRef{ruler}
have been submitted in a slighty extended form.

Additional work in the following areas is currently in progress:
\begin{Itemize}
\item
A compiler for GRIN \cite{boquist96grin-optim,boquist99phd-optim-lazy} to C--
\cite{www04cminusminus}.
We are also looking at extending GRIN with exceptions.
\item
Extending EH with GADT's (Generalised Algebraic Data Types).
\end{Itemize}



%%]

%%[goal
With this thesis we intend to achieve, over time, the following high-level goal:

\begin{quote}
A compiler for (an extended version of) Haskell which is extendable, understandable and maintainable.
\end{quote}

In this thesis this translates to the following, more concrete, goals and artefacts:

\begin{Itemize}
\item
All source material that appears in this thesis, the compiler, or other artefacts,
is shared in the form of source fragments,
which are then combined for use in text of executable.
This contributes to consistency between the compiler and its description.
\item
The description of the type system and its implementation are generated from one description.
This guarantees consistency between the formal notation of the static semantics and its implementation.
\item
The explanation of the compiler incorporating all features is organised as a sequence of small steps.
Each step focusses on a particular feature which is dealt with in relative isolation from
the preceding steps.
Each step corresponds to a working compiler in its own right.
\item ...
\end{Itemize}

The realisation of each of these goals is supported by the use of tools:

\begin{Itemize}
\item
Fragment administration and combination is managed by a tool called |Shuffle| (\appRef{appx-shuffle}).
\item
The description and implementation of the type system is generated by the |Ruler| system (\chapterRef{ruler}).
\item
The specification of the (remaining parts of the) implementation is expressed by an Attribute Grammar (AG) and
Haskell.
The AG system supports the independent description of aspects of an implementation (\secRef{secAGTut}).
\end{Itemize}

...

%%]

%%[overview
\subsubsection{Thesis overview}

The core of this thesis consists of a sequence of compilers, together named the Essential Haskell project,
abbreviated by EH.
Each compiler is built on top of a previous one and identified with |eh<n>| (or |ehc<n>|);
the explanation in this thesis follows this order, see \FigRef{fig-roadmap}.
The best route through this thesis therefore is straight from its beginning to the end.
However, some parts may be skipped or read independently:

\begin{Itemize}
\item
\chapterRef{ehc1} through \chapterRef{ehc3} explain the first three compilers.
We extensively use the AG system to describe the implementation.
We provide an AG tutorial in \secRef{secAGTut} at the end of this introduction,
but this tutorial may be skipped if one is already familiar with our system.
\item
The following chapters focus more on the explanation if issues and design.
Because we focus less on the corresponding implementation,
this part is not incorporated in the main story line.
\item
\chapterRef{ehc9} and \chapterRef{ruler} are derived from submitted papers and can be read
independently.
\end{Itemize}

appendices: not incorporated fragments (or as pdf overlay, or html?), shuffle doc

how we refer to not incorporated fragments, like this \chunkHideRef{impl.gamAsList}.

\subsubsection{System overview}

picture/discussion of relationship between: tools (ruler, shuffle, ag, hs, lhs2tex/tex), artefacts (fragments (of anything), type rules (via ruler), ag, hs, tex

\FigurePDF{system-overview}{System overview}{system-fig-overview}

where sources can be found

%%]

%%[roadMap
%%]

%%[readingPerspectives
%%]

%%[intro
Haskell98 \cite{peytonjones03has98-rev-rep} is a complex language,
not to mention its more experimental incarnations.
Though also intended as a research platform, realistic compilers for Haskell \cite{www04ghc}
have grown over the years
and understanding and experimenting with
those compilers is not an easy task.
Experimentation on a smaller scale usually is based upon relatively simple and restricted implementations
\cite{jones99thih}, often focusing only on a particular aspect of
the language and/or its implementation.
This paper aims at walking somewhere between this complexity and simplicity by
\begin{Itemize}
\item
Describing the implementation of essential aspects of Haskell
(or any other (functional) programming language), hence the name Essential Haskell (EH) used
for simplified variants of
Haskell\footnote{The 'E' in EH might also be expanded to other aspects of the compiler, like being an \textbf{E}xample.}
in \thispaper.
\item
Describing these aspects separately in order to provide a better understanding.
\item
Adding these aspects on top of each other
in an incremental way, thus leading to a sequence of compilers, each for a larger subset of complete Haskell (and extensions).
\item
Using tools like the Utrecht University Attribute Grammar (UUAG) system
\cite{baars04ag-www},
hereafter referred to as the AG system,
to allow for separate descriptions for the various aspects.
\end{Itemize}

The remaining sections of this introduction will expand on this by looking at
the intentions, purpose and limitations of \thispaper\ in more detail.
This is followed by a short description
of the individual languages for which we develop compilers throughout \thispaper.
The last part of the introduction contains a small tutorial on the AG system used 
in \thispaper.
After the introduction we continue with discussing the implementation
of the first three compilers
(sections \ref{ehc1}, \ref{ehc2} and \ref{ehc3})
out of a (currently) sequence of ten compilers.
On the web site \cite{dijkstra04ehc-web} for this project the  full distribution of the code for these compilers can be found.
We conclude \thispaper\ by reflecting upon our experiences with the AG system and the creation of \thispaper\ (\secRef{ehcConcl}).
%%]

%%[purpose
For whom is this material intended?
\begin{Itemize}
\item
For students who wish to learn more about the implementation of functional languages.
This paper also informally explains the required theory, in particular about type systems.
\item
For researchers who want to build (e.g.) a prototype and to experiment
with extensions to the type system and need a non-trivial and realistic starting point.
This paper provides documentation, design rationales and an implementation for such a starting point.
\item
For those who wish to study a larger example of the tools used to build the compilers in \thispaper.
We demonstrate the use of the AG system,
which allows us to separately describe the various aspects of a language implementation.
%if incl01TopicParsing
Parser combinators \cite{swierstra00parser-toytool,swierstra99parser-tutor}
are used to compactly describe executable syntax.
%endif
Other tools for maintaining consistency between different versions of the resulting compilers
and the source code text included in \thispaper\ are also used, but will not be discussed.
\end{Itemize}

For this intended audience \thispaper
%if llncs
provide:
%else
provides:
%endif

\begin{Itemize}
\item
A description of the implementation of a type checker/inferencer for
a subset of Haskell.
We describe the first three languages of a (currently) sequence of ten,
that end in a full implementation of an extended Haskell.
\item
A description of the semantics of Haskell, lying between the
more formal
\cite{hall96type-class-haskell,faxen02semantics-haskell}
and more implementation oriented
\cite{jones00thih,ipt:impl-func-prog-lang} and similar to other combinations of
theory and practice \cite{typing:types-prog-lang:pierce}.
\item
A gradual instead of a big bang explanation.
\item
Empirical support for the belief that the complexity of a compiler
can be managed by splitting the implementation of the compiler into separate aspects.
\item
A working combination of otherwise usually separately proven or implemented features.
\end{Itemize}

We will come back to this in the conclusion (see \secRef{ehcConcl}).

We restrict ourselves in the following ways, partly because of space limitations, partly by design:

\begin{Itemize}
%if storyAFP04Notes
\item
We do not discuss extensions to Haskell implemented in versions beyond the last version presented in \thispaper.
See \secRef{eh-not-described} for a preciser description of what can and cannot be found in \thispaper\
with respect to Haskell features.
%endif
\item
We concern ourselves with typing only.
Other aspects, like pretty printing and parsing, are not discussed.
However, the introduction to the AG system (see \secRef{ag-primer}) gives some examples
of the pretty printing and the interaction between parsing, AG code and Haskell code.
\item
We do not deal with type theory or parsing theory as a subject on its own.
This paper is intended to describe ``how to implement'' and
will use theory from that point of view.
Theoretical aspects are touched upon from a more intuitive point of view.
\end{Itemize}

Although informally and concisely introduced where necessary,
familiarity with the following will make reading and understanding \thispaper\ easier:
\begin{Itemize}
\item
Functional programming, in particular using Haskell
\item
Compiler construction in general
\item
Type systems, |lambda|-calculus
\item
Parser combinator library and AG system \cite{baars04ag-www,uust04www}
\end{Itemize}

%if incl00TopicAGPrimer
For those not familiar with the AG system a short tutorial has been included at the end of
this introduction (see \secRef{ag-primer}).
It also demonstrates the use of the parser combinators used throughout the implementation of
all EH versions.
%endif

We expect that by finding a balance between theory and implementation,
we serve both those who want to learn and those who want to do research.
It is also our belief that by splitting the big problem into smaller aspects the combination can
be explained in an easier way.

In the following sections we give examples of the Haskell features
present in the
series of compilers described in
%if not incl06
the following chapters.
%else
\chapterRef{ehc1} throughout
\chapterRef{ehc6}.
%endif
Only short examples are given, so the reader gets an impression of what is explained in more detail
and implemented in the relevant versions of the compiler.
%%]

%%[shortTour
Although all compilers described in \thispaper\ deal with a different issue,
they all have in common that they are based on the \IxAsIs{|lambda|-calculus},
most of the time using the syntax and semantics of Haskell.
The first version of our series of compilers therefore accepts a language that most closely resembles the
|lambda|-calculus, in particular typed |lambda|-calculus extended with |let| expressions
and some basic types and type constructors such as |Int|, |Char| and tuples
(see \appRef{appx-legenda-termlang} for all terms used throughout \thispaper).

We note that code generation is included in EH8.
Although we call all compilers `compiler', the versions before EH8 actually are type checkers as no translation
to an equivalent executable program is computed.

\Paragraph{EH version 1: |lambda|-calculus}
An EH program is a single expression, contrary to a Haskell program which consists of a set of declarations forming a module.

\begin{code}
%%1srcfile(test/1-demo2.eh%%)
\end{code}

All variables need to be typed explicitly; absence of an explicit type is considered to be an error.
The corresponding compiler (EH version 1, \chapterRef{ehc1}) checks the explicit types against
actual types.
%if not storyAFP04Notes
For example:

\begin{code}
%%1srcfile(test/1-all-fail2.eh%%)
\end{code}

is not accepted.
%endif

Besides the basic types |Int| and |Char|, more complex types can be formed by building tuples and defining functions:

\begin{code}
%%1srcfile(test/1-demo3.eh%%)
\end{code}

All types are monomorphic.

%if incl02
\Paragraph{EH version 2: Explicit/implicit typing}
The next version
(EH version 2, \chapterRef{ehc2})
no longer requires the explicit type specifications, which in that case will be inferred by the compiler.
%if not storyAFP04Notes
For example for:

\begin{code}
%%2srcfile(test/1-sig-fail.eh%%)
\end{code}

the compiler will infer the type specification |i :: %%2file(test/1-sig-fail.eh%%)|.
%endif

The reconstructed type information is monomorphic, for example the identity function in:

\begin{code}
%%2srcfile(test/2-demo1.eh%%)
\end{code}

is inferred to have the type |id :: %%2file(test/2-demo1.eh%%)|.

%endif %% incl02

%if incl03

\Paragraph{EH version 3: Polymorphism}
The third version
(EH version 3, \chapterRef{ehc3})
performs standard
Hindley-Milner type inferencing \cite{ipt:type-infer-milner,damas82principal-type}
which also supports parametric polymorphism.
For example,
\begin{code}
let  id = \x -> x
in   id 3
\end{code}
is inferred to have type |id :: %%3(let id = \x -> x in id 3%%)|;
|id| has type |id :: %%3(let id = \x -> x in id%%)|.

%if not storyAFP04Notes
A (polymorphic) type for a value can also be specified explicitly
\begin{code}
let  id :: a -> a
     id = \x -> x
in   id 3
\end{code}
The type signature is checked against the inferred type.
%endif

%endif %% incl03

%if incl04 || storyEHIntro
\Paragraph{EH version 4: Higher ranked types}
Standard Hindley-Milner type inferencing cannot infer polymorphic parameters,
so-called higher-ranked types.
A higher-ranked type may have a quantified type at an argument position,
allowing for polymorphic function arguments.
In general, this is a hard thing to do and even impossible for rank-3 (and higher) types
\cite{jim95rank,kfoury94direct,kfoury99rank2-decid,kfoury03rank2-princ},
so the fourth version
(EH version 4, \chapterRef{ehc4})
does not infer this type information, but
allows for explicitly specified polymorphism for (e.g.) parameters.

For example, the following is allowed.
\begin{code}
let  f :: (forall a . a -> a) -> (Int,Char)
     f = \i -> (i 3, i 'x')
in   f
\end{code}
Note that the type signature is thus required here.

This version also provides some notational sugaring by allowing one to omit
the explicit quantifiers from
the type signature (separately discussed in \chapterRef{ehc-partial-sig-quant-guess}).
For example, if the |forall| in the previous example is omitted
the correct location for the quantifier is inferred,
based on the occurrences of type variables in a type expression:
\begin{code}
let  f :: (a -> a) -> (Int,Char)
     f = \i -> (i 3, i 'x')
in   f
\end{code}
infers |f :: %%4(let  f :: (a -> a) -> (Int,Char) in f%%)|

Specifying a complete type signature can be difficult for complicated types,
so it is also permitted to leave argument and results of a function unspecified
using a \IxAsDef{partial type signature}
(separately discussed in \chapterRef{ehc-partial-sig-quant-guess}).
\begin{code}
%%4srcfile(test/4-ty-wild1.eh%%)
\end{code}
Here, for |f| only the part that cannot be inferred is given in the signature.

Finally, type information can be hidden, or encapsulated,
by using existential quantification:
\begin{code}
%%4srcfile(test/4-demo1.eh%%)
\end{code}
The tuple |xy| contains an |Int| (this type information os 'forgotten' via existential quantification)
and a function constructing an |Int| from the
value of which the type has been hidden.
Access to the elements of such a tuple is done by pattern matching, as in the argument position of the function |ixy|.
The attempt to construct |pq| fails.

When a value of an existentially quantified type is opened, that is,
it is bound to a value identifier,
the hidden type becomes visible in the form of a fresh type constant.


%endif %% incl04

\Paragraph{EH version 5: Data types}
The fifth version (EH version 5, \chapterEHVRef)
adds |data| types and opening/unpacking/scrutinizing
a data type value by means of a |case| expression.
\begin{code}
%%5srcfile(test/5-list.eh%%)
\end{code}

\Paragraph{EH version 6: Kinding}
The previous version allows incorrect programs because
data types can be used incorrectly (type signature declarations without a corresponding value declaration are allowed until
the code generation version of EH):
\begin{code}
%%6srcfile(test/5-list-wrong.eh%%)
\end{code}
The type of |v| is not a type of a value, and thus the type of |v|
itself is not well-typed.
The sixth version (EH version 6, \chapterEHVIRef)
adds kind (that is, the type of a type) inferencing.
%if False
For example, the previous example gives
\begin{TT}
%%6ppfile(test/5-list-wrong.eh%%)
\end{TT}
%endif

With the notion of the kind of a type we also allow
the notion of polymorphism for kinds:
\begin{code}
let  data Eq a b = Eq (forall f . f a -> f b)
     id = \x -> x
in   Eq id
\end{code}
infers for type constructor |Eq|\footnote{There is no need to specify the kind of |f|, but the current version of EH6 does not propagate kinds of quantified type variables. This is an error that will be fixed in the near future.}:

\begin{code}
Eq :: forall ^ k . k -> k -> *
\end{code}

Explicit kind signatures for types are also allowed, similar to type signatures for values.

\Paragraph{EH version 7: Non-extensible records}
The seventh version (EH version 7, \chapterEHVIIRef)
extends tuples to (non-extensible) records.
Fields can be named.
for tuples the default field names are their position (starting at |1|):

\begin{code}
%%7srcfile(test/7-demo1.eh%%)
\end{code}

The proposal by Jones \cite{jones99lightweight-ext-rec} is followed.

\Paragraph{EH version 8: Code generation}
The eighth version (EH version 8, \chapterEHVIIIRef)
adds code generation for a GRIN (Graph Reduction Intermediate Notation) like backend
\cite{boquist96grin-optim,boquist99phd-optim-lazy}.
The generated code can be run (for testing purposes only) by a small GRIN interpreter (|grini|).

\Paragraph{EH version 9: Implicit parameters, class system}
The ninth version (EH version 9, \chapterRef{ehc9})
adds a class system, and explicit parameter passing to implicit parameters:

\begin{code}
%%9srcfile(eh-frags/9-eq-nub.eh%%)
\end{code}

On top of a class system, we allow instances to be named (1), and passed explicitly (2) when
expected to be passed implicitly.


\Paragraph{EH version 10: Extensible records}
The tenth version (EH version 10, \chapterEHXRef)
adds extensible records (again following Jones \cite{jones99lightweight-ext-rec}),
using the class system to allow:

\begin{code}
let  add  ::  Int -> Int -> Int
     f    ::  (r\\x, r\\y) => (r|x :: Int,y :: Int) -> Int
     f    =   \r -> add r.x r.y
in
let  v1 = f (x = 3, y = 4)
     v2 = f (y = 5, a = 'z', x = 6)
in   v2
\end{code}

Tuple access functions can also be used in a more general way:

\begin{code}
%%10srcfile(test/10-snd.eh%%)
\end{code}


%%]

%%[haskellOmitted
\label{eh-not-described}
As mentioned before, only a subset of the full sequence of compilers is described in \thispaper.
Currently, as part of an ongoing work \cite{dijkstra04ehc-web},
in the compilers following the compilers described in \thispaper, the following Haskell features are dealt with:

\begin{description}
%if incl04
\item[EH 4.] Quantifiers everywhere: higher ranked types
\cite{shan04sexy-types,peytonjones04pract-inf-rank,botlan03ml-power-f,odersky97putting-ann}
and existentials \cite{perry91phd,laufer94poly-absdata,mitchell88absty-exist}.
See also the longer version of \thispaper\ handed out during the AFP04 summerschool
\cite{dijkstra04thag-part1}.
%endif
%if incl05
\item[EH 5.] Data types.
%endif
%if incl06
\item[EH 6.] Kinds, kind inference, kind checking, kind polymorphism.
%endif
%if incl07
\item[EH 7.] Non extensible records, subsuming tuples.
%endif
%if incl08
\item[EH 8.] Code generation for a GRIN (Graph Reduction Intermediate Notation) like backend
\cite{boquist96grin-optim,boquist99phd-optim-lazy}.
%endif
%if incl09
\item[EH 9.] Class system, explicit implicit parameters \cite{dijkstra04expl-impl-param-tr}.
%endif
%if incl10
\item[EH 10.] Extensible records \cite{gaster96poly-ext-rec-var,jones99lightweight-ext-rec}.
%endif
\end{description}

Also missing are features which fall in the category syntactic sugar, programming in the large and the like.
Haskell incorporates many features which make programming easier and/or manageable.
Just to mention a few:
\begin{Itemize}
\item
Binding group analysis
\item
Syntax directives like infix declarations
\item
Modules
\cite{diatchki02hask-module,shields01first-class-mod}.
\item
Type synonyms
\item
Syntactic sugar for |if|, |do|, list notation and comprehension.
\end{Itemize}

We have deliberately not dealt with these issues.
Though necessary and convenient we feel that these features should be added after all else has been dealt with,
so as not to make understanding and implementating essential features more difficult.

%%]

%%[newlyArisenIssues
\subsection{Untackled newly arisen issues}
The extra features on occasions also add new issues...

\paragraph{Kind checking required during type inferencing}

\TBD{}

Kinds may be different than tacitly assumed.

\begin{code}
let  data Eq a b = Eq (forall f . f a -> f b)
     data L a = N | C a (L a)
     undefined :: forall a . a
in   let  maf :: (a -> Eq a a) -> Eq L L
          maf = \g -> g undefined
     in   3
\end{code}

\paragraph{Co/contra variance analysis/inference/checking}

\TBD{}
%%]

%%[projectStatus
The implementation and description of the EH is an ongoing project.
This thesis therefore reflects work in progress in which we have partially achieved our goals:
\begin{Itemize}
\item
All presented code fragments come from the same sources as used by the implementation of all compilers.
\item
Part of the type related AG code is generated by the |Ruler| system.
This is the case for type rules and corresponding AG code for EH1 (\chapterRef{ehc1}),
EH2 (\chapterRef{ehc2}),
and EH3 (\chapterRef{ehc3}).
\item

\end{Itemize}

------

work in progress

consistency: partly achieved for type rules and their (ag) implementation, fully achieved for source code and explanation

coverage of compiler: partly achieved, focus on experiments (the presence of which supports claim of easy extendability)

see conclusion for evaluation

-------
%%]

%%[scratch
%if False
%if storyPHD
\subsection*%
%else
\subsection%
%endif
{About the presented code}

Multiple versions of a compiler are described and
form the basis around which the explanation has been woven.
This brings
some consequences:
\begin{Itemize}
\item
Versions are built on top of each other.
However, in practice this meant that
after a next version was constructed, refactoring of earlier versions was in general necessary.
As such what  we describe is ``an optimal line of development''.
It is not the case that the versions represent a timeline,
a tale of how the different versions came into being.
It also means that all versions are dependent on each other and
are designed as a whole.
Any desired change in the last version may imply a change in the first version.
Metaphorically speaking, in order to change the grown-up compiler you may have to tweak
its childhood.

In an ideal situation this would not have been necessary;
but it would be unfair if we did not mention the work that went into getting
all the laysers to work as neatly as they do now.
\item
Since we do not only want to sketch the approach but want to present
a complete compiler we also have to deal with many non-interesting details.
However, for \thispaper\ we have chosen to only incorporate aspects directly related to typing
and omit other aspects like pretty printing, parsing and error reporting.
The complete compiler text can be found on the website accompanying
\thispaper \cite{dijkstra04ehc-web}.
\end{Itemize}
%endif %% False
%%]

%%[summaryNL
Dit proefschrift bevat een beschrijving van een implementatie van een uitgebreide subset van de programmeertaal Haskell en
de gereedschappen die daarvoor nodig zijn.
Tegelijkertijd is het een experiment in de integratie de beschrijving en de broncode van de implementatie,
waarmee een zekere mate van consistentie wordt gegarandeerd.

to be done...
%%]

%%[summaryUU
Computer programmaas worden geschreven met behulp van computer programmaas,
in het bijzonder programmaas die een specificatie van een programma vertalen naar een werkend programma.
Zo'n specificatie wordt beschreven in een programmeertaal.
De huidige trend is dat
een programmeertaal, en de daarbij horende
implementatie van de vertaler voor zo'n programeertaal,
steeds meer van het werk van een programmeur uit handen neemt.
Programmeertaal en implementatie zelf worden daardoor ingewikkelder en steeds moeilijker te implementeren.
Het proefschrift "Stapsgewijs door Haskell" is een experiment in het stapsgewijs beschrijven van een
implementatie van de (functionele) programmeertaal Haskell met als doel een begrijpelijke en consistente uitleg
van die implementatie.
Als onderdeel van deze beschrijving worden eveneens enkele uitbreidingen op Haskell beschreven.
Het proefschrift representeert een tussenstadium in de ontwikkeling van een complete implementatie met bijbehorende beschrijving,
en zal als project hierna voortgezet worden.
Essentieel voor het welslagen van dit experiment en de voortzetting ervan is het gebruik van geautomatiseerde
oplossingen voor de problemen die handmatig niet te garanderen zijn:
consistentie en opsplitsing in stappen.
%%]

%%[overigUU
Onderwerp:
Een stapsgewijze beschrijving van een implementatie van de programmeertaal Haskell

Conclusie(s):
De beschrijving zelf die het proefschrift representeert is doel en conclusie.
Een conclusie op meta nivo is dat het daarbij essentieel is zoveel mogelijk van de beschrijving en gerelateerde
problematiek (consistentie en opsplitsing in stappen) te automatiseren.

Aanbeveling(en)
%%]

%%[summarySIREN
Part of the Essential Haskell (EH) project [1] is a description of an
implementation of an extended subset of the programming language
Haskell. The description [2] merges explanation with the actual code of the
implementation, thus guaranteeing some form of consistency. The goal is
to make description and implementation understandable, so that it can be
used as a means for education and (Haskell) programming language
research. In this thesis we take a stepwise approach to both description
and implementation, which starts with a simple version of Haskell and
then, step by step, we extend this simple version towards an extended
version of Haskell.

[1]. Atze Dijkstra. EHC Web. http://www.cs.uu.nl/groups/ST/Ehc/WebHome, 2004.
[2]. Atze Dijkstra. Stepping through Haskell (to be published), PhD thesis, 2005. 
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

