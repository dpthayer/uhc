%%[body
Specifying a type signature becomes cumbersome as soon as the specified type becomes complex.
This is a reason to rely on a type inferencer to find those type signatures.
However, if the intended type signature is too complicated, a type inferencer will fail to infer
the intended signature.
We are then required to specify the full signature instead of only the part which cannot be inferred 
by the type inferencer.

In \thischapt\ we investigate two techniques for relieving a programmer
from the burden of ``all or nothing'' type specification.
Both techniques support a joint specification of a type by programmer and system:

\begin{itemize}
\item
Partial type signatures.
Often, a complex type has only (relatively) small parts which are too complex to be inferred.
With partial type signatures we allow the specification of those parts,
leaving the remainder to be inferred by a type inferencer.
\item
Quantifier location inference.
Type variables in a type signature have to be explicitly quantified.
However, the use of type variable often corresponds to the intended quantifier:
|forall| for type variables relating function argument and result,
|exists| for type variables of a tuple (or other product) type.
With quantifier location inference we can omit quantifiers.
\end{itemize}

We first examine some examples,
followed by a discussion of the typing rules
affected by these features.
Both features are relatively independent of other language features,
which is the reason they are discussed separately.
Examples and type rules are based on the EH version from \chapterRef{ehc4} (EH4).

\Paragraph{Partial type signatures}

Partial type signatures are specified by type expressions where three dots ``|...|'',
called a \IxAsDef{type wildcard},
denote unspecified parts.
For example, the following declares the identity function |id|:

\begin{code}
%%3srcfile(test/2-demo-wild1.eh%%)
\end{code}

The type signature for |id| specifies that |id| should be a function,
but does not state anything about its argument and result.
The argument and result type remain unknown until the type inferencer has inferred their type.

A type wildcard is similar to a type variable, because both represent unknown type information.
However, type variables in a type signature represent quantified type variables.
We denote non-quantified type variables by the prefix `|%|',
called a \IxAsDef{named type wildcard}.
The previous declaration of |id| can now be rewritten to:

\begin{code}
%%3srcfile(test/3-demo-wild1.eh%%)
\end{code}

Omission of `|%|' yields a type expression ``|a -> b|'',
which is interpreted (by ``Quantifier location inference'')
as ``|(exists ^ a . a) -> forall ^ b . b|''.

A named type wildcard allows the specification of additional constraints to be used by type inference.
In the following, argument and result type should match, and the result should be of type |Int|.
This results in an inferred signature ``|ii :: Int -> Int|'':

\begin{code}
%%3srcfile(test/3-demo-wild2.eh%%)
\end{code}

Used in this way, partial type signatures are similar to lexically scoped type variables
\cite{peytonjones03lex-scope-tvs}.
Lexically scoped type variables allow scoped references to the types of parameters:

\begin{code}
%%3srcfile(test/4-demo-scope-tv1.eh%%)
\end{code}

Partial type signatures are most useful in specifying those parts type inference can not infer,
in particular higher-rank type information:

\begin{code}
%%4srcfile(test/4-ty-wild1.eh%%)
\end{code}

For |f| we only need to specify its rank-2 typed argument;
the rest can be left to be inferred.


\Paragraph{Partial type signatures for implicit parameters}

Implicit parameters can be omitted as well.
Within the context of the examples from \chapterRef{ehc9} we start with the following function:

%%@TopicPartialTySig.explImplExample

\Paragraph{Quantifier location inference}

Quantifiers for a type signature are specified explicitly in its type expression,
but may be omitted if their location in the type expression is where we expect it to be.
Here, the notion of what we expect is based on the following observations:

\begin{itemize}
\item
The universal quantifier |forall| is used to express the propagation of type information
between argument and result type of a function type.
\item
The existential quantifier |exists| is used to express encapsulation of a type which represents
data about which we want to hide type information.
\end{itemize}

For example, the type signature of the identity function |id| can be specified by the
following type expression:

\begin{code}
id :: a -> a
\end{code}

The expected location for |forall| is in front of the type signature.
Similarly, the following type signature also specifies ``|a->a|'',
but on a rank-2 position:

\begin{code}
f :: (a -> a) -> Int
\end{code}

Because type variable |a| is not referred to outside the rank-2 position,
the expected location of |forall| is in front of ``|a->a|'' at rank-2,
not in front of the full type signature on a rank-1 position,
Haskell's default.

For tuple types we put an existential quantifier in front.
For example for:

\begin{code}
v :: (a,a -> Int)
f :: (a,a -> Int) -> Int
\end{code}

A tuple type represents data composition. A type variable indicates lack of knowledge,
hence is interpreted as `forgotten' type information, or an existential type:

\begin{code}
v :: exists ^ a . (a,a -> Int)
f :: (exists ^ a . (a,a -> Int)) -> Int
\end{code}

Informally, a quantifier for a type variable is placed in front of a type fragment if
the the type variable does not occur outsided the type fragment.
If that position is a function type, |forall| is used, if a product type, a |exists| is used.
This algorithm is applied irrespective of the position of the type fragment,
so the following type expressions:

\begin{code}
f :: Int -> (a -> a)
g :: Int -> (a,a -> Int)
\end{code}

yield the following type signatures:

\begin{code}
f :: Int -> forall ^ a . a -> a
g :: Int -> exists ^ a . (a,a -> Int)
\end{code}

For |f|, this is isomporphic to the placement of |forall| in front of the type.
However, for |g|, the type is different from:

\begin{code}
g :: exists ^ a . Int -> (a,a -> Int)
\end{code}

The first signature of |g| allows two different invocations of |g| to return two different types for
the encapsulated type variable |a|.
The second type signature is opened when bound to |g|,
with a fresh type constant for type variable |a|:

\begin{code}
g :: Int -> (C_1,C_1 -> Int)
\end{code}

Two different invocations then are required to return the same, but hidden, type.

These rules all correspond, via the Curry-Howard isomorphism
\cite{srensen98curry-howard,wadler89theorems-for-free,wadler00proofs-are-programs,wadler02girard-reynolds-iso},
to their corresponding logical meaning.

A single type variables takes a somewhat special place.
What is the interpretation of the following types:

\begin{code}
v :: a
f :: a -> b
\end{code}

We interpret these types as follows:

\begin{code}
v :: forall ^ a . a
f :: (exists ^ a . a) -> forall ^ b . b
\end{code}

|v| corresponds to Haskell's @undefined@,
whereas |f|'s type corresponds (by means of logical equivalence via the Curry-Howard isomorphism)
with Haskell's interpretation:

\begin{code}
f :: forall ^ a . forall ^ b . a -> b
\end{code}

Finally, we note that the automatic placement of quantifiers always can be overridden
by means of an explicit specification of the quantifier.

\subsection{Partial type signatures}

Partial type signatures are already in early versions of EH meaningful.
EH version 2 (\chapterRef{ehc2}) allows type variables;
type wildcards are just type variables as far as the
implementation is concerned.
\RuleRef{t.wild} (\figRef{rules3.C.tyexpr.eh2}) shows how a type variable is created.
The type variable remains unbound, that is, we cannot refer to this type variable.
The next version of EH, version 3 (\chapterRef{ehc3}), allows references (by means of program identifiers)
to type variables.
Similar to the gathering of value identifier
we thread |TGamma| through all type rules to gather bindings to type variables.
At \ruleRef{t.var} and its wildcard variation 
\ruleRef{t.var.w} (\figRef{rules3.HM.tyexpr.eh3})
such a binding is added.

\rulerCmdUse{rules3.C.tyexpr.eh2}
\rulerCmdUse{rules3.HM.tyexpr.eh3}
%\rulerCmdUse{rules3.I1.tyexpr.eh4}

The type expression is used in a declaration for a type signature.
In \ruleRef{d.tysig} (\figPageRef{rules3.HM.decl.base}) the type signature of this type expression
is quantified over its free type variables, minus those which are introduced as a type wildcard.
These are still free to be bound by type inference;
quantification is done a second time after type inference.

\subsection{Quantifier location inference}

Our algorithm to place quantifiers is based on the rules,
more formally specified in \figRef{rules3.I1.tyqu.base}:

\begin{itemize}
\item
If a type variable occurs in two components of a composite type,
and the type variable does not occur outside the composite type,
the composite type is the quantifier location for the type variable
(\ruleRef{ty.qu.arrow}, \ruleRef{ty.qu.prod}).
\item
If a quantifier location is in front of a product type,
a |exists| is used (\ruleRef{ty.qu.prod}),
if in front of a function type, a |forall| is used (\ruleRef{ty.qu.arrow}).
\item
For a standalone type variable (does not occur elsewhere in the type),
a |forall| is used in a co-variant context, |exists| otherwise.
\end{itemize}

For the co- or contravariance context we use some additional notation (\figRef{eh-coco-legenda-notation}).
Co- and contravariant context is only propagated one argument level.
% The use of co- and contravariance becomes a bigger issue with the introduction of data types.

\rulerCmdUse{rules3.I1.tyqu.base}

\begin{TabularFigure}{Notation for co- and contravariant context}{eh-coco-legenda-notation}
%%@AppxNotation.notationTableFormat
%%@AppxNotation.notationTableHeader
%%@AppxNotation.notationCoCo
\end{TabularFigure}

\subsection{Related work, discussion}

Similarity with lexically scoped type variables.

Curry-Howard isomorphism.

%%]

%%[explImplExample
\begin{code}
f = \p q r s -> (eq p q, eq r s)
\end{code}

If |f|'s type signature is omitted,
we infer the following type:

\begin{code}
f :: forall a   .    Eq a            => a -> a -> forall b . Eq b => b -> b -> (Bool,Bool)
\end{code}

\textbf{Variation 1:}
Now, if we want to make clear that the dictionary for |b| should be passed before any of the |a|'s we write:

\begin{code}
f :: forall    b . (Eq b,  ...   ) => ...  -> ...  -> b -> b -> ...
-- INFERRED:
f :: forall a  b . (Eq b,  Eq a  ) => a    -> a    -> b -> b -> (Bool,Bool)
\end{code}

The parts indicated by `|...|' are inferred.

\textbf{Variation 2:}
The dots `|...|' in the type signature specify parts of the signature to
be filled by the type inferencer.
The inferred type may be polymorphic if no restrictions on its type are found by the type inferencer,
or it may be monomorphic as for |r :: Int| in:

\begin{code}
f  ::  forall a   . (  Eq a,  ...   )  =>     a ->  a ->  ...
f  =                                       \  p     q     r       s               ->  (eq p q  ,  eq r 3  )
-- INFERRED:
f  ::  forall a   .    Eq a            =>     a ->  a ->  Int ->  forall b . b    ->  (Bool    ,  Bool    )
\end{code}

\textbf{Variation 3:}
%if False
f  ::  forall a   .    Eq a            =>     a ->  a ->  Int ->  (exists b . b)  ->  (Bool    ,  Bool    )
For |s| any value can be passed; this is encoded by the existential quantification.
The introduction of the existential quantifier is the result of the a quantifier insertion rule which states
that for a single type variable on a contravariant position an |exists| is inserted.
%endif
If instead we still want |s| to have the same type as |r| we can use a more general variant of `|...|' in which
we can refer to the inferred type using a type variable prefixed with a percent symbol '|%|',
called a \IxAsDef{named wildcard}:

\begin{code}
f  ::  forall a   . (  Eq a,  ...   )  =>     a ->  a ->  %b   ->  %b              ->  ...
f  =                                       \  p     q     r        s               ->  (eq p q  ,  eq r 3  )
-- INFERRED:
f  ::  forall a   .    Eq a            =>     a ->  a ->  Int  ->  Int             ->  (Bool    ,  Bool    )
\end{code}

If `|...|' occurs in a type position, we call it a \IxAsDef{type wildcard}.
If `|...|' occurs in a in predicate position, we call it a \IxAsDef{predicate wildcard}.

Although the given example suggests that a wildcard may be used anywhere in a type,
there are some restrictions:
\begin{itemize}
\item
A named wildcard |%a| cannot be used as a predicate wildcard,
because |%a| then would refer to a set of predicates;
it does not make much sense to pass this set twice.
\item
A type wildcard can occur at an argument or result position of a function type.
A type wildcard itself may bind to a polymorphic type with predicates.
In other words, impredicativeness is allowed.
This is particularly convenient for type wildcards on a function's result position.
For example, the type wildcard |%b| in
\begin{code}
f :: forall a . Eq a => a -> a -> %b
\end{code}
is bound to
\begin{code}
forall b . Eq b => b -> b -> (Bool,Bool)
\end{code}
after further type inferencing.
\item
For the non wildcard part of a type signature
all occurrences of
a type variable in the final type must be given.
This is necessary because the type signature will be quantified over explicitly introduced
type variables.
\item
A sequence of explicit predicates may end with a predicate wildcard, standing for
an optional collection of additional predicates.
Multiple occurrences of a predicate wildcard or between explicit predicates would defeat the purpose
of being partially explicit. For example, for the type signature |(Eq b, ..., Eq c) => ...|
the argument position of |Eq c|'s dictionary cannot be predicted by the programmer.
\item
The absence of a predicate wildcard in front of a type
means \emph{no} predicates are allowed.
The only exception to this rule is a single type variable
or a type wildcard,
since these may be bound to a type which itself
contains predicates.
\end{itemize}

%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

