%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PART 3: Constraints and CHRs
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
SLIDE: Constraints: the |Prove| constraint
> -- eq :: Eq a => a -> a -> Bool
> test = eq [] [1,2,3]

>                Prove (Eq [Int]) 
> deriv(eqList)  Prove(Eq Int) 
> deriv(eqInt)   True 

> test = eq (eqList eqInt) [] [1,2,3]

* The type scheme of eq is instantiated with the type of the arguments ([Int])
* This results in the proof obligations: Prove (Eq [Int])
* Operationally: evidence has has to be inserted to resolve a proof constraint.



SLIDE: Constraints: the |Assume| constraint

> -- insert  :: Ord a => a -> [a] -> [a]
> -- sort    :: Ord a => [a] -> [a]
>
> testInsert :: Ord a => a -> [a] -> Bool
> testInsert x xs =  let  ys = insert x (sort xs)
>                    in   eq ys (sort ys)

>                Assume(Ord c1), Prove (Eq   [c1]),  Prove (Ord c1)
> deriv(eqList)  Assume(Ord c1), Prove (Eq   c1),    Prove (Ord c1)
> deriv(eqOrd)   Assume(Ord c1), Prove (Ord  c1)
> deriv()        Assume(Ord c1)

> testInsert :: DictOrd a -> a -> [a] -> Bool
> testInsert d x xs =  let  ys = insert d x (sort d xs)
>                      in   eq (eqList (eqOrd d)) ys (sort d ys)

* Introduce the function |testInsert|
* An assume constraint is generated for the predicate in the type signature 
* The meaning of an assumption is that there is a dictionary available.
* This is translated to an additional parameter of the overloaded function.

Context-reduction:
* Duplicate constraints can be removed
* Simplification using instances
* Simplification using the class hierarchy



SLIDE: Constraints: the |Assume| constraint cont'ed

> noteq :: Ord a => a -> a -> Bool
> noteq x y = not (eq x y) 

>                Assume(Ord c1), Prove (Eq c1)
> deriv(eqOrd)   Assume(Ord c1), Assume(Eq c1), Prove (Eq c1)
> deriv()        Assume(Ord c1), Assume(Eq c1)

* Haskell allows the def of |noteq|
* Simplification of the |Prove| constraints will not result in satisfaction
* Assumptions must be propagated



SLIDE: Constraint Handling Rules
%{
%format || = "|"
>  H1, ... , Hi <=>  G1, ... , Gj ^^ || ^^ B1, ... , Bk      ^^  (simplification)
>  H1, ... , Hi ==>  G1, ... , Gj ^^ || ^^ B1, ... , Bk      ^^  (propagation)
>  (i > 0, j >= 0, k >= 0)
%}

* CHRs: head, guard, body
* Simplification: replace head -> body
* Propagation: add body if head 
* To avoid non-termination a prop is applied only one time on each constraint



SLIDE: Generating context-reduction alternatives 
Simplification using the class hierarchy:
> class Eq a 
> class Ord a => Eq a

> Prove(Eq a), Prove(Ord a)  ==>    Reduction(Eq a, S "eqOrd", [Ord a])
> Assume(Ord a)  ==> Assume(Eq a),  Reduction(Eq a, S "eqOrd", [Ord a])

Simplification using instance decls:
> instance Eq Int
> instance Eq a => Eq [a]
> instance (Eq a, Eq b) => Eq (a, b)

> Prove(Eq Int)     ==>  Reduction(Eq Int, I "eqInt", [])
> Prove(Eq [a])     ==>  Prove(Eq   a), Reduction(Eq [a], I "eqList", [Eq a])
> Prove(Eq (a, b))  ==>  Prove(Eq   a), Prove(Eq b), Reduction(Eq (a, b), I "eqList", [Eq a, Eq b])

* Reduction constraints are generated by CHRs
* A reduction constraint represents a reduction alternative
* The second component is meta information



SLIDE: Every correct context-reduction alternative is generated!

> { Prove(Ord [v1]), Prove(Eq [v1]) }

> Prove(Eq [a])     ==>  Prove(Eq   a), Reduction(Eq [a], I "eqList", [Eq a])
> Prove(Eq a), Prove(Ord a)  ==>    Reduction(Eq a, S "eqOrd", [Ord a])

> Reduction(Eq [v1], S "eqOrd", [Ord [v1]])
> Reduction(Eq [v1], I "eqList", [Eq v1])

* Two rules apply on this constraint-set
* By using only prop CHRs every rule is applied, instead of applying only one rule in a non-deterministic way.
* Now both alternatives are generated and later we make a choice by using a heuristic 
* Hereby we defer design decisions and only use CHRs to generate correct possibilities
* Avoid non-deterministic choice or non-confluency
% Waarom is dit mooi???



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PART 4: Simplification graphs
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
SLIDE: Simplification graph by example:
> testInsert :: Ord a => (Int, a) -> [(Int, a)] -> Bool
> testInsert x xs =  let  ys = insert x (sort xs)
>                    in   eq ys (sort ys)

* Again the same function |testInsert|, but now with a restricting type sig.
* The following constraints are generated for this function.

> { Assume(Ord c1), Prove(Ord (Int, c1)), Prove(Eq [(Int, c1)]) }

* Applying the CHRs on the constraints result in the following reductions:

> {  Reduction (Ord  (Int, c1),    "ordTuple",  [Ord Int, Ord c1]),  Reduction (Ord  Int,  "ordInt",  [])
> ,  Reduction (Eq   [(Int, c1)],  "eqList",    [Eq (Int, c1)]),     Reduction (Eq   Int,  "eqInt",   [])
> ,  Reduction (Eq   (Int, c1),    "eqTuple"    [Eq Int, Eq c1]),    Reduction (Eq   c1,   "eqOrd",  [Ord c1])
> ,  Reduction (Eq   (Int, c1),    "eqOrd",     [Ord (Int, c1)]),    Reduction (Eq   Int,  "eqOrd",  [Ord Int])  
> }

* Find a solution using heuristic for Proves
* Adding a reduction for each assumption

> Assume(Ord c1)  --> Reduction(Ord c1, A "a1", [])



SLIDE: Constructing simplification graphs
* Add the reductions one-by-one, starting with the assumption
* Two types of nodes: predicates and And nodes
* True is a special case of And with the empty list

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PART 5: Heuristics
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
SLIDE: Heuristics: Introduction

For each |Prove| constraint:
- Choose a solution from the graph
- The chosen path is used to generate code

For example:
- a backtracking heuristic
- a cost-path heuristic
- Haskell~98 heuristic
- GHC heuristic

