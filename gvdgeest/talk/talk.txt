  In this talk I'm going to defend my master's thesis.
  I present a constraint based framework for the resolution of type class extensions.

  We will start with an introduction to type classes.
  Then I sketch the problem we are going to solve.
  And finally I present the solution to this problem.

  In programming languages and also in natural languages, we want to use the same identifiers for different purposes.
  For example, we want to use the equality operator to compare integers, but also Strings 
  Haskell has a very elegant solution for overloading identifiers called type classes.

TICK:: Type classes
  
  Consider the first class declaration.
  
  The class declaration introduces the type class predicate |Eq|.
  The type class Eq consists of the function |eq| for comparing two values of the same type on equality.
  The type of this function is...
  
TICK:: Predicate

  During this presentation we will focus on the part before the double arrow.
  The type Eq a before the arrow is called a type class predicate. 
  In this presentation we will focus on these predicates and double arrows.
  The predicate means that this function can be used forall types where we defined equality for.
  Note, that overloading is really something different from parametric polymorphism.

TICK:: Polymorphism vs Overloading

  Consider the polymorphic length function.
  The function has the same implementation for every possible type of |a|.
  However, the overloaded equality function has a different implementation for each type |a|.

  We can add types to a type class with the instance declaration. 
  For example, in the first instance declaration the function |primEqChar| is the implementation for values of type Char.
  
  The instance declaration for lists is even more interesting. 
  There we define equality for lists in terms in equality for elements.
  This is called a dictionary transformer, transforming one predicate into another.
  This instance declaration makes an infinite number of types instance of Eq.

TICK:: Infinite number of instances
  
  Not only the type Char is an instance of Eq, but also list of Char, list of list of Char, and so on.

  The function |elem| is defined in terms of equality.
  The nice thing of type classes is that this function is also overloaded.
  Finally, we use the function elem on list of characters.
  Note that we know that equality on list of characters is defined.

  To resolve overloading we not only have to check types, also the program has to be translated into a program without overload.
  
TICK:: Translation of Class and Instances

  Class declarations are translated into datatypes.
  Instance declarations are translated into values of that type.

  The next step is to translate the function elem and construct a dictionary for using the function |elem|

TICK:: Translation of functions

  The predicate in the function |elem| is translated into an additional parameter.
  When using |elem| we have to provide that parameter.
  
  The important observations is that predicates are translated into values of a datatype.
  And that we can construct these values using instance declarations.
  This process is called context-reduction and corresponds one-to-one to the generated code.

TICK:: Superclasses

  Classes can be arranged in a hierarchy. 
  We declare that Eq is a subclass of Ord in the class declaration for Ord.
  The class declaration is the only place where the double arrow has another meaning!!

TICK:: Superclass relation

  The arrow in the class declaration means that the instances of Eq must be a superset of the instance of Ord.
  That is very convenient because in order to define ordering for a type we need equality on that type!!

  This relation can also be seen if we translate the class and instance declarations.

TICK:: Translation superclass

  The dictionary of Eq is really of the dictionary for Ord.
  The important observation is that the double arrow in instance declarations and functions is translated into an additional parameter.
  However, the double arrow in the class declaration is like an aggregation.

  Although type classes were only proposed as a solution for overloading identifiers, they have become an active research topic where experimental type class extensions are still being proposed.

TICK:: HUGE design space

  The design space turned out to be huge!

TICK:: Constructor classes

  Mark Jones proposed an extension to define type classes over type constructors.
  With well known examples such as Monad and Functor and with instances for List and Maybe.
  Contructor classes is part of the  Haskell~98 standard.

TICK:: Overlapping instances

  Overlapping instance is a natural extension of type classes.
  This extension allows us to define not only the normal instance for showing a list.
  But also to define an instance for specifically showing a list of characters or showing a nested list.

TICK:: Multi-parameter type classes

  Multi-parameter type classes where already mentioned in the first paper concerning type classes by Wadler and Blot.
  For example, the following type class is attempt to abstract over collections with instances for list and set.
  However, in practice multi-parameter type classes often cause ambiguities.
  For example, the function test where two values of type Char and Bool are inserted into the same list is type-correct.
   
TICK:: Functional dependencies
  
  Functional dependencies were introduced by Mark Jones to solve those problems.
  With functional dependencies the programmer can define the relation between the params of a type class.  
  |c| arrow |d| means that the type of c uniqly determined the type of e.
  For example if the collection is of type list-of-Bool, the type of the elemt must be Bool.
  Therefore, we get a type error for the definition of test.

TICK:: Local instances

  Also work on the design of type classes in done in the ST group.
  Besides implicit and explicit parameters, Atze's EH compiler is the only compiler implementing local instances.
  In this example we redefine eq on integers for working on degrees.

TICK:: Context reduction strategies

  Consider the function |f| where we use the operator greater then on elements and equality on lists.
  There are three possible types for |f|.
  - Haskell~98: context-reduction using class and instance declarations.
  - Only context reduction using instance declarations, nice option when using scoped instances
  - GHC: no context reduction at all when overloading cannot be resolved locally.

TICK:: Type class derictives

  Other work done at our group by Bastiaan and Jurriaan
  With type class derictieves one can add additional checks on type classes.
  - a certain type can never be in a type class
  - a type class is closed.
  - type in two type classes are disjoint.

TICK:: Other extensions

  Also other predicate langauges exists working in the same way as type classes.

TICK:: Associated types

  Another solution for multi-parameter type classes

TICK:: Problem statement

  The design space is huge, however no uniform approach.
  not easy experiment with type class extensions.
  type error messages type classes difficult to understand.
 
TICK:: Approach 

  - comparable to how Top solves equality constraint and uses graph to
    generate type error messages.
  - in fact we just have a specification of a problem, generate solutions
    using rewrite rules and select a solution using a heuristic

TICK:: Step 1 constraints

  formulate the problem constraint language
  |pi| is the type of the predicates which we leave abstract
