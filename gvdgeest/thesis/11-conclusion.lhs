%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Chapter
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Conclusion and future work}
\label{ch:conclusion}

We have presented a constraint-based framework for the resolution of overloading.
In this chapter we first list the contributions of our work and then give an overview of future work.

\section{Conclusion}
The framework presented in this thesis was preceded by a prototype.
We tested and implemented this prototype in the type checker `Typing Haskell in Haskell'~\citep{jones99typing} and in the constraint-solver Top~\citep{heeren05}.
Class and instance declarations were translated into rules constructing a simplification graph.
Evidence could be generated from this graph.
However, we used a tailor made rule language instead of the more general CHRs, and the heuristic was hard-coded in the evidence generation algorithm.

In Chapter~\ref{ch:constraints} we presented a first version of the framework.
We showed how entailment of Haskell~98 type classes can be expressed in terms of CHRs.
Furthermore, a systematic translation was presented from class and instance declarations into CHRs.
We also check if the class hierarchy is acyclic during this translation.
On top of that, we have also implemented a domain specific language for CHRs together with a basic CHR solver in Haskell.
In Chapter~\ref{ch:evidence} we presented the final version of the framework.
We let each CHR generate reduction constraints to trace the derivation steps needed to arrive at a solution.
Furthermore, we use CHRs to generate every possible and correct context reduction alternative.
This is achieved by only using propagation CHRs.
The context reduction alternatives generated by CHRs are represented in a graph and a heuristic chooses a solution to resolve overloading.
These heuristics allows one to easily experiment with different design decisions.
To illustrate this, we presented heuristics emulating the context reduction behavior of Haskell~98 and GHC.
Furthermore, we presented a heuristic for the resolution of overlapping instances.

In Chapter~\ref{ch:localinstances} we explained how overloading can be resolved in the context of local instances.
First, we presented new entailment rules for scoped instances, and then we introduced a new predicate language by annotating predicates with a scope identifier.
To generate correct alternatives we adapted the translation from class and instance declarations into CHRs.
We only introduced one new CHR for scoping and add a guard to the CHRs generated for instance declarations.
However, the CHR for scoping generates many redundant reductions.
For this reason, we also presented an alternative encoding of scoping in terms of CHRs.

In Chapter~\ref{ch:improving} we extended the framework with improvement. 
Thereby, we have given an implementation for the theoretical framework of Jones~\citep{jones92theory, jones95improving, jones95qualified}.
This extension allows one to use the existing translation of functional dependencies into CHRs~\citep{fds-chrs, sulz06chrfd} in this framework.
Furthermore, it is also possible to resolve other qualified types using this framework such as extensible records~\citep{jones99lightweight}.

Finally, we have shown that almost every type-class extension can be formulated in this framework.
For example, we have explained how overlapping instances, local instances, multi-parameter type classes, and functional dependencies can be encoded.

\section{Future work}

\subsection*{Type class directives}
Type class directives~\citep{heerenhage05directives} are proposed to improve type error messages concerning type classes.
Consider the following example directives:
> never       Eq (a -> b)          : "functions cannot be tested for equality"
> never       Num Bool             : "arithmetic on booleans is not supported"
> close       Integral             : "the only Integral instances are Int and Integer"
> disjoint    Integral Fractional  : "something which is fractional can never be integral"
The above directives can easily be translated into the following CHRs:
> Prove (Eq (a -> b))   ==>  error "functions cannot be tested for equality"
> Prove (Num Bool)      ==>  error "arithmetic on booleans is not supported"
> Prove (Integral a)    ==>  a notinsign {Int, Integer}
>                       |    error "the only Integral instances are Int and Integer"
> Prove (Integral a), Prove (Fractional a)  
>                       ==>  error "something which is fractional can never be integral"
The directives can be applied in the framework by adding the above rules to the CHRs for simplification.
However, we did not describe how to handle the errors resulting from resolving overloading.
We expect that the type error infrastructure of Top can be inherited by integrating this framework with Top.

Type class directives can also lead to improving substitutions, because more information about the set of types in a class is available. 
It is interesting to examine how directives in combination with improvement can be encoded using this framework.


\subsection*{Existential types and type classes}
Combining existential types and type classes results in significant expressive power~\citep{laufer96exist}.
GHC~\citep{Ghc} supports existentially quantified data constructors with arbitrary contexts:
> data Showable = forallword a . Show a => Showable a
> 
> showable ((Sub Showable a1) x) = (Sub show p1) x
> 
> test = map showable  [(Sub Showable p2) 'c', (Sub Showable p3) "Hello World", (Sub Showable p4) False]
Surprisingly, the keyword forall is used to existentially quantify a variable.
The reason for this decision is that the type |forall a . Show a => a -> Showable| is assigned to the constructor |Showable|.
This construction allows for packaging heterogeneous values in a list and using the functions of type class |Show| on those values.
The following constraints are generated to resolve overloading for the above fragment:
>  {  (Sub (Prove (Show Char)) p2),  (Sub (Prove (Show String)) p3), (Sub (Prove (Show Bool)) p4)
>  ,  (Sub (Assume (Show c1)) a1),  (Sub (Prove (Show c1)) p1) }
Predicates must be proven when the constructor |Showable| is used and can be assumed when pattern matching on |Showable|.
Operationally, this means that the dictionary for |Show| must be stored in the constructor |Showable|.

EH~\citep{dijkstra05phd} allows a more direct encoding of existential types without the need for packing and unpacking using a datatype.
Instead, a type is closed (packed) by annotating a value with an existential type signature and an existential type is opened (unpacked) when binding an existential type to an identifier.
Consider the following EH fragment expressing the above example:
> showable :: (exists a . Show a => a) -> String
> showable = \(Sub x a1) -> (Sub show p1) x
> 
> test = map showable  [(Sub 'c' p2), (Sub "Hello World" p3), (Sub False p4)] :: [exists a . Show a => a]  
The types in the list are hidden by the explicit type signature and opened by binding each element to the variable |x| in the function |showable|.
The constraint set generated for the above example is exactly the same as the one presented for the GHC example.
The constraints resulting from these examples can be solved using our
framework.
Also the type system of EH already checks and propagates existential types.
However, the evidence translation scheme for existentially quantified predicates is not yet described and implemented. 
Furthermore, the meaning of multi-parameter type classes with both existentially and universally quantified types variables is not yet clear.

\subsection*{Recursive bindings}
In this thesis we did not address a minor issue occurring when generating evidence for (mutually) recursive bindings.
Consider the following recursive binding:
> elem x []       = False
> elem x (y:ys)   = x (Sub (==) p1) y || elem x ys
In this function the overloaded operator |(==)| is used.
After analyzing the body of the function |elem| we have to solve the constraint |Prove (Eq v1)| at location |p1| in the abstract-syntax tree.
We infer the type |Eq a => a -> [a] -> Bool| for the function |elem| because we cannot simplify the predicate |Eq v1| further.
The result is that the function |elem| expects a dictionary as evidence for using the operator |(==)|.
There are two alternatives for generating evidence for an overloaded recursive function: |elem1| and |elem2|.
> elem1 dictEq = elem'
>   where  elem' x []       = False
>          elem' x (y:ys)   = ((==) dictEq) x y || elem' x ys
>
>
> elem2 dictEq x []       = False
> elem2 dictEq x (y:ys)   = ((==) dictEq) x y || elem2 dictEq x ys
The first translation yields efficient code because the recursive call does not have to pass the dictionary for |Eq|.
A drawback is that the translation scheme is complex, especially for mutually recursive bindings.
The second translation is more straightforward, but a problem occurs with this translation.
Evidence has to be inserted for the recursive call to |elem2|.
However, no |Prove| constraint was generated for this recursive call because the type of |elem| is not yet known when analyzing the body of the function.
Therefore, no evidence is generated for the recursive call.

A solution is to extend the predicate language with predicate variables.
Those predicate variables relate places where predicates are possibly needed to places where predicate possibly must be inserted.
For example, the name of the function |elem| could be used as predicate variable.
The additionally generated constraint for the recursive call to |elem| would then be |Prove (elem)|.
A substitution from |elem| to |{Eq v1}| is added when the type of the function |elem| is inferred.
After applying the substitution on the constraints we still are able to prove the predicate using the framework.
Of course using a function identifier as a predicate variable is not the best choice because identifiers possibly shadow each other.
We deliberately did not implement a mechanism for predicate substitution in the framework because this problem depends on the evidence translation scheme of the compiler.
Furthermore, the framework is not able to solve predicate variables until they are substituted.

\subsection*{Resolution of other qualified types}
In this thesis we presented a number of entailment rules together with algorithmic versions of these rules in terms of CHRs.
There are many entailment relations described in the literature, such as for extensible records and subtyping~\citep{jones95qualified}.
It would be interesting to examine if other forms of qualified types could be encoded into CHRs and could be resolved with this framework.
It is already proven that extensible records can be encoded in terms of type classes with some common extensions such as multi-parameter type classes with functional dependencies~\citep{hlist}.
Therefore, it should also be possible to directly encode extensible records in the presented framework. 

\subsection*{Non-termination}
In this thesis we used simplification and propagation CHRs:
%{
%format || = "|"
>  H1, ... , Hi <=>  G1, ... , Gj ^^ || ^^ B1, ... , Bk      ^^  (simplification)
>  H1, ... , Hi ==>  G1, ... , Gj ^^ || ^^ B1, ... , Bk      ^^  (propagation)
>
>  (i > 0, j >= 0, k >= 0)
%}
We assumed the following condition on CHRs:
>  fv(H1, ... , Hi) supseteq fv(B1, ... , Bk)
The function |fv| computes the variables occurring in the constraints.
The variables in the head of a CHR must always be a superset of the variables in the body.
Not fulfilling this condition often results in non-termination.
For that reason this condition was also dictated by the initial proposal for functional dependencies~\citep{jones00type}. 
These conditions are called the {\it Coverage Condition} and the {\it Bound Variable Conditions} in the context of functional dependencies.
However, these conditions can safely be relaxed~\citep{fds-chrs, sulz06chrfd}.
For example, consider the following class and instance declarations:
> class F a
> class E a b | a -> b
> instance E a b => F a
> instance E Int Float
The first instance declaration violates the Coverage Condition because the set |{a}| is not a superset of |{a, b}|.
However, the CHRs resulting from these declarations are confluent and terminating because the variable |b| is fixed by |a| using the functional dependency. 
The simplification CHR generated for the first instance declaration must introduce a fresh type variable for |b|:
> Prove (F a) => b fresh | Prove (E a b)
Future work is to add support for generating fresh type variables in the body of a CHR.

Furthermore, compilers that allow users to experiment with advanced type class extensions usually fix the number of simplification and improvement steps performed to a certain depth.
The reason for this is to avoid non-termination of the compiler.
Such a mechanism is not present in the presented framework.

\subsection*{Improving substitutions}
In Chapter~\ref{ch:improving} we have given a short introduction to improvement and explained why improvement is useful.
Furthermore, we explained how we extended our framework to support improvement.
However, improvement is in some sense an ad-hoc extension of our framework.
We did not mention how improvement scales in combination with other extensions such as overlapping instances or local instances.
It would be nice to express improvements in the simplification graphs.
Improvements are then generated depending on the solution chosen by heuristics.
This would be an interesting research topic and we think our framework provides a solid basis for this research.
