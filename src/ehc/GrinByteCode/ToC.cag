%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Prettyprint Grin ByteCode program as C
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs module {%{EH}GrinByteCode.ToC} import(EH.Util.Pretty,{%{EH}Base.Common},{%{EH}Base.Opts},{%{EH}GrinByteCode})
%%]

%%[(8 codegen grin) hs import(EH.Util.Pretty,{%{EH}Base.Common},{%{EH}Base.Opts},qualified {%{EH}Config} as Cfg,{%{EH}GrinByteCode})
%%]

%%[(8 codegen grin) hs import(Data.Maybe,Data.Char,Data.Bits,qualified EH.Util.FastSeq as Seq,EH.Util.Utils,qualified Data.Map as Map)
%%]

%%[(8 codegen grin) hs export(gbmod2C)
%%]

%%[(8 codegen grin) import({GrinByteCode/AbsSyn})
%%]

%%[(8 codegen grin).gbmod2C hs
gbmod2C :: EHCOpts -> Module -> PP_Doc
gbmod2C opts m
  = let t = wrap_AGItf (sem_AGItf (AGItf_AGItf m))
                       (Inh_AGItf {opts_Inh_AGItf = opts}
                       )
    in  pp_Syn_AGItf t
%%]

%%[(20 codegen grin) -8.gbmod2C hs
gbmod2C :: EHCOpts -> Module -> (PP_Doc,PP_Doc)
gbmod2C opts m
  = let t = wrap_AGItf (sem_AGItf (AGItf_AGItf m))
                       (Inh_AGItf {opts_Inh_AGItf = opts}
                       )
    in  (pp_Syn_AGItf t,ppMain_Syn_AGItf t)
%%]

%%[(8 codegen grin)
WRAPPER AGItf
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% General info
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin)
ATTR AGItf Module AllInstr [ opts: EHCOpts | | ]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Utils
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs
ppCmtC :: PP a => EHCOpts -> a -> PP_Doc
ppCmtC opts x | ehcOptGenCmt opts = "/*" >#< pp x >#< "*/"
              | otherwise         = empty

ppHex :: Integral a => Int -> a -> PP_Doc
ppHex prec x = head $ ppHex' Nothing prec x

ppHex' :: Integral a => Maybe Int -> Int -> a -> [PP_Doc]
ppHex' split prec x
  = case split of
      Nothing  -> ["0x" >|< h]
      Just spl -> map ("0x" >|<) $ s h
               where s l = case splitAt spl l of
                             ([],_ ) -> []
                             (l1,l2) -> l1 : s l2
  where h = strHex prec x
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Code offset
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin)
ATTR Instr Instrs AllImm [ | cLoc: CodeAbsLoc | ]

SEM Module
  | Mod         instrs      .   cLoc        =   0

SEM Imm
  | Int         lhs         .   cLoc        =   @lhs.cLoc + @sz

SEM Instr
  | Label       loc         .   labelCLoc   :   CodeAbsLoc
                loc         .   labelCLoc   =   @lhs.cLoc
  | LabelRef    loc         .   labelCLocAft:   CodeAbsLoc
                loc         .   labelCLocAft=   @lhs.cLoc + Cfg.gbLabelOffsetSize
  | LinkChain   loc         .   linkCLoc    :   CodeAbsLoc
                loc         .   linkCLoc    =   @lhs.cLoc
  | Call Eval Apply AllocStore CaseCall LdGlobal
                loc         .   linkCLoc    :   CodeAbsLoc
                loc         .   linkCLoc    =   @lhs.cLoc + 1
  | CallC       loc         .   linkCLoc    :   CodeAbsLoc
                loc         .   linkCLoc    =   @callEnc.cLoc
  | RetCase     loc         .   linkCLoc    :   CodeAbsLoc
                loc         .   linkCLoc    =   @retOffSurr.cLoc

SEM Instr
  | Ld St       imm         .   cLoc        =   @lhs.cLoc + 1
  | Op          imm         .   cLoc        =   @lhs.cLoc + 2
  | Call CallC Eval Apply AllocStore CaseCall LdGlobal RetCase LinkChain
                lhs         .   cLoc        =   @linkCLoc + Cfg.sizeofWord
  | LabelRef    lhs         .   cLoc        =   @labelCLocAft
  | TailCall RetCall
                nArgMine    .   cLoc        =   @lhs.cLoc + 2
  | FetchUpdate LdNodeTag
                lhs         .   cLoc        =   @lhs.cLoc + 1
  | CallC       nArg        .   cLoc        =   @lhs.cLoc + 2
  | TailEval    nArgSurr    .   cLoc        =   @lhs.cLoc + 2
  | RetCase     nRes        .   cLoc        =   @lhs.cLoc + 2
  | Halt TagInt2Word UntagWord2Int TagWord2Word UntagWord2Word
                lhs         .   cLoc        =   @lhs.cLoc + 2
  | Fetch       lhs         .   cLoc        =   @lhs.cLoc + 1
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Labels
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs
type LocRefLoc = (LocRef,CodeAbsLoc)
%%]

%%[(8 codegen grin)
ATTR AllInstr [ | | locRefs USE {Seq.:++:} {Seq.empty}: {Seq.FastSeq LocRefLoc} ]

SEM Instr
  | Label       lhs         .   locRefs     =   Seq.singleton (@locRef,@labelCLoc)
%%]

%%[(8 codegen grin)
ATTR Instr [ | | isEntry: Bool ]

SEM Instr
  | Label		lhs			.	isEntry		=	case @locRef of {LocRef_CodeEntry _ -> True; _ -> False}
  | * - Label	lhs			.	isEntry		=	False
%%]

%%[(8 codegen grin)
ATTR AllInstr [ | | gathLabelLocMp USE {`Map.union`} {Map.empty}: LabelLocMp ]

SEM Instr
  | Label       lhs         .   gathLabelLocMp
  											=   if lrefIsLabel @locRef then Map.singleton (lrefId @locRef) @labelCLoc else Map.empty
  | AllocStore LdGlobal CaseCall RetCase LinkChain
  				lhs         .   gathLabelLocMp
  											=   maybe Map.empty (\l -> Map.singleton l @linkCLoc) $ lckeyMbLbl $ lcentryKey @linkChainEntry
%%]

%%[(8 codegen grin)
ATTR AllInstr [ labelLocMp: LabelLocMp | | ]

SEM Module
  | Mod         loc         .   labelLocMp  =   @instrs.gathLabelLocMp
%%]

%%[(8 codegen grin)
SEM Instr
  | LabelRef    loc         .   refOff      =   (panicJust "Instr.LabelRef.refOff" $ Map.lookup (lrefId @locRef) @lhs.labelLocMp)
                                                    - @labelCLocAft
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Link entries
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin)
SEM Instr
  | Call CallC Eval Apply
  				loc			.	linkChainEntry
  				  							=	LinkChainEntry (LinkChainKey LinkChainKind_CallInfo (LinkChainId_Loc @linkCLoc)) @ciInx
				loc			.	linkChainEntry
											:	LinkChainEntry
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% LinkChain info gathering
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin)
ATTR AllInstr [ | | gathLinkChainKeyMp USE {`Map.union`} {Map.empty}: LinkChainKeyMp ]

SEM Instr
  | AllocStore LdGlobal Call CallC Eval Apply CaseCall RetCase LinkChain
  				lhs         .   gathLinkChainKeyMp
  											=   Map.singleton (lcentryKey @linkChainEntry) (lcentryInfo @linkChainEntry)
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% LinkChain resolution
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin)
ATTR AllInstr [ linkChainResolvedMp: LinkChainResolvedMp | | ]

SEM Module
  | Mod         loc         .   (linkChainResolvedMp,mbLinkChainCodeLoc)
  											=   linkChainMpResolve @instrs.gathLabelLocMp @instrs.gathLinkChainKeyMp
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% LinkChain entries
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin)
ATTR AllInstr [ | linkChainResolvedIndInfoSet: LinkChainResolvedIndInfoSet | ]

SEM Module
  | Mod         instrs      .   linkChainResolvedIndInfoSet
                                            =   emptyLinkChainResolvedIndInfoSet
%%]

%%[(8 codegen grin)
SEM Instr
  | AllocStore LdGlobal Call CallC Eval Apply CaseCall RetCase LinkChain
                (loc.linkChain,lhs.linkChainResolvedIndInfoSet)
                                            =   maybe (0,@lhs.linkChainResolvedIndInfoSet) (linkChainResolvedInfoEncoding @lhs.linkChainResolvedIndInfoSet)
                                                $ linkChainResolvedLookup (lcentryKey @linkChainEntry) @lhs.linkChainResolvedMp
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% CallInfo's
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs
type CallInfoMp = Map.Map CallInfo Int

ciMpAdd :: CallInfo -> CallInfoMp -> (CallInfoMp,Int)
ciMpAdd ci m
  = case ci `Map.lookup` m of
      Just i -> (m,i)
      _      -> (Map.insert ci i m,i)
             where i = Map.size m
%%]

%%[(8 codegen grin)
ATTR AllInstr [ | callInfoMp: CallInfoMp | ]

SEM Instr
  | Call CallC Eval Apply
  				(lhs.callInfoMp,loc.ciInx)	=	ciMpAdd @callInfo @lhs.callInfoMp

SEM Module
  | Mod         instrs      .   callInfoMp	=   Map.empty
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% PP as code
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs
nl :: PP_Doc
nl = text " "

ppHexL :: [PP_Doc] -> PP_Doc
ppHexL
  = ppCommas . cvt
  where cvt = if Cfg.machineIsBigEndian then id else reverse

ppArr :: PP a => [a] -> PP_Doc
ppArr l = indent 2 (ppCurlysCommasBlock l >#< ";")

ppArr' :: PP a => [a] -> [PP_Doc]
ppArr' = ppBlock' "{ " "} ;" ", "

ppCast :: String -> PP_Doc -> PP_Doc
ppCast t v = ppParens $ ppParens t >|< ppParens v

ppNodeFlds :: PP n => n -> PP_Doc
ppNodeFlds n = n >|< ".content.fields"

ppNodeFld :: (PP n,PP o) => n -> o -> PP_Doc
ppNodeFld n o = ppArrAt (ppNodeFlds n) o

ppCnst :: EHCOpts -> (Int -> PP_Doc) -> Const -> PP_Doc
ppCnst _    mk (Const_Str       i) = ppCast "GB_Word" $ mk i
ppCnst opts _  (Const_CFunction n) = ppCast "GB_Word" $ ppAddrOf (pref ++ {- (if ehcOptPriv opts then "priv_" else "") ++ -} n)
                                   where pref = ""  -- if take 4 n == "prim" then "gb_" else ""
ppCnst _    _  (Const_CallInfo  n) = ppCast "GB_Word" $ ppAddrOf n

ppLine :: PP_Doc -> PP_Doc
ppLine p = p >-< text ""

ppFun :: (PP h, PP b) => h -> b -> PP_Doc
ppFun h b = h >#< "{" >-< indent 2 b >-< "}"

ppArrAt :: (PP a,PP o) => a -> o -> PP_Doc
ppArrAt a o = a >|< "[" >|< o >|< "]"

ppAddrOf :: PP a => a -> PP_Doc
ppAddrOf a = "&" >|< ppParens a

ppAddrArrAt :: (PP a,PP o) => a -> o -> PP_Doc
ppAddrArrAt a o = ppAddrOf $ ppArrAt a o

mkPre :: String -> String
mkPre = (++ "_")

ppTbl :: String -> PP_Doc -> [PP_Doc] -> PP_Doc
ppTbl tp nm tbl = ppLine $ "static" >#< tp >#< nm >|< "[] =" >-< ppArr tbl

ppTbl' :: String -> PP_Doc -> [PP_Doc] -> [PP_Doc]
ppTbl' tp nm tbl = [nl, "static" >#< tp >#< nm >|< "[] ="] ++ ppArr' tbl
%%]

%%[(8 codegen grin)
ATTR AllNT AGItf [ | | pp USE {>-<} {empty}: PP_Doc ]
%%]

%%[(20 codegen grin)
ATTR Module AGItf [ | | ppMain: PP_Doc ]
%%]

%%[(8 codegen grin)
SEM Module
  | Mod         loc         .   moduleNmPre             =   mkPre @moduleNm
                            .   ppNm                    =   \n -> @moduleNmPre >|< n
                            .   strNmByteCodeModule     =   "bytecodeModule"
                            .   strNmByteCodeEntry   	=   "bytecodeEntries"
                            .   ppNmAString             =   \i -> @ppNm "string" >|< i
                            .   ppNmAGCStackInfo        =   \i -> @ppNm "gcStackInfo" >|< i
                            .   ppNmACAF                =   @ppNm "caf"
                            .   ppNmByteCodeTbl         =   @ppNm "bytecode"
                            .   ppNmByteCodeTraceTbl    =   @ppNm "bytecodeInstrEntries"
                            .   ppNmByteCodeModule      =   @ppNm @strNmByteCodeModule
                            .   ppNmByteCodeEntry       =   @ppNm @strNmByteCodeEntry
                            .   ppNmConstTbl            =   @ppNm "constants"
                            .   ppNmGlobEntriesTbl      =   @ppNm "globalEntries"
                            .   ppNmCafEntriesTbl       =   @ppNm "cafEntries"
                            .   ppNmCafGlEntryIndicesTbl=   @ppNm "cafGlEntryIndices"
                            .   ppNmCafTbl              =   @ppNm "cafs"
                            .   strNmInitF              =   "initModule"
                            .   ppNmInitF               =   @ppNm @strNmInitF
                            .   ppNmMainCAFEntry        =   @ppNm "mainEntryPtr"
                            .   ppNmModEntriesTbl       =   @ppNm "moduleEntries"
                            .   ppNmGCInfosTbl          =   @ppNm "gcInfos"
                            .   ppNmLinkChainIndTbl     =   @ppNm "linkChainIndirections"
                            .   ppNmCallInfoTbl         =   @ppNm "callinfos"
%%[[20
                            .   strNmImpTbl             =   "impMods"
                            .   strNmExpNode            =   "expNode"
                            .   strNmExpNodeSz          =   @strNmExpNode ++ "_size"
                            .   ppImpModTbl             =   @ppNm @strNmImpTbl
                            .   ppNmExpNode             =   @ppNm @strNmExpNode
                            .   ppNmExpNodeOffs         =   @ppNm (@strNmExpNode ++ "_offs")
                            .   ppNmExpNodeSz           =   @ppNm @strNmExpNodeSz
%%]]

%%[[8
                lhs         .   pp          
%%][20
                lhs         .   (pp,ppMain)
%%]]
                                            =   -- 20091002, the below expr is growing too large, need to reorg someday
                                                let top     = ppLine $ ppCmtC @lhs.opts ("bytecode in C encoding for module" >#< @moduleNm)
                                                                       >-< vlist [ "#include" >#< pp (show i)
                                                                                 | i <- ["rts.h", "bc/interpreter.h"]
%%[[94
                                                                                        ++ @includeL
%%]]
                                                                                 ]
                                                    strNmL  = [ (@ppNmAString i,ppCmtC @lhs.opts (take 15 s) >-< ppStringAsHex s) | (i,s) <- zip [(0::Int)..] @stringL ]
                                                    -- strings = nl : [ "static char" >#< n >|< "[] =" >-< indent 2 (s >#< ";") | (n,s) <- strNmL ]
                                                    strings = nl : [ ppStaticDef "char" n "[]" s | (n,s) <- strNmL ]
                                                    (callinfos,gcStackInfos)
                                                            = ( ppTbl' "GB_CallInfo" @ppNmCallInfoTbl
                                                                  [ "GB_MkCallInfoWith"
                                                                    >|< ppParensCommas
                                                                          [ pp $ fromEnum $ ciKind ci
                                                                          , maybe (pp "NULL") (\i -> @ppNmAString i) $ ciMbNmStrInx ci
                                                                          , gcref
                                                                          , pp (ciExtra ci)                                                                                
                                                                          ]
                                                                    >#< ppCmtC @lhs.opts (show ci)
                                                                  -- | (inx,(ci,i)) <- cis
                                                                  | ((_,gcref),ci,i) <- cis
                                                                  ]
                                                              , [ ppStaticDef "GB_GCStackInfo" nm "" (ppCurlysCommas def) | ((Just (nm,def),_),_,_) <- cis ]
                                                              )
                                                            where -- cis = zip [0..] $ sortOn snd $ Map.toList @instrs.callInfoMp
                                                                  cis = [ (mk (ciGCStackInfo ci) inx, ci, i)
                                                                        | (inx,(ci,i)) <- zip [(0::Int) .. ] $ sortOn snd $ Map.toList @instrs.callInfoMp
                                                                        ]
                                                                      where mk (GCStackInfo sz ps) inx | sz > 0
                                                                              = ( Just (@ppNmAGCStackInfo inx,[pp sz, pp lenps, ppIntsAsHex ps])
                                                                                , ppAddrOf $ @ppNmAGCStackInfo inx
                                                                                )
                                                                              where lenps = length ps
                                                                            mk _                   _
                                                                              = (Nothing, pp "NULL")
                                                    consts  = ppTbl' "GB_Word" @ppNmConstTbl (map (ppCnst @lhs.opts @ppNmAString) @constL )
                                                    bcTrL   = tail @instrs.bcTrL
                                                    bcode   = ppTbl' "GB_Byte" @ppNmByteCodeTbl @instrs.ppL
                                                    bcodetrace
                                                            = ppTbl' "GB_ByteCodeInstrEntry" @ppNmByteCodeTraceTbl
                                                                (map (\(l,sz,c) -> ppCurlysCommasBlock [ppAddrArrAt @ppNmByteCodeTbl l,pp sz,ppPacked "\"" "\"" c])
                                                                 $ concat bcTrL
                                                                )
                                                    bcodeentries
                                                            = ppTbl' "GB_ByteCodeEntryPoint" @ppNmByteCodeEntry
                                                                (zipWith3 (\i l e
                                                                            -> let (bc,bcs) = if ehcOptGenTrace @lhs.opts then (ppAddrArrAt @ppNmByteCodeTraceTbl i, l) else (pp "NULL",0)
                                                                               in  ppCurlysCommasBlock
                                                                                     [ (@ppNmAString $ constInx $ eiNmStrConst e) >#< ppCmtC @lhs.opts (eiNm e)
                                                                                     , bc, pp bcs
                                                                                     ]
                                                                          ) (scanl (+) 0 bcTrLengthL) bcTrLengthL @allEntryL
                                                                )
                                                            where bcTrLengthL = map length bcTrL
                                                    bcodemodtrace
                                                            = "GB_ByteCodeModule" >#< @ppNmByteCodeModule >#< "="
                                                               >-< indent 2
                                                                     (ppCurlysCommasBlock
                                                                        (  [ ppStr @moduleNm ]
                                                                        ++ (if ehcOptGenTrace @lhs.opts
                                                                            then [ @ppNmByteCodeEntry, pp $ length @allEntryL ]
                                                                            else [ pp "NULL", pp "0" ]
                                                                           )
                                                                        ++ [ @ppNmByteCodeTbl
                                                                           , pp @instrs.cLoc
                                                                           , @ppNmGCInfosTbl
                                                                           , pp (length @gcInfoL)
                                                                           ]
                                                                        )
                                                                      >#< ";"
                                                                      )
                                                    linkChainInds
                                                            = ppTbl' "GB_LinkChainResolvedInfo" @ppNmLinkChainIndTbl
                                                                (map (\(LinkChainResolvedInfo kind info off) -> ppCurlysCommasBlock $ map pp [info, off, fromEnum kind]) $ reverse inds
                                                                )
                                                            where (_,inds) = @instrs.linkChainResolvedIndInfoSet
                                                    glEntryMp= Map.fromList [ (i,c) | (LocRef_CodeEntry i,c) <- Seq.toList @instrs.locRefs ]
                                                    cafGlEntryIndices = ppTbl' "HalfWord" @ppNmCafGlEntryIndicesTbl [ pp i | i <- @cafEntryL ]
                                                    nrCafs = length @cafEntryL
                                                    glEntries = ppTbl' "GB_BytePtr" @ppNmGlobEntriesTbl [ ppAddrArrAt @ppNmByteCodeTbl c | c <- Map.elems glEntryMp ]
                                                    gcInfosTbl = ppTbl' "GB_GCInfo" @ppNmGCInfosTbl [ ppCurlysCommasBlock $ mk i | i <- @gcInfoL ]
                                                              where mk i = case i of
%%[[97
                                                                             GCInfo sz -> [pp sz]
%%]]
                                                                             _         -> [pp (0::Int)]
                                                                             
                                                    initf   = ppLine $ ppCmtC @lhs.opts "Initialization"
                                                                       >-< ppFun ("void" >#< @ppNmInitF >|<
%%[[8
                                                                                  "()"
%%][20
                                                                                  "(GB_ModEntry* modTbl)"
%%]]
                                                                                 )
                                                                                 ("gb_InitTables" >|< ppParensCommasBlock args >#< ";")
                                                            where args = [ @ppNmByteCodeTbl, pp @instrs.cLoc
                                                                         , @ppNmCafGlEntryIndicesTbl, pp nrCafs
                                                                         , @ppNmGlobEntriesTbl, pp (Map.size glEntryMp)
                                                                         , @ppNmConstTbl
                                                                         , @ppNmGCInfosTbl
                                                                         , @ppNmLinkChainIndTbl
                                                                         , @ppNmCallInfoTbl
                                                                         , pp $ maybe 0 id @mbLinkChainCodeLoc
%%[[20
                                                                         , @ppImpModTbl, pp (length @impModNmL)
                                                                         , ppAddrOf @ppNmExpNode
                                                                         , @ppNmExpNodeSz, @ppNmExpNodeOffs
                                                                         , pp "modTbl"
%%]]
                                                                         ]
                                                    maincaf = ppLine $ "static GB_BytePtr*" >#< @ppNmMainCAFEntry >#< "="
                                                                       >#< ppAddrArrAt @ppNmGlobEntriesTbl @mainCafEntry >#< ";"
                                                    mainf   = ppLine $ ppCmtC @lhs.opts "Main entry point"
                                                                       >-< ppFun "int main(int argc, char** argv)"
                                                                                 (vlist
                                                                                  $  [ pp "int nRtsOpts = 0 ;"
                                                                                     , pp "main_GB_Init1( argc, argv, &nRtsOpts ) ;"
                                                                                     , "gb_Opt_TraceSteps =" >#< ehcOptGenTrace @lhs.opts >#< ";"
                                                                                     , "gb_Opt_Info =" >#< ehcOptGenRTSInfo @lhs.opts >#< ";"
                                                                                     , pp "argc -= nRtsOpts ; argv += nRtsOpts ;"
                                                                                     ]
                                                                                  ++ (if ehcOptGenTrace @lhs.opts then ["IF_GB_TR_ON(3,{gb_prModEntries" >|< ppParens @ppNmModEntriesTbl >#< ";});"] else [])
%%[[8
                                                                                  ++ [ @ppNmInitF >|< "()" >#< ";" ]
                                                                                  ++ [ "gb_SetModTable" >|< ppParensCommas [@ppNmModEntriesTbl,pp (1::Int)] >#< ";" ]
%%][20
                                                                                  ++ [ "GB_MkExpNodeIn(" >#< mkPre m >|< @strNmExpNode >|< ", " >|< mkPre m >|< @strNmExpNodeSz >|< " ) ;"
                                                                                     | (_,m) <- @allImpModNmL
                                                                                     ]
                                                                                  ++ [ mkPre m >|< @strNmInitF >|< ppParens @ppNmModEntriesTbl >#< ";"
                                                                                     | (_,m) <- @allImpModNmL
                                                                                     ]
                                                                                  ++ [ "gb_SetModTable" >|< ppParensCommas [@ppNmModEntriesTbl,pp $ length @allImpModNmL] >#< ";" ]
%%]]
                                                                                  ++ [ "main_GB_Run( argc, argv, gb_code_Eval, Cast(GB_Word,*" >|< @ppNmMainCAFEntry >|< ") ) ;"
                                                                                     , pp "return main_GB_Exit( argc, argv) ;"
                                                                                     ]
                                                                                 )
%%[[20
                                                    expnd   = ppLine $ "GB_NodePtr" >#< @ppNmExpNode >#< ";"
                                                                       >-< "static int" >#< @ppNmExpNodeOffs >|< "[] ="
                                                                       >-< ppArr [ eiEntryNr e >#< ppCmtC @lhs.opts (eiNm e) | e <- @expEntryL ]
                                                                       >-< "int" >#< @ppNmExpNodeSz >#< "=" >#< length @expEntryL >#< ";"
                                                    externs = nl : map (\(_,m) -> "extern void" >#< mkPre m >|< @strNmInitF >|< "(GB_ModEntry*)" >#< ";"
                                                                                      >-< "extern GB_NodePtr" >#< mkPre m >|< @strNmExpNode >#< ";"
                                                                                      >-< "extern int" >#< mkPre m >|< @strNmExpNodeSz >#< ";"
                                                                                      >-< "extern GB_ByteCodeModule" >#< mkPre m >|< @strNmByteCodeModule >#< ";"
                                                                       ) @allImpModNmL
%%]]
%%[[8
                                                    mods    = ppTbl "GB_ModEntry" @ppNmModEntriesTbl
                                                                ( [ ppCurlysCommasBlock [ pp $ show @moduleNm, ppAddrOf @ppNmByteCodeModule ] ]
                                                                  ++ [ppCurlysCommasBlock (replicate 2 $ pp $ "NULL")]
                                                                )
%%][20
                                                    impmods = ppTbl "GB_ImpModEntry" @ppImpModTbl
                                                                ( [ ppCurlysCommasBlock [ ppStr (show n), pp "0" >#< ppCmtC @lhs.opts "filled during linking" ]
                                                                  | (n,_) <- @impModNmL
                                                                  ]
                                                                )
                                                    mods    = ppTbl "GB_ModEntry" @ppNmModEntriesTbl
                                                                ( [ ppCurlysCommasBlock [ ppStr (show n), ppAddrOf $ mkPre m >|< @strNmExpNode, ppAddrOf $ mkPre m >|< @strNmByteCodeModule ]
                                                                  | (n,m) <- @allImpModNmL
                                                                  ]
                                                                  ++ [ppCurlysCommasBlock (replicate 3 $ pp $ "NULL")]
                                                                )
%%]]
                                                in  ( vlist
                                                      $  [ top ]
                                                      ++ strings
                                                      -- ++ gcInfos
                                                      ++ gcInfosTbl
                                                      ++ linkChainInds
                                                      ++ gcStackInfos
                                                      ++ callinfos
                                                      ++ bcode
                                                      ++ (if ehcOptGenTrace @lhs.opts then bcodetrace ++ bcodeentries else [])
                                                      ++ [bcodemodtrace]
                                                      ++ consts
                                                      ++ cafGlEntryIndices
                                                      ++ glEntries
%%[[20
                                                      ++ [ expnd
                                                         , impmods
                                                         ]
%%]]
                                                      ++ [ initf
%%[[8
                                                         , mods
                                                         , maincaf
                                                         , mainf
%%][20
%%]]
                                                         ]
%%[[8
%%][20
                                                    , vlist
                                                      $  [ maincaf ]
                                                      ++ externs
                                                      ++ [ mods
                                                         , mainf
                                                         ]
%%]]
                                                    )
%%]

%%[(8 codegen grin) hs
ppIntsAsHex :: [Int] -> PP_Doc
ppIntsAsHex xx = ppCurlysCommas [ ppHex' (Just 2) 2 x | x <- xx ]

ppStringAsHex :: String -> PP_Doc
ppStringAsHex s = ppIntsAsHex [ ord c | c <- s ++ [chr 0] ]
-- ppStringAsHex s = ppCurlysCommas [ ppHex' (Just 2) 2 (ord c) | c <- s ++ [chr 0] ]

ppStr :: String -> PP_Doc
ppStr s = pp $ show s

ppWord :: (Integral c) => c -> PP_Doc
ppWord = ppHexL . ppHex' (Just 2) (Cfg.sizeofWord * 2)

ppLinkChain :: Integer -> PP_Doc
ppLinkChain = ppWord

ppStaticDef :: String -> PP_Doc -> String -> PP_Doc -> PP_Doc
ppStaticDef ty nm modf def = "static" >#< ty >#< nm >|< modf >#< "=" >-< indent 2 (def >#< ";")
%%]

%%[(8 codegen grin)
SEM Instr
  | Ld St       lhs         .   pp          =   ppCommas [ppHex 2 @enc,@imm.pp]
  | Fetch       lhs         .   pp          =   ppCommas [ppHex 2 @enc]
  | Call Eval Apply AllocStore CaseCall LdGlobal
                lhs         .   pp          =   ppCommas [ppHex 2 @enc, ppLinkChain @linkChain]
  | TailCall RetCall
                lhs         .   pp          =   ppCommas [ppHex 2 @enc,ppHex 2 @enc2,@nArgMine.pp,@nArgSurr.pp]
  | TailEval    lhs         .   pp          =   ppCommas [ppHex 2 @enc,ppHex 2 @enc2,@nArgSurr.pp]
  | FetchUpdate LdNodeTag
                lhs         .   pp          =   ppCommas [ppHex 2 @enc]
  | CallC       lhs         .   pp          =   ppCommas [ppHex 2 @enc,ppHex 2 @enc2,@nArg.pp, @callEnc.pp, ppLinkChain @linkChain]
  | RetCase     lhs         .   pp          =   ppCommas [ppHex 2 @enc,ppHex 2 @enc2,@nRes.pp,@retOffSurr.pp, ppLinkChain @linkChain]
  | Op          lhs         .   pp          =   ppCommas [ppHex 2 @enc,ppHex 2 @enc2,@imm.pp]
  | Ann         lhs         .   pp          =   @instr.pp -- >#< ppCmtC @lhs.opts @ann
  | Halt TagInt2Word UntagWord2Int TagWord2Word UntagWord2Word
                lhs         .   pp          =   ppCommas [ppHex 2 @enc,ppHex 2 @enc2]
  | LabelRef    lhs         .   pp          =   ppCommas [ppWord @refOff]
  | LinkChain   lhs         .   pp          =   ppCommas [ppLinkChain @linkChain]
%%]

%%[(8 codegen grin)
SEM Imm
  | Int         loc         .   (ppL,sz)    =   case @lhs.immSz of
                                                  InsOp_ImmSz_Bits08 -> (ppHex' (Just 2)  2 @int,1)
                                                  InsOp_ImmSz_Bits16 -> (ppHex' (Just 2)  4 @int,2)
                                                  InsOp_ImmSz_Bits32 -> (ppHex' (Just 2)  8 @int,4)
                                                  InsOp_ImmSz_Bits64 -> (ppHex' (Just 2) 16 @int,8)
                lhs         .   pp          =   ppHexL @ppL
%%]

%%[(8 codegen grin)
ATTR Instrs [ | | ppL : {[PP_Doc]} ]

SEM Instrs
  | Nil         lhs         .   ppL         =   []
  | Cons        lhs         .   ppL         =   if @hd.hasCode
                                                then let instr = indent 3 @hd.pp
                                                         locmnemo = ppCmtC @lhs.opts (@lhs.cLoc >|< ":" >#< @hd.mn)
                                                         metapp = indent 40 (vlist $ map (\(k,m) -> ppCmtC @lhs.opts (k >#< "[" >#< m >#< "]")) $ @annL)
                                                     in  (locmnemo >|< metapp >-< instr) : @tl.ppL
                                                else @tl.ppL
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Symbolic bytecode table (for trace, debug)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs
type BCTrL = [(Int,Int,PP_Doc)]
%%]

%%[(8 codegen grin)
ATTR Instrs [ | | bcTrL: {[BCTrL]} ]

SEM Instrs
  | Nil         lhs         .   bcTrL       =   [[]]
  | Cons        lhs         .   bcTrL       =   if @hd.hasCode
                                                then let i = (@lhs.cLoc,@hd.cLoc - @lhs.cLoc,ppCommas' ([@hd.mn] ++ [ k >|< "=" >|< m | (k,m) <- @annL, allow k]))
                                                         allow k = not (k `elem` [AnnComment,AnnStackDepth])
                                                     in  case @tl.bcTrL of
                                                           (l:ls) -> (i:l) : ls
                                                else if @hd.isEntry then [] : @tl.bcTrL else @tl.bcTrL
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Generates code?
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin)
ATTR Instr [ | | hasCode: Bool ]

SEM Instr
  | Meta Label
                lhs         .   hasCode     =   False
  | * - Meta Label
                lhs         .   hasCode     =   True
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Additional comment
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin)
%%]
ATTR Instr Meta [ | | ppExtra USE {>|<} {empty}: PP_Doc ]
ATTR Instrs [ ppExtra: PP_Doc | | ]

SEM Meta
  | CmtHeader   lhs         .   ppExtra     =   indent 40 (ppCmtC @lhs.opts ("[" >#< @ann >#< "]"))

SEM Instr
  | Label       lhs         .   ppExtra     =   ppCmtC @lhs.opts ("[ .lbl" >#< lrefId @locRef >#< "]")

SEM Instrs
  | Cons        tl          .   ppExtra     =   @hd.ppExtra

SEM Module
  | Mod         instrs      .   ppExtra     =   empty

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Additional meta info to PP
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs
type AnnL = [(AnnKind,PP_Doc)]
%%]

%%[(8 codegen grin)
ATTR Instr Meta [ | | gathAnnL USE {++} {[]}: AnnL ]
ATTR Instrs Instr Meta [ annL: AnnL | | ]

SEM Meta
  | CmtHeader   lhs         .   gathAnnL    =   [(@kind,pp @ann)]

SEM Instr
  | Label       lhs         .   gathAnnL    =   [(AnnLabel,pp @locRef)]
  | LabelRef    lhs         .   gathAnnL    =   [(AnnLabelRef,pp @locRef)]
  | Ann         lhs         .   gathAnnL    =   (@kind,pp @ann) : @instr.gathAnnL

SEM Instrs
  | Cons        (loc.annL,tl.annL)          =   let m = @lhs.annL ++ @hd.gathAnnL
                                                in  if @hd.hasCode
                                                    then (m,[])
                                                    else ([],m)

SEM Module
  | Mod         instrs      .   annL        =   []
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% PP as mnemonic
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin)
ATTR AllInsOp Instr Imm [ | | mn USE {>|<} {empty}: PP_Doc ]
%%]

%%[(8 codegen grin)
SEM Instr
  | Ld          lhs         .   mn          =   "l"             >|< @ind.mn >|< @locDst.mn >|< @locSrc.mn >|< @immSz.mn >#< @imm.mn
  | St          lhs         .   mn          =   "s"             >|< @ind.mn >|< @locDst.mn >|< @locSrc.mn >|< @immSz.mn >#< @imm.mn
  | AllocStore  lhs         .   mn          =   "allocstore"    >|< @locSrc.mn
  | Fetch       lhs         .   mn          =   "fetch"         >|< @locSrc.mn
  | Call        lhs         .   mn          =   "call"          >|< @locSrc.mn
  | TailCall    lhs         .   mn          =   "tailcall"      >|< @locSrc.mn >|< @nArgMineSz.mn >|< @nArgSurrSz.mn >#< @nArgMine.mn >#< @nArgSurr.mn
  | TailEval    lhs         .   mn          =   "taileval"      >|< @locSrc.mn >|< @nArgSurrSz.mn >#< @nArgSurr.mn 
  | CaseCall    lhs         .   mn          =   pp "casecall"
  | FetchUpdate lhs         .   mn          =   pp "fetchupd"
  | LdNodeTag   lhs         .   mn          =   pp "lnt"
  | CallC       lhs         .   mn          =   "callc"         >|< @nArgSz.mn >#< @nArg.mn >#< @callEnc.mn
  | RetCall     lhs         .   mn          =   "retcall"       >|< @nArgMineSz.mn >|< @nArgSurrSz.mn >#< @nArgMine.mn >#< @nArgSurr.mn
  | RetCase     lhs         .   mn          =   "retcase"       >|< @nResSz.mn >|< @retOffSurrSz.mn >#< @nRes.mn >#< @retOffSurr.mn
  | Eval        lhs         .   mn          =   "eval"          >|< @locSrc.mn
  | Apply       lhs         .   mn          =   "apply"         >|< @locSrc.mn
  | Halt        lhs         .   mn          =   pp "halt"
  | TagInt2Word lhs         .   mn          =   pp "tagi2w"
  | UntagWord2Int
                lhs         .   mn          =   pp "untagw2i"
  | TagWord2Word
                lhs         .   mn          =   pp "tagw2w"
  | UntagWord2Word
                lhs         .   mn          =   pp "untagw2w"
  | LdGlobal	lhs         .   mn          =   "ldg"           >|< @locDst.mn
  | Op          lhs         .   mn          =   "o"             >|< @op.mn >|< @locDst.mn >|< @opndTy.mn >|< @ind.mn >|< @locSrc.mn >|< @immSz.mn >#< @imm.mn
  | LabelRef    lhs         .   mn          =   ".ref"          >#< lrefId @locRef
  | LinkChain   lhs         .   mn          =   pp ".lnk"

SEM Imm
  | Int         lhs         .   mn          =   case @lhs.immSz of
                                                  InsOp_ImmSz_Bits08 -> ppHex  2 @int
                                                  InsOp_ImmSz_Bits16 -> ppHex  4 @int
                                                  InsOp_ImmSz_Bits32 -> ppHex  8 @int
                                                  InsOp_ImmSz_Bits64 -> ppHex 16 @int

SEM InsOp_LocE
  | SP          lhs         .   mn          =   pp "s"
  | Reg         lhs         .   mn          =   pp "r"
  | Imm         lhs         .   mn          =   pp "i"
  | PC          lhs         .   mn          =   pp "p"

SEM InsOp_LocB
  | TOS         lhs         .   mn          =   pp "t"
  | Reg         lhs         .   mn          =   pp "r"

SEM InsOp_LocODst
  | TOS         lhs         .   mn          =   pp "t"
  | Reg         lhs         .   mn          =   pp "r"

SEM InsOp_LocOSrc
  | SP          lhs         .   mn          =   pp "s"
  | Reg         lhs         .   mn          =   pp "r"
  | Imm         lhs         .   mn          =   pp "i"
  | TOS         lhs         .   mn          =   pp "t"

SEM InsOp_TyOp
  | Add         lhs         .   mn          =   pp "a"
  | Sub         lhs         .   mn          =   pp "s"
  | Mul         lhs         .   mn          =   pp "m"
  | Quot        lhs         .   mn          =   pp "q"

SEM InsOp_DataOp
  | IntWord     lhs         .   mn          =   pp "iw"
  | IntInf      lhs         .   mn          =   pp "ii"
  | FloatWord   lhs         .   mn          =   pp "fw"

SEM InsOp_ImmSz
  | Bits08      lhs         .   mn          =   pp "08"
  | Bits16      lhs         .   mn          =   pp "16"
  | Bits32      lhs         .   mn          =   pp "32"
  | Bits64      lhs         .   mn          =   pp "64"

SEM InsOp_Deref
  | Zero        lhs         .   mn          =   pp "0"
  | One         lhs         .   mn          =   pp "1"
  | Two         lhs         .   mn          =   pp "2"
  | Int         lhs         .   mn          =   pp "i"

%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Encodings, must be same as rts/src/grinbc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin)
ATTR AllInsOp Meta [ | | enc: Int ]

SEM Instr
  -- load group
  | Ld          loc         .   enc         =   0x00 .|. (@ind.enc `shiftL` 5) .|. (@locDst.enc `shiftL` 4) .|. (@locSrc.enc `shiftL` 2) .|. (@immSz.enc)
  -- store group
  | St          loc         .   enc         =   0x80 .|. (@ind.enc `shiftL` 5) .|. (@locDst.enc `shiftL` 3) .|. (@locSrc.enc `shiftL` 2) .|. (@immSz.enc)
  -- arithmetic group
  | Op          loc         .   enc         =   0xC0 .|. (@op.enc `shiftL` 3) .|. (@opndTy.enc `shiftL` 1) .|. (@locDst.enc)
  -- eval/ldg group
  | Eval        loc         .   enc         =   0xE0 .|. (@locSrc.enc)
  | Apply       loc         .   enc         =   0xE2 .|. (@locSrc.enc)
  | TailEval    loc         .   enc         =   0xE4 .|. (@locSrc.enc)
  | LdGlobal	loc         .   enc         =   0xE6 .|. (@locDst.enc)
  -- call/control group
  | Call        loc         .   enc         =   0xF0 .|. (@locSrc.enc)
  | TailCall    loc         .   enc         =   0xF2 .|. (@locSrc.enc)
  | RetCall     loc         .   enc         =   0xF4
  | RetCase     loc         .   enc         =   0xF5
  | CaseCall    loc         .   enc         =   0xF6
  | CallC       loc         .   enc         =   0xF7
  -- alloc group
  | AllocStore  loc         .   enc         =   0xEC .|. (@locSrc.enc)
  | Fetch       loc         .   enc         =   0xEE .|. (@locSrc.enc)
  -- others
  | FetchUpdate loc         .   enc         =   0xF9
  | LdNodeTag   loc         .   enc         =   0xFC
  | Halt TagInt2Word UntagWord2Int TagWord2Word UntagWord2Word
            	loc         .   enc         =   0xFE
%%]

%%[(8 codegen grin)
SEM Instr
  | TailCall RetCall
                loc         .   enc2        =   (@nArgMineSz.enc `shiftL` 2) .|. (@nArgSurrSz.enc `shiftL` 0)
  | CallC       loc         .   enc2        =   (@nArgSz.enc)
  | TailEval    loc         .   enc2        =   (@nArgSurrSz.enc `shiftL` 0)
  | RetCase     loc         .   enc2        =   (@nResSz.enc `shiftL` 2) .|. (@retOffSurrSz.enc)
  | Op          loc         .   enc2        =   (@ind.enc `shiftL` 4) .|. (@locSrc.enc `shiftL` 2) .|. (@immSz.enc)
  | Halt        loc         .   enc2        =   0xFF
  | TagInt2Word loc         .   enc2        =   0xFC
  | UntagWord2Int
                loc         .   enc2        =   0xFD
  | TagWord2Word
                loc         .   enc2        =   0xFA
  | UntagWord2Word
                loc         .   enc2        =   0xFB

SEM Meta
  | CmtHeader   loc         .   enc         =   0xFF

SEM InsOp_LocE
  | SP          lhs         .   enc         =   0
  | Reg         lhs         .   enc         =   1
  | Imm         lhs         .   enc         =   2
  | PC          lhs         .   enc         =   3

SEM InsOp_LocB
  | TOS         lhs         .   enc         =   0
  | Reg         lhs         .   enc         =   1

SEM InsOp_LocODst
  | TOS         lhs         .   enc         =   0
  | Reg         lhs         .   enc         =   1

SEM InsOp_LocOSrc
  | SP          lhs         .   enc         =   0
  | Reg         lhs         .   enc         =   1
  | Imm         lhs         .   enc         =   2
  | TOS         lhs         .   enc         =   3

SEM InsOp_TyOp
  | Add         lhs         .   enc         =   0
  | Sub         lhs         .   enc         =   1
  | Mul         lhs         .   enc         =   2
  | Quot        lhs         .   enc         =   3

SEM InsOp_DataOp
  | IntWord     lhs         .   enc         =   0
  | IntInf      lhs         .   enc         =   1
  | FloatWord   lhs         .   enc         =   2

SEM InsOp_ImmSz
  | Bits08      lhs         .   enc         =   0
  | Bits16      lhs         .   enc         =   1
  | Bits32      lhs         .   enc         =   2
  | Bits64      lhs         .   enc         =   3

SEM InsOp_Deref
  | Zero        lhs         .   enc         =   0
  | One         lhs         .   enc         =   1
  | Two         lhs         .   enc         =   2
  | Int         lhs         .   enc         =   3

SEM InsOp_DerefB
  | One         lhs         .   enc         =   0
  | Two         lhs         .   enc         =   1
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% How to pp, context
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin)
ATTR Imm [ immSz: InsOp_ImmSz | | ]

SEM Instr
  | Ld St       imm         .   immSz       =   @immSz.self
  | Op          imm         .   immSz       =   @immSz.self
  | TailCall RetCall
                nArgMine    .   immSz       =   @nArgMineSz.self
                nArgSurr    .   immSz       =   @nArgSurrSz.self
  | TailEval    nArgSurr    .   immSz       =   @nArgSurrSz.self
  | CallC       nArg        .   immSz       =   @nArgSz.self
                callEnc     .   immSz       =   InsOp_ImmSz_Bits32
  | RetCase     nRes        .   immSz       =   @nResSz.self
                retOffSurr  .   immSz       =   @retOffSurrSz.self
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Replica's, SELF
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin)
ATTR InsOp_ImmSz [ | | self: SELF ]
%%]

