%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

Float all lambda's to global level.
Assume that each lambda has no free variables, other than the globally available ones.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Float lambda's to global level
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs module {%{EH}Core.Trf.LamFloatGlobal} import(EH.Util.Utils,EH.Util.FastSeq,{%{EH}Base.Common},{%{EH}Core},{%{EH}Ty}) export(cmodTrfLamFloatGlobal)
%%]

-- for debug
%%[8 hs import({%{EH}Base.Debug},UU.Pretty)
%%]

%%[8.WRAPPER ag import({Core/AbsSyn},{Core/CommonLev})
WRAPPER CodeAGItf
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell itf
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs
cmodTrfLamFloatGlobal :: CModule -> CModule
cmodTrfLamFloatGlobal cmod
  =  let  t = wrap_CodeAGItf  (sem_CodeAGItf (CodeAGItf_AGItf cmod))
                              (Inh_CodeAGItf)
     in   cTrf_Syn_CodeAGItf t
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Level
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
SEM CExpr
  | Let         binds       .   lev         =   @lhs.lev + 1
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Transformation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR AllCodeNT [ | | cTrf: SELF  cFloatedBinds USE {:++:} {FSeqNil}: {FastSeq (CBindCateg,FastSeq CBind)} ]
ATTR AllBind [ | | cLamBinds, cOtherBinds USE {:++:} {FSeqNil}: {FastSeq CBind} ]
ATTR CodeAGItf [ | | cTrf: CModule ]

SEM CBind
  | Bind        lhs         .   (cOtherBinds,cLamBinds)
                                            =   if @expr.isLam
                                                then (FSeqNil,FSeq @cTrf)
                                                else (FSeq @cTrf,FSeqNil)
  | FFI         lhs         .   cOtherBinds =   FSeq @cTrf

SEM CExpr
  | Let         lhs         .   (cTrf,cFloatedBinds)
                                            =   if @lhs.lev == cLevModule
                                                then ( foldr (\(c,b) e -> mkCExprLet c (toList b) e) @body.cTrf
                                                       $ toList (@binds.cFloatedBinds :++: FSeq (@categ,@binds.cLamBinds :++: @binds.cOtherBinds))
                                                     , FSeqNil
                                                     )
                                                else ( mkCExprLet @categ (toList @binds.cOtherBinds) @body.cTrf
                                                     , FSeq (@categ,@binds.cLamBinds) :++: @binds.cFloatedBinds :++: @body.cFloatedBinds
                                                     )
%%]

