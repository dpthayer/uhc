%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Inline let bindings for variables and constants
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs module {%{EH}Core.Trf.InlineLetAlias} import(Data.Maybe,qualified Data.Map as Map,{%{EH}Base.Common},{%{EH}Base.Builtin},{%{EH}Core},{%{EH}Ty}) export(cmodTrfInlineLetAlias)
%%]

%%[8.WRAPPER ag import({Core/AbsSyn},{Core/CommonLev})
WRAPPER CodeAGItf
%%]

%%[20 hs import(qualified Data.Set as Set)
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell itf
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8.cmodTrfInlineLetAlias hs
cmodTrfInlineLetAlias :: CModule -> CModule
cmodTrfInlineLetAlias cmod
  =  let  t = wrap_CodeAGItf (sem_CodeAGItf (CodeAGItf_AGItf cmod)) Inh_CodeAGItf
     in   cTrf_Syn_CodeAGItf t
%%]

%%[20 -8.cmodTrfInlineLetAlias hs
cmodTrfInlineLetAlias :: HsNameS -> CModule -> CModule
cmodTrfInlineLetAlias globNmS cmod
  =  let  t = wrap_CodeAGItf (sem_CodeAGItf (CodeAGItf_AGItf cmod))
                             (Inh_CodeAGItf {globNmS_Inh_CodeAGItf = globNmS})
     in   cTrf_Syn_CodeAGItf t
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Globally used vars
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[20
ATTR CodeAGItf CExpr CModule AllBind [ globNmS: HsNameS | | ]

SEM CAlt
  | Alt         loc         .   globNmS     =   Set.empty

SEM CPatBind
  | Bind        loc         .   globNmS     =   Set.empty
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Let bindings for just names
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs
type NmMp = Map.Map HsName CExpr
%%]

%%[8
ATTR AllCodeNT [ nmMp: NmMp | | ]

SEM CodeAGItf
  | AGItf       module      .   nmMp        =   Map.empty

SEM CExpr
  | Let         loc         .   allowTrf    =   @categ /= CBindStrict && @categ /= CBindFFI -- && @lhs.lev > cLevModule
                            .   allowStrTrf =   @categ /= CBindFFI -- && @lhs.lev > cLevModule
                            .   nmMpNew     =   Map.foldWithKey
                                                  (\n r m
                                                    -> case r of
                                                         CExpr_Var nm
                                                           | nm `Map.member` @binds.bindNmMp
                                                             -> m
                                                           | @allowTrf || (@allowStrTrf && cexprIsEvaluated r')
                                                             -> Map.insert n r' m
                                                           where r' = maybe r id . Map.lookup nm $ @lhs.nmMp
                                                         _ | @allowTrf
                                                             -> Map.insert n r m
                                                         CExpr_Int i
                                                           | @allowStrTrf
                                                             -> Map.insert n r m
                                                         _   -> m
                                                  )
                                                  Map.empty
                                                  @binds.bindNmMp
                            .   nmMp        =   @nmMpNew `Map.union` @lhs.nmMp
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Is expr a substitutable value?
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR CExpr [ | | mbRepl: {Maybe CExpr} ]

SEM CExpr
  | Var Int Char
  				lhs         .   mbRepl      =   Just @cTrf
  | * - Var Int Char
                lhs         .   mbRepl      =   Nothing
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Bound id's
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR AllBind [ | | bindNmMp USE {`Map.union`} {Map.empty}: NmMp ]
ATTR AllBind [ | | bindL USE {++} {[]}: {[(HsName,CBind)]} ]

SEM CBind
  | Bind        lhs         .   (bindNmMp,bindL)
                                            =   case @expr.mbRepl of
                                                  Just r | @nm /= hsnMain
%%[[20
                                                           && not (@nm `Set.member` @lhs.globNmS)
%%]]
                                                    -> (@nm `Map.singleton` r,[(@nm,@cTrf)])
                                                  _ -> (Map.empty,[(@nm,@cTrf)])
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Transformation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR AllCodeNT [ | | cTrf: SELF ]
ATTR CodeAGItf [ | | cTrf: CModule ]
%%]

%%[8
SEM CExpr
  | Let         lhs         .   cTrf        =   if Map.null @nmMpNew
                                                then @cTrf
                                                else mkCExprLet @categ [ b | (n,b) <- @binds.bindL, not (n `Map.member` @nmMpNew)] @body.cTrf
  | Var         lhs         .   cTrf        =   maybe @cTrf id . Map.lookup @nm $ @lhs.nmMp
%%]

