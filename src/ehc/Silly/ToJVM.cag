%%[0 hs
{
{-| JAVA!!!
-}
}
%%]

%%[(8 codegen grin) hs module {%{EH}Silly.ToJVM}
%%]
%%[(8 codegen grin) hs import({%{EH}Silly})
%%]
%%[(8 codegen grin) hs import({%{EH}Base.Common} hiding (nextUnique))
%%]
%%[(8 codegen grin) hs import({%{EH}Base.Opts})
%%]
%%[(8 codegen grin) hs import({%{EH}ConfigDefines})
%%]
%%[(8 codegen grin) import({Silly/AbsSyn})
%%]
%%[(8 codegen grin) hs import(EH.Util.Pretty)
%%]
%%[(8 codegen grin) hs import(Brianweb.Java hiding (Constant))
%%]
%%[(8 codegen grin) hs import(Brianweb.Java.Words (JInt))
%%]
%%[(8 codegen grin) hs import(Data.List (elemIndex))
%%]
%%[(8 codegen grin) hs import(qualified Brianweb.Java as J)
%%]
%%[(8 codegen grin)
WRAPPER SilModule
%%]

%%[(8 codegen grin)
PRAGMA nocycle
%%]

%%[(8 codegen grin) hs export( silly2jvm )
{-|
-} 

silly2jvm :: EHCOpts -> SilModule -> Class
silly2jvm opts silmod = 
  jvmCode_Syn_SilModule
     $ wrap_SilModule
        (sem_SilModule silmod)
        (Inh_SilModule 42)

nextUnique :: Int -> (Int, Int)
nextUnique u = (u + 1, u)

mergeCode :: Code -> Code -> Code
mergeCode (Code _ _ a) (Code _ _ b) = Code Nothing Nothing (a ++ b)

emptyCode :: Code
emptyCode = Code Nothing Nothing []

singleCode :: Instruction -> Code
singleCode = Code Nothing Nothing . return

code :: [Instruction] -> Code
code = Code Nothing Nothing

type JVMVar = String

cRuntime   = "Runtime"
cContainer = "Runtime$Container"
tContainer = TClass cContainer
fTag       = "tag"
fPayload   = "payload"
fIntVal    = "intVal"
fRP        = "RP"
fCRP       = "CRP"
fGlobals   = "Globals"
fCGlobals  = "CGlobals"

{-
testSilModule = SilModule_SilModule
  [] [] [
    Function_Function  (HNm "hsmain") False
    []
    []
    [
      Statement_IfThenElse
        (Value_CompareGT
          (Value_Con (Constant_LiteralInt 8))
          (Constant_LiteralInt 4)
        )
        ([Statement_Call (HNm "putStrLn") False
          [Value_Con (Constant_LiteralStr "aapjes!")]])
        ([Statement_Call (HNm "putStrLn") False
          [Value_Con (Constant_LiteralStr "kipjes!")]])
    , Statement_Return 1
    ]
  ]
  undefined
-}

primitiveFunctions :: [(HsName, Code -> Code)]
primitiveFunctions = [
  (HNm "putStrLn", \c ->
    singleCode (Get True (FieldRef {
      fr_class = "java.lang.System"
      , fr_name = "out"
      , fr_type = TClass "java.io.PrintStream"}
      ))
    `mergeCode` c `mergeCode`
    singleCode (
      Invoke IVirtual (MethodRef {
        mr_class = "java.io.PrintStream"
      , mr_name = "println"
      , mr_args = [TClass "java.lang.String"]
      , mr_ret = Nothing
      }))
    )
  ]

methodMain = 
  Method {
    m_flags = [Public,Static]
  , m_name = "main"
  , m_ret = Nothing
  , m_args = [TArray {unArray = TClass {unClass = "java.lang.String"}}]
  , m_code = Just (Code {
      c_max_stack  = Nothing
    , c_max_locals = Nothing
    , c_instructions = [
        Const (CInt 42)
      , Store TInt 1
      , Get True (FieldRef {
          fr_class = "java.lang.System"
        , fr_name = "out"
        , fr_type = TClass {unClass = "java.io.PrintStream"}
        })
      , Invoke IStatic (MethodRef {mr_class = "fib",     mr_name = "fun_x_1_main",  mr_args = [], mr_ret = Just TInt})
      , Invoke IStatic (MethodRef {mr_class = "Runtime", mr_name = "finish",        mr_args = [], mr_ret = Nothing})
      , Load TInt 1
      , Pop TInt
      , Return Nothing
      ]
    })
  , m_exceptions = []
  , m_signature = Nothing
  , m_deprecated = False
  }

%%]

{-
Possible optimizations

  1) Probably, not sure yet, the ALLOC size in silly is the maximum of all
     possible constructors for a data-type. This is safe but sometimes wastes
     some space. Maybe we can detect what the real value of this ALLOC should
     be for our payload array.
  2) Inline the payload into the container by statically creating a bunch of
     Java classes for every length a value can be. These classes can be called
     something like `Value<n>'. When we perform this the optimization (1) will
     bot be possible anymore, but we skip one indirection.
  3) Do not use a separate Int bucket for the case that the tag is CInt, but
     use some bit magic to store this integer in the tag itself.
  4) Do not use an indirect RP bucket to make our life easier in the Subs case
     but use a direct RP array. This is somewhat more involved because we then
     need to know that we are Subs'ing the RP which needs some aspect. This
     optimization is quite essential because you save an indirection on `every'
     return.
  n) ...
-}

%%[(8 codegen grin)
ATTR SilModule
     [ | | jvmCode : {Class} ]

ATTR Functions
     [ | | jvmCode : {[Method]} ]

ATTR Function
     [ | | jvmCode : {Method} ] 

ATTR Statements Statement 
     Values Value Variable 
     [ | | jvmCode : {Code} ]

ATTR Alternatives
     [ | | jvmCode : {[(JInt, Label, Code)]} ]  

ATTR Alternative
     [ | | jvmCode : {(JInt, Label, Code)} ]

ATTR AllNT
     [ | counter : Int | ]

ATTR AllNT - SilModule
     [ jvmCons : {[(String, Int)]} | | ]

ATTR AllNT - SilModule
     [ jvmGlobs : {[HsName]} | | ]

ATTR AllNT [ | | jvmIsTag USE {||} {False} : Bool ]

ATTR AllNT [ | | jvmIsInt USE {||} {False} : Bool ]
ATTR Variable [ jvmAssignInt : Bool | | ]

ATTR Constant [ | | jvmVal : {J.Constant} ]  

SEM SilModule
  | SilModule   lhs.jvmCode  = defaultClass {
                                 c_methods = methodMain : @functions.jvmCode
                               , c_this    = "fib"
                               }
          functions.jvmCons  = @constants
          functions.jvmGlobs = @variables

SEM Functions
  | Cons        lhs.jvmCode = @hd.jvmCode : @tl.jvmCode
  | Nil         lhs.jvmCode = []

SEM Function
  | Function    lhs.jvmCode = Method {
                                m_flags = [Public,Static]
                              , m_name       = show @name
                              , m_ret        = Just TInt
                              , m_args       = replicate (length @parameters) (TClass cObject)
                              , m_exceptions = []
                              , m_signature  = Nothing
                              , m_deprecated = False
                              , m_code       = Just @body.jvmCode
                              }

SEM Statements
  | Cons        lhs.jvmCode = @hd.jvmCode `mergeCode` @tl.jvmCode
  | Nil         lhs.jvmCode = emptyCode

{
jvmAssignment dest source isTag isInt =
  dest
  `mergeCode` source
  `mergeCode` singleCode
  (if isTag
  then Put False (FieldRef cContainer fTag TInt)
  else if isInt
       then Put False (FieldRef cContainer fIntVal TInt)
       else AStore tObject)

-- Muchos pain! Because we might/probably compute source twice.
jvmAssignment2 dest1 dest2 source isTag isInt =

  dest1
  `mergeCode` source
  `mergeCode` singleCode
  (if isTag
  then Put False (FieldRef cContainer fTag TInt)
  else if isInt
       then Put False (FieldRef cContainer fIntVal TInt)
       else AStore tObject)

  `mergeCode` dest2
  `mergeCode` source
  `mergeCode` singleCode
  (if isTag
  then Put False (FieldRef cContainer fTag TInt)
  else if isInt
       then Put False (FieldRef cContainer fIntVal TInt)
       else AStore tObject)

}

SEM Statement
  -- Watch out that indices 1 upto N are in the array not in the box itself.
  | Assignment  lhs.jvmCode = jvmAssignment @dest.jvmCode @source.jvmCode @dest.jvmIsTag @source.jvmIsInt
                dest.jvmAssignInt = @source.jvmIsInt
  | Assignment2 lhs.jvmCode = jvmAssignment2 @dest1.jvmCode @dest2.jvmCode @source.jvmCode @dest1.jvmIsTag @source.jvmIsInt
                dest1.jvmAssignInt = @source.jvmIsInt
                dest2.jvmAssignInt = @source.jvmIsInt
  | Call        lhs.jvmCode = maybe (error "JVM: no real call yet") ($ @args.jvmCode)
                              (lookup @name primitiveFunctions)
  | Comment     lhs.jvmCode = emptyCode

  {-
  INVARIANT: This generic IfThenElse compiles to the specific
  greater-than-equal comparison, because this is the only pattern it appears in
  the original silly code.
  -}
  | IfThenElse  loc.labelElse  : UNIQUEREF counter
                loc.labelEndIf : UNIQUEREF counter
                lhs.jvmCode = @condition.jvmCode
                              `mergeCode` singleCode (If CmpGt @loc.labelElse)
                              `mergeCode` @thenpart.jvmCode
                              `mergeCode` singleCode (Goto @loc.labelEndIf)
                              `mergeCode` singleCode (Note (Label @loc.labelElse))
                              `mergeCode` @elsepart.jvmCode
                              `mergeCode` singleCode (Note (Label @loc.labelEndIf))
  | Switch      loc.labelSwitchEnd : UNIQUEREF counter
                lhs.jvmCode = let 
                                alts   = @body.jvmCode
                                end    = @loc.labelSwitchEnd
                                arms   = map (\(_, _, code)   -> code `mergeCode` singleCode (Goto end))
                                labels = map (\(when, lbl, _) -> (when, lbl))
                              in
                              @scrutinee.jvmCode
                              `mergeCode` singleCode (Switch Lookup 0 (labels alts))
                              `mergeCode` foldl mergeCode emptyCode (arms alts)
                              `mergeCode` singleCode (Note (Label end))
  | Jump        lhs.jvmCode = error "JVM: no jumps  supported."
  | Label       lhs.jvmCode = error "JVM: no labels supported."
  | Return      lhs.jvmCode = code [Const $ CInt $ fromIntegral @retdiff, Return $ Just TInt]
  | Smart       lhs.jvmCode = error "JVM: not implemented yet (smart)."
  | * - Assignment Assignment2 Call Comment Jump Label Return Smart Switch IfThenElse
                lhs.jvmCode = error "JVM: not supported."

SEM Alternatives
  | Cons        lhs.jvmCode = @hd.jvmCode : @tl.jvmCode
  | Nil         lhs.jvmCode = []

SEM Alternative
  | Alternative lhs.jvmCode = let l = @loc.label in
                              case @when.jvmVal of
                                CInt i -> (i, l, singleCode (Note $ Label l) `mergeCode` @body.jvmCode)
                                _      -> error "JVM: non-integer case scrutinee"
                loc.label   : UNIQUEREF counter

SEM Values
  | Cons        lhs.jvmCode = @hd.jvmCode `mergeCode` @tl.jvmCode
  | Nil         lhs.jvmCode = emptyCode

SEM Value
  | Alloc       lhs.jvmCode = code [
                                  New cContainer
                                , Dup TInt
                                , Dup TInt
                                , Invoke ISpecial (MethodRef cContainer "<init>" [] Nothing)
                                , Const (CInt (fromIntegral @size - 1))
                                , NewArray tObject 1
                                , Put False (FieldRef cContainer fPayload (TArray tObject))
                                ]
  | Call        lhs.jvmCode = maybe (error "JVM: no such foreign call") ($ @args.jvmCode)
                              (lookup (HNm @name) primitiveFunctions)
  | Con         lhs.jvmCode = singleCode $ Const @con.jvmVal
  | Var         lhs.jvmCode = @var.jvmCode
                var.jvmAssignInt = False
  | CompareGT   lhs.jvmCode = singleCode (Const @con.jvmVal) `mergeCode` @val.jvmCode
  | Offset      lhs.jvmCode = @var.jvmCode
                              `mergeCode` singleCode (Const (CInt (fromIntegral @off)))
                              `mergeCode` singleCode (Arith Add TInt)
                var.jvmAssignInt = False
  | Label       lhs.jvmCode = error "JVM: no support for Var Labels."

SEM Variable
  | Global      lhs.jvmCode = code [  -- todo: do not use indirection (container) here.
                                  Get True $ FieldRef cRuntime fCGlobals $ tContainer
                                , Get False (FieldRef cContainer fPayload (TArray tObject))
                                , Const (CInt $ fromIntegral $ maybe (error "JVM: global lookup failed") id $ @name `elemIndex` @lhs.jvmGlobs)
                                ]
  | Local       lhs.jvmCode = singleCode $ Load TInt $ fromIntegral (@pos + 1)
  | Param       lhs.jvmCode = error "JVM: not implemented yet (param)."
  | RP          lhs.jvmCode = singleCode $ Get True $ FieldRef cRuntime fCRP $ tContainer
  | Subs        lhs.jvmCode = @array.jvmCode `mergeCode`
                              (if @index == 0 || @lhs.jvmAssignInt
                              then emptyCode
                              else code [
                                  Get False (FieldRef cContainer fPayload (TArray tObject))
                                , Const (CInt (fromIntegral @index - 1))
                                ])
               lhs.jvmIsTag = @index == 0

  | * - Global Local Param RP Subs
                lhs.jvmCode = error "JVM: this Variable kind not supported."

SEM Constant
  | LiteralInt  lhs.jvmVal   = CInt (fromIntegral @value)
                lhs.jvmIsInt = True
  | LiteralStr  lhs.jvmVal   = CString @value
  | Alias       lhs.jvmVal   = case @name `lookup` @lhs.jvmCons of
                                 Nothing -> error ("JVM: no such constant alias: " ++ @name)
                                 Just  a -> CInt (fromIntegral a)


%%]

