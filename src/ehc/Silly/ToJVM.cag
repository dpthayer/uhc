%%[0 hs
{
{-| JAVA!!!
-}
}
%%]

%%[(8 codegen grin) hs module {%{EH}Silly.ToJVM}
%%]
%%[(8 codegen grin) hs import({%{EH}Silly})
%%]
%%[(8 codegen grin) hs import({%{EH}Base.Common} hiding (nextUnique))
%%]
%%[(8 codegen grin) hs import({%{EH}Base.Opts})
%%]
%%[(8 codegen grin) hs import({%{EH}ConfigDefines})
%%]
%%[(8 codegen grin) import({Silly/AbsSyn})
%%]
%%[(8 codegen grin) hs import(EH.Util.Pretty)
%%]
%%[(8 codegen grin) hs import(Brianweb.Java hiding (Constant))
%%]
%%[(8 codegen grin) hs import(qualified Brianweb.Java as J)
%%]
%%[(8 codegen grin)
WRAPPER SilModule
%%]

%%[(8 codegen grin)
PRAGMA nocycle
%%]

%%[(8 codegen grin) hs export( silly2jvm )
{-|
-} 

silly2jvm :: EHCOpts -> SilModule -> Class
silly2jvm opts silmod = 
  jvmCode_Syn_SilModule
     $ wrap_SilModule
        (sem_SilModule testSilModule)
        (Inh_SilModule 42)

nextUnique :: Int -> (Int, Int)
nextUnique u = (u + 1, u)

mergeCode :: Code -> Code -> Code
mergeCode (Code _ _ a) (Code _ _ b) = Code Nothing Nothing (a ++ b)

emptyCode :: Code
emptyCode = Code Nothing Nothing []

singleCode :: Instruction -> Code
singleCode = Code Nothing Nothing . return

code :: [Instruction] -> Code
code = Code Nothing Nothing

type JVMVar = String

testSilModule = SilModule_SilModule
  [] [] [
    Function_Function  (HNm "hsmain") False
    []
    []
    [
      Statement_IfThenElse
        (Value_CompareGT
          (Value_Con (Constant_LiteralInt 4))
          (Constant_LiteralInt 8)
        )
        ([Statement_Call (HNm "putStrLn") False
          [Value_Con (Constant_LiteralStr "aapjes!")]])
        ([Statement_Call (HNm "putStrLn") False
          [Value_Con (Constant_LiteralStr "kipjes!")]])
    , Statement_Return 1
    ]
  ]

primitiveFunctions :: [(HsName, Code -> Code)]
primitiveFunctions = [
  (HNm "putStrLn", \c ->
    singleCode (Get True (FieldRef {
      fr_class = "java.lang.System"
      , fr_name = "out"
      , fr_type = TClass {unClass = "java.io.PrintStream"}}
      ))
    `mergeCode` c `mergeCode`
    singleCode (
      Invoke IVirtual (MethodRef {
        mr_class = "java.io.PrintStream"
      , mr_name = "println"
      , mr_args = [TClass {unClass = "java.lang.String"}]
      , mr_ret = Nothing
      }))
    )
  ]

methodMain = 
  Method {
    m_flags = [Public,Static]
  , m_name = "main"
  , m_ret = Nothing
  , m_args = [TArray {unArray = TClass {unClass = "java.lang.String"}}]
  , m_code = Just (Code {
      c_max_stack = Nothing
    , c_max_locals = Nothing
    , c_instructions = [
        Const (CInt 42)
      , Store TInt 1
      , Get True (FieldRef {
          fr_class = "java.lang.System"
        , fr_name = "out"
        , fr_type = TClass {unClass = "java.io.PrintStream"}
        })
      , Invoke IStatic  (MethodRef {mr_class = "hello",               mr_name = "hsmain",  mr_args = [], mr_ret = Just TInt})
      , Invoke IVirtual (MethodRef {mr_class = "java.io.PrintStream", mr_name = "println", mr_args = [TInt], mr_ret = Nothing})
      , Load TInt 1
      , Pop TInt
      , Return Nothing
      ]
    })
  , m_exceptions = []
  , m_signature = Nothing
  , m_deprecated = False
  }

%%]

%%[(8 codegen grin)
ATTR SilModule
     [ | | jvmCode : {Class} ]

ATTR Functions
     [ | | jvmCode : {[Method]} ]

ATTR Function
     [ | | jvmCode : {Method} ] 

ATTR Statements Statement Alternative
     Values Value Variable 
     [ | | jvmCode : {Code} ]

ATTR SilModule
     Function Functions
     Statement Statements
     Value Values
     Alternative Alternatives
     Variable Variable
     [ | counter : Int | ]

ATTR Constant
     [ | | jvmVal  : {J.Constant} ]  

ATTR Alternatives
     [ | | jvmCode : {[Code]} ]  




SEM SilModule
  | SilModule   lhs.jvmCode = defaultClass {
                                c_methods = methodMain : @functions.jvmCode
                              , c_this    = "hello"
                              }

SEM Functions
  | Cons        lhs.jvmCode = @hd.jvmCode : @tl.jvmCode

  | Nil         lhs.jvmCode = []

SEM Function
  | Function    lhs.jvmCode = Method {
                                m_flags = [Public,Static]
                              , m_name       = show @name
                              , m_ret        = Just TInt -- Return type.
                              , m_args       = replicate (length @parameters) (TClass cObject)
                              , m_exceptions = []
                              , m_signature  = Nothing
                              , m_deprecated = False
                              , m_code       = Just @body.jvmCode
                              }
SEM Statements
  | Cons        lhs.jvmCode = @hd.jvmCode `mergeCode` @tl.jvmCode

  | Nil         lhs.jvmCode = emptyCode

SEM Statement
  | Assignment  lhs.jvmCode = error "JVM: not implemented yet."

  | Assignment2 lhs.jvmCode = error "JVM: not implemented yet."

  | Call        lhs.jvmCode = maybe (error "JVM: no real call yet") ($ @args.jvmCode)
                              (lookup @name primitiveFunctions)

  | Comment     lhs.jvmCode = error "JVM: not implemented yet."

  {-
  INVARIANT: This generic IfThenElse compiles to the specific
  greater-than-equal comparison, because this is the only pattern it appears in
  the original silly code.
  -}
  | IfThenElse  loc.labelElse  : UNIQUEREF counter
                loc.labelEndIf : UNIQUEREF counter
                lhs.jvmCode = @condition.jvmCode
                              `mergeCode` singleCode (If CmpGt @loc.labelElse)
                              `mergeCode` @thenpart.jvmCode
                              `mergeCode` singleCode (Goto @loc.labelEndIf)
                              `mergeCode` singleCode (Note (Label @loc.labelElse))
                              `mergeCode` @elsepart.jvmCode
                              `mergeCode` singleCode (Note (Label @loc.labelEndIf))

  | Switch      lhs.jvmCode = error "JVM: not implemented yet."

  | Jump        lhs.jvmCode = error "JVM: not implemented yet."

  | Label       lhs.jvmCode = error "JVM: not implemented yet."

  | Return      lhs.jvmCode = code [Const $ CInt $ fromIntegral @retdiff, Return $ Just TInt]

  | Smart       lhs.jvmCode = error "JVM: not implemented yet."

  | * - Assignment Assignment2 Call Comment Jump Label Return Smart Switch IfThenElse
                lhs.jvmCode = error "JVM: not implemented yet."

SEM Alternatives
  | Cons        lhs.jvmCode = @hd.jvmCode : @tl.jvmCode

  | Nil         lhs.jvmCode = []

SEM Alternative
  | Alternative lhs.jvmCode = error "JVM: not implemented yet."

SEM Values
  | Cons        lhs.jvmCode = @hd.jvmCode `mergeCode` @tl.jvmCode

  | Nil         lhs.jvmCode = emptyCode

SEM Value
  | Alloc       lhs.jvmCode = singleCode $ NewArray TInt (fromIntegral @size) -- todo: always managed?

  | Call        lhs.jvmCode = maybe (error "JVM: no such foreign call") ($ @args.jvmCode)
                              (lookup (HNm @name) primitiveFunctions)

  | Con         lhs.jvmCode = singleCode $ Const @con.jvmVal

  | Var         lhs.jvmCode = error "JVM: no support for Var Values."

  | CompareGT   lhs.jvmCode = @val.jvmCode `mergeCode` singleCode (Const @con.jvmVal)

  | Offset      lhs.jvmCode = @var.jvmCode
                              `mergeCode` singleCode (Const (CInt (fromIntegral @off)))
                              `mergeCode` singleCode (Arith Add TInt)

  | Label       lhs.jvmCode = error "JVM: no support for Var Labels."

SEM Variable
  | Global      lhs.jvmCode = error "JVM: not implemented yet."

  | Local       lhs.jvmCode = error "JVM: not implemented yet."

  | Param       lhs.jvmCode = error "JVM: not implemented yet."

  | RP          lhs.jvmCode = error "JVM: not implemented yet."

  | Subs        lhs.jvmCode = error "JVM: not implemented yet."

  | * - Global Local Param RP Subs
                lhs.jvmCode = error "JVM: not implemented yet."

SEM Constant
  | LiteralInt  lhs.jvmVal  = CInt (fromIntegral @value)

  | LiteralStr  lhs.jvmVal  = CString @value

  | Alias       lhs.jvmVal  = error "JVM: not implemented yet."

%%]


{-test = Class {c_major = 49
             ,c_minor = 0
             ,c_flags = [Super]
             ,c_this = "hello"
             ,c_super = Just "java.lang.Object"
             ,c_interfaces = []
             ,c_fields = []
             ,c_methods = [
                Method {m_flags = []
                 ,m_name = "<init>"
                 ,m_ret = Nothing
                 ,m_args = []
                 ,m_code = Just (Code {c_max_stack = Nothing
                                      ,c_max_locals = Nothing
                                      ,c_instructions = [ Note (LineNumber 1)
                                                        , Load (TClass {unClass = "java.lang.Object"}) 0
                                                        , Invoke ISpecial (MethodRef {mr_class = "java.lang.Object"
                                                                                     ,mr_name = "<init>"
                                                                                     ,mr_args = []
                                                                                     ,mr_ret = Nothing}
                                                                          )
                                                        , Return Nothing
                                                        ]
                                       })
                 ,m_exceptions = []
                 ,m_signature = Nothing
                 ,m_deprecated = False},
               Method {m_flags = [Public,Static]
               ,m_name = "main"
               ,m_ret = Nothing
               ,m_args = [TArray {unArray = TClass {unClass = "java.lang.String"}}]
               ,m_code = Just (Code {c_max_stack = Nothing
                                    ,c_max_locals = Nothing
                                    ,c_instructions = [Note (LineNumber 5),
                                                       Get True (FieldRef {
                                                          fr_class = "java.lang.System"
                                                         ,fr_name = "out"
                                                         ,fr_type = TClass {unClass = "java.io.PrintStream"}}
                                                         )
                                                       , Const (CString "hello, oops")
                                                       , Invoke IVirtual (MethodRef {mr_class = "java.io.PrintStream" ,mr_name = "println" ,mr_args = [TClass {unClass = "java.lang.String"}] ,mr_ret = Nothing})
                                                       , Note (LineNumber 6),Return Nothing]
                                                      })
                              ,m_exceptions = []
                              ,m_signature = Nothing
                              ,m_deprecated = False}
              ]
              ,c_sourcefile = Just "hello.java"
              ,c_innerclasses = []
              ,c_enclosing_method = Nothing
              ,c_signature = Nothing
              ,c_deprecated = False
              ,c_userdata = []
           }-}

