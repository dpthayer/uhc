%%[0 hs
{
{-| JAVA!!!
-}
}
%%]

%%[(8 codegen grin) hs module {%{EH}Silly.ToJVM}
%%]
%%[(8 codegen grin) hs import({%{EH}Silly})
%%]
%%[(8 codegen grin) hs import({%{EH}Base.Common} hiding (nextUnique))
%%]
%%[(8 codegen grin) hs import({%{EH}Base.Opts})
%%]
%%[(8 codegen grin) hs import({%{EH}ConfigDefines})
%%]
%%[(8 codegen grin) import({Silly/AbsSyn})
%%]
%%[(8 codegen grin) hs import(EH.Util.Pretty)
%%]
%%[(8 codegen grin) hs import(Brianweb.Java hiding (Constant))
%%]
%%[(8 codegen grin) hs import(qualified Brianweb.Java as J)
%%]
%%[(8 codegen grin)
WRAPPER SilModule
%%]

%%[(8 codegen grin)
PRAGMA nocycle
%%]

%%[(8 codegen grin) hs export( silly2jvm )
{-|
-} 

silly2jvm :: EHCOpts -> SilModule -> Class
silly2jvm opts silmod = 
  jvmCode_Syn_SilModule
     $ wrap_SilModule
        (sem_SilModule testSilModule)
        (Inh_SilModule 42)

nextUnique :: Int -> (Int, Int)
nextUnique u = (u + 1, u)

mergeCode :: Code -> Code -> Code
mergeCode (Code _ _ a) (Code _ _ b) = Code Nothing Nothing (a ++ b)

emptyCode :: Code
emptyCode = Code Nothing Nothing []

singleCode :: Instruction -> Code
singleCode = Code Nothing Nothing . return

code :: [Instruction] -> Code
code = Code Nothing Nothing

type JVMVar = String

cRuntime   = "Runtime"
cContainer = "Runtime$Container"
tContainer = TClass cContainer
fPayload   = "payload"
fTag       = "tag"
fRP        = "RP"
fCRP       = "CRP"

testSilModule = SilModule_SilModule
  [] [] [
    Function_Function  (HNm "hsmain") False
    []
    []
    [
      Statement_IfThenElse
        (Value_CompareGT
          (Value_Con (Constant_LiteralInt 8))
          (Constant_LiteralInt 4)
        )
        ([Statement_Call (HNm "putStrLn") False
          [Value_Con (Constant_LiteralStr "aapjes!")]])
        ([Statement_Call (HNm "putStrLn") False
          [Value_Con (Constant_LiteralStr "kipjes!")]])
    , Statement_Return 1
    ]
  ]
  undefined

primitiveFunctions :: [(HsName, Code -> Code)]
primitiveFunctions = [
  (HNm "putStrLn", \c ->
    singleCode (Get True (FieldRef {
      fr_class = "java.lang.System"
      , fr_name = "out"
      , fr_type = TClass "java.io.PrintStream"}
      ))
    `mergeCode` c `mergeCode`
    singleCode (
      Invoke IVirtual (MethodRef {
        mr_class = "java.io.PrintStream"
      , mr_name = "println"
      , mr_args = [TClass "java.lang.String"]
      , mr_ret = Nothing
      }))
    )
  ]

methodMain = 
  Method {
    m_flags = [Public,Static]
  , m_name = "main"
  , m_ret = Nothing
  , m_args = [TArray {unArray = TClass {unClass = "java.lang.String"}}]
  , m_code = Just (Code {
      c_max_stack  = Nothing
    , c_max_locals = Nothing
    , c_instructions = [
        Const (CInt 42)
      , Store TInt 1
      , Get True (FieldRef {
          fr_class = "java.lang.System"
        , fr_name = "out"
        , fr_type = TClass {unClass = "java.io.PrintStream"}
        })
      , Invoke IStatic  (MethodRef {mr_class = "hello",               mr_name = "hsmain",  mr_args = [], mr_ret = Just TInt})
      , Invoke IVirtual (MethodRef {mr_class = "java.io.PrintStream", mr_name = "println", mr_args = [TInt], mr_ret = Nothing})
      , Load TInt 1
      , Pop TInt
      , Return Nothing
      ]
    })
  , m_exceptions = []
  , m_signature = Nothing
  , m_deprecated = False
  }

%%]

{-
Possible optimizations

  1) Probably, not sure yet, the ALLOC size in silly is the maximum of all
     possible constructors for a data-type. This is safe but sometimes wastes
     some space. Maybe we can detect what the real value of this ALLOC should
     be for our payload array.
  2) Inline the payload into the container by statically creating a bunch of
     Java classes for every length a value can be. These classes can be called
     something like `Value<n>'. When we perform this the optimization (1) will
     bot be possible anymore, but we skip one indirection.
  3) Do not use a separate Int bucket for the case that the tag is CInt, but
     use some bit magic to store this integer in the tag itself.
  4) Do not use an indirect RP bucket to make our life easier in the Subs case
     but use a direct RP array. This is somewhat more involved because we then
     need to know that we are Subs'ing the RP which needs some aspect. This
     optimization is quite essential because you save an indirection on `every'
     return.
  n) ...
-}

%%[(8 codegen grin)
ATTR SilModule
     [ | | jvmCode : {Class} ]

ATTR Functions
     [ | | jvmCode : {[Method]} ]

ATTR Function
     [ | | jvmCode : {Method} ] 

ATTR Statements Statement Alternative
     Values Value Variable 
     [ | | jvmCode : {Code} ]

ATTR SilModule
     Function Functions
     Statement Statements
     Value Values
     Alternative Alternatives
     Variable Variable
     [ | counter : Int | ]

ATTR Function Functions
     Statement Statements
     Value Values
     Alternative Alternatives
     Variable Variable
     [ jvmCons : {[(String, Int)]} | | ]

ATTR Constant
     [ | | jvmVal  : {J.Constant} ]  

ATTR Alternatives
     [ | | jvmCode : {[Code]} ]  

SEM SilModule
  | SilModule   lhs.jvmCode = defaultClass {
                                c_methods = methodMain : @functions.jvmCode
                              , c_this    = "hello"
                              }
          functions.jvmCons = @constants

SEM Functions
  | Cons        lhs.jvmCode = @hd.jvmCode : @tl.jvmCode
  | Nil         lhs.jvmCode = []

SEM Function
  | Function    lhs.jvmCode = Method {
                                m_flags = [Public,Static]
                              , m_name       = show @name
                              , m_ret        = Just TInt -- Return type.
                              , m_args       = replicate (length @parameters) (TClass cObject)
                              , m_exceptions = []
                              , m_signature  = Nothing
                              , m_deprecated = False
                              , m_code       = Just @body.jvmCode
                              }

SEM Statements
  | Cons        lhs.jvmCode = @hd.jvmCode `mergeCode` @tl.jvmCode
  | Nil         lhs.jvmCode = emptyCode

SEM Statement
  -- Watch out that indices 1 upto N are in the array not in the box itself.
  | Assignment  lhs.jvmCode = error "JVM: not implemented yet."
  | Assignment2 lhs.jvmCode = error "JVM: not implemented yet."
  | Call        lhs.jvmCode = maybe (error "JVM: no real call yet") ($ @args.jvmCode)
                              (lookup @name primitiveFunctions)
  | Comment     lhs.jvmCode = error "JVM: not implemented yet."

  {-
  INVARIANT: This generic IfThenElse compiles to the specific
  greater-than-equal comparison, because this is the only pattern it appears in
  the original silly code.
  -}
  | IfThenElse  loc.labelElse  : UNIQUEREF counter
                loc.labelEndIf : UNIQUEREF counter
                lhs.jvmCode = @condition.jvmCode
                              `mergeCode` singleCode (If CmpGt @loc.labelElse)
                              `mergeCode` @thenpart.jvmCode
                              `mergeCode` singleCode (Goto @loc.labelEndIf)
                              `mergeCode` singleCode (Note (Label @loc.labelElse))
                              `mergeCode` @elsepart.jvmCode
                              `mergeCode` singleCode (Note (Label @loc.labelEndIf))
  | Switch      lhs.jvmCode = error "JVM: not implemented yet."
  | Jump        lhs.jvmCode = error "JVM: no jumps  supported."
  | Label       lhs.jvmCode = error "JVM: no labels supported."
  | Return      lhs.jvmCode = code [Const $ CInt $ fromIntegral @retdiff, Return $ Just TInt]
  | Smart       lhs.jvmCode = error "JVM: not implemented yet."
  | * - Assignment Assignment2 Call Comment Jump Label Return Smart Switch IfThenElse
                lhs.jvmCode = error "JVM: not supported."

SEM Alternatives
  | Cons        lhs.jvmCode = @hd.jvmCode : @tl.jvmCode
  | Nil         lhs.jvmCode = []

SEM Alternative
  | Alternative lhs.jvmCode = error "JVM: not implemented yet."

SEM Values
  | Cons        lhs.jvmCode = @hd.jvmCode `mergeCode` @tl.jvmCode
  | Nil         lhs.jvmCode = emptyCode

SEM Value
  | Alloc       lhs.jvmCode = code [
                                  New cContainer
                                , Dup TInt
                                , Dup TInt
                                , Invoke ISpecial (MethodRef cContainer "<init>" [] Nothing)
                                , Const (CInt (fromIntegral @size - 1))
                                , NewArray tObject 1
                                , Put False (FieldRef cContainer fPayload (TArray tObject))
                                ]
  | Call        lhs.jvmCode = maybe (error "JVM: no such foreign call") ($ @args.jvmCode)
                              (lookup (HNm @name) primitiveFunctions)
  | Con         lhs.jvmCode = singleCode $ Const @con.jvmVal
  | Var         lhs.jvmCode = error "JVM: no support for Var Values."
  | CompareGT   lhs.jvmCode = singleCode (Const @con.jvmVal) `mergeCode` @val.jvmCode
  | Offset      lhs.jvmCode = @var.jvmCode
                              `mergeCode` singleCode (Const (CInt (fromIntegral @off)))
                              `mergeCode` singleCode (Arith Add TInt)
  | Label       lhs.jvmCode = error "JVM: no support for Var Labels."

SEM Variable
  | Global      lhs.jvmCode = error "JVM: not implemented yet."
  | Local       lhs.jvmCode = singleCode $ Load TInt $ fromIntegral (@pos + 1)
  | Param       lhs.jvmCode = error "JVM: not implemented yet."
  | RP          lhs.jvmCode = singleCode $ Get True $ FieldRef cRuntime fCRP $ TArray tObject
  | Subs        lhs.jvmCode = if @index == 0
                              then singleCode (Get False (FieldRef cContainer fTag TInt))
                              else code [
                                  Get False (FieldRef cContainer fPayload tContainer)
                                , Const (CInt (fromIntegral @index - 1))
                                , ALoad tObject
                                ]
  | * - Global Local Param RP Subs
                lhs.jvmCode = error "JVM: this Variable kind not supported."

SEM Constant
  | LiteralInt  lhs.jvmVal  = CInt (fromIntegral @value)
  | LiteralStr  lhs.jvmVal  = CString @value
  | Alias       lhs.jvmVal  = error "JVM: aliases not supported."

%%]

