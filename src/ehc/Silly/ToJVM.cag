%%[0 hs
{
{-| JAVA!!!
-}
}
%%]

%%[(8 codegen grin) hs module {%{EH}Silly.ToJVM}
%%]
%%[(8 codegen grin) hs import({%{EH}Silly})
%%]
%%[(8 codegen grin) hs import({%{EH}Base.Common})
%%]
%%[(8 codegen grin) hs import({%{EH}Base.Opts})
%%]
%%[(8 codegen grin) hs import({%{EH}ConfigDefines})
%%]
%%[(8 codegen grin) import({Silly/AbsSyn})
%%]
%%[(8 codegen grin) hs import(EH.Util.Pretty)
%%]
%%[(8 codegen grin) hs import(Brianweb.Java hiding (Constant))
%%]
%%[(8 codegen grin)
WRAPPER SilModule
%%]

%%[(8 codegen grin)
PRAGMA nocycle
%%]

%%[(8 codegen grin) hs export( silly2jvm )
{-|
-} 
silly2jvm :: EHCOpts -> SilModule -> Class
silly2jvm opts silmod = 
  jvmCode_Syn_SilModule
     $ wrap_SilModule
        (sem_SilModule testSilModule)
        (Inh_SilModule)

testSilModule = SilModule_SilModule
  [] [] [
    Function_Function  (HNm "cool") False
    []
    []
    [
--       Statement_Assignment (Variable_Local 0 (HNm "aaa")) (Value_Con (Constant_LiteralInt 20))
      Statement_Return 0
    ]
  ]

mergeCode :: Code -> Code -> Code
mergeCode (Code _ _ a) (Code _ _ b) = Code Nothing Nothing (a ++ b)

emptyCode :: Code
emptyCode = Code Nothing Nothing []

singleCode :: Instruction -> Code
singleCode = Code Nothing Nothing . return

code :: [Instruction] -> Code
code = Code Nothing Nothing

type JVMVar = String

primitiveFunctions :: [(HsName, Code)]
primitiveFunctions = [
  (HNm "putStrLn", singleCode $
    Invoke IVirtual (MethodRef {
      mr_class = "java.io.PrintStream"
    , mr_name = "println"
    , mr_args = [TClass {unClass = "java.lang.String"}]
    , mr_ret = Nothing
    }))
  ]

methodMain = 
  Method {
    m_flags = [Public,Static]
  , m_name = "main"
  , m_ret = Nothing
  , m_args = [TArray {unArray = TClass {unClass = "java.lang.String"}}]
  , m_code = Just (Code {c_max_stack = Nothing
  , c_max_locals = Nothing
  , c_instructions = [Note (LineNumber 5),
    Get True (FieldRef {
      fr_class = "java.lang.System"
      , fr_name = "out"
      , fr_type = TClass {unClass = "java.io.PrintStream"}}
      )
    , Const (CString "hello, oops")
    , Invoke IVirtual (MethodRef {mr_class = "java.io.PrintStream" ,mr_name =
      "println" ,mr_args = [TClass {unClass = "java.lang.String"}] ,mr_ret =
        Nothing})
      , Note (LineNumber 6),Return Nothing]
      }
    )
  , m_exceptions = []
  , m_signature = Nothing
  , m_deprecated = False
  }

%%]

%%[(8 codegen grin)
ATTR SilModule
     [ | | jvmCode : {Class} ]

ATTR Functions
     [ | | jvmCode : {[Method]} ]

ATTR Function
     [ | | jvmCode : {Method} ] 

ATTR Statements Statement Alternative
     Values Value Variable
     [ | | jvmCode : {Code} ]

ATTR Alternatives
     [ | | jvmCode : {[Code]} ]  

-- ATTR Values
--      [ | | jvmVar : {[JVMVar]} ]

-- ATTR Value Variable Constant
--      [ | | jvmVar : {JVMVar} ]   

-- ATTR Alternatives
--      [ | | jumpTargets : {[(JVMVar,JVMVar)]} ]

-- ATTR Alternative
--      [ | | jumpTarget : {(JVMVar,JVMVar)} ]  

SEM SilModule
  | SilModule   lhs.jvmCode = defaultClass {
                                c_methods = methodMain : @functions.jvmCode
                              , c_this    = "hello"
                              }

SEM Functions
  | Cons        lhs.jvmCode = @hd.jvmCode : @tl.jvmCode
  | Nil         lhs.jvmCode = []

SEM Function
  | Function    lhs.jvmCode = Method {
                                m_flags = [Public,Static]
                              , m_name       = show @name
                              , m_ret        = Just TInt -- Return type.
                              , m_args       = replicate (length @parameters) (TClass cObject)
                              , m_exceptions = []
                              , m_signature  = Nothing
                              , m_deprecated = False
                              , m_code       = Just @body.jvmCode
                              }
SEM Statements
  | Cons        lhs.jvmCode = @hd.jvmCode `mergeCode` @tl.jvmCode
  | Nil         lhs.jvmCode = emptyCode

SEM Statement
  | Assignment  lhs.jvmCode = error "JVM: not implemented yet."

  | Assignment2 lhs.jvmCode = error "JVM: not implemented yet."

  | Call        lhs.jvmCode = error "JVM: not implemented yet."

  | Comment     lhs.jvmCode = error "JVM: not implemented yet."

  | IfThenElse  lhs.jvmCode = error "JVM: not implemented yet."

  | Switch      lhs.jvmCode = error "JVM: not implemented yet."

  | Jump        lhs.jvmCode = error "JVM: not implemented yet."

  | Label       lhs.jvmCode = error "JVM: not implemented yet."

  | Return      lhs.jvmCode = code [Const $ CInt $ fromIntegral @retdiff, Return $ Just TInt]

  | Smart       lhs.jvmCode = error "JVM: not implemented yet."

  | * - Assignment Assignment2 Call Comment Jump Label Return Smart Switch IfThenElse
                lhs.jvmCode = error "JVM: not implemented yet."

SEM Alternatives
  | Cons        lhs.jvmCode = @hd.jvmCode : @tl.jvmCode
  | Nil         lhs.jvmCode = []

SEM Alternative
  | Alternative lhs.jvmCode = error "JVM: not implemented yet."

SEM Values
  | Cons        lhs.jvmCode = @hd.jvmCode `mergeCode` @tl.jvmCode
  | Nil         lhs.jvmCode = emptyCode

SEM Value
  | Alloc       lhs.jvmVar  = error "JVM: not implemented yet."
  | Call        lhs.jvmVar  = error "JVM: not implemented yet."
  | Con         lhs.jvmVar  = error "JVM: not implemented yet."
  | Var         lhs.jvmVar  = error "JVM: not implemented yet."
  | CompareGT   lhs.jvmVar  = error "JVM: not implemented yet."
  | Offset      lhs.jvmVar  = error "JVM: not implemented yet."

SEM Variable
  | Global      lhs.jvmVar  = error "JVM: not implemented yet."
  | Local       lhs.jvmVar  = error "JVM: not implemented yet."
  | Param       lhs.jvmVar  = error "JVM: not implemented yet."
  | RP          lhs.jvmVar  = error "JVM: not implemented yet."
  | Subs        lhs.jvmVar  = error "JVM: not implemented yet."
  | * -
    Global
    Local
    Param
    RP
    Subs        lhs.jvmCode = error "JVM: not implemented yet."

SEM Constant
  | LiteralInt  lhs.jvmVar  = error "JVM: not implemented yet."
  | LiteralStr  lhs.jvmVar  = error "JVM: not implemented yet."
  | Alias       lhs.jvmVar  = error "JVM: not implemented yet."

%%]


{-test = Class {c_major = 49
             ,c_minor = 0
             ,c_flags = [Super]
             ,c_this = "hello"
             ,c_super = Just "java.lang.Object"
             ,c_interfaces = []
             ,c_fields = []
             ,c_methods = [
                Method {m_flags = []
                 ,m_name = "<init>"
                 ,m_ret = Nothing
                 ,m_args = []
                 ,m_code = Just (Code {c_max_stack = Nothing
                                      ,c_max_locals = Nothing
                                      ,c_instructions = [ Note (LineNumber 1)
                                                        , Load (TClass {unClass = "java.lang.Object"}) 0
                                                        , Invoke ISpecial (MethodRef {mr_class = "java.lang.Object"
                                                                                     ,mr_name = "<init>"
                                                                                     ,mr_args = []
                                                                                     ,mr_ret = Nothing}
                                                                          )
                                                        , Return Nothing
                                                        ]
                                       })
                 ,m_exceptions = []
                 ,m_signature = Nothing
                 ,m_deprecated = False},
               Method {m_flags = [Public,Static]
               ,m_name = "main"
               ,m_ret = Nothing
               ,m_args = [TArray {unArray = TClass {unClass = "java.lang.String"}}]
               ,m_code = Just (Code {c_max_stack = Nothing
                                    ,c_max_locals = Nothing
                                    ,c_instructions = [Note (LineNumber 5),
                                                       Get True (FieldRef {
                                                          fr_class = "java.lang.System"
                                                         ,fr_name = "out"
                                                         ,fr_type = TClass {unClass = "java.io.PrintStream"}}
                                                         )
                                                       , Const (CString "hello, oops")
                                                       , Invoke IVirtual (MethodRef {mr_class = "java.io.PrintStream" ,mr_name = "println" ,mr_args = [TClass {unClass = "java.lang.String"}] ,mr_ret = Nothing})
                                                       , Note (LineNumber 6),Return Nothing]
                                                      })
                              ,m_exceptions = []
                              ,m_signature = Nothing
                              ,m_deprecated = False}
              ]
              ,c_sourcefile = Just "hello.java"
              ,c_innerclasses = []
              ,c_enclosing_method = Nothing
              ,c_signature = Nothing
              ,c_deprecated = False
              ,c_userdata = []
           }-}

