%%[0 hs
{
{-| Compile stage from Silly to Java Bytecode, stuitable to run as a .class
    file in the Java Virtual Machine.
-}
}
%%]

%%[(8 codegen grin) hs module {%{EH}Silly.ToJVM}
%%]
%%[(8 codegen grin) hs import({%{EH}Silly})
%%]
%%[(8 codegen grin) hs import({%{EH}Base.Common} hiding (nextUnique))
%%]
%%[(8 codegen grin) hs import({%{EH}Base.Opts})
%%]
%%[(8 codegen grin) hs import({%{EH}ConfigDefines})
%%]
%%[(8 codegen grin) import({Silly/AbsSyn})
%%]
%%[(8 codegen grin) hs import(EH.Util.Pretty)
%%]
%%[(8 codegen grin) hs import(Brianweb.Java hiding (Constant))
%%]
%%[(8 codegen grin) hs import(Data.Int (Int32))
%%]
%%[(8 codegen grin) hs import(Data.List (elemIndex))
%%]
%%[(8 codegen grin) hs import(qualified Data.IntMap as M)
%%]
%%[(8 codegen grin) hs import(qualified Brianweb.Java as J)
%%]
%%[(8 codegen grin)
WRAPPER SilModule
%%]

%%[(8 codegen grin)
PRAGMA nocycle
%%]

%%[(8 codegen grin) hs export( silly2jvm )

-------- main entry point for EHC's Silly --------------------------------------

silly2jvm :: EHCOpts -> SilModule -> Class
silly2jvm opts silmod = 
  jvmCode_Syn_SilModule
     $ wrap_SilModule
        (sem_SilModule silmod)
        (Inh_SilModule 42)

-------- some useful tools for code combining ----------------------------------

bool a b True  = a
bool a b False = b

emptyCode :: Code
emptyCode = Code Nothing Nothing []

type CodeS = Code -> Code

class Coding a where
  code :: a -> CodeS

noCode :: CodeS
noCode = id

(%) :: (Coding a, Coding b) => a -> b -> CodeS
(%) a b i = code a i `merge` code b i
  where merge (Code _ _ a) (Code _ _ b) = Code Nothing Nothing (a ++ b)

instance Coding CodeS where
  code = id

instance Coding Instruction where
  code i (Code _ _ c) = Code Nothing Nothing (i:c)

instance Coding a => Coding [a] where
  code = foldl1 (%) . map code

codeIf, codeUnless :: Coding c => Bool -> c -> CodeS
codeIf     b c = (code c `bool` noCode) b
codeUnless b c = (noCode `bool` code c) b

-------- runtime related material ---------------------------------------------

-- Values that we do not want to hardcode in the code generator.

cNode      = "Runtime$Node"
cIntNode   = "Runtime$IntNode"
cRuntime   = "Runtime"
tNode      = TClass cNode
tIntNode   = TClass cIntNode
tPayload   = TArray tNode
tRuntime   = TClass cRuntime

fGlobals = FieldRef cRuntime "Globals" tPayload
fPayload = FieldRef cNode    "payload" tPayload
fTag     = FieldRef cNode    "tag"     TInt
fIntVal  = FieldRef cIntNode "intVal"  TInt
fCRP     = FieldRef cRuntime "CRP"     tNode

-- Mapping of Haskell function names to built-in primitive functions.
-- TODO: this list may grow in the future and may deserve its own module.

primitiveFunctions :: [(HsName, CodeS -> CodeS)]
primitiveFunctions = [
  (HNm "putStrLn", \c ->
    (Get True (FieldRef {
      fr_class = "java.lang.System"
      , fr_name = "out"
      , fr_type = TClass "java.io.PrintStream"}
      ))
    % c %
    (Invoke IVirtual (MethodRef {
        mr_class = "java.io.PrintStream"
      , mr_name = "println"
      , mr_args = [TClass "java.lang.String"]
      , mr_ret = Nothing
      }))
    )
  ,(HNm "primAddInt", \c ->
    c %
    (Invoke IStatic (MethodRef cRuntime "primAddInt" [tNode, tNode] (Just tNode)))
    )
  ]

-- Main method compiled into the generated .class file that bootstraps the
-- runtime system and the haskell program.

javaMain :: String -> String -> Int -> Method
javaMain hsModule hsMain _CINT = 
  Method {
    m_flags = [Public,Static]
  , m_name = "main"
  , m_ret = Nothing
  , m_args = [TArray (TClass "java.lang.String")]
  , m_code = Just (Code {
      c_max_stack  = Nothing
    , c_max_locals = Nothing
    , c_instructions = [
        Const (CInt 42)
      , Store TInt 1
      , Get True (FieldRef {
          fr_class = "java.lang.System"
        , fr_name = "out"
        , fr_type = TClass "java.io.PrintStream"
        })
      , constInt _CINT
      , Invoke IStatic (MethodRef "Runtime" "initialize" [TInt] Nothing)
      , Invoke IStatic (MethodRef hsModule  "initialize" []     (Just TInt))
      , Invoke IStatic (MethodRef hsModule hsMain        []     (Just TInt))
      , Invoke IStatic (MethodRef "Runtime" "finish"     []     Nothing)
      , Load TInt 1
      , Pop TInt
      , Return Nothing
      ]
    })
  , m_exceptions = []
  , m_signature = Nothing
  , m_deprecated = False
  }

%%]

-------- attribute definitions ------------------------------------------------

%%[(8 codegen grin)

{

nextUnique :: Int -> (Int, Int)
nextUnique u = (u + 1, u)

type Locals = M.IntMap JvmType
type AssignCode = (CodeS, Locals -> Locals)

data JvmType = JvmTag | JvmInt | JvmNode
  deriving (Show, Eq)

}

ATTR SilModule
  [ | | jvmCode : {Class} ]

ATTR Functions
  [ | | jvmCode : {[Method]} ]

ATTR Function
  [ | | jvmCode : {Method} ] 

ATTR Statements Statement Values Value Variable Constant
  [ | | jvmCode : {CodeS} ]

ATTR Alternatives
  [ | | jvmCode : {[(Int32, Label, CodeS)]} ]  

ATTR Alternative
  [ | | jvmCode : {(Int32, Label, CodeS)} ]

ATTR AllNT
  [ | counter : Int | ]

ATTR AllNT - SilModule
  [ jvmCons : {[(String, Int)]} | | ]

ATTR AllNT - SilModule
  [ jvmGlobs : {[HsName]} | | ]

ATTR AllNT - SilModule
  [ jvmLhs : Bool | | ]

-- Contains a mapping from local variable indices to types.
ATTR AllNT - SilModule Function Functions
  [ | jvmLType : {Locals} | ]

ATTR AllNT - SilModule Function Functions
  [ paramLength : {Int} | | ]

ATTR Values Value Variable Constant
  [ | | jvmType USE {`const`} {} : JvmType ]

ATTR Variable
  [ jvmAssignType : JvmType | | ]

ATTR Variable 
  [ | | jvmAssignCode USE {++} {(noCode, id)} : {AssignCode} ]

ATTR Value Constant
  [ jvmAssignToTag : Bool | | ]

ATTR Constant
  [ | | jvmVal : {J.Constant} ]

ATTR Values
  [ | | length USE {+} {1} : Int ]

-------- code generation ------------------------------------------------------

{-
Possible optimizations

  1) Probably, not sure yet, the ALLOC size in silly is the maximum of all
     possible constructors for a data-type. This is safe but sometimes wastes
     some space. Maybe we can detect what the real value of this ALLOC should
     be for our payload array.
  2) In-line the payload into the node by statically creating a bunch of
     Java classes for every length a value can be. These classes can be called
     something like `Value<n>'. When we perform this the optimization (1) will
     bot be possible anymore, but we skip one indirection.
  3) Do not use a separate Int bucket for the case that the tag is CInt, but
     use some bit magic to store this integer in the tag itself.
  4) Do not use an indirect RP bucket to make our life easier in the Subs case
     but use a direct RP array. This is somewhat more involved because we then
     need to know that we are Subs'ing the RP which needs some aspect. This
     optimization is quite essential because you save an indirection on `every'
     return.
  5) Every global lookup now has an additional step for getting the globals
     array. Using `real Java' globals will probably significantly speedup using
     the globals.
  n) ...


  (double assignments)
-}

{

jvmError :: String -> a
jvmError s = error ("JVM: no support for " ++ s)

cInt = CInt . fromIntegral
constInt = Const . cInt

jvmAssignment ::
     CodeS                     -- ^ Lhs of assignment.
  -> AssignCode                -- ^ How to assign to Lhs.
  -> CodeS                     -- ^ Rhs of assignment.
  -> JvmType                   -- ^ Type of lhs.
  -> JvmType                   -- ^ Type of rhs.
  -> M.IntMap JvmType          -- ^ Known types of local variable.
  -> (CodeS, M.IntMap JvmType) -- ^ Assignment code, possibly updates local variable types.

jvmAssignment dest assign source left right locals =
  (dest % source % acode, flocals locals)
  where (acode, flocals) = assign

jvmAssignment2 ::
     CodeS                     -- ^ First lhs of assignment.
  -> AssignCode                -- ^ How to assign to first Lhs.
  -> CodeS                     -- ^ Second lhs of assignment.
  -> AssignCode                -- ^ How to assign to second Lhs.
  -> CodeS                     -- ^ Rhs of assignment.
  -> JvmType                   -- ^ Type of lhs.
  -> JvmType                   -- ^ Type of rhs.
  -> M.IntMap JvmType          -- ^ Known types of local variable.
  -> (CodeS, M.IntMap JvmType) -- ^ Assignment code, possibly updates local variable types.

jvmAssignment2 dest1 assign1 dest2 assign2 source left right locals =
  let (code1, locals1) = jvmAssignment dest1 assign1 source left right locals
      (code2, locals2) = jvmAssignment dest2 assign2 source left right locals1
  in (code1 % code2, locals2)

}

-------- code generation using AGs --------------------------------------------

SEM SilModule
  | SilModule   lhs.jvmCode = defaultClass {
                                c_methods =
                                  javaMain "fib" "fun_x_1_main"
                                    -- this `maybe 0 id' is probably safe, no
                                    -- CInt means that all use of it is
                                    -- optimized away.
                                    (maybe 0 id ("CInt" `lookup` @constants))
                                  : @functions.jvmCode
                              , c_this = "fib"
                              }
          functions.jvmCons = @constants
         functions.jvmGlobs = @variables
           functions.jvmLhs = False
                              
SEM Functions                 
  | Cons        lhs.jvmCode = @hd.jvmCode : @tl.jvmCode
  | Nil         lhs.jvmCode = []

SEM Function                  
  | Function    lhs.jvmCode = Method {
                                m_flags = [Public,Static]
                              , m_name       = show @name
                              , m_ret        = Just TInt
                              , m_args       = replicate (length @parameters) tNode
                              , m_exceptions = []
                              , m_signature  = Nothing
                              , m_deprecated = False
                              , m_code       = Just (@body.jvmCode emptyCode)
                              }
              body.jvmLType = M.empty
           body.paramLength = length @parameters
                              
SEM Statements                
  | Cons        lhs.jvmCode = @hd.jvmCode % @tl.jvmCode
  | Nil         lhs.jvmCode = noCode

SEM Statement

  | Assignment  lhs.jvmCode = fst @loc.code
                   loc.code = jvmAssignment
                                @dest.jvmCode
                                @dest.jvmAssignCode
                                @source.jvmCode
                                @dest.jvmType
                                @source.jvmType
                                @lhs.jvmLType
               lhs.jvmLType = snd @loc.code
         dest.jvmAssignType = @source.jvmType
                dest.jvmLhs = True
              source.jvmLhs = False
         source.jvmAssignToTag = @dest.jvmType == JvmTag
                              
  | Assignment2 lhs.jvmCode = fst @loc.code
                   loc.code = jvmAssignment2
                                @dest1.jvmCode
                                @dest1.jvmAssignCode
                                @dest2.jvmCode
                                @dest2.jvmAssignCode
                                @source.jvmCode
                                @dest1.jvmType
                                @source.jvmType
                                @lhs.jvmLType
               lhs.jvmLType = snd @loc.code
        dest1.jvmAssignType = @source.jvmType
        dest2.jvmAssignType = @source.jvmType
               dest1.jvmLhs = True
               dest2.jvmLhs = True
              source.jvmLhs = False
         source.jvmAssignToTag = @dest1.jvmType == JvmTag
                              
                              -- Real call or built-in call?
  | Call        lhs.jvmCode = case lookup @name primitiveFunctions of
                                Nothing   -> @args.jvmCode
                                           % Invoke IStatic (MethodRef "fib" (show @name) (replicate @args.length tNode) $ Just TInt)
                                           % Pop TInt -- TODO ask Jeroen/Atze whether this is safe.

                                Just prim -> prim @args.jvmCode
                              
  | Comment     lhs.jvmCode = noCode
                              
                              -- INVARIANT: This generic IfThenElse compiles to
                              -- the specific greater-than-equal comparison,
                              -- because this is the only pattern it appears in
                              -- the original silly code.
  | IfThenElse  lhs.jvmCode = @condition.jvmCode
                              % If CmpGt @loc.labelElse
                              % @thenpart.jvmCode
                              % Goto @loc.labelEndIf
                              % Note (Label @loc.labelElse)
                              % @elsepart.jvmCode
                              % Note (Label @loc.labelEndIf)
             loc.labelEndIf : UNIQUEREF counter
              loc.labelElse : UNIQUEREF counter
   condition.jvmAssignToTag = False

  | Switch
         loc.labelSwitchEnd : UNIQUEREF counter
                lhs.jvmCode = let 
                                alts   = @body.jvmCode
                                end    = @loc.labelSwitchEnd
                                arms   = map (\(_, _, c)   -> c % Goto end)
                                labels = map (\(when, lbl, _) -> (when, lbl)) alts
                              in
                              @scrutinee.jvmCode
                              % Switch Lookup (snd $ head labels) labels
                              % arms alts
                              % Note (Label end)
   scrutinee.jvmAssignToTag = False

  | Jump        lhs.jvmCode = jvmError "jumps"
  | Label       lhs.jvmCode = jvmError "labels"
  | Return      lhs.jvmCode = constInt @retdiff
                              % Return (Just TInt)
  | Smart       lhs.jvmCode = jvmError "smart"

  | * - Assignment
       Assignment2 Call
       Comment Jump Label
       Return Smart Switch
       IfThenElse
                lhs.jvmCode = jvmError "this statement"

SEM Alternatives
  | Cons        lhs.jvmCode = @hd.jvmCode : @tl.jvmCode
  | Nil         lhs.jvmCode = []

SEM Alternative
  | Alternative lhs.jvmCode = let l = @loc.label in
                              case @when.jvmVal of
                                CInt i -> (i, l, Note (Label l) % @body.jvmCode)
                                _      -> jvmError "non-integer case scrutinee"
                  loc.label : UNIQUEREF counter
        when.jvmAssignToTag = jvmError "no assign to tag for Alternative.when"

SEM Values
  | Cons        lhs.jvmCode = @hd.jvmCode % @tl.jvmCode
          hd.jvmAssignToTag = False
                lhs.jvmType = @hd.jvmType
  | Nil         lhs.jvmCode = noCode
                lhs.jvmType = jvmError "Nil value jvm type"

SEM Value

  | Alloc       lhs.jvmCode = New cNode
                              % Dup TInt
                              % Dup TInt
                              % Invoke ISpecial (MethodRef cNode "<init>" [] Nothing)
                              % constInt (@size - 1)
                              % NewArray tNode 1
                              % Put False fPayload
                lhs.jvmType = JvmNode

  | Call        lhs.jvmCode = case lookup (HNm @name) primitiveFunctions of
                                Nothing   -> jvmError $ "No primitive function: " ++ @name
                                Just prim -> prim @args.jvmCode
                lhs.jvmType = JvmNode -- todo this probably isn't always the case

  | Var         lhs.jvmCode = @var.jvmCode
          var.jvmAssignType = jvmError "variable assign type"

  | CompareGT   lhs.jvmCode = Const @con.jvmVal
                              % @val.jvmCode
                lhs.jvmType = JvmInt

                              -- Observation: We cannot perform `Arith Add's on
                              -- references here. But Offsets are only used in
                              -- conjunction with Globals and Locals. 
  | Offset      lhs.jvmCode = @var.jvmCode
                              % constInt (@off - 1)
                              % Arith Add TInt
                              % codeUnless @lhs.jvmLhs (ALoad tNode)
                 var.jvmLhs = True
                lhs.jvmType = JvmNode
          var.jvmAssignType = jvmError "offset assign type"

  | Label       lhs.jvmCode = jvmError "label value"
                lhs.jvmType = jvmError "label value jvm type"

SEM Variable

  | Global      lhs.jvmCode = let idx = (jvmError "unknown globals" `maybe` id)
                                        (@name `elemIndex` @lhs.jvmGlobs)
                              in Get True fGlobals
                               % constInt idx
                               % codeUnless @lhs.jvmLhs (ALoad tNode)

                lhs.jvmType = JvmNode

                              -- We get a type from our parent assignment, but
                              -- we know we are here for tNode.
          lhs.jvmAssignCode = (code (AStore tNode), id)

                              -- todo: add parameter count to @pos?
  | Local       lhs.jvmCode = let typ = case M.lookup @pos @lhs.jvmLType of
                                          Just JvmTag -> TInt
                                          _           -> tNode
                              in codeUnless @lhs.jvmLhs $ Load typ @loc.jvmIndex

          lhs.jvmAssignCode = let typ = case @lhs.jvmAssignType of
                                          JvmTag -> TInt
                                          _      -> tNode
                              in (code $ Store typ @loc.jvmIndex, M.insert @pos @lhs.jvmAssignType)
                lhs.jvmType = JvmNode
                loc.jvmIndex = fromIntegral $ @pos + @lhs.paramLength - 1

  | Param       lhs.jvmCode = code $ Load tNode (fromIntegral $ @pos - 1)
                lhs.jvmType = jvmError "param jvm type"

                              -- RP is always used in conjunction with Subs.
  | RP          lhs.jvmCode = code $ Get True fCRP
                lhs.jvmType = jvmError "RP jvm type"

  | Subs        lhs.jvmCode = @array.jvmCode %
                              case (@index == 0, @lhs.jvmLhs) of
                                (True,  False) -> code (Get False fTag)
                                (True,  True)  -> noCode
                                (False, True)  -> Get False fPayload
                                                % constInt (@index - 1)
                                (False, False) -> Get False fPayload
                                                % constInt (@index - 1)
                                                % ALoad tNode

          lhs.jvmAssignCode = let tag   = Put False fTag
                                  notag = AStore tNode
                              in ((code tag `bool` code notag) (@index == 0), id)
 
               array.jvmLhs = False

                lhs.jvmType = (JvmTag `bool` JvmNode) (@index == 0)

  | * - Global Local
        Param RP Subs
                lhs.jvmCode = jvmError "unknown variable kind"
                lhs.jvmType = jvmError "this variable jvm type"

SEM Constant
  | LiteralInt   lhs.jvmCode = if @lhs.jvmAssignToTag 
                               then (code $ Const $ cInt @value )
                               else ( New cIntNode
                                    % Dup TInt
                                    % Const (cInt @value)
                                    % Invoke ISpecial (MethodRef cIntNode "<init>" [TInt] Nothing)
                                    )
                 lhs.jvmVal = cInt @value
                lhs.jvmType = if @lhs.jvmAssignToTag then JvmInt else JvmNode
  | LiteralStr   lhs.jvmCode = code $ Const (CString @value)
                 lhs.jvmVal = CString @value
                lhs.jvmType = jvmError "literal string jvm type"

  | Alias        lhs.jvmCode = code $ Const @loc.jvmVal
                  lhs.jvmVal = @loc.jvmVal
                  loc.jvmVal = case @name `lookup` @lhs.jvmCons of
                                Nothing -> jvmError ("unknown constant alias: " ++ @name)
                                Just  a -> cInt a
                lhs.jvmType = JvmTag

%%]

