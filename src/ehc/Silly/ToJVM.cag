%%[0 hs
{
{-| Compile stage from Silly to Java Bytecode, stuitable to run as a .class
    file in the Java Virtual Machine.
-}
}
%%]

%%[(8 codegen grin) hs module {%{EH}Silly.ToJVM}
%%]
%%[(8 codegen grin) hs import({%{EH}Silly})
%%]
%%[(8 codegen grin) hs import({%{EH}Base.Common} hiding (nextUnique))
%%]
%%[(8 codegen grin) hs import({%{EH}Base.Opts})
%%]
%%[(8 codegen grin) hs import({%{EH}ConfigDefines})
%%]
%%[(8 codegen grin) import({Silly/AbsSyn})
%%]
%%[(8 codegen grin) hs import(EH.Util.Pretty)
%%]
%%[(8 codegen grin) hs import(Brianweb.Java hiding (Constant))
%%]
%%[(8 codegen grin) hs import(Data.Int (Int32))
%%]
%%[(8 codegen grin) hs import(Data.List (elemIndex))
%%]
%%[(8 codegen grin) hs import(qualified Data.IntMap as M)
%%]
%%[(8 codegen grin) hs import(qualified Brianweb.Java as J)
%%]
%%[(8 codegen grin)
WRAPPER SilModule
%%]

%%[(8 codegen grin)
PRAGMA nocycle
%%]

%%[(8 codegen grin) hs export( silly2jvm )

-------- main entry point for EHC's Silly --------------------------------------

silly2jvm :: EHCOpts -> SilModule -> Class
silly2jvm opts silmod = 
  jvmCode_Syn_SilModule
     $ wrap_SilModule
        (sem_SilModule silmod)
        (Inh_SilModule 42)

-------- some useful tools for code combining ----------------------------------

bool a b True  = a
bool a b False = b

emptyCode :: Code
emptyCode = Code Nothing Nothing []

type CodeS = Code -> Code

class Coding a where
  code :: a -> CodeS

noCode :: CodeS
noCode = id

(%) :: (Coding a, Coding b) => a -> b -> CodeS
(%) a b i = code a i `merge` code b i
  where merge (Code _ _ a) (Code _ _ b) = Code Nothing Nothing (a ++ b)

instance Coding CodeS where
  code = id

instance Coding Instruction where
  code i (Code _ _ c) = Code Nothing Nothing (i:c)

instance Coding a => Coding [a] where
  code = foldl1 (%) . map code

codeIf, codeUnless :: Coding c => Bool -> c -> CodeS
codeIf     b c = (code c `bool` noCode) b
codeUnless b c = (noCode `bool` code c) b

-------- runtime related material ---------------------------------------------

-- Values that we do not want to hardcode in the code generator.

cNode      = "Runtime$Node"
cIntNode   = "Runtime$IntNode"
cRuntime   = "Runtime"
tNode      = TClass cNode
tIntNode   = TClass cIntNode
tPayload   = TArray tNode
tRuntime   = TClass cRuntime

fGlobals = FieldRef cRuntime "Globals" tPayload
fPayload = FieldRef cNode    "payload" tPayload
fTag     = FieldRef cNode    "tag"     TInt
fIntVal  = FieldRef cIntNode "intVal"  TInt
fCRP     = FieldRef cRuntime "CRP"     tNode

-- Mapping of Haskell function names to built-in primitive functions.
-- TODO: this list may grow in the future and may deserve its own module.

primitiveFunctions :: [(HsName, CodeS -> CodeS)]
primitiveFunctions = [
  (HNm "putStrLn", \c ->
    (Get True (FieldRef {
      fr_class = "java.lang.System"
      , fr_name = "out"
      , fr_type = TClass "java.io.PrintStream"}
      ))
    % c %
    (Invoke IVirtual (MethodRef {
        mr_class = "java.io.PrintStream"
      , mr_name = "println"
      , mr_args = [TClass "java.lang.String"]
      , mr_ret = Nothing
      }))
    )
  ,(HNm "primAddInt", \c ->
    c %
    (Invoke IStatic (MethodRef cRuntime "primAddInt" [TInt, TInt] (Just TInt)))
    )
  ]

-- Main method compiled into the generated .class file that bootstraps the
-- runtime system and the haskell program.

javaMain :: String -> String -> Int -> Method
javaMain hsModule hsMain _CINT = 
  Method {
    m_flags = [Public,Static]
  , m_name = "main"
  , m_ret = Nothing
  , m_args = [TArray (TClass "java.lang.String")]
  , m_code = Just (Code {
      c_max_stack  = Nothing
    , c_max_locals = Nothing
    , c_instructions = [
        Const (CInt 42)
      , Store TInt 1
      , Get True (FieldRef {
          fr_class = "java.lang.System"
        , fr_name = "out"
        , fr_type = TClass "java.io.PrintStream"
        })
      , constInt _CINT
      , Invoke IStatic (MethodRef "Runtime" "initialize" [TInt] Nothing)
      , Invoke IStatic (MethodRef hsModule  "initialize" []     (Just TInt))
      , Invoke IStatic (MethodRef hsModule hsMain        []     (Just TInt))
      , Invoke IStatic (MethodRef "Runtime" "finish"     []     Nothing)
      , Load TInt 1
      , Pop TInt
      , Return Nothing
      ]
    })
  , m_exceptions = []
  , m_signature = Nothing
  , m_deprecated = False
  }

%%]

-------- attribute definitions ------------------------------------------------

%%[(8 codegen grin)

{

nextUnique :: Int -> (Int, Int)
nextUnique u = (u + 1, u)

type Locals = M.IntMap JvmType
type AssignCode = (CodeS, Locals -> Locals)

data JvmType = JvmInt | JvmNode
  deriving (Show, Eq)

}

ATTR SilModule
  [ | | jvmCode : {Class} ]

ATTR Functions
  [ | | jvmCode : {[Method]} ]

ATTR Function
  [ | | jvmCode : {Method} ] 

ATTR Statements Statement Values Value Variable 
  [ | | jvmCode : {CodeS} ]

ATTR Alternatives
  [ | | jvmCode : {[(Int32, Label, CodeS)]} ]  

ATTR Alternative
  [ | | jvmCode : {(Int32, Label, CodeS)} ]

ATTR AllNT
  [ | counter : Int | ]

ATTR AllNT - SilModule
  [ jvmCons : {[(String, Int)]} | | ]

ATTR AllNT - SilModule
  [ jvmGlobs : {[HsName]} | | ]

ATTR AllNT - SilModule
  [ jvmLhs : Bool | | ]

-- Contains a mapping from local variable indices to types.
ATTR AllNT - SilModule Function Functions
  [ | jvmLType : {Locals} | ]

ATTR AllNT
  [ | | jvmType USE {`const`} {jvmError "uninitialized LHS type."} : JvmType ]

ATTR Variable
  [ jvmAssignType : JvmType | | ]

ATTR Variable 
  [ | | jvmAssign USE {++} {(noCode, id)} : {AssignCode} ]

ATTR Constant
  [ | | jvmVal : {J.Constant} ]  

-------- code generation ------------------------------------------------------

{-
Possible optimizations

  1) Probably, not sure yet, the ALLOC size in silly is the maximum of all
     possible constructors for a data-type. This is safe but sometimes wastes
     some space. Maybe we can detect what the real value of this ALLOC should
     be for our payload array.
  2) In-line the payload into the node by statically creating a bunch of
     Java classes for every length a value can be. These classes can be called
     something like `Value<n>'. When we perform this the optimization (1) will
     bot be possible anymore, but we skip one indirection.
  3) Do not use a separate Int bucket for the case that the tag is CInt, but
     use some bit magic to store this integer in the tag itself.
  4) Do not use an indirect RP bucket to make our life easier in the Subs case
     but use a direct RP array. This is somewhat more involved because we then
     need to know that we are Subs'ing the RP which needs some aspect. This
     optimization is quite essential because you save an indirection on `every'
     return.
  5) Every global lookup now has an additional step for getting the globals
  array. Using `real Java' globals will probably significantly speedup using
  the globals.
  n) ...


  (double assignments)
-}

{

jvmError :: String -> a
jvmError s = error ("JVM: no support for " ++ s)

cInt = CInt . fromIntegral
constInt = Const . cInt

jvmAssignment ::
     CodeS                     -- ^ Lhs of assignment.
  -> AssignCode                -- ^ How to assign to Lhs.
  -> CodeS                     -- ^ Rhs of assignment.
  -> JvmType                   -- ^ Type of lhs.
  -> JvmType                   -- ^ Type of rhs.
  -> M.IntMap JvmType          -- ^ Known types of local variable.
  -> (CodeS, M.IntMap JvmType) -- ^ Assignment code, possibly updates local variable types.

jvmAssignment dest assign source left right locals =
  (dest % source % acode, flocals locals)
  where (acode, flocals) = assign

jvmAssignment2 ::
     CodeS                     -- ^ First lhs of assignment.
  -> AssignCode                -- ^ How to assign to first Lhs.
  -> CodeS                     -- ^ Second lhs of assignment.
  -> AssignCode                -- ^ How to assign to second Lhs.
  -> CodeS                     -- ^ Rhs of assignment.
  -> JvmType                   -- ^ Type of lhs.
  -> JvmType                   -- ^ Type of rhs.
  -> M.IntMap JvmType          -- ^ Known types of local variable.
  -> (CodeS, M.IntMap JvmType) -- ^ Assignment code, possibly updates local variable types.

jvmAssignment2 dest1 assign1 dest2 assign2 source left right locals =
  let (code1, locals1) = jvmAssignment dest1 assign1 source left right locals
      (code2, locals2) = jvmAssignment dest2 assign2 source left right locals1
  in (code1 % code2, locals2)

}

-------- code generation using AGs --------------------------------------------

SEM SilModule
  | SilModule   lhs.jvmCode = defaultClass {
                                c_methods = javaMain
                                              "fib"
                                              "fun_x_1_main"
                                              ((\(Just x) -> x) ("CInt" `lookup` @constants))
                                          : @functions.jvmCode
                              , c_this    = "fib"
                              }
          functions.jvmCons = @constants
         functions.jvmGlobs = @variables
           functions.jvmLhs = False
                              
SEM Functions                 
  | Cons        lhs.jvmCode = @hd.jvmCode : @tl.jvmCode
  | Nil         lhs.jvmCode = []
                              
SEM Function                  
  | Function    lhs.jvmCode = Method {
                                m_flags = [Public,Static]
                              , m_name       = show @name
                              , m_ret        = Just TInt
                              , m_args       = replicate (length @parameters) (TClass cObject)
                              , m_exceptions = []
                              , m_signature  = Nothing
                              , m_deprecated = False
                              , m_code       = Just (@body.jvmCode emptyCode)
                              }
              body.jvmLType = M.empty
                              
SEM Statements                
  | Cons        lhs.jvmCode = @hd.jvmCode % @tl.jvmCode
  | Nil         lhs.jvmCode = noCode

SEM Statement

  | Assignment  lhs.jvmCode = fst @loc.code
                   loc.code = jvmAssignment
                                @dest.jvmCode
                                @dest.jvmAssign
                                @source.jvmCode
                                @dest.jvmType
                                @source.jvmType
                                @lhs.jvmLType
               lhs.jvmLType = snd @loc.code
         dest.jvmAssignType = @source.jvmType
                dest.jvmLhs = True
              source.jvmLhs = False
                              
  | Assignment2 lhs.jvmCode = fst @loc.code
                   loc.code = jvmAssignment2
                                @dest1.jvmCode
                                @dest1.jvmAssign
                                @dest2.jvmCode
                                @dest2.jvmAssign
                                @source.jvmCode
                                @dest1.jvmType
                                @source.jvmType
                                @lhs.jvmLType
               lhs.jvmLType = snd @loc.code
        dest1.jvmAssignType = @source.jvmType
        dest2.jvmAssignType = @source.jvmType
               dest1.jvmLhs = True
               dest2.jvmLhs = True
              source.jvmLhs = False
                              
                              -- Real call or built-in call?
  | Call        lhs.jvmCode = case lookup @name primitiveFunctions of
                                Nothing   -> @args.jvmCode
                                           % Invoke IStatic (MethodRef "fib" (show @name) [] $ Just TInt)
                                Just prim -> prim @args.jvmCode
                                -- TODO: this fails when we have a "computed" Int: we need to unbox the arguments.
                              
  | Comment     lhs.jvmCode = noCode
                              
                              -- INVARIANT: This generic IfThenElse compiles to
                              -- the specific greater-than-equal comparison,
                              -- because this is the only pattern it appears in
                              -- the original silly code.
  | IfThenElse  lhs.jvmCode = @condition.jvmCode
                              % If CmpGt @loc.labelElse
                              % @thenpart.jvmCode
                              % Goto @loc.labelEndIf
                              % Note (Label @loc.labelElse)
                              % @elsepart.jvmCode
                              % Note (Label @loc.labelEndIf)
             loc.labelEndIf : UNIQUEREF counter
              loc.labelElse : UNIQUEREF counter

  | Switch
         loc.labelSwitchEnd : UNIQUEREF counter
                lhs.jvmCode = let 
                                alts   = @body.jvmCode
                                end    = @loc.labelSwitchEnd
                                arms   = map (\(_, _, c)   -> c % Goto end)
                                labels = map (\(when, lbl, _) -> (when, lbl)) alts
                              in
                              @scrutinee.jvmCode
                              % Switch Lookup (snd $ head labels) labels
                              % arms alts
                              % Note (Label end)

  | Jump        lhs.jvmCode = jvmError "jumps"
  | Label       lhs.jvmCode = jvmError "labels"
  | Return      lhs.jvmCode = constInt @retdiff
                              % Return (Just TInt)
  | Smart       lhs.jvmCode = jvmError "smart"

  | * - Assignment
       Assignment2 Call
       Comment Jump Label
       Return Smart Switch
       IfThenElse
                lhs.jvmCode = jvmError "this statement"

SEM Alternatives
  | Cons        lhs.jvmCode = @hd.jvmCode : @tl.jvmCode
  | Nil         lhs.jvmCode = []

SEM Alternative
  | Alternative lhs.jvmCode = let l = @loc.label in
                              case @when.jvmVal of
                                CInt i -> (i, l, Note (Label l) % @body.jvmCode)
                                _      -> jvmError "non-integer case scrutinee"
                  loc.label : UNIQUEREF counter

SEM Values
  | Cons        lhs.jvmCode = @hd.jvmCode % @tl.jvmCode
  | Nil         lhs.jvmCode = noCode

SEM Value

  | Alloc       lhs.jvmCode = New cNode
                              % Dup TInt
                              % Dup TInt
                              % Invoke ISpecial (MethodRef cNode "<init>" [] Nothing)
                              % constInt (@size - 1)
                              % NewArray tNode 1
                              % Put False fPayload
                lhs.jvmType = JvmNode

                              -- todo: this is probably ffi only!!
                              -- Real call of built-in call?
  | Call        lhs.jvmCode = case lookup (HNm @name) primitiveFunctions of
                                Nothing   -> @args.jvmCode
                                           % Invoke IStatic (MethodRef "fib" @name [] $ Just TInt)
                                Just prim -> prim @args.jvmCode

  | Con         lhs.jvmCode = code (Const @con.jvmVal)

  | Var         lhs.jvmCode = @var.jvmCode
          var.jvmAssignType = jvmError "variable assign type"

  | CompareGT   lhs.jvmCode = Const @con.jvmVal
                              % @val.jvmCode
                lhs.jvmType = JvmInt

                              -- Observation: We cannot perform `Arith Add's on
                              -- references here. But Offsets are only used in
                              -- conjunction with Globals and Locals. 
  | Offset      lhs.jvmCode = @var.jvmCode
                              % constInt (@off - 1)
                              % Arith Add TInt
                              % codeUnless @lhs.jvmLhs (ALoad tNode)
                 var.jvmLhs = True
                lhs.jvmType = JvmNode
          var.jvmAssignType = jvmError "offset assign type"

  | Label       lhs.jvmCode = jvmError "label variables"

SEM Variable

  | Global      lhs.jvmCode = let idx = (jvmError "unknown globals" `maybe` id)
                                        (@name `elemIndex` @lhs.jvmGlobs)
                              in Get True fGlobals
                               % constInt idx
                               % codeUnless @lhs.jvmLhs (ALoad tNode)

                lhs.jvmType = JvmNode

                              -- We get a type from our parent assignment, but
                              -- we know we are here for tNode.
              lhs.jvmAssign = (code (AStore tNode), id)

                              -- todo: add parameter count to @pos?
  | Local       lhs.jvmCode = codeUnless @lhs.jvmLhs $
                                let tp = (jvmError "unknown local" `maybe` id)
                                         (M.lookup @pos @lhs.jvmLType)
                                in case tp of
                                  JvmInt  -> Load TInt  (fromIntegral @pos)
                                  JvmNode -> Load tNode (fromIntegral @pos)

              lhs.jvmAssign = let c = case @lhs.jvmAssignType of
                                        JvmInt  -> Store TInt  (fromIntegral @pos)
                                        JvmNode -> Store tNode (fromIntegral @pos)
                              in (code c, M.insert @pos @lhs.jvmAssignType)
                lhs.jvmType = maybe (jvmError $ "No type for variable: " ++ (show @pos)) id $ M.lookup @pos @lhs.jvmLType

  | Param       lhs.jvmCode = code $ Load tNode (fromIntegral @pos)
                lhs.jvmType = jvmError "undefined LHS type: Variable.Param"

                              -- RP is always used in conjunction with Subs.
  | RP          lhs.jvmCode = code $ Get True fCRP
                lhs.jvmType = jvmError "undefined LHS type: Variable.RP"

  | Subs        lhs.jvmCode = @array.jvmCode %
                              case (@index == 0, @lhs.jvmLhs) of
                                (True,  False) -> code (Get False fTag)
                                (True,  True)  -> noCode
                                (False, False) -> Get False fPayload
                                                % constInt (@index - 1)
                                                % ALoad tNode
                                (False, True)  -> Get False fPayload
                                                % constInt (@index - 1)
                                                % codeIf (@lhs.jvmAssignType == JvmInt) (
                                                    New cIntNode
                                                  % Dup TInt
                                                  % Dup TInt
                                                  % Invoke ISpecial (MethodRef cIntNode "<init>" [] Nothing))

              lhs.jvmAssign = let tag   = Put False fTag
                                  int   = Put False fIntVal
                                  notag = codeIf (@lhs.jvmAssignType == JvmInt) int
                                          % AStore tNode
                              in ((code tag `bool` notag) (@index == 0), id)
 
               array.jvmLhs = False

                lhs.jvmType = (JvmInt `bool` JvmNode) (@index == 0)

  | * - Global Local
        Param RP Subs
                lhs.jvmCode = jvmError "unknown variable kind"

SEM Constant
  | LiteralInt   lhs.jvmVal = cInt @value
                lhs.jvmType = JvmInt
  | LiteralStr   lhs.jvmVal = CString @value

  | Alias        lhs.jvmVal = case @name `lookup` @lhs.jvmCons of
                                Nothing -> jvmError ("unknown constant alias: " ++ @name)
                                Just  a -> cInt a

%%]

