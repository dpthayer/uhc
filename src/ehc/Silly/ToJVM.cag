%%[0 hs
{
{-| JAVA!!!
-}
}
%%]

%%[(8 codegen grin) hs module {%{EH}Silly.ToJVM}
%%]
%%[(8 codegen grin) hs import({%{EH}Silly})
%%]
%%[(8 codegen grin) hs import({%{EH}Base.Common} hiding (nextUnique))
%%]
%%[(8 codegen grin) hs import({%{EH}Base.Opts})
%%]
%%[(8 codegen grin) hs import({%{EH}ConfigDefines})
%%]
%%[(8 codegen grin) import({Silly/AbsSyn})
%%]
%%[(8 codegen grin) hs import(EH.Util.Pretty)
%%]
%%[(8 codegen grin) hs import(Brianweb.Java hiding (Constant))
%%]
%%[(8 codegen grin) hs import(Data.Int (Int32))
%%]
%%[(8 codegen grin) hs import(Data.List (elemIndex))
%%]
%%[(8 codegen grin) hs import(qualified Data.IntMap as M)
%%]
%%[(8 codegen grin) hs import(qualified Brianweb.Java as J)
%%]
%%[(8 codegen grin)
WRAPPER SilModule
%%]

%%[(8 codegen grin)
PRAGMA nocycle
%%]

%%[(8 codegen grin) hs export( silly2jvm )

--------------------------------------------------------------------------------

silly2jvm :: EHCOpts -> SilModule -> Class
silly2jvm opts silmod = 
  jvmCode_Syn_SilModule
     $ wrap_SilModule
        (sem_SilModule silmod)
--         (sem_SilModule testSilModule)
        (Inh_SilModule 42)

nextUnique :: Int -> (Int, Int)
nextUnique u = (u + 1, u)

mergeCode :: Code -> Code -> Code
mergeCode (Code _ _ a) (Code _ _ b) = Code Nothing Nothing (a ++ b)

(%) = mergeCode

emptyCode :: Code
emptyCode = Code Nothing Nothing []

singleCode :: Instruction -> Code
singleCode = Code Nothing Nothing . return

code :: [Instruction] -> Code
code = Code Nothing Nothing

type JVMVar = String

cNode      = "Runtime$Node"
cIntNode   = "Runtime$IntNode"
cRuntime   = "Runtime"
fCGlobals  = "CGlobals"
fCRP       = "CRP"
fGlobals   = "Globals"
fIntVal    = "intVal"
fPayload   = "payload"
fRP        = "RP"
fTag       = "tag"
tNode      = TClass cNode
tPayload   = TArray tNode

primitiveFunctions :: [(HsName, Code -> Code)]
primitiveFunctions = [
  (HNm "putStrLn", \c ->
    singleCode (Get True (FieldRef {
      fr_class = "java.lang.System"
      , fr_name = "out"
      , fr_type = TClass "java.io.PrintStream"}
      ))
    % c %
    singleCode (
      Invoke IVirtual (MethodRef {
        mr_class = "java.io.PrintStream"
      , mr_name = "println"
      , mr_args = [TClass "java.lang.String"]
      , mr_ret = Nothing
      }))
    )
  ]

testSilModule = SilModule_SilModule
  [] [HNm "fst", HNm "snd", HNm "trd"] [
    Function_Function  (HNm "initialize") False
    []
    []
    [
    -- allocate 1 word for fst. enough for a CInt.
      Statement_Assignment
        (Variable_Global $ HNm "fst")
        (Value_Alloc 1 GCManaged)

    -- make it a CInt, with tag 9.
    , Statement_Assignment
        (Variable_Subs (Variable_Global $ HNm "fst") 0)
        (Value_Con $ Constant_LiteralInt 9)

    -- set the integer value to 100.
    , Statement_Assignment
        (Variable_Subs (Variable_Global $ HNm "fst") 1)
        (Value_Con $ Constant_LiteralInt 4)


    -- allocate 4 word node, save to global.
    , Statement_Assignment
        (Variable_Global $ HNm "trd")
        (Value_Alloc 4 GCManaged)

    -- assign const 33 to tag.
    , Statement_Assignment
        (Variable_Subs (Variable_Global $ HNm "trd") 0)
        (Value_Con $ Constant_LiteralInt 33)

    -- assign node to itself in slot 2 of 4.
    , Statement_Assignment
        (Variable_Subs (Variable_Global $ HNm "trd") 1)
        (Value_Offset  (Variable_Global $ HNm "fst") 3)

    -- assign node to itself in slot 2 of 4.
    , Statement_Assignment
        (Variable_Subs (Variable_Global $ HNm "trd") 2)
        (Value_Var     (Variable_Global $ HNm "trd"))

    -- assign global fst to trd in slot 3 of 4.
    , Statement_Assignment
        (Variable_Subs (Variable_Global $ HNm "trd") 3)
        (Value_Var     (Variable_Global $ HNm "fst"))



    , Statement_Switch
    
       (Value_Var (Variable_Subs (Variable_Global $ HNm "fst") 1))
    
    [

      Alternative_Alternative (Constant_LiteralInt 4)
   
       -- assign global fst to RP 1.
       [Statement_Assignment
         (Variable_Subs Variable_RP 1)
         (Value_Var (Variable_Global $ HNm "fst"))]

    , Alternative_Alternative (Constant_LiteralInt 33)

       -- assign global fst to RP 4.
       [Statement_Assignment
         (Variable_Subs Variable_RP 4)
         (Value_Var (Variable_Global $ HNm "trd"))]

    ]



    , Statement_Return 1
    ]
  ]
  undefined

methodMain = 
  Method {
    m_flags = [Public,Static]
  , m_name = "main"
  , m_ret = Nothing
  , m_args = [TArray (TClass "java.lang.String")]
  , m_code = Just (Code {
      c_max_stack  = Nothing
    , c_max_locals = Nothing
    , c_instructions = [
        Const (CInt 42)
      , Store TInt 1
      , Get True (FieldRef {
          fr_class = "java.lang.System"
        , fr_name = "out"
        , fr_type = TClass "java.io.PrintStream"
        })
      , Invoke IStatic (MethodRef "Runtime" "initialize" [] Nothing)
      , Invoke IStatic (MethodRef "fib" "initialize"     [] (Just TInt))
      , Invoke IStatic (MethodRef "fib" "fun_x_1_main"   [] (Just TInt))
      , Invoke IStatic (MethodRef "Runtime" "finish"     [] Nothing)
      , Load TInt 1
      , Pop TInt
      , Return Nothing
      ]
    })
  , m_exceptions = []
  , m_signature = Nothing
  , m_deprecated = False
  }

%%]

--------------------------------------------------------------------------------

{-
Possible optimizations

  1) Probably, not sure yet, the ALLOC size in silly is the maximum of all
     possible constructors for a data-type. This is safe but sometimes wastes
     some space. Maybe we can detect what the real value of this ALLOC should
     be for our payload array.
  2) Inline the payload into the node by statically creating a bunch of
     Java classes for every length a value can be. These classes can be called
     something like `Value<n>'. When we perform this the optimization (1) will
     bot be possible anymore, but we skip one indirection.
  3) Do not use a separate Int bucket for the case that the tag is CInt, but
     use some bit magic to store this integer in the tag itself.
  4) Do not use an indirect RP bucket to make our life easier in the Subs case
     but use a direct RP array. This is somewhat more involved because we then
     need to know that we are Subs'ing the RP which needs some aspect. This
     optimization is quite essential because you save an indirection on `every'
     return.
  n) ...


  (double assignments)
-}

%%[(8 codegen grin)
ATTR SilModule
  [ | | jvmCode : {Class} ]

ATTR Functions
  [ | | jvmCode : {[Method]} ]

ATTR Function
  [ | | jvmCode : {Method} ] 

ATTR Statements Statement Values Value Variable 
  [ | | jvmCode : {Code} ]

ATTR Alternatives
  [ | | jvmCode : {[(Int32, Label, Code)]} ]  

ATTR Alternative
  [ | | jvmCode : {(Int32, Label, Code)} ]

ATTR AllNT
  [ | counter : Int | ]

ATTR AllNT - SilModule
  [ jvmCons : {[(String, Int)]} | | ]

ATTR AllNT - SilModule
  [ jvmGlobs : {[HsName]} | | ]

ATTR AllNT - SilModule
  [ jvmLhs : Bool | | ]

{
type Locals = M.IntMap JvmType
}

-- Contains a mapping from local variable indices to types.
ATTR AllNT - SilModule Function Functions
  [ | jvmLType : {Locals} | ]

ATTR AllNT
  [ | | jvmType USE {`const`} {error "JVM: No LHS type."} : JvmType ]

ATTR Variable
  [ jvmAssignType : JvmType | | ]

{

type AssignCode = (Code, Locals -> Locals)

}

ATTR Variable 
  [ | | jvmAssign USE {++} {(emptyCode, id)} : {AssignCode} ]

ATTR Constant
  [ | | jvmVal : {J.Constant} ]  

--------------------------------------------------------------------------------

SEM SilModule
  | SilModule  lhs.jvmCode  = defaultClass {
                                c_methods = methodMain : @functions.jvmCode
                              , c_this    = "fib"
                              }
         functions.jvmCons  = @constants
         functions.jvmGlobs = @variables
         functions.jvmLhs   = False

SEM Functions
  | Cons        lhs.jvmCode = @hd.jvmCode : @tl.jvmCode
  | Nil         lhs.jvmCode = []

SEM Function
  | Function    lhs.jvmCode = Method {
                                m_flags = [Public,Static]
                              , m_name       = show @name
                              , m_ret        = Just TInt
                              , m_args       = replicate (length @parameters) (TClass cObject)
                              , m_exceptions = []
                              , m_signature  = Nothing
                              , m_deprecated = False
                              , m_code       = Just @body.jvmCode
                              }
              body.jvmLType = M.empty

SEM Statements
  | Cons        lhs.jvmCode = @hd.jvmCode % @tl.jvmCode
  | Nil         lhs.jvmCode = emptyCode

{

data JvmType = JvmTag | JvmInt | JvmLocal | JvmNode
  deriving (Show, Eq)

jvmAssignment ::
     Code                        -- ^ Lhs of assignment.
  -> AssignCode                  -- ^ How to assign to Lhs.
  -> Code                        -- ^ Rhs of assignment.
  -> JvmType                     -- ^ Type of lhs.
  -> JvmType                     -- ^ Type of rhs.
  -> M.IntMap JvmType            -- ^ Known types of local variable.
  -> (Code, M.IntMap JvmType)    -- ^ Assignment code, possibly updates local variable types.

jvmAssignment dest assign source left right locals =
  (dest % source % acode, flocals locals)
  where (acode, flocals) = assign

jvmAssignment2 ::
     Code                        -- ^ First lhs of assignment.
  -> AssignCode                  -- ^ How to assign to first Lhs.
  -> Code                        -- ^ Second lhs of assignment.
  -> AssignCode                  -- ^ How to assign to second Lhs.
  -> Code                        -- ^ Rhs of assignment.
  -> JvmType                     -- ^ Type of lhs.
  -> JvmType                     -- ^ Type of rhs.
  -> M.IntMap JvmType            -- ^ Known types of local variable.
  -> (Code, M.IntMap JvmType)    -- ^ Assignment code, possibly updates local variable types.

jvmAssignment2 dest1 assign1 dest2 assign2 source left right locals =
  let (code1, locals1) = jvmAssignment dest1 assign1 source left right locals
      (code2, locals2) = jvmAssignment dest2 assign2 source left right locals1
  in (code1 % code2, locals2)

}

SEM Statement

  | Assignment  lhs.jvmCode = fst @loc.code
                loc.code    = jvmAssignment
                                @dest.jvmCode
                                @dest.jvmAssign
                                @source.jvmCode
                                @dest.jvmType
                                @source.jvmType
                                @lhs.jvmLType
               lhs.jvmLType = snd @loc.code
         dest.jvmAssignType = @source.jvmType
          dest.jvmLhs       = True
        source.jvmLhs       = False

  | Assignment2 lhs.jvmCode = fst @loc.code
                loc.code    = jvmAssignment2
                                @dest1.jvmCode
                                @dest1.jvmAssign
                                @dest2.jvmCode
                                @dest2.jvmAssign
                                @source.jvmCode
                                @dest1.jvmType
                                @source.jvmType
                                @lhs.jvmLType
               lhs.jvmLType = snd @loc.code
        dest1.jvmAssignType = @source.jvmType
        dest2.jvmAssignType = @source.jvmType
         dest1.jvmLhs       = True
         dest2.jvmLhs       = True
        source.jvmLhs       = False

  | Call        lhs.jvmCode = case lookup @name primitiveFunctions of

                                -- Real call.
                                Nothing ->
                                  @args.jvmCode % singleCode
                                  (Invoke IStatic $ MethodRef "fib" (show @name) [] $ Just TInt)

                                -- Built-in call.
                                Just prim -> prim @args.jvmCode

  | Comment     lhs.jvmCode = emptyCode

  {-
    INVARIANT: This generic IfThenElse compiles to the specific
    greater-than-equal comparison, because this is the only pattern it appears
    in the original silly code.
  -}
  | IfThenElse  loc.labelElse  : UNIQUEREF counter
                loc.labelEndIf : UNIQUEREF counter
                lhs.jvmCode = @condition.jvmCode
                              % singleCode (If CmpGt @loc.labelElse)
                              % @thenpart.jvmCode
                              % singleCode (Goto @loc.labelEndIf)
                              % singleCode (Note (Label @loc.labelElse))
                              % @elsepart.jvmCode
                              % singleCode (Note (Label @loc.labelEndIf))

  | Switch      loc.labelSwitchEnd : UNIQUEREF counter
                lhs.jvmCode = let 
                                alts   = @body.jvmCode
                                end    = @loc.labelSwitchEnd
                                arms   = map (\(_, _, code)   -> code % singleCode (Goto end))
                                labels = map (\(when, lbl, _) -> (when, lbl)) alts
                              in
                              @scrutinee.jvmCode
                              % singleCode (Switch Lookup (snd $ head labels) labels)
                              % foldl mergeCode emptyCode (arms alts)
                              % singleCode (Note (Label end))

  | Jump        lhs.jvmCode = error "JVM: no jumps  supported."
  | Label       lhs.jvmCode = error "JVM: no labels supported."
  | Return      lhs.jvmCode = code [Const $ CInt $ fromIntegral @retdiff, Return $ Just TInt]
  | Smart       lhs.jvmCode = error "JVM: not implemented yet (smart)."

  | * - Assignment Assignment2 Call Comment Jump Label Return Smart Switch IfThenElse
                lhs.jvmCode = error "JVM: not supported."

SEM Alternatives
  | Cons        lhs.jvmCode = @hd.jvmCode : @tl.jvmCode
  | Nil         lhs.jvmCode = []

SEM Alternative
  | Alternative lhs.jvmCode = let l = @loc.label in
                              case @when.jvmVal of
                                CInt i -> (i, l, singleCode (Note $ Label l) % @body.jvmCode)
                                _      -> error "JVM: non-integer case scrutinee"
                loc.label   : UNIQUEREF counter

SEM Values
  | Cons        lhs.jvmCode = @hd.jvmCode % @tl.jvmCode
  | Nil         lhs.jvmCode = emptyCode

SEM Value

  | Alloc       lhs.jvmCode = code [
                                  New cNode
                                , Dup TInt
                                , Dup TInt
                                , Invoke ISpecial $ MethodRef cNode "<init>" [] Nothing
                                , Const (CInt (fromIntegral @size - 1))
                                , NewArray tNode 1
                                , Put False (FieldRef cNode fPayload $ TArray tNode)
                                ]
                lhs.jvmType = JvmNode

                            -- todo: this is probably ffi only!!
  | Call        lhs.jvmCode = case lookup (HNm @name) primitiveFunctions of

                                -- Real call.
                                Nothing ->
                                  @args.jvmCode % singleCode
                                  (Invoke IStatic $ MethodRef "fib" @name [] $ Just TInt)

                                -- Built-in call.
                                Just prim -> prim @args.jvmCode

  | Con         lhs.jvmCode = singleCode $ Const @con.jvmVal
  | Var         lhs.jvmCode = @var.jvmCode
          var.jvmAssignType = error "JVM: no assign type for variables."

  | CompareGT   lhs.jvmCode = singleCode (Const @con.jvmVal) % @val.jvmCode
                lhs.jvmType = JvmInt

  {-
    Observation: We cannot perform `Arith Add's on references here.  But
    Offsets are only used in conjunction with Globals and Locals. 
  -}

  | Offset      lhs.jvmCode = @var.jvmCode
                              % singleCode (Const (CInt (fromIntegral @off - 1)))
                              % singleCode (Arith Add TInt)
                              % if @lhs.jvmLhs
                                then emptyCode  -- Do not load when left hand side.
                                else singleCode (ALoad tNode)
                 var.jvmLhs = True
                lhs.jvmType = JvmNode
          var.jvmAssignType = error "JVM: no assign type for offsets."

  | Label       lhs.jvmCode = error "JVM: no support for Var Labels."

SEM Variable

  | Global      lhs.jvmCode = code [
                                  Get True $ FieldRef cRuntime fGlobals $ tPayload
                                , Const (CInt $ fromIntegral
                                              $ maybe (error "JVM: global lookup failed") id
                                              $ @name `elemIndex` @lhs.jvmGlobs)
                                ] %
                              if @lhs.jvmLhs
                              then emptyCode
                              else singleCode (ALoad tNode)

             lhs.jvmType = JvmNode

             -- We get a type from our parent assignment, but we know we are here for tNode.
             lhs.jvmAssign = (singleCode (AStore tNode), id)

  | Local       lhs.jvmCode = if @lhs.jvmLhs
                              then emptyCode
                              else let tp = maybe (error "JVM: local type not in map.")
                                              id (M.lookup @pos @lhs.jvmLType)
                                   in case tp of
                                     JvmInt  -> singleCode (Load TInt  (fromIntegral @pos))
                                     JvmNode -> singleCode (Load tNode (fromIntegral @pos))
                                     e       -> error ("JVM: unknown type in Local: " ++ show e)
                                    -- todo: add parameter count to @pos?

             lhs.jvmAssign = (case @lhs.jvmAssignType of
                               JvmInt  -> singleCode (Store TInt  (fromIntegral @pos))
                               JvmNode -> singleCode (Store tNode (fromIntegral @pos))
                               e       -> error ("JVM: unknown type in Local: " ++ show e)
                             , M.insert @pos @lhs.jvmAssignType)

               lhs.jvmType = JvmLocal
  
  | Param      lhs.jvmCode = singleCode $ Load tNode (fromIntegral @pos)

             -- RP is always used in conjunction with Subs.
  | RP          lhs.jvmCode = singleCode $ Get True $ FieldRef cRuntime fCRP $ tNode

  | Subs        lhs.jvmCode = @array.jvmCode %
                              if @index == 0
                              then if @lhs.jvmLhs
                                   then emptyCode
                                   else singleCode (Get False (FieldRef cNode fTag TInt))
                              -- We assume we never inspect the intVal except
                              -- in primitive functions.
                              else 
                                case @lhs.jvmLhs of
                                  False ->
                                    code [
                                      Get False (FieldRef cNode fPayload tPayload)
                                    , Const (CInt (fromIntegral @index - 1))
                                    , ALoad tNode
                                    ]
                                  _ -> 
                                    code [
                                      Get False (FieldRef cNode fPayload tPayload)
                                    , Const (CInt (fromIntegral @index - 1))
                                    ]
                                    % if @lhs.jvmAssignType == JvmInt
                                      then code [
                                         New cIntNode
                                       , Dup TInt
                                       , Dup TInt
                                       , Invoke ISpecial $ MethodRef cIntNode "<init>" [] Nothing
                                       ]
                                      else emptyCode

              lhs.jvmAssign = ((
                                if @index == 0
                                then singleCode (Put False (FieldRef cNode fTag TInt))
                                else ((if @lhs.jvmAssignType == JvmInt
                                     then code [Put False (FieldRef cIntNode fIntVal TInt)]
                                     else emptyCode)
                                     % singleCode (AStore tNode)))
                                , id)
 
               array.jvmLhs = False

                lhs.jvmType = if @index == 0
                              then JvmTag
                              else JvmNode

  | * - Global Local Param RP Subs
                lhs.jvmCode = error "JVM: this Variable kind not supported."

SEM Constant
  | LiteralInt  lhs.jvmVal   = CInt (fromIntegral @value)
                lhs.jvmType  = JvmInt
  | LiteralStr  lhs.jvmVal   = CString @value

  | Alias       lhs.jvmVal   = case @name `lookup` @lhs.jvmCons of
                                 Nothing -> error ("JVM: no such constant alias: " ++ @name)
                                 Just  a -> CInt (fromIntegral a)


%%]

