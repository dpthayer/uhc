%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell importable interface to eliminate 'Equal' types
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Compute canonic form of type w.r.t. Eq and Ord.
This matters at:
- rows, where fields may be in arbitrary order

This matters for:
- comparing types, in particular within predicates during proving

%%[10 hs module {%{EH}Ty.Trf.Canonic} import({%{EH}Base.Common},{%{EH}Base.Builtin},{%{EH}Ty},{%{EH}Ty.FitsIn})
%%]

%%[10 hs import(qualified Data.Set as Set)
%%]

%%[11 hs import({%{EH}Base.Opts})
%%]

%%[10.WRAPPER ag import({Ty/AbsSyn},{Ty/CommonAG})
WRAPPER TyAGItf
%%]

%%[10 hs 
tyCanonic :: FIIn -> Ty -> Ty
tyCanonic fi ty
  =  let  t =  wrap_TyAGItf
                 (sem_TyAGItf (TyAGItf_AGItf ty))
                 (Inh_TyAGItf
%%[[11
                   { fi_Inh_TyAGItf = fi
                   }
%%]]
                 )
     in   repl_Syn_TyAGItf t
%%]

%%[10 hs export(predCanonic)
predCanonic :: FIIn -> Pred -> Pred
predCanonic fi pr
  = case tyCanonic fi $ Ty_Pred pr of
      Ty_Pred pr' -> pr'
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Context info
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[11
ATTR TyAGItf AllTy [ fi: FIIn | | ]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Replacement
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[10
ATTR AllTyAndFlds [ | | repl: SELF ]
ATTR TyAGItf  [ | | repl: Ty ]

SEM Ty
  | Ext             lhs     .   repl            =   if @isSpineRoot
                                                    then let (row,exts) = tyRowExts @repl
                                                             exts' = tyRowCanonOrder exts
                                                         in  mkTyRow row exts'
                                                    else @repl
%%]

%%[11
SEM Ty
  | App             lhs     .   repl            =   if @isSpineRoot
                                                    then tyBetaRedFull @lhs.fi @repl
                                                    else @repl
  | Con             lhs     .   repl            =   tyBetaRedFull @lhs.fi @repl
%%]


