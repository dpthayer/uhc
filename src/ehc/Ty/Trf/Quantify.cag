%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Module itf
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[3 hs module {%{EH}Ty.Trf.Quantify} import(EH.Util.Utils,{%{EH}Base.Builtin},{%{EH}Base.Common},{%{EH}Ty},{%{EH}Cnstr},{%{EH}Substitutable}) export(tyQuantify, tyQuantifyClosed)
%%]

%%[4 hs import({%{EH}Base.Debug},UU.Pretty)
%%]

%%[4 hs import(qualified Data.Set as Set,qualified Data.Map as Map,Data.List as List)
%%]

%%[4 ag import({Ty/AbsSyn},{Ty/CommonAG},{Ty/TyVarCommon})
WRAPPER TyAGItf
%%]

%%[6 hs export(kiQuantify)
%%]

%%[9 hs import(Data.Maybe,EH.Util.Utils,UU.Pretty) export(tyQuantifyPr,tyQuantifyRank,TyQuOut(..),TyQuOpts(..),defaultTyQuOpts)
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell importable interface to Ty quantify
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[3.tyQuantify hs
tyQuantify :: (TyVarId -> Bool) -> Ty -> Ty
tyQuantify tvIsBound ty = mkTyQu (filter (not.tvIsBound) (ftv ty)) ty
%%]

%%[3.tyQuantifyClosed hs
tyQuantifyClosed :: Ty -> Ty
tyQuantifyClosed = tyQuantify (const False)
%%]

%%[9.tyQuantifyClosed -3.tyQuantifyClosed hs
tyQuantifyClosed :: Ty -> Ty
tyQuantifyClosed = tyQuantifyRank [1..]

tyQuantifyRank :: [Int] -> Ty -> Ty
tyQuantifyRank rL ty
  = tqoTy (tyQuantifyPr (defaultTyQuOpts {tqoptQuRanks = rL}) (const False) TyQu_Forall [] ty)
%%]

%%[4.tyQuantify -3.tyQuantify hs
tyQuantify :: (TyVarId -> Bool) -> Ty -> Ty
tyQuantify tvIsBound ty
  = let  t  =  wrap_TyAGItf
                  (sem_TyAGItf (TyAGItf_AGItf ty))
                  (Inh_TyAGItf {tvIsBound_Inh_TyAGItf = tvIsBound})
    in   quTy_Syn_TyAGItf t
%%]

%%[6.tyQuantify -4.tyQuantify hs
tyQuantify :: (TyVarId -> Bool) -> Ty -> Ty
tyQuantify tvIsBound ty = tyQuantify' tvIsBound TyQu_Forall ty

kiQuantify :: (TyVarId -> Bool) -> Ty -> Ty
kiQuantify tvIsBound ty = tyQuantify' tvIsBound TyQu_KiForall ty
%%]

%%[6.tyQuantifyPrime hs
tyQuantify' :: (TyVarId -> Bool) -> TyQu -> Ty -> Ty
tyQuantify' tvIsBound baseQuant ty
  = let  t  =  wrap_TyAGItf
                  (sem_TyAGItf  (TyAGItf_AGItf ty))
                  (Inh_TyAGItf  { baseQu_Inh_TyAGItf        = baseQuant
                                , tvIsBound_Inh_TyAGItf     = tvIsBound
                                })
    in   quTy_Syn_TyAGItf t
%%]

%%[9.tyQuantifyPrime -6.tyQuantifyPrime hs
tyQuantify' :: (TyVarId -> Bool) -> TyQu -> Ty -> Ty
tyQuantify' tvIsBound baseQuant ty = tqoTy (tyQuantifyPr defaultTyQuOpts tvIsBound baseQuant [] ty)
%%]

%%[9 hs
data TyQuOpts  = TyQuOpts  {tqoptLeaveImpls :: Bool, tqoptQuRanks :: [Int]}

defaultTyQuOpts :: TyQuOpts
defaultTyQuOpts = TyQuOpts False [1..]

data TyQuOut
  = TyQuOut   { tqoTy               ::  Ty
              , tqoInsPrIdSet       ::  Set.Set PredOccId
              , tqoImplsCnstr       ::  Cnstr
              }

instance Show TyQuOut where
  show _ = ""

instance PP TyQuOut where
  pp tqo = pp (tqoImplsCnstr tqo)
%%]
              , tqoPredAsArgLocs    ::  PredAsArgLocs
instance PP TyQuOut where
  pp tqo = pp (tqoImplsCnstr tqo) >|< "/" >|< ppBracketsCommas (tqoPredAsArgLocs tqo)

%%[9 hs
tyQuantifyPr :: TyQuOpts -> (TyVarId -> Bool) -> TyQu -> [PredOcc] -> Ty -> TyQuOut
tyQuantifyPr opts tvIsBound baseQuant prL ty
  = let  t  =  wrap_TyAGItf
                  (sem_TyAGItf  (TyAGItf_AGItf ty))
                  (Inh_TyAGItf  { baseQu_Inh_TyAGItf        = baseQuant
                                , tvIsBound_Inh_TyAGItf     = tvIsBound
                                , opts_Inh_TyAGItf          = opts
                                , prLL_Inh_TyAGItf          = [prL]
                                })
    in   TyQuOut
            { tqoTy                 = quTy_Syn_TyAGItf t
            , tqoInsPrIdSet         = Set.empty -- insPrIdSet_Syn_TyAGItf t
            , tqoImplsCnstr         = emptyCnstr -- assocLToCnstrImpls (prImpls_Syn_TyAGItf t)
            }
%%]
            , tqoPredAsArgLocs      = predAsArgsLocs_Syn_TyAGItf t

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Options
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[9
ATTR TyAGItf AllTy [ opts: TyQuOpts | | ]

SEM TyAGItf
  | AGItf       ty          .   opts        =   @lhs.opts {tqoptQuRanks = take 5 (tqoptQuRanks @lhs.opts)}
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Fixed tvars
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4
ATTR AllTy [ | | gathFxTvM USE {`Map.union`} {Map.empty}: TvCatMp ]
ATTR AllTy [ fxTvM: TvCatMp | | ]

SEM Ty
  | Var         lhs         .   gathFxTvM   =   @tv `Map.singleton` @categ.self

SEM TyAGItf
  | AGItf       loc         .   fxTvM       =   @ty.gathFxTvM
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Free row vars
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[90
ATTR Ty [ | | frRowTvL: TyVarIdL ]

SEM Ty
  | Ext         lhs         .   frRowTvL    =   @ty.frRowTvL
  | App         loc         .   frRowTvL    =   @func.frRowTvL `List.union` @arg.frRowTvL
  | * - App Ext
                lhs         .   frRowTvL    =   []
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Rank
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4
ATTR AllTy [ rank: Int | | ]

SEM Ty
  | App         arg         .   rank        =   @lhs.rank + (if @isArrowArg then 1 else 0)

SEM TyAGItf
  | AGItf       ty          .   rank        =   1
%%]

%%[9
SEM Ty
  | Var App Pred
                loc         .   isQuRank    =   @lhs.rank `elem` tqoptQuRanks @lhs.opts
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Is type a tvar?
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4
%%]
ATTR Ty [ | | isVar: Bool ]

SEM Ty
  | Var         lhs         .   isVar       =   True
  | * - Var     lhs         .   isVar       =   False

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Is location in type a place where we treat quantification specially?
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[6_4.isSpecLoc
ATTR Ty [ | | isSpecLoc: Bool  isSpecLocL: [Bool] ]

SEM Ty
  | App         loc         .   isSpecLoc   =   @isSpineRoot && (@appIsArrow || @appIsLikeProd)
                            .   isSpecLocL  =   @arg.isSpecLoc : @func.isSpecLocL
  | * - App     loc         .   isSpecLoc   =   False
                            .   isSpecLocL  =   []
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Is location in type a place where quantification of previously existentialized tvar may be done?
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[6_4
SEM Ty
  | App         loc         .   isReQuExLoc =   @lhs.rank > 1
                                                ||  @lhs.rank == 1
                                                    &&  (@lhs.tyCtxt == TyQuCtxtArrow && not @arg.isArrow
                                                        || @lhs.tyCtxt /= TyQuCtxtArrow
                                                        )
  | Var         loc         .   isReQuExLoc =   True
%%]

%%[9
%%]
SEM Ty
  | Pred        loc         .   isReQuExLoc =   True

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Is location in type a place where quantification of fixed tvar may be done?
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4
SEM Ty
  | App         loc         .   isQuFxLoc   =   @lhs.rank > 1
                                                ||  @lhs.rank == 1
                                                    &&  (@lhs.tyCtxt == TyQuCtxtArrow && not @arg.isArrow
                                                        || @lhs.tyCtxt == TyQuCtxtOther
                                                        )
  | Var         loc         .   isQuFxLoc   =   False
%%]

%%[9
SEM Ty
  | Pred        loc         .   isQuFxLoc   =   False
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% The implicit preds
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

To be removed when Trf/MergePreds is done

%%[9
ATTR Ty [ | | mbImpls: {Maybe Impls} ]

SEM Ty
  | Impls       lhs         .   mbImpls                 =   Just @impls.quTy
  | App         lhs         .   mbImpls                 =   if @isArrowArg then @arg.mbImpls else Nothing
  | * - App Impls
                lhs         .   mbImpls                 =   Nothing
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Can predicates be inserted at location in ty
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

To be removed when Trf/MergePreds is done

%%[9
ATTR AllTy [ mbPrLoc: {Maybe ImplsVarId} | | ]

SEM TyAGItf
  | AGItf       ty          .   mbPrLoc                 =   Nothing

SEM Ty
  | App         loc         .   (implsPrL,mbTail)       =   if tqoptLeaveImpls @lhs.opts
                                                            then ([],Nothing)
                                                            else maybe ([],Nothing) implsPredsMbTail @func.mbImpls
                arg         .   mbPrLoc                 =   @mbTail
  | Var         loc         .   implsPrL                =   []
  | * - App Var Con Any
                loc         .   mbPrLoc                 =   Nothing
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Determine insertable preds
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

To be removed when Trf/MergePreds is done

%%[9 hs
prLLArrowSplit :: [TyVarId] -> [[PredOcc]] -> ([PredOcc],[[PredOcc]])
prLLArrowSplit frTvL prLL
  =  let  (h,r) = partition (all (`elem` frTvL) . ftv) . concat $ prLL
     in   (h,[r])
%%]

%%[9
ATTR TyAGItf AllTy [ prLL: {[[PredOcc]]} | | ]

SEM Ty
  | Var         loc         .   (herePrL,_)             =   prLLArrowSplit @qSurrTvL @lhs.prLL
  | App         (loc.herePrL,func.prLL,arg.prLL)        =   if @isSpineRoot
                                                            then  if @appIsArrow
                                                                  then  let  (h,r) = prLLArrowSplit (@arrArgTvL ++ @lhs.qSurrTvL) @lhs.prLL
                                                                        in   (h,[],r)
                                                                  else  let  (h,_) = prLLArrowSplit (@frTvL ++ @lhs.qSurrTvL) @lhs.prLL
                                                                        in   (h,[],[])
                                                            else  ([],[],[])
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Pass preds up to pred insertable location
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

To be removed when Trf/MergePreds is done

%%[9
ATTR AllTy [ | | insPrL USE {++} {[]} : {[PredOcc]} ]

SEM Ty
  | App         loc         .   candPrL         =   @herePrL ++ @func.insPrL ++ @arg.insPrL
  | Var         loc         .   candPrL         =   @herePrL
  | App Var     (loc.insHerePrL,lhs.insPrL)     =   maybe ([],@candPrL) (const (@candPrL,[])) @lhs.mbPrLoc
                loc         .   insPrL          =   @implsPrL ++ @insHerePrL
                            .   hasNoInsPrL     =   null @insPrL
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Determine quantifiable tvars
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4.tvBoundAdd hs
tvBoundAdd :: (TyVarId -> Bool) -> TyVarIdL -> TyVarId -> Bool
tvBoundAdd tvIsBound tvL = \v -> v `elem` tvL || tvIsBound v
%%]

%%[4.tvarsToQuant hs
tvarsToQuant :: Bool -> TvCatMp -> (TyVarId -> Bool) -> (TyVarId -> Bool) -> TyVarIdL -> (TyVarIdL,TyVarIdL,TyVarId -> Bool)
tvarsToQuant isQuLoc _ mayQuFx tvIsBound tvL
  =  if isQuLoc
     then  let boundables = filter (\tv -> not (tvIsBound tv)) tvL
           in (boundables,[],tvBoundAdd tvIsBound boundables)
     else  ([],[],tvIsBound)
%%]

%%[6_4.tvarsToQuant -4.tvarsToQuant hs
tvarsToQuant :: Bool -> TvCatMp -> (TyVarId -> Bool) -> (TyVarId -> Bool) -> TyVarIdL -> (TyVarIdL,TyVarIdL,TyVarId -> Bool)
tvarsToQuant isQuLoc fxTvM mayQuFx tvIsBound tvL
  =  if isQuLoc
     then  let  tvFrL = filter (\tv -> not (tvIsBound tv)) tvL
                (bndEx,bnd) = partition (tvIsEx fxTvM) tvFrL
           in   (bnd,filter mayQuFx bndEx,tvBoundAdd tvIsBound tvFrL)
     else  ([],[],tvIsBound)
%%]

%%[4.tvMayQuFx hs
tvMayQuFx :: TyQu -> TvCatMp -> Bool -> TyVarId -> Bool
tvMayQuFx qu fxTvM isQuFxLoc tv
  = True
%%]

%%[6_4.tvMayQuFx -4.tvMayQuFx hs
tvMayQuFx :: TyQu -> TvCatMp -> Bool -> TyVarId -> Bool
tvMayQuFx qu fxTvM isQuFxLoc tv
  = isQuFxLoc 
%%]

%%[4.tvIsBound
ATTR TyAGItf AllTy [ tvIsBound: {TyVarId -> Bool} | | ]

SEM TyAGItf
  | AGItf       loc         .   (qBndTvL,qBndExTvL,tvIsBound)
                                                        =   tvarsToQuant True @fxTvM (const False) @lhs.tvIsBound @qHereTvL

SEM Ty
  | App Var     loc         .   (qBndTvL,qBndExTvL,tvIsBound)
                                                        =   tvarsToQuant @isQuLoc @lhs.fxTvM (tvMayQuFx @hereQu @lhs.fxTvM @isQuFxLoc) @lhs.tvIsBound @qHereTvL
  | Quant       loc         .   tvIsBound               =   tvBoundAdd @lhs.tvIsBound @introTVarL
%%]

%%[9
SEM Ty
  | App Var     loc         .   (qBndTvL,qBndExTvL,tvIsBound)
                                                        :=  tvarsToQuant @isQuLoc @lhs.fxTvM (tvMayQuFx @hereQu @lhs.fxTvM @isQuFxLoc) @lhs.tvIsBound (@qHereTvL `List.union` ftv @candPrL)
%%]

%%[9
SEM Ty
  | Pred        loc         .   (qBndTvL,qBndExTvL,tvIsBound)
                                                        =   tvarsToQuant @isQuLoc @lhs.fxTvM (const False) @lhs.tvIsBound @qHereTvL
%%]

%%[11
SEM Ty
  | Lam         loc         .   tvIsBound               =   tvBoundAdd @lhs.tvIsBound @introTVarL
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Which quantifier to use for quantification
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4.hereQu
SEM TyAGItf
  | AGItf       loc         .   hereQu          =   TyQu_Forall

SEM Ty
  | App         loc         .   qAsExist        =   @appIsLikeProd || @lhs.coco == ContraVariant && not @appIsArrow
  | Var         loc         .   qAsExist        =   @lhs.coco == ContraVariant
  | App Var     loc         .   hereQu          =   if @qAsExist then TyQu_Exists else TyQu_Forall
  | Quant       loc         .   hereQu          =   @qu.self
%%]

%%[6.hereQu
ATTR TyAGItf AllTy [ baseQu: TyQu | | ]

SEM TyAGItf
  | AGItf       loc         .   hereQu          :=  @lhs.baseQu

SEM Ty
  | App Var     loc         .   hereQu          :=  if @qAsExist then tyquExists @lhs.baseQu else @lhs.baseQu
%%]

%%[9.hereQu
SEM Ty
  | App         loc         .   qAsExist        :=  @hasNoInsPrL && (@appIsLikeProd || @lhs.coco == ContraVariant && not @appIsArrow)
  | Var         loc         .   qAsExist        :=  @hasNoInsPrL && @lhs.coco == ContraVariant
%%]

%%[9
SEM Ty
  | Pred        loc         .   qAsExist        =   @lhs.coco == ContraVariant
                            .   hereQu          =   if @qAsExist then tyquExists @lhs.baseQu else @lhs.baseQu
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Quantified type
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4 hs
mkTyQuEx :: TyQu -> TyVarIdL -> TyVarIdL -> Ty -> Ty
mkTyQuEx q tvL tvExL t = mkTyQu q tvL (mkTyQu (tyquExists q) tvExL t)
%%]

%%[4.quTy
ATTR TyAGItf [ | | quTy: Ty ]
ATTR AllTy TyQu TyVarCateg [ | | quTy: SELF ]

SEM TyAGItf
  | AGItf       lhs         .   quTy            =   mkTyQuEx @hereQu @qBndTvL @qBndExTvL @ty.quTy

SEM Ty
  | Var         lhs         .   quTy            =   mkTyQuEx @hereQu @qBndTvL @qBndExTvL (Ty_Var @tv @categ.quTy)
  | App         loc         .   quTy            =   mkTyQuEx @hereQu @qBndTvL @qBndExTvL (Ty_App @func.quTy @arg.quTy)
  | Quant       lhs         .   quTy            =   Ty_Quant @qu.self @tv @ty.quTy
%%]
SEM Ty
  | App         loc         .   quTy            =   mkTyQuEx @hereQu @qBndTvL @qBndExTvL (Ty_App @func.quTy @arg.quTy)
  | Var         lhs         .   quTy            =   tr "Var" (pp @self >#< "coco=" >|< @lhs.coco >#< "isQuLoc=" >|< @isQuLoc >#< ppBracketsCommas @qBndTvL >#< ppBracketsCommas @frTvL) $ mkTyQuEx @hereQu @qBndTvL @qBndExTvL (Ty_Var @tv @categ.quTy)
  | App         loc         .   quTy            =   tr "App" (pp @self >#< "coco=" >|< @lhs.coco >#< "isQuLoc=" >|< @isQuLoc >#< "isQuFxLoc=" >|< @isQuFxLoc >#< "isSpineRoot=" >|< @isSpineRoot >#< ppBracketsCommas @qBndTvL >#< ppBracketsCommas (map ppBracketsCommas @frTvLL)) $ mkTyQuEx @hereQu @qBndTvL @qBndExTvL (Ty_App @func.quTy @arg.quTy)

%%[9 hs
mkTyQuForRank :: Bool -> TyQu -> TyVarIdL -> TyVarIdL -> Ty -> Ty
mkTyQuForRank allow q tvL tvExL t = if allow then mkTyQuEx q tvL tvExL t else t
%%]

%%[9
SEM Ty
  | Var         lhs         .   quTy            :=  mkTyQuForRank @isQuRank @hereQu @qBndTvL @qBndExTvL $ Ty_Var @tv @categ.quTy
  | App         loc         .   quTy            :=  let  (rwYTvL,rwNTvL) = partition (`elem` @frRowTvL) @qBndTvL
                                                    in   mkTyQuForRank @isQuRank @hereQu rwNTvL @qBndExTvL
                                                         $  mkTyQuForRank @isQuRank @lhs.baseQu rwYTvL []
                                                         $  Ty_App @func.quTy @arg.quTy
  | Pred        lhs         .   quTy            =   mkTyQuForRank @isQuRank @hereQu @qBndTvL @qBndExTvL (Ty_Pred @pr.quTy)
%%]

%%[11
SEM Ty
  | Lam         lhs         .   quTy            =   Ty_Lam @tv @ty.quTy
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Preds which have been inserted (from the given ones)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

To be removed when Trf/MergePreds is done

%%[9
%%]
ATTR TyAGItf AllTy [ | | insPrIdSet USE {`Set.union`} {Set.empty} : {Set.Set PredOccId} ]

SEM Ty
  | App         lhs         .   insPrIdSet      =   Set.fromList (map poPoi @insHerePrL) `Set.union` @func.insPrIdSet `Set.union` @arg.insPrIdSet
  | Var         lhs         .   insPrIdSet      =   Set.fromList (map poPoi @insHerePrL)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Additional bindings for implicits variables
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

To be removed when Trf/MergePreds is done

%%[9 hs
prOccLImpls :: Maybe ImplsVarId -> [PredOcc] -> AssocL ImplsVarId Impls
prOccLImpls mbI prL
  = maybe [] (\i -> [(i,foldr (\p im -> Impls_Cons (poId p) (poPr p) (poPoi p) im) Impls_Nil prL)]) mbI
%%]

%%[9
ATTR TyAGItf [ | | prImpls: {AssocL ImplsVarId Impls} ]
ATTR AllTy [ | prImpls: {AssocL ImplsVarId Impls} | ]

SEM TyAGItf
  | AGItf       ty          .   prImpls         =   []

SEM Ty
  | App         lhs         .   prImpls         =   (if @isArrowRoot then prOccLImpls @lhs.mbPrLoc @insHerePrL else []) ++ @arg.prImpls
  | Var         lhs         .   prImpls         =   prOccLImpls @lhs.mbPrLoc @insHerePrL ++ @lhs.prImpls
%%]

