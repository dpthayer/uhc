%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Substituting holes
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(9 codegen) hs module {%{EH}TyCore.Subst} import(Data.Maybe,qualified Data.Set as Set,qualified Data.Map as Map,EH.Util.Pretty,EH.Util.Utils,{%{EH}Base.Opts},{%{EH}Base.Common},{%{EH}VarMp})
%%]

%%[(9 codegen) hs import({%{EH}TyCore.Base},{%{EH}TyCore.Pretty},{%{EH}TyCore.Coercion})
%%]

%%[(9 codegen) hs import(qualified {%{EH}Ty} as T)
%%]

%%[(9 codegen).WRAPPER ag import({TyCore/AbsSyn})
WRAPPER Expr
%%]

%%[(9 codegen)
PRAGMA novisit
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Code substitution
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(9 codegen) hs export(CSubst,emptyCSubst)
data CSubstInfo
	=  CSIExpr      {csiRepl    :: !Expr                                           }
    |  CSIImpls     {csiAppCoeL :: ![Coe]       , csiLamCoeL    :: ![Coe]           }
    |  CSIBinds     {csiBindL   :: !ValBindL                                          }
    deriving Show

type CSubst = Map.Map UID CSubstInfo

emptyCSubst :: CSubst
emptyCSubst = Map.empty
%%]

On Expr

%%[(9 codegen) hs export(cSubstAppExpr)
cSubstAppExpr :: Bool -> CSubst -> Expr -> Maybe Expr -> Expr
cSubstAppExpr doDeepSubst cs ce mbOnCe
  = cRepl_Syn_Expr t
  where t = wrap_Expr
              (sem_Expr ce)
              (Inh_Expr { cSubst_Inh_Expr = cs
                         , coeArg_Inh_Expr = maybe Expr_CoeArg id mbOnCe
                         , doDeepSubst_Inh_Expr = doDeepSubst
                         })
%%]

On ValBind

%%[(9 codegen) hs export(cSubstAppValBind)
cSubstAppValBind :: Bool -> CSubst -> ValBind -> ValBind
cSubstAppValBind doDeepSubst cs (ValBind_Val n m t e) = ValBind_Val n m t (cSubstAppExpr doDeepSubst cs e Nothing)
%%]

On CSubst, merges only, application is postponed

%%[(9 codegen) hs
cSubstAppSubst :: CSubst -> CSubst -> CSubst
cSubstAppSubst = Map.union
%%]
  
%%[(9 codegen) hs export(uidImplsLToCSubst,uidValBindLLToCSubst,uidExprLToCSubst,poiExprLToCSubst,cnstrImplsToCSubst,cAppCoeArg)
cAppCoeArg :: Expr -> Expr -> Expr
cAppCoeArg ce coeArg
  = cSubstAppExpr False emptyCSubst ce (Just coeArg)

uidExprLToCSubst :: AssocL UID Expr -> CSubst
uidExprLToCSubst = Map.fromList . assocLMapElt CSIExpr

uidValBindLLToCSubst :: AssocL UID ValBindL -> CSubst
uidValBindLLToCSubst = Map.fromList . assocLMapElt CSIBinds

poiExprLToCSubst :: AssocL PredOccId Expr -> CSubst
poiExprLToCSubst = uidExprLToCSubst . assocLMapKey poiId

uidImplsLToCSubst :: AssocL UID ([Coe],[Coe]) -> CSubst
uidImplsLToCSubst = Map.fromList . assocLMapElt (uncurry CSIImpls)

cnstrImplsToCSubst :: EHCOpts -> VarMp -> CSubst
cnstrImplsToCSubst opts c
  =  uidImplsLToCSubst
        [ (iv,(mkImplsAppCoe opts i,mkImplsLamCoe coeId i))
        | (iv,VMIImpls i) <- varmpToAssocL c, let (_,mbTl) = T.implsPredsMbTail i, isNothing mbTl
        ]
%%]

%%[(9 codegen) hs
instance PP CSubstInfo where
  pp (CSIExpr       ce   )  = pp ce
  pp (CSIImpls      l r  )  = pp (fst $ coeWeaveOnAsSubst uidStart l r Expr_CoeArg)
  pp (CSIBinds      b    )  = pp "CSIBinds" -- ppValBindL b
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Code substitution as class
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(9 codegen) hs export(CSubstitutable(..))
infixr `cSubstApp`

class CSubstitutable a where
  cSubstApp :: CSubst -> a -> a

instance CSubstitutable Expr where
  cSubstApp cs ce | Map.null cs
    =  ce
  cSubstApp cs ce
    = cSubstAppExpr False cs ce Nothing

instance CSubstitutable CSubst where
  cSubstApp cs s = cs `cSubstAppSubst` s
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Deepness/shallowness of subst
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(9 codegen)
ATTR AllCodeNT AGItf [ doDeepSubst: Bool | | ]
%%]

%%[(9 codegen)
SEM Expr
  | HoleLet ImplsApp ImplsLam
  				loc			.	doDeepSubstHere
  											=	False
  | Hole
  				loc			.	doDeepSubstHere
  											=	@lhs.doDeepSubst
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Replacement
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Expansion/substitution only 1 time if not doDeepSubst,
except for ImplsApp & ImplsLam which must be expanded fully (required for weaving these).
????? is this so?

%%[(9 codegen)
ATTR AllNT AGItf [ cSubst: CSubst  coeArg: Expr | | ]

SEM Expr
  | Hole        (loc.replv,loc.isRepl)      =   case Map.lookup @uid @lhs.cSubst of
                                                  Just (CSIExpr ce)  -> (ce,True)
                                                  _                  -> (@cRepl,False)
  | HoleLet     (loc.replv,loc.isRepl)      =   case Map.lookup @bindsUid @lhs.cSubst of
                                                  Just (CSIBinds b)  -> (@lhs.cSubst `cSubstApp` mkExprLetRec b @body.cRepl,True)
                                                  _                  -> (@cRepl,False)
  | CoeArg      (loc.replv,loc.isRepl)      =   (@lhs.coeArg,True)
  | ImplsApp ImplsLam
                (loc.coeAppL,loc.coeLamL,loc.isRepl)
                                            =   case Map.lookup @uid @lhs.cSubst of
                                                  Just (CSIImpls ca cl)  -> (ca,cl,True)
                                                  _                      -> ([],[],False)
  | ImplsApp    loc         .   replv       =   coeWeaveOn2 emptyCSubst @coeAppL [] @func.cRepl
  | ImplsLam    loc         .   replv       =   coeWeaveOn2 emptyCSubst [] @coeLamL @body.cRepl

SEM Expr
  | Hole HoleLet CoeArg ImplsApp ImplsLam
                inst        .   repl'       :   Expr
                inst        .   repl'       =   @replv

SEM Expr
  | HoleLet     loc         .   uid         =   @bindsUid

SEM Expr
  | Hole HoleLet ImplsApp ImplsLam
                repl'       .   cSubst      =   @lhs.cSubst
%%]

%%[(9 codegen)
ATTR AllNT AGItf [ | | cRepl: SELF ]

SEM Expr
  | CoeArg      lhs         .   cRepl       =   @replv -- if @isRepl then @repl'.cRepl else @cRepl
  | Hole HoleLet ImplsApp ImplsLam
                lhs         .   cRepl       =   if @lhs.doDeepSubst && @isRepl then @repl'.cRepl else @replv
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Coercion: from Coe -> Expr, with or without postponed substitution
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(9 codegen) hs export(coeEvalOnAsSubst)
coeEvalOnAsSubst :: UID -> Coe -> Expr -> (Expr,CSubst)
coeEvalOnAsSubst uniq coe ce
  = (c,s)
  where (_,c,s) = ev uniq coe ce
        ev uniq coe ce
          = case coe of
              c | coeIsId c     -> mk ce
              Coe  f            -> mk $ f ce
              CoeApp a m        -> mk $ mkExprApp1Meta ce a m
              CoeLam n m t      -> mk $ mkExprLam1Meta n m t ce
              CoeLamLet n t i   -> mk $ mkExprLam1 n t (mkExprLetHole i ce)
              CoeLetRec b       -> mk $ mkExprLet ValBindCateg_Rec b ce
              CoeCompose c1 c2  -> (u2, c1', s2 `cSubstAppSubst` s1)
                                where (u1,c2',s1) = ev uniq c2 ce
                                      (u2,c1',s2) = ev u1   c1 c2'
              CoeC e            -> (u', e `cAppCoeArg` Expr_Hole u, uidExprLToCSubst [(u,ce)])
                                where (u',u) = mkNewUID uniq
              CoeImplApp iv     -> mk $ Expr_ImplsApp ce iv
              CoeImplLam iv     -> mk $ Expr_ImplsLam iv ce
          where mk c = (uniq,c,emptyCSubst)
%%]

%%[(9 codegen) hs
coeEvalOn :: Coe -> Expr -> Expr
coeEvalOn coe ce
  = s `cSubstApp` ce'
  where (ce',s) = coeEvalOnAsSubst uidStart coe ce
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Coercion: canceling (wiping) & combining (weaving)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(9 codegen) hs
coeWeaveOnAsSubst :: UID -> [Coe] -> [Coe] -> Expr -> (Expr,CSubst)
coeWeaveOnAsSubst = coeWeaveWithSubstOnAsSubst emptyCSubst

coeWeaveWithSubstOnAsSubst :: CSubst -> UID -> [Coe] -> [Coe] -> Expr -> (Expr,CSubst)
coeWeaveWithSubstOnAsSubst cs uniq lCoeL rCoeL ce
  = snd $ foldr ev (foldr ev (uniq,(ce,emptyCSubst)) (reverse lCoeL)) rCoeL
  where ev c (uniq,(e,s)) = (u',(cs `cSubstApp` e',s' `cSubstAppSubst` s))
          where (u',u ) = mkNewUID uniq
                (e',s') = coeEvalOnAsSubst u c e
%%]

%%[(9 codegen && hmTyRuler) hs
coeWeaveOn :: CSubst -> [Coe] -> [Coe] -> Expr -> Expr
coeWeaveOn cs lCoeL rCoeL ce
  =  let  ev c e = cs `cSubstApp` (c `coeEvalOn` e)
     in   foldr ev (foldr ev ce (reverse lCoeL)) rCoeL
%%]

%%[(9 codegen) hs
coeWeaveOn2 :: CSubst -> [Coe] -> [Coe] -> Expr -> Expr
coeWeaveOn2 cs lCoeL rCoeL ce
  = cSubstAppExpr True s e Nothing
  where (e,s) = coeWeaveWithSubstOnAsSubst cs uidStart lCoeL rCoeL ce
%%]

%%[(9 codegen) hs
coeWipe :: [Coe] -> [Coe] -> ([Coe],[Coe])
coeWipe l r
  = (reverse l', reverse r')
  where w l r =  case lr of
                   (CoeImplApp li:ls,CoeImplLam ri:rs)
                                  | li == ri   -> w ls rs
                                  | otherwise  -> lr
                   _                           -> lr
              where lr = (l,r)
        (l',r') = w (reverse l) (reverse r)
%%]

%%[(9 codegen) hs export(coeWipeWeaveAsSubst2)
coeWipeWeaveAsSubst :: EHCOpts -> UID -> VarMp -> [Coe] -> [Coe] -> (Coe,CSubst)
coeWipeWeaveAsSubst opts uniq c lCoeL rCoeL
  = (CoeC e,s)
  where (lCoeL',rCoeL') = coeWipe (concatMap (coeImplsAppLVarMp opts c) lCoeL) (concatMap (coeImplsAppRVarMp c) rCoeL)
        (e,s) = coeWeaveOnAsSubst uniq lCoeL' rCoeL' Expr_CoeArg

coeWipeWeaveAsSubst2 :: EHCOpts -> UID -> VarMp -> CSubst -> [Coe] -> [Coe] -> (Coe,CSubst)
coeWipeWeaveAsSubst2 opts uniq c cs lCoeL rCoeL
  = (CoeC e,s)
  where (lCoeL',rCoeL') = coeWipe (concatMap (coeImplsAppLVarMp opts c) lCoeL) (concatMap (coeImplsAppRVarMp c) rCoeL)
        (e,s) = coeWeaveWithSubstOnAsSubst cs uniq lCoeL' rCoeL' Expr_CoeArg
%%]

%%[(9 codegen && hmTyRuler) hs export(coeWipeWeave)
coeWipeWeave :: EHCOpts -> VarMp -> CSubst -> [Coe] -> [Coe] -> Coe
coeWipeWeave opts c cs lCoeL rCoeL
  =  let  (lCoeL',rCoeL')
            = coeWipe (concatMap (coeImplsAppLVarMp opts c) lCoeL) (concatMap (coeImplsAppRVarMp c) rCoeL)
     in   CoeC (coeWeaveOn2 cs lCoeL' rCoeL' Expr_CoeArg)
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Coercion
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(9 codegen) hs export(mkPoiLLamCoe,mkPoisAppCoe,mkImplsAppCoe,mkImplsLamCoe,mkLamBodyCoe)
coeImplsAppLVarMp :: EHCOpts -> VarMp -> Coe -> [Coe]
coeImplsAppLVarMp opts c coe
  =  case coe of
       CoeImplApp i  -> maybe [coe] (mkImplsAppCoe opts) (varmpImplsLookupCyc i c)
       _             -> [coe]

coeImplsAppRVarMp :: VarMp -> Coe -> [Coe]
coeImplsAppRVarMp c coe
  =  case coe of
       CoeImplLam i  -> maybe [coe] (mkImplsLamCoe coeId) (varmpImplsLookupCyc i c)
       _             -> [coe]

mkPoisAppCoe :: EHCOpts -> [PredOccId] -> [Coe]
mkPoisAppCoe opts = map (\i -> mkAppCoe1With (mkExprPrHole opts i) (MetaVal_Dict Nothing))

mkImplsAppCoe :: EHCOpts -> T.Impls -> [Coe]
mkImplsAppCoe opts = mkPoisAppCoe opts . T.implsPrIds

mkPoiLLamCoe :: Coe -> [(PredOccId,Ty)] -> [Coe]
mkPoiLLamCoe onLast poiL
  =  case map mk poiL of
       l@(_:_)            -> h ++ [t `coeCompose` onLast]
                          where (h,t) = fromJust $ initlast l
       _ | coeIsId onLast -> []
         | otherwise      -> [onLast]
  where mk (poi,ty) = mkLamCoe1With (poiHNm poi) (MetaVal_Dict Nothing) ty

mkImplsLamCoe :: Coe -> T.Impls -> [Coe]
mkImplsLamCoe onLast is = mkPoiLLamCoe onLast (zip (T.implsPrIds is) (repeat (tyErr "mkImplsLamCoe")))

mkLamBodyCoe :: Coe -> [Coe] -> [Coe]
mkLamBodyCoe onLast l
  =  case l of
       (_:_)              -> h ++ [onLast `coeCompose` t]
                          where h = init l
                                t = last l
       _ | coeIsId onLast -> []
         | otherwise      -> [onLast]
%%]

%%[(9 codegen) hs
instance PP Coe where
  pp c = "<" >|< pp (fst $ coeEvalOnAsSubst uidStart c Expr_CoeArg) >|< ">"
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% LRCoe coercion for lamda
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(9 codegen) hs export(lrcoeWipeWeaveAsSubst,lrcoeForLamTyAppAsSubst)
lrcoeWipeWeaveAsSubst :: EHCOpts -> UID -> VarMp -> LRCoe -> (Coe,CSubst)
lrcoeWipeWeaveAsSubst opts uniq cnstr (LRCoe LRCoeId _ _) = (coeId,emptyCSubst)
lrcoeWipeWeaveAsSubst opts uniq cnstr lrcoe               = coeWipeWeaveAsSubst opts uniq cnstr (lrcoeLeftL lrcoe) (lrcoeRightL lrcoe)

lrcoeForLamTyAppAsSubst :: EHCOpts -> UID -> Ty -> LRCoe -> LRCoe -> (LRCoe,CSubst)
lrcoeForLamTyAppAsSubst opts uniq ty f a
  = (LRCoe k [l] [r] `lrcoeUnion` a, s)
  where (u',u1,u2,u3) = mkNewLevUID3 uniq
        n = uidHNm u1
        r = mkLamCoe1 n ty
        (k,l,s)
          = case f of
              lr@(LRCoe LRCoeOther _ _)
                -> (lrcoeKindOfCoe c, mkAppCoe [a], cSubstAppSubst s1 s2)
                where (c,s1) = lrcoeWipeWeaveAsSubst opts u2 emptyVarMp lr
                      (a,s2) = coeEvalOnAsSubst u3 c (Expr_Var n)
              LRCoe LRCoeId _ _
                -> (LRCoeId, l, emptyCSubst)
                where l = mkAppCoe [Expr_Var n]

%%]

%%[(9 codegen && hmTyRuler) hs export(lrcoeWipeWeave,lrcoeForLamTyApp)
lrcoeWipeWeave :: EHCOpts -> VarMp -> CSubst -> LRCoe -> Coe
lrcoeWipeWeave opts cnstr csubst (LRCoe LRCoeId _ _) = coeId
lrcoeWipeWeave opts cnstr csubst lrcoe               = coeWipeWeave opts cnstr csubst (lrcoeLeftL lrcoe) (lrcoeRightL lrcoe)

lrcoeForLamTyApp :: EHCOpts -> UID -> Ty -> CSubst -> LRCoe -> LRCoe -> LRCoe
lrcoeForLamTyApp opts uniq ty csubst f a
  = LRCoe k [l] [r] `lrcoeUnion` a
  where n = uidHNm uniq
        r = mkLamCoe1 n ty
        (k,l)
          = case f of
              lr@(LRCoe LRCoeOther _ _)
                -> (lrcoeKindOfCoe c, l)
                where l = mkAppCoe [c `coeEvalOn` Expr_Var n]
                      c = lrcoeWipeWeave opts emptyVarMp csubst lr
              LRCoe LRCoeId _ _
                -> (LRCoeId, l)
                where l = mkAppCoe [Expr_Var n]
%%]

