%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell importable interface to Grin ByteCode
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs module {%{EH}GrinByteCode} import({%{EH}Base.Common},{%{EH}GrinCode},qualified {%{EH}Config} as Cfg,{%{EH}GrinCode.Pretty})
%%]

%%[(8 codegen grin) hs import(EH.Util.Utils,EH.Util.Pretty as Pretty,Data.Bits,qualified EH.Util.FastSeq as Seq,qualified Data.Map as Map)
%%]

%%[(8 codegen grin) hs import({%{EH}Base.Builtin},{%{EH}Base.Builtin2},{%{EH}Base.Opts})
%%]

%%[(8 codegen grin) hs import({%{EH}Base.Binary} as Binary)
%%]

%%[(8 codegen grin) hs export(AGItf(..),Module(..),Instr(..), Instrs, Meta(..))
%%]

%%[(8 codegen grin) hs export(InsOp_LocE(..), InsOp_LocB(..), InsOp_LocODst(..), InsOp_LocOSrc(..), InsOp_TyOp(..), InsOp_DataOp(..), InsOp_ImmSz(..), InsOp_Deref(..), InsOp_DerefB(..), Imm(..))
%%]

%%[(8 codegen grin) ag import({GrinByteCode/AbsSyn})
%%]

%%[(20 codegen grin) hs import({%{EH}Core(HsName2OffsetMpMp)})
%%]

%%[(99 codegen grin) hs import({%{EH}Base.ForceEval})
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Configuration like constants
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Nr of words of basic values, both boxed and unboxed
20070904: Not yet used consistently, will it change anyway?

%%[(8 codegen grin) hs export(nrValWords)
nrValWords :: Int
nrValWords = 1
%%]

Nr of words occupied by header in node

%%[(8 codegen grin) hs export(nrNodeHdrWords)
nrNodeHdrWords :: Int
nrNodeHdrWords = 1
%%]

Nr of words required for call return info:
return address + saved bp

%%[(8 codegen grin) hs export(nrCallRetWords)
nrCallRetWords :: Int
nrCallRetWords = 2
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Additional datastructures, not incorporated as AST
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Instruction sequence

%%[(8 codegen grin) hs export(InsSeq)
type InsSeq = Seq.FastSeq Instr
%%]

Constants

%%[(8 codegen grin) hs export(Const(..))
data Const
  = Const_Str           { constInx    :: !Int    }
  | Const_CFunction     { constCFunNm :: !String }
  | Const_CallInfo      { constCINm   :: !String }		-- used only in ToC
%%[[20
  | Const_ImpNode
%%]]
  deriving(Eq,Ord,Show)

%%]

Link items, to be resolved at runtime initialization.

%%[(8 codegen grin) hs export(Link(..),LinkTbl(..))
data LinkTbl
  = LinkTbl_Const
  | LinkTbl_CodeEntry
  | LinkTbl_PatchCode_Deref0		-- patch with linkVal
  | LinkTbl_PatchCode_Deref1		-- patch with *linkVal
  | LinkTbl_PatchCode_Deref2		-- patch with **linkVal
  | LinkTbl_PatchOffsets			-- patch offsets to absolute address
  | LinkTbl_CallInfo				-- same as LinkTbl_Const, with implicit offset in determined by size of const table, used only in ToC
%%[[20
  | LinkTbl_ImpEntry
%%]]
  deriving (Show,Eq,Ord,Enum)

data Link
  = Link
      { linkTbl :: !LinkTbl
      , linkVal :: !Int
      }
  deriving Show
%%]

%%[(8 codegen grin) hs export(linkCode,linkConst,linkOffsets)
linkConst :: Int -> Link
linkConst x = Link LinkTbl_Const x

linkCode :: Int -> Link
linkCode x = Link LinkTbl_CodeEntry x

linkOffsets :: Int -> Link
linkOffsets x = Link LinkTbl_PatchOffsets x
%%]

%%[(20 codegen grin) hs export(linkImpEntry)
linkImpEntry :: Int -> Link
linkImpEntry m = Link LinkTbl_ImpEntry m
%%]

Reference to defining location in code

%%[(8 codegen grin) hs export(LocRef(..),LabelId,newLabelId,lrefIsLabel)
type LabelId = Int

newLabelId :: LabelId -> (LabelId,LabelId)
newLabelId l = (l+1,l)

lrefIsLabel :: LocRef -> Bool
lrefIsLabel (LocRef_Label _) = True
lrefIsLabel _                = False

data LocRef
  = LocRef_CodeEntry    !Int                         -- resolved at initialization runtime, translates to
  | LocRef_Label        { lrefId :: !LabelId }       -- resolved before runtime, translates to offsets
  deriving (Eq,Ord,Show)
%%]

%%[(8 codegen grin) hs
instance PP LocRef where
  pp (LocRef_CodeEntry c) = ".cod" >#< c
  pp (LocRef_Label     l) = ".lbl" >#< l
%%]

%%[(8 codegen grin) hs export(StackDepth)
type StackDepth = Int
%%]

Call Info

%%[(8 codegen grin) hs
data CallInfoExtra
  = CallInfoExtra_CCall [BasicSize]		-- type: (res : args)
  | CallInfoExtra_None
  deriving(Eq,Ord,Show)
%%]

%%[(8 codegen grin) hs
instance PP CallInfoExtra where
  pp (CallInfoExtra_CCall t) = pp $ show $ map basicGrinSizeCharEncoding t
  pp CallInfoExtra_None      = pp "NULL"
%%]

%%[(8 codegen grin) hs export(CallInfo(..),CallInfoKind(..))
type MbStrInx = Maybe Int

data CallInfo
  = CallInfo
      { ciKind			:: !CallInfoKind
      , ciMbNmStrInx	:: !MbStrInx					-- index of string, if any
      , ciExtra			:: !CallInfoExtra
      }
  deriving(Eq,Ord,Show)

data CallInfoKind
  = CallInfoKind_Call             -- normal call
  | CallInfoKind_Tail             -- tail call
  | CallInfoKind_Eval             -- eval call
  | CallInfoKind_EvalWrap         -- eval call internal wrapper
  | CallInfoKind_TailEv           -- tail eval call
  | CallInfoKind_Apply            -- apply call
  | CallInfoKind_CCall            -- C call
  | CallInfoKind_EvCont           -- eval update continuation
  | CallInfoKind_ApCont           -- apply continuation
  | CallInfoKind_PApCont          -- partial apply continuation
  | CallInfoKind_Hdlr             -- exception handler installment
  deriving (Enum,Eq,Ord,Show)
%%]

%%[(8 codegen grin) hs export(mkCICall)
mkCIExtra :: CallInfoExtra -> CallInfoKind -> MbStrInx -> CallInfo
mkCIExtra e k i = CallInfo k i e

mkCI :: CallInfoKind -> MbStrInx -> CallInfo
mkCI k i = mkCIExtra CallInfoExtra_None k i

mkCICall    = mkCI                              CallInfoKind_Call
mkCICCall e = mkCIExtra (CallInfoExtra_CCall e) CallInfoKind_CCall
mkCIEval    = mkCI                              CallInfoKind_Eval
mkCIApply   = mkCI                              CallInfoKind_Apply
%%]

Entry point info

%%[(8 codegen grin) hs export(EntryInfo(..))
data EntryInfo
  = EntryInfo
      { eiNm			:: !HsName
      , eiEntryNr		:: !Int
      , eiIsCAF			:: !Bool
      , eiNmStrConst	:: !Const
      }
%%]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Optimisation info
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs export(OptimCtxt(..),defaultOptimCtxt)
data OptimCtxt
  = OptimCtxt
      { ocxOmitTOSLd        :: !Bool
      }

defaultOptimCtxt :: OptimCtxt
defaultOptimCtxt = OptimCtxt False
%%]

%%[(8 codegen grin) hs export(OptimEffect(..),defaultOptimEffect)
data OptimEffect
  = OptimEffect
{- -- moved to separate transformation to eliminate redundant eval's
      { oefIsEvaluated         :: Bool
      }
-}

defaultOptimEffect :: OptimEffect
defaultOptimEffect = OptimEffect {- False -}
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Environmental info for name resolution
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs
type ValAccessAnnot = Either BasicAnnot BasicSize			-- either we have to deal with the annotation or it has already been done partly and we need to propagate the size

vaAnnotBasicSize :: ValAccessAnnot -> BasicSize
vaAnnotBasicSize = either grinBasicAnnotSize id
%%]

%%[(8 codegen grin) hs export(ValAccess(..),ValAccessGam)
data ValAccess
  = Val_Local           { vaStackDepth :: StackDepth, vaAnnot :: ValAccessAnnot }		-- value on the stack
  | Val_NodeTagLocal    { vaStackDepth :: StackDepth }									-- tag of node on the stack
  | Val_NodeFldLocal    { vaStackDepth :: StackDepth, vaAnnot :: ValAccessAnnot }		-- field 0 of node on the stack
  | Val_Int             Integer
  | Val_GlobEntry       { vaEntryInx :: Int }
%%[[20
  | Val_ImpEntry        { vaModOff, vaEntryOff :: Int }
%%]]
  deriving Show

instance PP ValAccess where
  pp = pp . show

type ValAccessGam = Map.Map HsName ValAccess
%%]

%%[(8 codegen grin) hs
vaHasAnnot :: ValAccess -> Bool
vaHasAnnot (Val_Local        _ _) = True
vaHasAnnot (Val_NodeFldLocal _ _) = True
vaHasAnnot _                      = False
%%]

%%[(20 codegen grin) hs export(ImpNmMp)
type ImpNmMp = Map.Map HsName Int
%%]

%%[(8 codegen grin) hs export(NmEnv(..))
data NmEnv
  = NmEnv
      { neVAGam     :: ValAccessGam
%%[[20
      , neImpNmMp   :: HsName2OffsetMpMp
%%]]
      }
%%]

%%[(8 codegen grin).nmEnvLookup hs export(nmEnvLookup)
nmEnvLookup :: HsName -> NmEnv -> Maybe ValAccess
nmEnvLookup nm env = Map.lookup nm $ neVAGam env
%%]

%%[(20 codegen grin) -8.nmEnvLookup hs export(nmEnvLookup)
nmEnvLookup :: HsName -> NmEnv -> Maybe ValAccess
nmEnvLookup nm env
  = case Map.lookup nm $ neVAGam env of
      Nothing
        -> do { q <- hsnQualifier nm
              ; (mo,entryMp) <- Map.lookup q $ neImpNmMp env
              ; eo <- Map.lookup nm entryMp
              ; return (Val_ImpEntry mo eo)
              }
      v -> v
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Load info
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs export(LoadSrc(..))
data LoadSrc
  = LoadSrc_TOS         
  | LoadSrc_Imm         { ldsrcImm      :: !Integer                            }
  | LoadSrc_Imm_Int     { ldsrcImm      :: !Integer                            }
  | LoadSrc_TOS_Rel     { ldsrcOff      :: !StackDepth   , ldsrcNrWords :: Int }
  | LoadSrc_TOS_Tag
  | LoadSrc_Reg_Rel     { ldsrcOff      :: !StackDepth   , ldsrcNrWords :: Int }
  deriving (Show)

ldsrc2ins' :: (Instr -> Instr) -> LoadSrc -> (InsSeq,StackDepth)
ldsrc2ins' instrann s
  = case s of
      LoadSrc_TOS          -> (Seq.empty                          ,0         )
      LoadSrc_TOS_Rel  o n -> (Seq.fromList  $ ann      $ ldlm n o,n         )
      LoadSrc_TOS_Tag      -> (Seq.singleton $ instrann $ ldnt    ,nrValWords)
      LoadSrc_Reg_Rel  o n -> (Seq.fromList  $ ann      $ ldrm n o,n         )
      LoadSrc_Imm      c   -> (Seq.singleton $ instrann $ ldc  c  ,nrValWords)
      LoadSrc_Imm_Int  c   -> (Seq.singleton $ instrann $ ldi  c  ,nrValWords)
  where ldlm n o = replicate n (ldl o)
        ldrm n o = [ l1tr o' | o' <- reverse [o..o+n-1] ]	-- hardcoded 'stack grows down' assumption
        ann (h:t) = instrann h : t

ldsrc2ins :: LoadSrc -> (InsSeq,StackDepth)
ldsrc2ins = ldsrc2ins' id
%%]

%%[(8 codegen grin) hs
instance PP LoadSrc where
  pp = pp . show
%%]

%%[(8 codegen grin) hs export(Load(..))
data Load
  = Load
      { ldPreIns        :: !InsSeq
      , ldPreStackInc   :: !StackDepth
      , ldPreLoc        :: !LoadSrc
      , ldPostIns       :: !InsSeq
      }

loadWithPrePostFrom :: [Instr] -> StackDepth -> LoadSrc -> [Instr] -> Load
loadWithPrePostFrom pre presz s post = Load (Seq.fromList pre) presz s (Seq.fromList post)

loadWithPreFrom :: [Instr] -> StackDepth -> LoadSrc -> Load
loadWithPreFrom pre presz s = loadWithPrePostFrom pre presz s []

loadWithPre0From :: [Instr] -> LoadSrc -> Load
loadWithPre0From pre s = loadWithPreFrom pre 0 s

loadWithPost0From :: LoadSrc -> [Instr] -> Load
loadWithPost0From s post = loadWithPrePostFrom [] 0 s post

loadFrom :: LoadSrc -> Load
loadFrom s = loadWithPreFrom [] 0 s
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Named value access
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs export(nmLd')
nmLd' :: OptimCtxt -> NmEnv -> Int -> StackDepth -> HsName -> (Maybe ValAccess,Load,BasicSize)
nmLd' optim env modNmConstInx stkDepth nm
  = case nmEnvLookup nm env of
      mva@(Just va)
        -> case va of
             Val_Local o annot
               -> (mva,loadWithPrePostFrom [meta' AnnIdUse (nm >#< either pp pp annot >#< src)] 0 src post,vaAnnotBasicSize annot)
               where (src,post)
                         = case annot of
                             Left (BasicAnnot_FromTaggedPtr sgn _) -> (srcDflt Cfg.sizeofGrWord ,[untag2 sgn])
                             Left (BasicAnnot_ToTaggedPtr   sgn _) -> (srcDflt Cfg.sizeofGrWord ,[])
                             Left (BasicAnnot_Size bsz _         ) -> (srcDflt (basicSizeInBytes bsz),[])
                             Left (BasicAnnot_Dflt               ) -> (srcDflt Cfg.sizeofGrWord ,[])
                             Right _                               -> (srcDflt Cfg.sizeofGrWord ,[])
                         where srcDflt n = offSrc (stkDepth - o) (nrByte2Word n)
             Val_NodeTagLocal o
               -> (mva,loadFrom (offSrc (stkDepth - o) nrValWords),dfltBasicSize)
             Val_NodeFldLocal o annot
               -> (mva,l,vaAnnotBasicSize annot)
               where l   = case annot of
                             Left (BasicAnnot_FromTaggedPtr sgn _) -> loadWithPost0From (offSrc (stkDepth - o) nrValWords) [untag2 sgn]
                             Left (BasicAnnot_ToTaggedPtr   sgn _) -> loadWithPost0From (offSrc (stkDepth - o) nrValWords) [tag2   sgn]
                             Left (BasicAnnot_Size bsz _         ) -> loadWithPre0From [ldlr (stkDepth - o)] (LoadSrc_Reg_Rel nrNodeHdrWords $ nrByte2Word $ basicSizeInBytes bsz)
                             _                                     -> panic "GrinByteCode.nmLd'.Val_NodeFldLocal"
             Val_Int i
               -> (mva,loadFrom (LoadSrc_Imm_Int i),dfltBasicSize)
             Val_GlobEntry o
               -> (mva,loadWithPreFrom [instrann' AnnIdUse nm $ ldg InsOp_LocB_TOS (linkCode o)] nrValWords LoadSrc_TOS,dfltBasicSize)
%%[[20
             Val_ImpEntry mo eo
               -> (mva,loadWithPre0From [instrann' AnnIdUse nm $ ldg InsOp_LocB_Reg (linkImpEntry mo)] (LoadSrc_Reg_Rel (eo + nrNodeHdrWords) nrValWords),dfltBasicSize)
%%]]
      _ -> (Nothing,loadWithPreFrom [instrann' AnnIdUse ("dummy ld for" >#< nm) $ ldl stkDepth] nrValWords LoadSrc_TOS,dfltBasicSize)
  where offSrc off sz = if off == 0 then LoadSrc_TOS else LoadSrc_TOS_Rel off sz
        dfltBasicSize = grinBasicAnnotSize BasicAnnot_Dflt
%%]

%%[(8 codegen grin) hs
vaAndLd2Ins :: OptimCtxt -> HsName -> (Maybe ValAccess,Load,x) -> (InsSeq,StackDepth)
vaAndLd2Ins optim nm vald
  = case vald of
      (Just (Val_Local _ (Left annot)),Load pins pdep LoadSrc_TOS postins,_)
        | not (ocxOmitTOSLd optim)
          -> (pins Seq.:++: ins Seq.:++: postins,pdep + dep)
          where (ins,dep) = ldsrc2ins' (instrann' AnnIdUse (nm >#< annot)) (LoadSrc_TOS_Rel 0 nrValWords)
      (_,Load pins pdep ls postins,_)
          -> (pins Seq.:++: ins Seq.:++: postins,pdep + dep)
          where (ins,dep) = ldsrc2ins' (instrann $ show ls) ls
%%]

%%[(8 codegen grin) hs export(nmLd)
nmLd :: OptimCtxt -> NmEnv -> Int -> StackDepth -> HsName -> (InsSeq,StackDepth)
nmLd optim env modNmConstInx stkDepth nm
  = vaAndLd2Ins optim nm $ nmLd' optim env modNmConstInx stkDepth nm
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% GrVal Value introduction
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs export(GrValIntro(..))
data GrValIntro
  = GrValIntro_Nm    !HsName
  | GrValIntro_Int   !Integer
  | GrValIntro_Str   !String !Link
  | GrValIntro_Grp   !GrTag ![GrValIntro]
  | GrValIntro_Basic !GrTag !HsName
  | GrValIntro_Enum  !HsName
  | GrValIntro_None
%%]

%%[(8 codegen grin) hs export(GrValIntroAlt(..))
data GrValIntroAlt
  = GrValIntroAlt_OnTOS     InsSeq StackDepth OptimEffect [BasicSize]
  | GrValIntroAlt_Delay     InsSeq StackDepth OptimEffect (Maybe ValAccess) Load BasicSize
%%]

%%[(8 codegen grin) hs export(gviLd,gviLd',gviLdFold)
gviLdFold' :: GrValIntroAlt -> OptimCtxt -> NmEnv -> Int -> StackDepth -> [GrValIntro] -> GrValIntroAlt
gviLdFold' dflt optim env modNmConstInx stkDepth introL
  = foldl ld dflt $ reverse $ introL
  where ld (GrValIntroAlt_OnTOS ins dep _ basicsz) intro
          = GrValIntroAlt_OnTOS (ins Seq.:++: ins') (dep+dep') defaultOptimEffect (basicsz' ++ basicsz)
          where (GrValIntroAlt_OnTOS ins' dep' _ basicsz') = gviLd optim env modNmConstInx (stkDepth+dep) intro

gviLdFold :: OptimCtxt -> NmEnv -> Int -> StackDepth -> [GrValIntro] -> GrValIntroAlt
gviLdFold = gviLdFold' (GrValIntroAlt_OnTOS Seq.empty 0 defaultOptimEffect [])

gviLd' :: OptimCtxt -> NmEnv -> Int -> StackDepth -> GrValIntro -> GrValIntroAlt
gviLd' optim env modNmConstInx stkDepth intro
  = ld optim (GrValIntroAlt_OnTOS Seq.empty 0 defaultOptimEffect []) intro
  where ld optim dflt@(GrValIntroAlt_OnTOS ins dfltInc _ _) intro
          = case intro of
              GrValIntro_Nm nm
                -> GrValIntroAlt_Delay ins dfltInc defaultOptimEffect mbva l basicsz
                where (mbva,l,basicsz) = nmLd' optim env modNmConstInx stkDepth nm
              GrValIntro_Str s l
                -> GrValIntroAlt_OnTOS (ins Seq.::+: (instrann (show l) $ ldg InsOp_LocB_TOS l)) (dfltInc+nrValWords) defaultOptimEffect [dfltBasicSize]
              GrValIntro_Int i
                -> GrValIntroAlt_Delay ins dfltInc defaultOptimEffect Nothing (loadFrom $ LoadSrc_Imm_Int i) dfltBasicSize
              GrValIntro_Enum nm
                -> case mbva of
                     Just va | vaHasAnnot va
                       -> case vaAnnot va of
                            Left BasicAnnot_Dflt                -> basicAnnotDflt nm
                            Left (BasicAnnot_ToTaggedPtr sgn _) -> basicAnnotTaggedPtr sgn nm ml dfltBasicSize
                            _                                   -> panic "GrinByteCode.gviLd'.GrValIntro_Enum.Just"
                     _ -> panic "GrinByteCode.gviLd'.GrValIntro_Enum.Nothing"
                where ml@(mbva,l,basicsz) = nmLd' optim env modNmConstInx stkDepth nm
              GrValIntro_Basic gtag nm
                -> case mbva of
                     Just va | vaHasAnnot va
                       -> case vaAnnot va of
                            Left BasicAnnot_Dflt                    -> basicAnnotDflt nm
                            Left (a@(BasicAnnot_ToTaggedPtr sgn _)) -> basicAnnotTaggedPtr sgn nm ml (grinBasicAnnotSize a)
                            Left (BasicAnnot_Size bsz _)
                              -> GrValIntroAlt_OnTOS (ins Seq.:++: Seq.fromList [meta' AnnTag (ppGrTag gtag)] Seq.:++: tins Seq.:++: sins) sinc defaultOptimEffect [basicsz]
                              where (ins,inc) = vaAndLd2Ins optim nm ml
                                    (tins,tinc,allocInc,isEvaluated) = tag env modNmConstInx (dep'+inc) gtag (nrByte2Word bsz')
                                    (sins,sinc) = ndStore (allocInc + (nrByte2Word bsz') + tinc)
                                    bsz' = basicSizeInBytes bsz
                            Right bSz                               -> basicSize nm ml bSz
                            _ -> panic "GrinByteCode.gviLd'.GrValIntro_Basic.Just"
                     _ -> panic "GrinByteCode.gviLd'.GrValIntro_Basic.Nothing"
                where ml@(mbva,l,basicsz) = nmLd' optim env modNmConstInx stkDepth nm
{-
              GrValIntro_Grp gtag [i] | tagIsUnboxed gtag
                -> ld optim dflt i
-}
              GrValIntro_Grp gtag is
                -> GrValIntroAlt_OnTOS (ins Seq.:++: Seq.fromList [meta' AnnTag (ppGrTag gtag)] Seq.:++: tins Seq.:++: sins) sinc defaultOptimEffect [dfltBasicSize]
                where i@(GrValIntroAlt_OnTOS ins inc _ _) = gviLdFold' dflt (optim {ocxOmitTOSLd = False}) env modNmConstInx dep' is
                      (tins,tinc,allocInc,isEvaluated) = tag env modNmConstInx (dep'+inc) gtag inc
                      (sins,sinc) = ndStore (allocInc + inc + tinc)
              _ -> dflt
          where dep' = stkDepth + dfltInc
                basicAnnotDflt nm
                  = GrValIntroAlt_Delay ins dfltInc defaultOptimEffect mbva l basicsz
                  where (mbva,l,basicsz) = nmLd' optim env modNmConstInx stkDepth nm
                basicAnnotTaggedPtr sgn nm ml bSz
                  = GrValIntroAlt_OnTOS (ins Seq.::+: tag2 sgn) inc defaultOptimEffect [bSz]
                  where (ins,inc) = vaAndLd2Ins optim nm ml
                basicSize nm ml bSz
                  = GrValIntroAlt_OnTOS (ins) inc defaultOptimEffect [bSz]
                  where (ins,inc) = vaAndLd2Ins optim nm ml
                dfltBasicSize = grinBasicAnnotSize BasicAnnot_Dflt

gviLd :: OptimCtxt -> NmEnv -> Int -> StackDepth -> GrValIntro -> GrValIntroAlt
gviLd optim env modNmConstInx stkDepth intro
  = case gviLd' optim env modNmConstInx stkDepth intro of
      GrValIntroAlt_Delay ins inc optimEffect mbva l basicsz
        -> GrValIntroAlt_OnTOS (ins Seq.:++: sins) (inc + sinc) optimEffect [basicsz]
        where (sins,sinc) = vaAndLd2Ins optim hsnUnknown (mbva,l,basicsz)
      a -> a
%%]

%%[(8 codegen grin) hs export(gvCall)
gvCall :: MbStrInx -> NmEnv -> Int -> InsSeq -> Int -> StackDepth -> HsName -> (InsSeq,StackDepth)
gvCall i nmEnv modNmConstInx ins inc stkDepth nm
  = (ins Seq.:++: fins Seq.:++: Seq.fromList [call i InsOp_LocB_TOS], nrValWords)
  where (fins,_) = nmLd defaultOptimCtxt nmEnv modNmConstInx (stkDepth + inc) nm
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Constants
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs export(nrWord2Byte)
nrWord2Byte :: Integral c => c -> c
nrWord2Byte sz
  = sz * wSz
  where wSz = fromInteger Cfg.sizeofGrWordAsInteger
%%]

%%[(8 codegen grin) hs export(nrByte2Word)
nrByte2Word :: Integral c => c -> c
nrByte2Word sz
  = (sz-1) `div` wSz + 1
  where wSz = fromInteger Cfg.sizeofGrWordAsInteger
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Unboxed values
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs export(tagIsUnboxed)
tagIsUnboxed :: EHCOpts -> GrTag -> Bool
tagIsUnboxed opts
  = \gt -> case gt of
              GrTag_Con _ _ nm | check nm
                -> True
              GrTag_Unboxed
                -> True
              _ -> False
  where check = maybe False biGbcMayLiveUnboxed . builtinGrinMayLiveUnboxed opts
%%]

%%[(8 codegen grin) hs export(tagAllowsUnboxedLife)
tagAllowsUnboxedLife :: EHCOpts -> GrTag -> Unbox
tagAllowsUnboxedLife opts gt
  = if tagIsUnboxed opts gt
    then Unbox_FirstField
    else case gt of
           GrTag_Con ann t nm | gtannMaxArity ann == 0
             -> Unbox_Tag t
           _ -> Unbox_None
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Constructing: immediate operands
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs
imm :: Integral c => c -> (InsOp_ImmSz,Imm)
imm c
  = (s,Imm_Int i)
  where (s,i)
          = case toInteger c of
              i | i <  0 -> (s, i .&. m)
                         where (s,m) = case i of
                                         i | i >= pow2_7neg  -> (InsOp_ImmSz_Bits08,mask2_8 )
                                           | i >= pow2_15neg -> (InsOp_ImmSz_Bits16,mask2_16)
                                           | i >= pow2_31neg -> (InsOp_ImmSz_Bits32,mask2_32)
                                           | otherwise       -> (InsOp_ImmSz_Bits64,mask2_64)
              i | i >= 0 -> (s, i .&. mask2_64)
                         where s = case i of
                                     i | i < pow2_7sub1  -> InsOp_ImmSz_Bits08
                                       | i < pow2_15sub1 -> InsOp_ImmSz_Bits16
                                       | i < pow2_31sub1 -> InsOp_ImmSz_Bits32
                                       | otherwise       -> InsOp_ImmSz_Bits64
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Constructing: loading
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs export(ldc,ldl,ldg,ldi,l1tr,l2ts,ldnt)
ld :: Integral c => InsOp_Deref -> InsOp_LocB -> InsOp_LocE -> c -> Instr
ld ind locB locE c
  = Instr_Ld ind locB locE s i
  where (s,i) = imm c

-- load constant on TOS
ldc :: Integral c => c -> Instr
ldc = ld InsOp_Deref_Zero InsOp_LocB_TOS InsOp_LocE_Imm

-- load integer constant on TOS
ldi :: Integral c => c -> Instr
ldi = ld InsOp_Deref_Int InsOp_LocB_TOS InsOp_LocE_Imm

-- load local relative to SP on TOS
ldl :: Integral c => c -> Instr
ldl c = ld InsOp_Deref_One InsOp_LocB_TOS InsOp_LocE_SP (nrWord2Byte c)

-- load local relative to SP in reg
ldlr :: Integral c => c -> Instr
ldlr c = ld InsOp_Deref_One InsOp_LocB_Reg InsOp_LocE_SP (nrWord2Byte c)

-- load relative to reg on TOS
l1tr :: Integral c => c -> Instr
l1tr c = ld InsOp_Deref_One InsOp_LocB_TOS InsOp_LocE_Reg (nrWord2Byte c)

l2ts :: Integral c => c -> Instr
l2ts c = ld InsOp_Deref_Two InsOp_LocB_TOS InsOp_LocE_SP (nrWord2Byte c)

ldg :: InsOp_LocB -> Link -> Instr
ldg locB l = Instr_LdGlobal locB l

ldnt :: Instr
ldnt = Instr_LdNodeTag
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Constructing: link
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs export(link)
link :: Link -> Instr
link = Instr_Link
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Constructing: storing
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

-- not implemented yet

%%[(8 codegen grin) hs export()
st :: Integral c => InsOp_DerefB -> InsOp_LocE -> InsOp_LocB -> c -> Instr
st ind locE locB c
  = Instr_St ind locE locB s i
  where (s,i) = imm c
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Constructing: label
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs export(labelref,label)
labelref :: LocRef -> Instr
labelref l = Instr_LabelRef l

label :: LocRef -> Instr
label l = Instr_Label l
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Constructing: allocation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs export(allocstore,fetch,fetchupdate,ndStore)
allocstore :: InsOp_LocB -> Instr
allocstore locB = Instr_AllocStore locB

fetch :: InsOp_LocB -> Instr
fetch locB = Instr_Fetch locB

fetchupdate :: Instr
fetchupdate = Instr_FetchUpdate

ndStore :: Int -> (InsSeq,StackDepth)
ndStore sz = (Seq.fromList [ldc (nrWord2Byte sz),meta' AnnAllocStore sz,allocstore InsOp_LocB_TOS], nrValWords)
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Constructing: eval
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs export(eval,apply,taileval)
eval :: MbStrInx -> InsOp_LocB -> Instr
eval i locB = Instr_Eval locB (mkCIEval i)

taileval :: Integral c => InsOp_LocB -> c -> Instr
taileval locB nArgSurr
  = Instr_TailEval locB s1 i1
  where (s1,i1) = imm $ nrWord2Byte nArgSurr
        -- (s2,i2) = imm $ nrWord2Byte retOffSurr

apply :: MbStrInx -> InsOp_LocB -> Instr
apply i locB = Instr_Apply locB (mkCIApply i)
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Constructing: control, call, etc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs export(call,retcall,tailcall,casecall,retcase,callc)
call :: MbStrInx -> InsOp_LocB -> Instr
call i locB = Instr_Call locB (mkCICall i)

rettailcall :: Integral c => (InsOp_ImmSz -> InsOp_ImmSz -> Imm -> Imm -> Instr) -> c -> c -> Instr
rettailcall mk nArgMine nArgSurr -- retOffSurr
  = mk s1 s2 i1 i2
  where (s1,i1) = imm $ nrWord2Byte nArgMine
        (s2,i2) = imm $ nrWord2Byte nArgSurr
        -- (s3,i3) = imm $ nrWord2Byte retOffSurr

retcall :: Integral c => c -> c -> Instr
retcall = rettailcall Instr_RetCall

tailcall :: Integral c => InsOp_LocB -> c -> c -> Instr
tailcall locB = rettailcall (Instr_TailCall locB)

casecall :: Instr
casecall
  = Instr_CaseCall

callc :: Integral c => MbStrInx -> [BasicSize] -> c -> Instr
callc i ty nArg
  = Instr_CallC s1 i1 ce (mkCICCall ty i)
  where (s1,i1) = imm nArg
        (_ ,ce) = imm $ basicGrinSizeLEncoding ty

retcase :: Integral c => c -> c -> Instr
retcase nRes retOffSurr
  = Instr_RetCase s1 s2 i1 i2
  where (s1,i1) = imm $ nrWord2Byte nRes
        (s2,i2) = imm $ nrWord2Byte retOffSurr
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Constructing: operators
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs export(op)
op :: Integral c => InsOp_TyOp -> InsOp_DataOp -> InsOp_LocODst -> InsOp_Deref -> InsOp_LocOSrc -> c -> Instr
op opTy opndTy locDst ind locSrc c
  = Instr_Op opTy opndTy locDst ind locSrc s1 i1
  where (s1,i1) = imm c
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Constructing: conversion
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs
tagi2w :: Instr
tagi2w = Instr_TagInt2Word

untagw2i :: Instr
untagw2i = Instr_UntagWord2Int

tagw2w :: Instr
tagw2w = Instr_TagWord2Word

untagw2w :: Instr
untagw2w = Instr_UntagWord2Word
%%]

%%[(8 codegen grin) hs export(untag2)
tag2 :: Bool -> Instr
tag2 sgn = if sgn then tagi2w else tagw2w

untag2 :: Bool -> Instr
untag2 sgn = if sgn then untagw2i else untagw2w
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Constructing: comment
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs export(AnnKind(..))
data AnnKind
  = AnnComment
  | AnnFunStart
  | AnnStackDepth
  | AnnIdUse
  | AnnTag
  | AnnAllocStore
  | AnnLabel
  | AnnLabelRef
  deriving (Eq,Show)

instance PP AnnKind where
  pp AnnComment      = Pretty.empty
  pp AnnFunStart     = pp "funstart"
  pp AnnStackDepth   = pp "stackoff"
  pp AnnIdUse        = pp "iduse"
  pp AnnTag          = pp "tag"
  pp AnnAllocStore   = pp "allocstore"
  pp AnnLabel        = pp "lbldef"
  pp AnnLabelRef     = pp "lblref"
%%]

%%[(8 codegen grin) hs export(meta',meta)
meta' :: PP a => AnnKind -> a -> Instr
meta' k a = Instr_Meta $ Meta_CmtHeader k $ pp a

meta :: PP a => a -> Instr
meta = meta' AnnComment
%%]

%%[(8 codegen grin) hs
instrann' :: PP a => AnnKind -> a -> Instr -> Instr
instrann' k a = Instr_Ann k $ showPP a

instrann :: PP a => a -> Instr -> Instr
instrann = instrann' AnnComment
%%]

%%[(8 codegen grin) hs
%%]
metaprop' :: PP a => AnnKind -> String -> a -> Instr
metaprop' k prop a = meta' k (prop >|< "=" >|< a)

metaprop :: PP a => String -> a -> Instr
metaprop = metaprop' AnnComment

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Constructing: tag
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Offsets should coincide with def of GB_NodeHeader, src/rts/grinbc/grinbc

%%[(8 codegen grin) hs
[tgShSize,tgShCateg,tagShGC,tagShTag,tgShNdEv]
  = if Cfg.use32Bits then [16,14,12,2,0::Int] else [32,30,28,2,0]

tgNeedEval_No, tgNeedEval_Yes, tgNeedEval_BlH :: Integer
tgNeedEval_No  = 0
tgNeedEval_Yes = 1
tgNeedEval_BlH = 2
%%]
[tgShSize,tgShNdEv,tgShCateg,tagShGC,tagShTag]
  = if Cfg.use32Bits then [16,14,12,10,0::Int] else [32,30,28,26,0]

load tag, yield stack increment and additional size to alloc

%%[(8 codegen grin) hs export(tag)
tag :: NmEnv -> Int -> StackDepth -> GrTag -> Int -> (InsSeq,StackDepth,StackDepth,Bool)
tag env modNmConstInx stkDepth gt sz
  = case gt of
      GrTag_Unboxed -> (Seq.empty,0,0,False)
      GrTag_Any     -> (Seq.empty,0,0,False) 
      _
        -> (tins Seq.:++: Seq.fromList [ldc tword],tinc+1,allocInc,isEvaluated)
        where (needEval,categ',tg',tins,tinc,allocInc)
                = case gt of
                    GrTag_Con _ tg nm    -> (tgNeedEval_No ,0,tg,Seq.empty      ,0  ,0)
                    GrTag_Hole           -> (tgNeedEval_BlH,0, 0,Seq.fromList [ldc 0],1  ,0)
                    GrTag_Rec            -> (tgNeedEval_No ,0, 0,Seq.empty      ,0  ,0)
                    GrTag_App      nm    -> (tgNeedEval_Yes,1, 0,Seq.empty      ,0  ,0)
                    GrTag_Fun      nm    -> (tgNeedEval_Yes,0, 0,ins            ,inc,0)
                                         where (ins,inc) = nmLd defaultOptimCtxt env modNmConstInx stkDepth nm
                    GrTag_PApp m   nm    -> (tgNeedEval_No ,1,m ,ins            ,inc,0)
                                         where (ins,inc) = nmLd defaultOptimCtxt env modNmConstInx stkDepth nm
              tword = (toInteger (sz+tinc+allocInc+1) `shiftL` tgShSize) .|. needEval `shiftL` tgShNdEv .|. categ' `shiftL` tgShCateg .|. toInteger tg' `shiftL` tagShTag
              isEvaluated = needEval == tgNeedEval_No
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Constructing: misc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs export(halt)
halt :: Instr
halt = Instr_Halt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% ForceEval instances
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(99 codegen grin) hs
instance ForceEval Const
instance ForceEval Link
instance ForceEval LocRef
instance ForceEval CallInfo
instance ForceEval EntryInfo
%%]

