%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell importable interface to Grin ByteCode
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs module {%{EH}GrinByteCode} import({%{EH}Base.Common},{%{EH}GrinCode},qualified {%{EH}Config} as Cfg,{%{EH}GrinCode.Pretty})
%%]

%%[(8 codegen grin) hs import(EH.Util.Utils,EH.Util.Pretty as Pretty,Data.Bits,Data.Maybe,qualified EH.Util.FastSeq as Seq,qualified Data.Map as Map)
%%]

%%[(8 codegen grin) hs import({%{EH}Base.Builtin},{%{EH}Base.Builtin2},{%{EH}Base.Opts})
%%]

%%[(8 codegen grin) hs import({%{EH}Base.Binary} as Binary)
%%]

%%[(8 codegen grin) hs export(AGItf(..),Module(..),Instr(..), Instrs, Meta(..))
%%]

%%[(8 codegen grin) hs export(InsOp_LocE(..), InsOp_LocB(..), InsOp_LocODst(..), InsOp_LocOSrc(..), InsOp_TyOp(..), InsOp_DataOp(..), InsOp_ImmSz(..), InsOp_Deref(..), InsOp_DerefB(..), Imm(..))
%%]

%%[(8 codegen grin) ag import({GrinByteCode/AbsSyn})
%%]

%%[(20 codegen grin) hs import({%{EH}Core(HsName2OffsetMpMp)})
%%]

%%[(99 codegen grin) hs import({%{EH}Base.ForceEval})
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Configuration like constants
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Nr of words of basic values, both boxed and unboxed
20070904: Not yet used consistently, will it change anyway?

%%[(8 codegen grin) hs export(nrValWords)
nrValWords :: Int
nrValWords = 1
%%]

Nr of words occupied by header in node

%%[(8 codegen grin) hs export(nrNodeHdrWords)
nrNodeHdrWords :: Int
nrNodeHdrWords = 1
%%]

Nr of words required for call return info:
return address + saved bp

%%[(8 codegen grin) hs export(nrCallRetWords)
nrCallRetWords :: Int
nrCallRetWords = 2
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Code location
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs export(CodeAbsLoc,CodeRelOff)
type CodeAbsLoc = Int		-- absolute location
type CodeRelOff = Int		-- relative location
%%]
codeLocNil :: CodeAbsLoc
codeLocNil = -1

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Labels
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs export(LabelId,newLabelId)
type LabelId = Int

newLabelId :: GBState -> (GBState,LabelId)
newLabelId st = (st {gbstateLbl = l+1},l)
  where l = gbstateLbl st
%%]

%%[(8 codegen grin) hs export(LabelLocMp,labelLocAdd,labelLocNew)
type LabelLocMp = Map.Map LabelId CodeAbsLoc

labelLocAdd :: LabelId -> CodeAbsLoc -> LabelLocMp -> LabelLocMp
labelLocAdd lbl loc m = Map.insert lbl loc m

labelLocNew :: GBState -> CodeAbsLoc -> LabelLocMp -> (GBState,LabelId,LabelLocMp)
labelLocNew lbl loc m
  = (next,lbl',Map.insert lbl' loc m)
  where (next,lbl') = newLabelId lbl
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Additional datastructures, not incorporated as AST
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Instruction sequence

%%[(8 codegen grin) hs export(InsSeq)
type InsSeq = Seq.FastSeq Instr
%%]

Constants

%%[(8 codegen grin) hs export(Const(..))
data Const
  = Const_Str           { constInx    :: !Int    }
  | Const_CFunction     { constCFunNm :: !String }
  | Const_CallInfo      { constCINm   :: !String }		-- used only in ToC
%%[[20
  | Const_ImpNode
%%]]
  deriving(Eq,Ord,Show)

%%]

Reference to defining location in code

%%[(8 codegen grin) hs export(LocRef(..),lrefIsLabel)
lrefIsLabel :: LocRef -> Bool
lrefIsLabel (LocRef_Label _) = True
lrefIsLabel _                = False

data LocRef
  = LocRef_CodeEntry    !Int                         -- resolved at initialization runtime, translates to
  | LocRef_Label        { lrefId :: !LabelId }       -- resolved before runtime, translates to offsets
  deriving (Eq,Ord,Show)
%%]

%%[(8 codegen grin) hs
instance PP LocRef where
  pp (LocRef_CodeEntry c) = ".cod" >#< c
  pp (LocRef_Label     l) = ".lbl" >#< l
%%]

%%[(8 codegen grin) hs export(StackDepth)
type StackDepth = Int
%%]

Call Info

%%[(8 codegen grin) hs
data CallInfoExtra
  = CallInfoExtra_CCall [BasicSize]		-- type: (res : args)
  | CallInfoExtra_None
  deriving(Eq,Ord,Show)
%%]

%%[(8 codegen grin) hs
instance PP CallInfoExtra where
  pp (CallInfoExtra_CCall t) = pp $ show $ map basicGrinSizeCharEncoding t
  pp CallInfoExtra_None      = pp "NULL"
%%]

%%[(8 codegen grin) hs export(CallInfo(..),CallInfoKind(..))
type MbStrInx = Maybe Int

data CallInfo
  = CallInfo
      { ciKind			:: !CallInfoKind
      , ciMbNmStrInx	:: !MbStrInx					-- index of string, if any
      , ciExtra			:: !CallInfoExtra
      }
  deriving(Eq,Ord,Show)

data CallInfoKind
  = CallInfoKind_Call             -- normal call
  | CallInfoKind_Tail             -- tail call
  | CallInfoKind_Eval             -- eval call
  | CallInfoKind_EvalWrap         -- eval call internal wrapper
  | CallInfoKind_TailEv           -- tail eval call
  | CallInfoKind_Apply            -- apply call
  | CallInfoKind_CCall            -- C call
  | CallInfoKind_EvCont           -- eval update continuation
  | CallInfoKind_ApCont           -- apply continuation
  | CallInfoKind_PApCont          -- partial apply continuation
  | CallInfoKind_Hdlr             -- exception handler installment
  deriving (Enum,Eq,Ord,Show)
%%]

%%[(8 codegen grin) hs export(mkCICall)
mkCIExtra :: CallInfoExtra -> CallInfoKind -> MbStrInx -> CallInfo
mkCIExtra e k i = CallInfo k i e

mkCI :: CallInfoKind -> MbStrInx -> CallInfo
mkCI k i = mkCIExtra CallInfoExtra_None k i

mkCICall    = mkCI                              CallInfoKind_Call
mkCICCall e = mkCIExtra (CallInfoExtra_CCall e) CallInfoKind_CCall
mkCIEval    = mkCI                              CallInfoKind_Eval
mkCIApply   = mkCI                              CallInfoKind_Apply
%%]

Entry point info

%%[(8 codegen grin) hs export(EntryInfo(..))
data EntryInfo
  = EntryInfo
      { eiNm			:: !HsName
      , eiEntryNr		:: !Int
      , eiIsCAF			:: !Bool
      , eiNmStrConst	:: !Const
      }
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Link Chain
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

GC info, corresponds to src/rts/base/types/GB_GCInfo

%%[(8 codegen grin) hs export(GCInfo(..))
data GCInfo
  = GCInfo_None														-- dummy place holder, not to be used
  | GCInfo
      { gci_nrOfTOS_No_GCTrace			:: !Int						-- Nr of TOS values which may not be traced, like double & float
      }
%%]

%%[(8 codegen grin) hs export(GCInfoInx)
type GCInfoInx = Int
%%]

%%[(8 codegen grin) hs export(basicGCInfoL)
-- both table and its indices below should correspond
basicGCInfoL :: [GCInfo]
basicGCInfoL
  = [ GCInfo_None
    , GCInfo 1 												-- 1, only for header
    , GCInfo 2 												-- for header + 1 (first) field
%%[[97
    , GCInfo (basicSizeInWords BasicSize_Float  + 1)		-- 1 extra for header
    , GCInfo (basicSizeInWords BasicSize_Double + 1)
%%]]
    ]
%%]

%%[(8 codegen grin) hs export(gcInfoInx_None)
gcInfoInx_None, gcInfoInx_NdHeaderOnly :: Int
gcInfoInx_None         = 0
gcInfoInx_NdHeaderOnly = 1
gcInfoInx_Nd1Field     = 2
%%]

%%[(97 codegen grin).gcInfo -8.gcInfo hs
gcInfoInx_Float, gcInfoInx_Double :: Int
gcInfoInx_Float  = 3
gcInfoInx_Double = 4
%%]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Link Chain
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

20090923. New representation of linking info. Instead of separate tables
pointing to locations in the code, this variant uses a linked list of
entries inside the code. This is much more C code space efficient,
because no separate tables are required and the list can be overwritten
with the actual entries. For now, the design will be for the newly added
GCInfo.

Each entry in the code consists of one word only, which both encodes the
next entry and the payload. If this does not fit, an entry in an
indirection table is used.

Each entry is keyed by a kind and location (label), later to be translated
to a separate list for each kind, each ordered by code location of the labels,
where the next entry is encoded by an offset relative to the current.

The definition of LinkChainKind must corespond with the defines
GB_LinkChainKind_XXX in src/rts/base/types.

%%[(8 codegen grin) hs export(LinkChainKind(..),LinkChainKey(..),LinkChainId(..),linkChainId,LinkChainKeyInfo,lckeyMbLbl,lckeyMbLoc)
data LinkChainEncoding
  = LinkChainEncoding_Ind			-- to a separate table, the payload now is the index into that table
  | LinkChainEncoding_16_10			-- inline, 16(32) bits for inx, 10(26) for offset
  deriving (Enum)

data LinkChainKind
  = LinkChainKind_None
  | LinkChainKind_GCInfo			-- ref to GC Info
  | LinkChainKind_Const				-- ref to constant
  | LinkChainKind_Code				-- ref to global code entrypoint
  | LinkChainKind_Offset			-- ref to label
  | LinkChainKind_Offsets			-- ref to labels
  | LinkChainKind_CallInfo			-- ref to callinfo
%%[[20
  | LinkChainKind_ImpEntry			-- ref to imported code entrypoint
%%]]
  deriving (Eq,Ord,Enum,Show)

data LinkChainId
  = LinkChainId_Lbl !LabelId
  | LinkChainId_Loc !CodeAbsLoc
  deriving (Eq,Ord,Show)

linkChainId :: (LabelId -> x) -> (CodeAbsLoc -> x) -> LinkChainId -> x
linkChainId lbl _   (LinkChainId_Lbl l) = lbl l
linkChainId _   loc (LinkChainId_Loc l) = loc l

data LinkChainKey
  = LinkChainKey
      { lckeyKind		:: !LinkChainKind
      , lckeyId			:: !LinkChainId
      }
  deriving (Eq,Ord,Show)

lckeyMbLbl :: LinkChainKey -> Maybe LabelId
lckeyMbLbl k = case lckeyId k of {LinkChainId_Lbl l -> Just l ; _ -> Nothing}

lckeyMbLoc :: LinkChainKey -> Maybe LabelId
lckeyMbLoc k = case lckeyId k of {LinkChainId_Loc l -> Just l ; _ -> Nothing}

type LinkChainKeyInfo = Int													-- info must be representable by Int
%%]

%%[(8 codegen grin) hs export(LinkChainKeyMp)
type LinkChainKeyMp      = Map.Map LinkChainKey LinkChainKeyInfo
%%]

%%[(8 codegen grin) hs
%%]
-- the 'escape' entry when it does not fit in a word
data LinkChainIndirectionEntry
  = LinkChainIndirectionEntry
      { lcind
      }

%%[(8 codegen grin) hs export(LinkChainResolvedInfo(..),LinkChainResolvedIndInfoSet,emptyLinkChainResolvedIndInfoSet)
-- when resolved we have the original info & relative offset to next entry
data LinkChainResolvedInfo = LinkChainResolvedInfo LinkChainKind LinkChainKeyInfo CodeRelOff

-- the 'escape' entries when it does not fit in a word, as reversed list + its (cached) size
type LinkChainResolvedIndInfoSet = (Int,[LinkChainResolvedInfo])

emptyLinkChainResolvedIndInfoSet :: LinkChainResolvedIndInfoSet
emptyLinkChainResolvedIndInfoSet = (0,[])
%%]

%%[(8 codegen grin) hs export(linkChainResolvedInfoEncoding)
linkChainResolvedInfoEncoding :: LinkChainResolvedIndInfoSet -> LinkChainResolvedInfo -> (Integer,LinkChainResolvedIndInfoSet)
linkChainResolvedInfoEncoding 
  = \indset i
       -> case i of
            LinkChainResolvedInfo kind info off
              | info' >= 0 && info' < p1 && off' < p2
                          -> (info' `shiftL` b1 .|. off' `shiftL` b2 .|. k kind `shiftL` b3 .|. e16_10, indset)
              | otherwise -> let (sz,inds) = indset
                             in  (toInteger sz `shiftL` b3 .|. eInd, (sz+1, i : inds))
              where info' = toInteger info
                    off'  = toInteger off
  where k e  = toInteger $ fromEnum e
        b1 = Cfg.sizeofWordInBits `div` 2
        b3 = 2
        b2 = b3 + 4
        p1 = pow2 (Cfg.sizeofWordInBits - b1)
        p2 = pow2 (b1 - b2)
        e16_10 = k LinkChainEncoding_16_10
        eInd   = k LinkChainEncoding_Ind
%%]

%%[(8 codegen grin) hs export(LinkChainResolvedMp)
type LinkChainResolvedMp = Map.Map LinkChainKey LinkChainResolvedInfo
%%]

%%[(8 codegen grin) hs export(LinkChainEntry(..))
-- as it appears in GB code
data LinkChainEntry
  = LinkChainEntry
       { lcentryKey		:: !LinkChainKey
       , lcentryInfo	:: !LinkChainKeyInfo
       }
  deriving Show
%%]

%%[(8 codegen grin) hs export(linkChainConst,linkChainGCInfo,linkChainCode,linkChainOffset,linkChainOffsets)
linkChainEntry :: LinkChainKind -> LabelId -> Int -> LinkChainEntry
linkChainEntry kind lbl inx = LinkChainEntry (LinkChainKey kind (LinkChainId_Lbl lbl)) inx

linkChainConst :: LabelId -> Int -> LinkChainEntry
linkChainConst = linkChainEntry LinkChainKind_Const

linkChainCode :: LabelId -> Int -> LinkChainEntry
linkChainCode = linkChainEntry LinkChainKind_Code

linkChainGCInfo :: LabelId -> Int -> LinkChainEntry
linkChainGCInfo = linkChainEntry LinkChainKind_GCInfo

linkChainOffset :: LabelId -> Int -> LinkChainEntry
linkChainOffset = linkChainEntry LinkChainKind_Offset

linkChainOffsets :: LabelId -> Int -> LinkChainEntry
linkChainOffsets = linkChainEntry LinkChainKind_Offsets
%%]

%%[(20 codegen grin) hs export(linkChainImpEntry)
linkChainImpEntry :: LabelId -> Int -> LinkChainEntry
linkChainImpEntry = linkChainEntry LinkChainKind_ImpEntry
%%]

%%[(8 codegen grin) hs export(linkChainResolvedLookup)
linkChainResolvedLookup :: LinkChainKey -> LinkChainResolvedMp -> Maybe LinkChainResolvedInfo
linkChainResolvedLookup = Map.lookup
%%]

%%[(8 codegen grin) hs export(linkChainMpResolve)
linkChainMpResolve :: LabelLocMp -> LinkChainKeyMp -> (LinkChainResolvedMp,Maybe CodeRelOff)
linkChainMpResolve labelLocMp keyMp
  = foldr (\(k,(info,mbabsloc)) (m,mbnextabsloc) ->
              let diff  = case (mbnextabsloc,mbabsloc) of
                            (Just n, Just l) -> n - l
                            _                -> 0
                  info' = case (lckeyKind k,mbabsloc) of
                            (LinkChainKind_Offset, Just l) | isJust mblblloc
                               -> fromJust mblblloc - (l + Cfg.gbLabelOffsetSize)
                               where mblblloc = Map.lookup info labelLocMp
                            _  -> info
              in  (Map.insert k (LinkChainResolvedInfo (lckeyKind k) info' diff) m, mbabsloc)
          )
          (Map.empty,Nothing)
  $ sortOn (snd.snd)
  $ [ (k, (i, linkChainId (\l -> Map.lookup l labelLocMp) Just (lckeyId k)))
    | (k,i) <- Map.toList keyMp
    ]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Optimisation info
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs export(OptimCtxt(..),defaultOptimCtxt)
data OptimCtxt
  = OptimCtxt
      { ocxOmitTOSLd        :: !Bool
      }

defaultOptimCtxt :: OptimCtxt
defaultOptimCtxt = OptimCtxt False
%%]

%%[(8 codegen grin) hs export(OptimEffect(..),defaultOptimEffect)
data OptimEffect
  = OptimEffect
{- -- moved to separate transformation to eliminate redundant eval's
      { oefIsEvaluated         :: Bool
      }
-}

defaultOptimEffect :: OptimEffect
defaultOptimEffect = OptimEffect {- False -}
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Environmental info for name resolution
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs
type ValAccessAnnot = Either BasicAnnot BasicSize			-- either we have to deal with the annotation or it has already been done partly and we need to propagate the size

vaAnnotBasicSize :: ValAccessAnnot -> BasicSize
vaAnnotBasicSize = either grinBasicAnnotSize id
%%]

%%[(8 codegen grin) hs export(ValAccess(..),ValAccessGam)
data ValAccess
  = Val_Local           { vaStackDepth :: StackDepth, vaAnnot :: ValAccessAnnot }		-- value on the stack
  | Val_NodeTagLocal    { vaStackDepth :: StackDepth }									-- tag of node on the stack
  | Val_NodeFldLocal    { vaStackDepth :: StackDepth, vaAnnot :: ValAccessAnnot }		-- field 0 of node on the stack
  | Val_Int             Integer
  | Val_GlobEntry       { vaEntryInx :: Int }
%%[[20
  | Val_ImpEntry        { vaModOff, vaEntryOff :: Int }
%%]]
  deriving Show

instance PP ValAccess where
  pp = pp . show

type ValAccessGam = Map.Map HsName ValAccess
%%]

%%[(8 codegen grin) hs
vaHasAnnot :: ValAccess -> Bool
vaHasAnnot (Val_Local        _ _) = True
vaHasAnnot (Val_NodeFldLocal _ _) = True
vaHasAnnot _                      = False
%%]

%%[(20 codegen grin) hs export(ImpNmMp)
type ImpNmMp = Map.Map HsName Int
%%]

%%[(8 codegen grin) hs export(NmEnv(..))
data NmEnv
  = NmEnv
      { neVAGam     :: ValAccessGam
%%[[20
      , neImpNmMp   :: HsName2OffsetMpMp
%%]]
      }
%%]

%%[(8 codegen grin).nmEnvLookup hs export(nmEnvLookup)
nmEnvLookup :: HsName -> NmEnv -> Maybe ValAccess
nmEnvLookup nm env = Map.lookup nm $ neVAGam env
%%]

%%[(20 codegen grin) -8.nmEnvLookup hs export(nmEnvLookup)
nmEnvLookup :: HsName -> NmEnv -> Maybe ValAccess
nmEnvLookup nm env
  = case Map.lookup nm $ neVAGam env of
      Nothing
        -> do { q <- hsnQualifier nm
              ; (mo,entryMp) <- Map.lookup q $ neImpNmMp env
              ; eo <- Map.lookup nm entryMp
              ; return (Val_ImpEntry mo eo)
              }
      v -> v
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Load info
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs export(LoadSrc(..))
data LoadSrc
  = LoadSrc_TOS         
  | LoadSrc_Imm         { ldsrcImm      :: !Integer                            }
  | LoadSrc_Imm_Int     { ldsrcImm      :: !Integer                            }
  | LoadSrc_TOS_Rel     { ldsrcOff      :: !StackDepth   , ldsrcNrWords :: Int }
  | LoadSrc_TOS_Tag
  | LoadSrc_Reg_Rel     { ldsrcOff      :: !StackDepth   , ldsrcNrWords :: Int }
  deriving (Show)

ldsrc2ins' :: (Instr -> Instr) -> LoadSrc -> (InsSeq,StackDepth)
ldsrc2ins' instrann s
  = case s of
      LoadSrc_TOS          -> (Seq.empty                          ,0         )
      LoadSrc_TOS_Rel  o n -> (Seq.fromList  $ ann      $ ldlm n o,n         )
      LoadSrc_TOS_Tag      -> (Seq.singleton $ instrann $ ldnt    ,nrValWords)
      LoadSrc_Reg_Rel  o n -> (Seq.fromList  $ ann      $ ldrm n o,n         )
      LoadSrc_Imm      c   -> (Seq.singleton $ instrann $ ldc  c  ,nrValWords)
      LoadSrc_Imm_Int  c   -> (Seq.singleton $ instrann $ ldi  c  ,nrValWords)
  where ldlm n o = replicate n (ldl o)
        ldrm n o = [ l1tr o' | o' <- reverse [o..o+n-1] ]	-- hardcoded 'stack grows down' assumption
        ann (h:t) = instrann h : t

ldsrc2ins :: LoadSrc -> (InsSeq,StackDepth)
ldsrc2ins = ldsrc2ins' id
%%]

%%[(8 codegen grin) hs
instance PP LoadSrc where
  pp = pp . show
%%]

%%[(8 codegen grin) hs export(Load(..))
data Load
  = Load
      { ldPreIns        :: !InsSeq
      , ldPreStackInc   :: !StackDepth
      , ldPreLoc        :: !LoadSrc
      , ldPostIns       :: !InsSeq
      }

loadWithPrePostFrom :: [Instr] -> StackDepth -> LoadSrc -> [Instr] -> Load
loadWithPrePostFrom pre presz s post = Load (Seq.fromList pre) presz s (Seq.fromList post)

loadWithPreFrom :: [Instr] -> StackDepth -> LoadSrc -> Load
loadWithPreFrom pre presz s = loadWithPrePostFrom pre presz s []

loadWithPre0From :: [Instr] -> LoadSrc -> Load
loadWithPre0From pre s = loadWithPreFrom pre 0 s

loadWithPost0From :: LoadSrc -> [Instr] -> Load
loadWithPost0From s post = loadWithPrePostFrom [] 0 s post

loadFrom :: LoadSrc -> Load
loadFrom s = loadWithPreFrom [] 0 s
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Named value access
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs export(nmLd')
nmLd' :: OptimCtxt -> NmEnv -> Int -> StackDepth -> GBState -> HsName -> (Maybe ValAccess,Load,BasicSize,GBState)
nmLd' optim env modNmConstInx stkDepth gbState nm
  = case nmEnvLookup nm env of
      mva@(Just va)
        -> case va of
             Val_Local o annot
               -> (mva,loadWithPrePostFrom [meta' AnnIdUse (nm >#< either pp pp annot >#< src)] 0 src post,vaAnnotBasicSize annot,gbState)
               where (src,post)
                         = case annot of
                             Left (BasicAnnot_FromTaggedPtr sgn _) -> (srcDflt Cfg.sizeofGrWord ,[untag2 sgn])
                             Left (BasicAnnot_ToTaggedPtr   sgn _) -> (srcDflt Cfg.sizeofGrWord ,[])
                             Left (BasicAnnot_Size bsz _         ) -> (srcDflt (basicSizeInBytes bsz),[])
                             Left (BasicAnnot_Dflt               ) -> (srcDflt Cfg.sizeofGrWord ,[])
                             Right _                               -> (srcDflt Cfg.sizeofGrWord ,[])
                         where srcDflt n = offSrc (stkDepth - o) (nrByte2Word n)
             Val_NodeTagLocal o
               -> (mva,loadFrom (offSrc (stkDepth - o) nrValWords),dfltBasicSize,gbState)
             Val_NodeFldLocal o annot
               -> (mva,l,vaAnnotBasicSize annot,gbState)
               where l   = case annot of
                             Left (BasicAnnot_FromTaggedPtr sgn _) -> loadWithPost0From (offSrc (stkDepth - o) nrValWords) [untag2 sgn]
                             Left (BasicAnnot_ToTaggedPtr   sgn _) -> loadWithPost0From (offSrc (stkDepth - o) nrValWords) [tag2   sgn]
                             Left (BasicAnnot_Size bsz _         ) -> loadWithPre0From [ldlr (stkDepth - o)] (LoadSrc_Reg_Rel nrNodeHdrWords $ nrByte2Word $ basicSizeInBytes bsz)
                             _                                     -> panic "GrinByteCode.nmLd'.Val_NodeFldLocal"
             Val_Int i
               -> (mva,loadFrom (LoadSrc_Imm_Int i),dfltBasicSize,gbState)
             Val_GlobEntry o
               -> (mva,loadWithPreFrom [instrann' AnnIdUse nm $ ldg InsOp_LocB_TOS (linkChainCode codeLbl o)] nrValWords LoadSrc_TOS,dfltBasicSize,gbState2)
               where (gbState2,codeLbl) = newLabelId gbState
%%[[20
             Val_ImpEntry mo eo
               -> (mva,loadWithPre0From [instrann' AnnIdUse nm $ ldg InsOp_LocB_Reg (linkChainImpEntry codeLbl mo)] (LoadSrc_Reg_Rel (eo + nrNodeHdrWords) nrValWords),dfltBasicSize,gbState2)
               where (gbState2,codeLbl) = newLabelId gbState
%%]]
      _ -> (Nothing,loadWithPreFrom [instrann' AnnIdUse ("dummy ld for" >#< nm) $ ldl stkDepth] nrValWords LoadSrc_TOS,dfltBasicSize,gbState)
  where offSrc off sz = if off == 0 then LoadSrc_TOS else LoadSrc_TOS_Rel off sz
        dfltBasicSize = grinBasicAnnotSize BasicAnnot_Dflt
%%]

%%[(8 codegen grin) hs
vaAndLd2Ins :: OptimCtxt -> HsName -> (Maybe ValAccess,Load,x,y) -> (InsSeq,StackDepth)
vaAndLd2Ins optim nm vald
  = case vald of
      (Just (Val_Local _ (Left annot)),Load pins pdep LoadSrc_TOS postins,_,_)
        | not (ocxOmitTOSLd optim)
          -> (pins Seq.:++: ins Seq.:++: postins,pdep + dep)
          where (ins,dep) = ldsrc2ins' (instrann' AnnIdUse (nm >#< annot)) (LoadSrc_TOS_Rel 0 nrValWords)
      (_,Load pins pdep ls postins,_,_)
          -> (pins Seq.:++: ins Seq.:++: postins,pdep + dep)
          where (ins,dep) = ldsrc2ins' (instrann $ show ls) ls
%%]

%%[(8 codegen grin) hs export(nmLd)
nmLd :: OptimCtxt -> NmEnv -> Int -> StackDepth -> GBState -> HsName -> (InsSeq,StackDepth,GBState)
nmLd optim env modNmConstInx stkDepth gbState nm
  = (ins,dep,gbState2)
  where l@(_,_,_,gbState2) = nmLd' optim env modNmConstInx stkDepth gbState nm
        (ins,dep) = vaAndLd2Ins optim nm l
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% GrVal Value introduction
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs export(GrValIntro(..))
data GrValIntro
  = GrValIntro_Nm    !HsName
  | GrValIntro_Int   !Integer
  | GrValIntro_Str   !String !Int
  | GrValIntro_Grp   !GrTag ![GrValIntro]
  | GrValIntro_Basic !GrTag !HsName
  | GrValIntro_Enum  !HsName
  | GrValIntro_None
%%]

%%[(8 codegen grin) hs export(GBState(..))
data GBState
  = GBState
      { gbstateLbl			:: !LabelId
      }
%%]

%%[(8 codegen grin) hs export(GrValIntroAlt(..))
data GrValIntroAlt
  = GrValIntroAlt_OnTOS     InsSeq StackDepth OptimEffect [BasicSize]
  | GrValIntroAlt_Delay     InsSeq StackDepth OptimEffect (Maybe ValAccess) Load BasicSize
%%]

%%[(8 codegen grin) hs export(gviLd,gviLd',gviLdFold)
gviLdFold' :: EHCOpts -> GrValIntroAlt -> OptimCtxt -> NmEnv -> Int -> StackDepth -> GBState -> [GrValIntro] -> (GrValIntroAlt,GBState)
gviLdFold' opts dflt optim env modNmConstInx stkDepth gbState introL
  = foldl ld (dflt, gbState) $ reverse $ introL
  where ld (GrValIntroAlt_OnTOS ins dep _ basicsz, gbState) intro
          = (GrValIntroAlt_OnTOS (ins Seq.:++: ins') (dep+dep') defaultOptimEffect (basicsz' ++ basicsz), gbState2)
          where (GrValIntroAlt_OnTOS ins' dep' _ basicsz', gbState2) = gviLd opts optim env modNmConstInx (stkDepth+dep) gbState intro

gviLdFold :: EHCOpts -> OptimCtxt -> NmEnv -> Int -> StackDepth -> GBState -> [GrValIntro] -> (GrValIntroAlt,GBState)
gviLdFold opts = gviLdFold' opts (GrValIntroAlt_OnTOS Seq.empty 0 defaultOptimEffect [])

gviLd' :: EHCOpts -> OptimCtxt -> NmEnv -> Int -> StackDepth -> GBState -> GrValIntro -> (GrValIntroAlt,GBState)
gviLd' opts optim env modNmConstInx stkDepth gbState intro
  = ld optim (GrValIntroAlt_OnTOS Seq.empty 0 defaultOptimEffect []) intro
  where ld optim dflt@(GrValIntroAlt_OnTOS ins dfltInc _ _) intro
          = case intro of
              GrValIntro_Nm nm
                -> (GrValIntroAlt_Delay ins dfltInc defaultOptimEffect mbva l basicsz, gbState2)
                where (mbva,l,basicsz,gbState2) = nmLd' optim env modNmConstInx stkDepth gbState nm
              GrValIntro_Str s constInx
                -> (GrValIntroAlt_OnTOS (ins Seq.::+: (instrann (show lce) $ ldg InsOp_LocB_TOS lce)) (dfltInc+nrValWords) defaultOptimEffect [dfltBasicSize], gbState2)
                where (gbState2,constLbl) = newLabelId gbState
                      lce = linkChainConst constLbl constInx
              GrValIntro_Int i
                -> (GrValIntroAlt_Delay ins dfltInc defaultOptimEffect Nothing (loadFrom $ LoadSrc_Imm_Int i) dfltBasicSize, gbState)
              GrValIntro_Enum nm
                -> case mbva of
                     Just va | vaHasAnnot va
                       -> case vaAnnot va of
                            Left BasicAnnot_Dflt                -> basicAnnotDflt nm gbState2
                            Left (BasicAnnot_ToTaggedPtr sgn _) -> basicAnnotTaggedPtr sgn nm ml dfltBasicSize gbState2
                            _                                   -> panic "GrinByteCode.gviLd'.GrValIntro_Enum.Just"
                     _ -> panic "GrinByteCode.gviLd'.GrValIntro_Enum.Nothing"
                where ml@(mbva,l,basicsz,gbState2) = nmLd' optim env modNmConstInx stkDepth gbState nm
              GrValIntro_Basic gtag nm
                -> case mbva of
                     Just va | vaHasAnnot va
                       -> case vaAnnot va of
                            Left BasicAnnot_Dflt                    -> basicAnnotDflt nm gbState2
                            Left (a@(BasicAnnot_ToTaggedPtr sgn _)) -> basicAnnotTaggedPtr sgn nm ml (grinBasicAnnotSize a) gbState2
                            Left (BasicAnnot_Size bsz bty)
                              -> ( GrValIntroAlt_OnTOS (ins Seq.:++: Seq.fromList [meta' AnnTag (ppGrTag gtag)] Seq.:++: tins Seq.:++: sins) sinc defaultOptimEffect [basicsz]
                                 , gbState4
                                 )
                              where (ins,inc) = vaAndLd2Ins optim nm ml
                                    (tins,tinc,isEvaluated,gcInfoInx,gbState3) = tag env modNmConstInx (dep'+inc) gtag (Just bty) (nrByte2Word bsz') gbState2
                                    (gbState4,allocLbl) = newLabelId gbState3
                                    (sins,sinc) = ndStore ((nrByte2Word bsz') + tinc) allocLbl gcInfoInx
                                    bsz' = basicSizeInBytes bsz
                            Right bSz                               -> basicSize nm ml bSz gbState2
                            _ -> panic "GrinByteCode.gviLd'.GrValIntro_Basic.Just"
                     _ -> panic "GrinByteCode.gviLd'.GrValIntro_Basic.Nothing"
                where ml@(mbva,l,basicsz,gbState2) = nmLd' optim env modNmConstInx stkDepth gbState nm
              GrValIntro_Grp gtag is
                -> ( GrValIntroAlt_OnTOS (prepins Seq.:++: ins Seq.:++: Seq.fromList [meta' AnnTag (ppGrTag gtag)] Seq.:++: tins Seq.:++: sins) sinc defaultOptimEffect [dfltBasicSize]
                   , gbState4
                   )
                where (prepins,prepinc) = case (is, tag env modNmConstInx dep' gtag Nothing 0 gbState) of
                                            ([],(_,1,_,_,_)) | Cfg.nodeNeedsForwarding opts -> (Seq.fromList [ldc 0],1)
                                            _                                               -> (Seq.empty           ,0)
                      i@(GrValIntroAlt_OnTOS ins inc _ _, gbState2) = gviLdFold' opts dflt (optim {ocxOmitTOSLd = False}) env modNmConstInx (dep' + prepinc) gbState is
                      inc' = prepinc + inc
                      (tins,tinc,isEvaluated,gcInfoInx,gbState3) = tag env modNmConstInx (dep' + inc') gtag Nothing inc' gbState2
                      (gbState4,allocLbl) = newLabelId gbState3
                      (sins,sinc) = ndStore (inc' + tinc) allocLbl gcInfoInx
              _ -> (dflt, gbState)
          where dep' = stkDepth + dfltInc
                basicAnnotDflt nm gbState
                  = (GrValIntroAlt_Delay ins dfltInc defaultOptimEffect mbva l basicsz, gbState2)
                  where (mbva,l,basicsz,gbState2) = nmLd' optim env modNmConstInx stkDepth gbState nm
                basicAnnotTaggedPtr sgn nm ml bSz gbState
                  = (GrValIntroAlt_OnTOS (ins Seq.::+: tag2 sgn) inc defaultOptimEffect [bSz], gbState)
                  where (ins,inc) = vaAndLd2Ins optim nm ml
                basicSize nm ml bSz gbState
                  = (GrValIntroAlt_OnTOS (ins) inc defaultOptimEffect [bSz], gbState)
                  where (ins,inc) = vaAndLd2Ins optim nm ml
                dfltBasicSize = grinBasicAnnotSize BasicAnnot_Dflt

gviLd :: EHCOpts -> OptimCtxt -> NmEnv -> Int -> StackDepth -> GBState -> GrValIntro -> (GrValIntroAlt,GBState)
gviLd opts optim env modNmConstInx stkDepth gbState intro
  = case gviLd' opts optim env modNmConstInx stkDepth gbState intro of
      (GrValIntroAlt_Delay ins inc optimEffect mbva l basicsz, gbState2)
        -> (GrValIntroAlt_OnTOS (ins Seq.:++: sins) (inc + sinc) optimEffect [basicsz], gbState2)
        where (sins,sinc) = vaAndLd2Ins optim hsnUnknown (mbva,l,basicsz,gbState2)
      a -> a
%%]

%%[(8 codegen grin) hs export(gvCall)
gvCall :: MbStrInx -> NmEnv -> Int -> InsSeq -> Int -> StackDepth -> GBState -> HsName -> (InsSeq,StackDepth,GBState)
gvCall i nmEnv modNmConstInx ins inc stkDepth gbState nm
  = (ins Seq.:++: fins Seq.:++: Seq.fromList [call i InsOp_LocB_TOS], nrValWords,gbState2)
  where (fins,_,gbState2) = nmLd defaultOptimCtxt nmEnv modNmConstInx (stkDepth + inc) gbState nm
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Constants
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs export(nrWord2Byte)
nrWord2Byte :: Integral c => c -> c
nrWord2Byte sz
  = sz * wSz
  where wSz = fromInteger Cfg.sizeofGrWordAsInteger
%%]

%%[(8 codegen grin) hs export(nrByte2Word)
nrByte2Word :: Integral c => c -> c
nrByte2Word sz
  = (sz-1) `div` wSz + 1
  where wSz = fromInteger Cfg.sizeofGrWordAsInteger
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Unboxed values
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs export(tagIsUnboxed)
tagIsUnboxed :: EHCOpts -> GrTag -> Bool
tagIsUnboxed opts
  = \gt -> case gt of
              GrTag_Con _ _ nm | check nm
                -> True
              GrTag_Unboxed
                -> True
              _ -> False
  where check = maybe False biGbcMayLiveUnboxed . builtinGrinMayLiveUnboxed opts
%%]

%%[(8 codegen grin) hs export(tagAllowsUnboxedLife)
tagAllowsUnboxedLife :: EHCOpts -> GrTag -> Unbox
tagAllowsUnboxedLife opts gt
  = if tagIsUnboxed opts gt
    then Unbox_FirstField
    else case gt of
           GrTag_Con ann t nm | gtannMaxArity ann == 0
             -> Unbox_Tag t
           _ -> Unbox_None
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Constructing: immediate operands
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs
imm :: Integral c => c -> (InsOp_ImmSz,Imm)
imm c
  = (s,Imm_Int i)
  where (s,i)
          = case toInteger c of
              i | i <  0 -> (s, i .&. m)
                         where (s,m) = case i of
                                         i | i >= pow2_7neg  -> (InsOp_ImmSz_Bits08,mask2_8 )
                                           | i >= pow2_15neg -> (InsOp_ImmSz_Bits16,mask2_16)
                                           | i >= pow2_31neg -> (InsOp_ImmSz_Bits32,mask2_32)
                                           | otherwise       -> (InsOp_ImmSz_Bits64,mask2_64)
              i | i >= 0 -> (s, i .&. mask2_64)
                         where s = case i of
                                     i | i < pow2_7sub1  -> InsOp_ImmSz_Bits08
                                       | i < pow2_15sub1 -> InsOp_ImmSz_Bits16
                                       | i < pow2_31sub1 -> InsOp_ImmSz_Bits32
                                       | otherwise       -> InsOp_ImmSz_Bits64
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Constructing: loading
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs export(ldc,ldl,ldg,ldi,l1tr,l2ts,ldnt)
ld :: Integral c => InsOp_Deref -> InsOp_LocB -> InsOp_LocE -> c -> Instr
ld ind locB locE c
  = Instr_Ld ind locB locE s i
  where (s,i) = imm c

-- load constant on TOS
ldc :: Integral c => c -> Instr
ldc = ld InsOp_Deref_Zero InsOp_LocB_TOS InsOp_LocE_Imm

-- load integer constant on TOS
ldi :: Integral c => c -> Instr
ldi = ld InsOp_Deref_Int InsOp_LocB_TOS InsOp_LocE_Imm

-- load local relative to SP on TOS
ldl :: Integral c => c -> Instr
ldl c = ld InsOp_Deref_One InsOp_LocB_TOS InsOp_LocE_SP (nrWord2Byte c)

-- load local relative to SP in reg
ldlr :: Integral c => c -> Instr
ldlr c = ld InsOp_Deref_One InsOp_LocB_Reg InsOp_LocE_SP (nrWord2Byte c)

-- load relative to reg on TOS
l1tr :: Integral c => c -> Instr
l1tr c = ld InsOp_Deref_One InsOp_LocB_TOS InsOp_LocE_Reg (nrWord2Byte c)

l2ts :: Integral c => c -> Instr
l2ts c = ld InsOp_Deref_Two InsOp_LocB_TOS InsOp_LocE_SP (nrWord2Byte c)

ldg :: InsOp_LocB -> LinkChainEntry -> Instr
ldg locB l = Instr_LdGlobal locB l

ldnt :: Instr
ldnt = Instr_LdNodeTag
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Constructing: link
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs
%%]
link :: Link -> Instr
link = Instr_Link

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Constructing: storing
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

-- not implemented yet

%%[(8 codegen grin) hs export()
st :: Integral c => InsOp_DerefB -> InsOp_LocE -> InsOp_LocB -> c -> Instr
st ind locE locB c
  = Instr_St ind locE locB s i
  where (s,i) = imm c
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Constructing: label
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs export(labelref,label,labelref2)
labelref :: LocRef -> Instr
labelref l = Instr_LabelRef l

labelref2 :: [LabelId] -> GBState -> ([Instr],GBState)
labelref2 lbls st
  = foldr (\l (is,st) -> let (st',llbl) = newLabelId st
                         in  (Instr_LinkChain (linkChainOffset llbl l) : is, st')
          )
          ([],st) lbls

label :: LocRef -> Instr
label l = Instr_Label l
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Constructing: fetching contents of a node
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs export(fetch,fetchupdate)
fetch :: InsOp_LocB -> Instr
fetch locB = Instr_Fetch locB

fetchupdate :: Instr
fetchupdate = Instr_FetchUpdate
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Constructing: allocation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs
allocstore :: InsOp_LocB -> LabelId -> GCInfoInx -> Instr
allocstore locB lbl gcinx = Instr_AllocStore locB (linkChainGCInfo lbl gcinx)

-- prepare node allocation by providing padding upto minimum size
{-
ndStorePrep :: EHCOpts -> Int -> (InsSeq,StackDepth)
ndStorePrep opts sz
  = (Seq.fromList $ replicate szExtra $ ldc 0, szExtra)
  where szPadded = Cfg.minwordsofNode opts `max` sz
        szExtra  = szPadded - sz
-}

ndStore :: Int -> LabelId -> GCInfoInx -> (InsSeq,StackDepth)
ndStore sz lbl gcinx = (Seq.fromList [ldc (nrWord2Byte sz),meta' AnnAllocStore sz,allocstore InsOp_LocB_TOS lbl gcinx], nrValWords)
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Constructing: eval
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs export(eval,apply,taileval)
eval :: MbStrInx -> InsOp_LocB -> Instr
eval i locB = Instr_Eval locB (mkCIEval i)

taileval :: Integral c => InsOp_LocB -> c -> Instr
taileval locB nArgSurr
  = Instr_TailEval locB s1 i1
  where (s1,i1) = imm $ nrWord2Byte nArgSurr
        -- (s2,i2) = imm $ nrWord2Byte retOffSurr

apply :: MbStrInx -> InsOp_LocB -> Instr
apply i locB = Instr_Apply locB (mkCIApply i)
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Constructing: control, call, etc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs export(call,retcall,tailcall,casecall,retcase,callc)
call :: MbStrInx -> InsOp_LocB -> Instr
call i locB = Instr_Call locB (mkCICall i)

rettailcall :: Integral c => (InsOp_ImmSz -> InsOp_ImmSz -> Imm -> Imm -> Instr) -> c -> c -> Instr
rettailcall mk nArgMine nArgSurr -- retOffSurr
  = mk s1 s2 i1 i2
  where (s1,i1) = imm $ nrWord2Byte nArgMine
        (s2,i2) = imm $ nrWord2Byte nArgSurr
        -- (s3,i3) = imm $ nrWord2Byte retOffSurr

retcall :: Integral c => c -> c -> Instr
retcall = rettailcall Instr_RetCall

tailcall :: Integral c => InsOp_LocB -> c -> c -> Instr
tailcall locB = rettailcall (Instr_TailCall locB)

casecall :: LinkChainEntry -> Instr
casecall l
  = Instr_CaseCall l

callc :: Integral c => MbStrInx -> [BasicSize] -> c -> Instr
callc i ty nArg
  = Instr_CallC s1 i1 ce (mkCICCall ty i)
  where (s1,i1) = imm nArg
        (_ ,ce) = imm $ basicGrinSizeLEncoding ty

retcase :: Integral c => c -> c -> LinkChainEntry -> Instr
retcase nRes retOffSurr l
  = Instr_RetCase s1 s2 i1 i2 l
  where (s1,i1) = imm $ nrWord2Byte nRes
        (s2,i2) = imm $ nrWord2Byte retOffSurr
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Constructing: operators
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs export(op)
op :: Integral c => InsOp_TyOp -> InsOp_DataOp -> InsOp_LocODst -> InsOp_Deref -> InsOp_LocOSrc -> c -> Instr
op opTy opndTy locDst ind locSrc c
  = Instr_Op opTy opndTy locDst ind locSrc s1 i1
  where (s1,i1) = imm c
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Constructing: conversion
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs
tagi2w :: Instr
tagi2w = Instr_TagInt2Word

untagw2i :: Instr
untagw2i = Instr_UntagWord2Int

tagw2w :: Instr
tagw2w = Instr_TagWord2Word

untagw2w :: Instr
untagw2w = Instr_UntagWord2Word
%%]

%%[(8 codegen grin) hs export(untag2)
tag2 :: Bool -> Instr
tag2 sgn = if sgn then tagi2w else tagw2w

untag2 :: Bool -> Instr
untag2 sgn = if sgn then untagw2i else untagw2w
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Constructing: comment
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs export(AnnKind(..))
data AnnKind
  = AnnComment
  | AnnFunStart
  | AnnStackDepth
  | AnnIdUse
  | AnnTag
  | AnnAllocStore
  | AnnLabel
  | AnnLabelRef
  deriving (Eq,Show)

instance PP AnnKind where
  pp AnnComment      = Pretty.empty
  pp AnnFunStart     = pp "funstart"
  pp AnnStackDepth   = pp "stackoff"
  pp AnnIdUse        = pp "iduse"
  pp AnnTag          = pp "tag"
  pp AnnAllocStore   = pp "allocstore"
  pp AnnLabel        = pp "lbldef"
  pp AnnLabelRef     = pp "lblref"
%%]

%%[(8 codegen grin) hs export(meta',meta)
meta' :: PP a => AnnKind -> a -> Instr
meta' k a = Instr_Meta $ Meta_CmtHeader k $ pp a

meta :: PP a => a -> Instr
meta = meta' AnnComment
%%]

%%[(8 codegen grin) hs
instrann' :: PP a => AnnKind -> a -> Instr -> Instr
instrann' k a = Instr_Ann k $ showPP a

instrann :: PP a => a -> Instr -> Instr
instrann = instrann' AnnComment
%%]

%%[(8 codegen grin) hs
%%]
metaprop' :: PP a => AnnKind -> String -> a -> Instr
metaprop' k prop a = meta' k (prop >|< "=" >|< a)

metaprop :: PP a => String -> a -> Instr
metaprop = metaprop' AnnComment

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Constructing: tag
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Offsets should coincide with def of GB_NodeHeader, src/rts/base/types

%%[(8 codegen grin) hs
[tgShSize,tgShCateg,tagShGC,tagShTag,tgShNdEv]
  = if Cfg.use32Bits then [16,14,12,2,0::Int] else [32,30,28,2,0]

tgNeedEval_No, tgNeedEval_Yes, tgNeedEval_BlH :: Integer
tgNeedEval_No  = 0
tgNeedEval_Yes = 1
tgNeedEval_BlH = 2

tgCat_GB_NodeTagCat_Con
  , tgCat_GB_NodeTagCat_PAp
  , tgCat_GB_NodeTagCat_Fun
  , tgCat_GB_NodeTagCat_App
%%[[97
  , tgCat_GB_NodeTagCat_Intl
%%]]
      :: Integer

-- not requiring evaluation
tgCat_GB_NodeTagCat_Con  = 0
tgCat_GB_NodeTagCat_PAp  = 1
%%[[97
tgCat_GB_NodeTagCat_Intl = 3
%%]]
-- requiring evaluation
tgCat_GB_NodeTagCat_Fun  = 0
tgCat_GB_NodeTagCat_App  = 1

%%[[97
tgIntl_GB_NodeTag_Intl_Float
  , tgIntl_GB_NodeTag_Intl_Double
      :: Int
tgIntl_GB_NodeTag_Intl_Float  = 2
tgIntl_GB_NodeTag_Intl_Double = 3
%%]]
%%]

load tag, yield stack increment and additional size to alloc

%%[(8 codegen grin) hs export(tag)
tag :: NmEnv -> Int -> StackDepth -> GrTag -> Maybe BasicTy -> Int -> GBState -> (InsSeq,StackDepth,Bool,GCInfoInx,GBState)
tag env modNmConstInx stkDepth gt bty sz gbState
  = case gt of
      GrTag_Unboxed
        -> (Seq.empty,0,False,gcInfoInx_None,gbState)
      _ -> (tins Seq.:++: Seq.fromList [ldc tword],tinc+1,isEvaluated,gcInfo,gbState2)
        where (needEval,categ',tg',tins,tinc,gcInfo,gbState2)
                = case bty of
%%[[97
                    Just BasicTy_Double         -> (tgNeedEval_No ,tgCat_GB_NodeTagCat_Intl,tgIntl_GB_NodeTag_Intl_Double,Seq.empty           ,0  ,gcInfoInx_Double      , gbState )
                    Just BasicTy_Float          -> (tgNeedEval_No ,tgCat_GB_NodeTagCat_Intl,tgIntl_GB_NodeTag_Intl_Float ,Seq.empty           ,0  ,gcInfoInx_Float       , gbState )
%%]]
                    _ -> case gt of
                           GrTag_Con _ tg nm    -> (tgNeedEval_No ,tgCat_GB_NodeTagCat_Con ,tg                           ,Seq.empty           ,0  ,gcInfoInx_NdHeaderOnly, gbState )
                           GrTag_Hole           -> (tgNeedEval_BlH,0                       ,0                            ,Seq.fromList [ldc 0],1  ,gcInfoInx_NdHeaderOnly, gbState )
                           GrTag_Rec            -> (tgNeedEval_No ,tgCat_GB_NodeTagCat_Con ,0                            ,Seq.empty           ,0  ,gcInfoInx_NdHeaderOnly, gbState )
                           GrTag_App      nm    -> (tgNeedEval_Yes,tgCat_GB_NodeTagCat_App ,0                            ,Seq.empty           ,0  ,gcInfoInx_NdHeaderOnly, gbState )
                           GrTag_Fun      nm    -> (tgNeedEval_Yes,tgCat_GB_NodeTagCat_Fun ,0                            ,ins                 ,inc,gcInfoInx_NdHeaderOnly, gbState2)
                                                where (ins,inc,gbState2) = nmLd defaultOptimCtxt env modNmConstInx stkDepth gbState nm
                           GrTag_PApp m   nm    -> (tgNeedEval_No ,tgCat_GB_NodeTagCat_PAp ,m                            ,ins                 ,inc,gcInfoInx_NdHeaderOnly, gbState2)
                                                where (ins,inc,gbState2) = nmLd defaultOptimCtxt env modNmConstInx stkDepth gbState nm
              tword = (toInteger (sz+tinc+1) `shiftL` tgShSize) .|. needEval `shiftL` tgShNdEv .|. categ' `shiftL` tgShCateg .|. toInteger tg' `shiftL` tagShTag
              isEvaluated = needEval == tgNeedEval_No
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Constructing: misc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs export(halt)
halt :: Instr
halt = Instr_Halt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% ForceEval instances
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(99 codegen grin) hs
instance ForceEval Const
instance ForceEval LinkChainEntry
instance ForceEval LocRef
instance ForceEval CallInfo
instance ForceEval EntryInfo
%%]

