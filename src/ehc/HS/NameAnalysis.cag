%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Names: dependencies, binding group, in scope
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Levels
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[1 hs
type NmLev = Int

nmLevAbsent, nmLevBuiltin, nmLevOutside, nmLevModule :: NmLev
nmLevAbsent  = -3
nmLevBuiltin = -2
nmLevOutside = -1
nmLevModule  =  0
%%]

%%[1
ATTR AllNT [ nmLev: NmLev | | ]
%%]

%%[5
ATTR
  Qualifier
%%[[9
  Statement
%%]
  [ | | nmLev: NmLev ]
%%]

%%[1
SEM AGItf
    | AGItf
        loc             .   nmLev       =   nmLevModule
%%]

%%[1
SEM Declaration
    | TypeSignature
        loc             .   nmLev       =   @lhs.nmLev + 1
%%[[5
    | Data Newtype
        loc             .   nmLev       =   @lhs.nmLev -- + 1
%%]
%%[[9
    | Class InstanceUseImplicitly Default
        loc             .   nmLev       =   @lhs.nmLev -- + 1
    | Instance
        loc             .   nmLev       =   @lhs.nmLev + 1
%%]
%%[[11
    | Type
        loc             .   nmLev       =   @lhs.nmLev + 1
%%]
%%]

%%[4
SEM Type
    | Forall Exists
        loc             .   nmLev       =   @lhs.nmLev + 1
%%]

%%[5
SEM Constructor
	| Constructor Infix
		loc				.	nmLev		=	@lhs.nmLev + 1
%%]

%%[7
SEM FieldDeclaration
	| FieldDeclaration
		loc				.	nmLev		=	@lhs.nmLev + 1
%%]

%%[9
SEM ContextItem
    | Forall
        loc             .   nmLev       =   @lhs.nmLev + 1
%%]

%%[1
SEM Expression
    | Lambda Let
        loc             .   nmLev       =   @lhs.nmLev + 1
    | Typed
        type            .   nmLev       =   @lhs.nmLev + 1
%%]

%%[4
SEM Pattern
    | Typed
        type            .   nmLev       =   @lhs.nmLev + 1
%%]

%%[1
SEM FunctionBinding
    | FunctionBinding
        loc             .   nmLev       =   @lhs.nmLev + 1
%%]

%%[1
%%]
SEM LeftHandSide
    | Function Infix
        loc             .   nmLev       =   @lhs.nmLev + 1
    | Parenthesized
        patterns        .   nmLev       =   @lhs.nmLev + 1

%%[1
SEM RightHandSide
    | *
        loc             .   nmLev       =   @lhs.nmLev + 1
%%]

%%[5
SEM Alternative
    | Alternative
        loc             .   nmLev       =   @lhs.nmLev + 1
%%]

%%[5
SEM Qualifier
    | Let Generator
        loc             .   nmLev       =   @lhs.nmLev + 1
%%]

%%[9
SEM Statement
    | Let Generator
        loc             .   nmLev       =   @lhs.nmLev + 1
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Module name
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[12
ATTR
  AGItf AllModule AllDeclaration AllFunctionBinding LeftHandSide AllFieldDeclaration AllConstructor
  AllExpression AllPattern AllRowRecordPatternBinding
    [ moduleNm: HsName | | ]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% The actual name used for referring to value/type/...
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[12 hs
mkModQualNm :: Int -> HsName -> HsName -> HsName
mkModQualNm 0 m n = hsnSetQual m n
mkModQualNm _ _ n = n
%%]

%%[1.Declaration.refname
SEM Declaration
    | Fixity
        loc             .   oprefnames 	=   @operators
    | TypeSignature
        loc             .   refnames 	=   @names
%%[[5
	| Data Newtype
		loc				.	typerefname	=	@simpletype.name
%%]
%%[[8
	| ForeignImport ForeignExport
		loc				.	refname		=	@name
%%]
%%[[9
	| Instance InstanceUseImplicitly
		loc				.	classrefname=	@name
	| Class Instance InstanceUseImplicitly
		loc				.	instancerefname
										=	@instancename
	| Class
		loc				.	classrefname=	@simpletype.name
%%]
%%[[11
	| Type
		loc				.	typerefname	=	@simpletype.name
%%]
%%]

%%[12 -1.Declaration.refname
SEM Declaration
    | Fixity
        loc             .   oprefnames 	=   map (mkModQualNm @lhs.nmLev @lhs.moduleNm) @operators
    | TypeSignature
        loc             .   refnames 	=   map (mkModQualNm @lhs.nmLev @lhs.moduleNm) @names
	| Data Newtype
		loc				.	typerefname	=	mkModQualNm @lhs.nmLev @lhs.moduleNm @simpletype.name
	| ForeignImport ForeignExport
        loc             .   refname  	=   mkModQualNm @lhs.nmLev @lhs.moduleNm @name
	| Instance InstanceUseImplicitly
		loc				.	classrefname=	mkModQualNm @lhs.nmLev @lhs.moduleNm @name
	| Class Instance InstanceUseImplicitly
		loc				.	instancerefname
										=	mkModQualNm @lhs.nmLev @lhs.moduleNm @instancename
	| Class
		loc				.	classrefname=	mkModQualNm @lhs.nmLev @lhs.moduleNm @simpletype.name
	| Type
		loc				.	typerefname	=	mkModQualNm @lhs.nmLev @lhs.moduleNm @simpletype.name
%%]

%%[1
ATTR LeftHandSide [ | | refname: HsName ]
%%]

%%[1.LeftHandSide.refname
SEM LeftHandSide
	| Function
		loc				.	refname		=	@name
	| Infix
		loc				.	refname		=	@operator
%%]

%%[12 -1.LeftHandSide.refname
SEM LeftHandSide
	| Function
		loc				.	refname		=	mkModQualNm @lhs.nmLev @lhs.moduleNm @name
	| Infix
		loc				.	refname		=	mkModQualNm @lhs.nmLev @lhs.moduleNm @operator
%%]

%%[1.Type.refname
SEM Type
	| Constructor
		loc				.	refname		=	@name
%%]

%%[1
SEM Expression
	| Variable Constructor
%%[[7
	  RecordConstruction
%%]
		loc				.	refname		=	@name
%%]

%%[1.Pattern.refname
SEM Pattern
	| Variable Constructor As
		loc				.	refname		=	@name
	| InfixConstructor
		loc				.	refname		=	@constructorOperator
%%]

%%[12 -1.Pattern.refname
SEM Pattern
	| Variable As
		loc				.	refname		=	mkModQualNm @lhs.nmLev @lhs.moduleNm @name
	| Constructor
		loc				.	refname		=	@name
	| InfixConstructor
		loc				.	refname		=	@constructorOperator
%%]

%%[5
ATTR AllConstructor [ | | conrefnames USE {++} {[]} : Names ]
%%]

%%[5.Constructor.refname
SEM Constructor
    | Constructor
        loc        	 	.   conrefname  =   @constructor
    | Infix
        loc        	 	.   conrefname  =   @constructorOperator
%%[[7
SEM Constructor
    | Record
        loc        	 	.   conrefname  =   @constructor
%%]
%%]

%%[12 -5.Constructor.refname
SEM Constructor
    | Constructor Record
        loc        	 	.   conrefname  =   mkModQualNm @lhs.nmLev @lhs.moduleNm @constructor
    | Infix
        loc         	.   conrefname  =   mkModQualNm @lhs.nmLev @lhs.moduleNm @constructorOperator
%%]

%%[5
SEM Constructor
    | Constructor
        lhs        	 	.   conrefnames =   [@conrefname]
    | Infix
        lhs         	.   conrefnames =   [@conrefname]
%%[[7
SEM Constructor
    | Record
        lhs        	 	.   conrefnames =   [@conrefname]
%%]
%%]

%%[7
ATTR AllFieldDeclaration AllConstructor [ | | fldrefnames USE {++} {[]} : Names ]
%%]

%%[7.FieldDeclaration.refname
SEM FieldDeclaration
    | FieldDeclaration
        loc         	.   fldrefnames =   @names
%%]

%%[12 -7.FieldDeclaration.refname
SEM FieldDeclaration
    | FieldDeclaration
        loc         	.   fldrefnames =   map (mkModQualNm @lhs.nmLev @lhs.moduleNm) @names
%%]

%%[7
SEM RecordExpressionBinding
	| RecordExpressionBinding
        loc             .   refname 	=   @name
%%]

%%[9
SEM ContextItem
	| Class
		loc				.	refname		=	@name

SEM Deriving
	| Deriving
		loc				.	refname		=	@name
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Identifier occurrences
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[1 hs
data IdAspect
  = IdAsp_Val_Var
  | IdAsp_Val_Pat       {iaspDecl   ::  EH.Decl                         }
  | IdAsp_Val_Fun       {iaspPatL   :: [EH.PatExpr], iaspBody :: EH.Expr}
  | IdAsp_Val_Sig       {iaspDecl   ::  EH.Decl                         }
  | IdAsp_Val_Fix
  | IdAsp_Val_Con
%%[[5
  | IdAsp_Val_Fld
%%]
  | IdAsp_Type_Con
%%[[3
  | IdAsp_Type_Var
%%]
%%[[5
  | IdAsp_Type_Def      {iaspDecl   ::  EH.Decl                         }
%%]
%%[[6
  | IdAsp_Kind_Con
%%]
%%[[8
  | IdAsp_Val_FFI       {iaspDecl   ::  EH.Decl                         }
%%]
%%[[9
  | IdAsp_Class_Class
  | IdAsp_Class_Def     {iaspDecls  ::  EH.Decl                         }
  | IdAsp_Inst_Inst
  | IdAsp_Inst_Def      {iaspDecl   ::  EH.Decl, iaspClassNm :: HsName  }
  | IdAsp_Dflt_Def      {iaspDecl   ::  EH.Decl                         }
%%]
  | IdAsp_Any
%%]

%%[1 hs
instance Show IdAspect where
  show _ = "IdAspect"
%%]

%%[1 hs
instance PP IdAspect where
  pp  IdAsp_Val_Var         = pp "VAR"
  pp (IdAsp_Val_Pat _  )    = pp "PAT"
  pp (IdAsp_Val_Fun _ _)    = pp "FUN"
  pp (IdAsp_Val_Sig _  )    = pp "SIG"
  pp  IdAsp_Val_Fix         = pp "FIX"
  pp  IdAsp_Val_Con         = pp "CON"
%%[[5
  pp  IdAsp_Val_Fld         = pp "FLD"
%%]
  pp  IdAsp_Type_Con        = pp "CON"
%%[[3
  pp  IdAsp_Type_Var        = pp "VAR"
%%]
%%[[5
  pp (IdAsp_Type_Def _ )    = pp "DEF"
%%]
%%[[6
  pp  IdAsp_Kind_Con        = pp "CON"
%%]
%%[[8
  pp (IdAsp_Val_FFI _  )    = pp "FFI"
%%]
%%[[9
  pp  IdAsp_Class_Class     = pp "CLS"
  pp (IdAsp_Class_Def _)    = pp "DEF"
  pp  IdAsp_Inst_Inst       = pp "INS"
  pp (IdAsp_Inst_Def _ _)   = pp "DEF"
  pp (IdAsp_Dflt_Def _ )    = pp "DEF"
%%]
  pp  IdAsp_Any             = pp "ANY"
%%]

%%[1 hs
data IdDefOcc
  = IdDefOcc
      { doccOcc     :: IdOcc
      , doccAsp     :: IdAspect
      , doccLev     :: NmLev
      , doccRange   :: Range
      }
  deriving (Show)
%%]

%%[1 hs
doccForUse :: Maybe IdDefOcc -> Maybe NmLev
doccForUse = fmap doccLev
%%]

%%[1 hs
instance PP IdDefOcc where
  pp o = doccOcc o >|< "/" >|< doccAsp o >|< "/" >|< doccLev o

emptyIdDefOcc = IdDefOcc (IdOcc hsnUnknown IdOcc_Any) IdAsp_Any nmLevAbsent emptyRange

type IdDefOccGam = Gam    IdOcc  IdDefOcc
type IdDefOccAsc = AssocL IdOcc [IdDefOcc]
%%]

%%[9 hs
idDefOccGamPartitionByKind :: [IdOccKind] -> IdDefOccGam -> (IdDefOccAsc,IdDefOccAsc)
idDefOccGamPartitionByKind ks
  = partition (\(IdOcc n k',_) -> k' `elem` ks) . gamToAssocDupL
%%]

%%[12 hs
idDefOccGamByKind :: IdOccKind -> IdDefOccGam -> AssocL HsName IdDefOcc
idDefOccGamByKind k g = [ (n,head i) | (IdOcc n _,i) <- fst (idDefOccGamPartitionByKind [k] g) ]
%%]

%%[1 hs
mkBuiltinIdDefOcc :: HsName -> IdOccKind -> (IdOcc,IdDefOcc)
mkBuiltinIdDefOcc n k
  = (o,emptyIdDefOcc {doccOcc = o, doccLev = nmLevBuiltin, doccRange = builtinRange})
  where o = IdOcc n k

tyGam2IdDefOccGam :: TyGam -> IdDefOccGam
tyGam2IdDefOccGam = gamMap (\(n,tgi) -> mkBuiltinIdDefOcc n IdOcc_Type)

%%[[6
kiGam2IdDefOccGam :: KiGam -> IdDefOccGam
kiGam2IdDefOccGam = gamMap (\(n,kgi) -> mkBuiltinIdDefOcc n IdOcc_Kind)
%%]
%%]

%%[1 hs
data IdUseOcc
  = IdUseOcc
      { uoccOcc     :: IdOcc
      , uoccAsp     :: IdAspect
      , uoccRange   :: Range
      , uoccMbDef   :: Maybe NmLev
      }
  deriving (Show)

instance PP IdUseOcc where
  pp o = uoccOcc o >|< "/" >|< uoccMbDef o

type IdUseOccGam = Gam    IdOcc  IdUseOcc
type IdUseOccAsc = AssocL IdOcc [IdUseOcc]
%%]

%%[1 hs
splitIdUseOccGam :: Int -> IdUseOccGam -> (IdUseOccGam, IdUseOccAsc, IdUseOccAsc, IdUseOccGam)
splitIdUseOccGam level g
  = (assocDupLToGam o,h,i,assocDupLToGam e)
  where (o,h,i,e)
          = foldr
              (\x@(k,occs) (o,h,i,e)
                 -> case partition (isJust . uoccMbDef) occs of
                      (occ:_,[]) -> case compare (fromJust $ uoccMbDef $ occ) level of
                                      LT -> (x:o,  h,  i,  e)
                                      EQ -> (  o,x:h,  i,  e)
                                      GT -> (  o,  h,x:i,  e)
                      (_,(_:_))  ->         (  o,  h,  i,x:e)
              )
              ([],[],[],[])
              (gamToAssocDupL g)
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Identifier def's
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[3 hs
tvarL2IdDefOccGam :: Int -> Range -> [HsName] -> IdDefOccGam
tvarL2IdDefOccGam nmLev rng ns
  = assocLToGam [ (o,IdDefOcc o IdAsp_Type_Var nmLev rng) | n <- ns, let o = IdOcc n IdOcc_Type ]

tvarS2IdDefOccGam :: Int -> Range -> Set.Set HsName -> IdDefOccGam
tvarS2IdDefOccGam nmLev rng ns
  = tvarL2IdDefOccGam nmLev rng (Set.toList ns)
%%]

%%[1
ATTR
  AllPattern
  AllDeclaration AllFunctionBinding
  LeftHandSide
%%[[7
  AllRowRecordPatternBinding
%%]
    [ | | idOccDefGam USE {`gamAddGam`} {emptyGam} : IdDefOccGam ]
%%]

%%[1
SEM Declaration
    | TypeSignature
        loc             .   idOccDefGam =   assocLToGam [ (o,IdDefOcc o (IdAsp_Val_Sig (@mkEHSig n)) @lhs.nmLev @range) | n <- @refnames, let o = IdOcc n IdOcc_Val ]
%%[[3
                        .   idOccDefGamType
                                        =   tvarS2IdDefOccGam @nmLev @range @type.freeTvarS
%%]
    | Fixity
        loc             .   idOccDefGam =   assocLToGam [ (o,IdDefOcc o IdAsp_Val_Fix @lhs.nmLev @range) | n <- @operators, let o = IdOcc n IdOcc_Val ]
    | PatternBinding
        loc             .   idOccDef    =   IdOcc (maybe (mkHNm @lUniq) id @pattern.mbTopNm) IdOcc_Pat
                        .   idOccDefGamPat
                                        =   gamUnit @idOccDef (IdDefOcc @idOccDef (IdAsp_Val_Pat @eh) @lhs.nmLev @range)
                        .   idOccDefGam =   @idOccDefGamPat `gamAddGam` @pattern.idOccDefGam
%%]
%%[5
    | Data Newtype
        loc             .   idOccDef    =   IdOcc @typerefname IdOcc_Type
                        .   idOccDefGamType
                                        =   tvarL2IdDefOccGam @nmLev @simpletype.range @simpletype.typevariables -- ???? or from constrs itself, so implicit exists is allowed
                        .   idOccDefGamConstrs
                                        =   assocLToGam [ (o,IdDefOcc o IdAsp_Val_Con @lhs.nmLev @simpletype.range) | n <- @constructors.conrefnames, let o = IdOcc n IdOcc_Val ]
%%[[7
                                            `gamAddGam`
                                            assocLToGam [ (o,IdDefOcc o IdAsp_Val_Fld @lhs.nmLev @simpletype.range) | n <- @constructors.fldrefnames, let o = IdOcc n IdOcc_Val ]
%%]
                        .   idOccDefGam =   gamUnit @idOccDef (IdDefOcc @idOccDef (IdAsp_Type_Def @eh) @lhs.nmLev @simpletype.range)
                                            `gamAddGam` @idOccDefGamConstrs
%%]
%%[9
    | Class
        loc             .   idOccDef    =   IdOcc @classrefname IdOcc_Class
                        .   idOccDefGamType
                                        =   tvarL2IdDefOccGam @nmLev @simpletype.range @simpletype.typevariables
                        .   idOccDefGamSigAsVar
                                        =   assocLToGam [ (o,d {doccAsp = IdAsp_Val_Var}) | (o,d@(IdDefOcc _ (IdAsp_Val_Sig _) _ _)) <- gamToAssocL @where.idOccDefGam ]
                        .   idOccDefGam =   gamUnit @idOccDef (IdDefOcc @idOccDef (IdAsp_Class_Def @eh) @lhs.nmLev @simpletype.range)
                                            `gamUnion` @idOccDefGamSigAsVar
    | Instance
        loc             .   idOccDef    =   IdOcc @instancerefname IdOcc_Inst
                        .   idOccDefVal =   IdOcc @instancerefname IdOcc_Val
                        .   idOccDefGam =   assocLToGam [ (o,IdDefOcc o a @lhs.nmLev @range) | (o,a) <- [(@idOccDef,IdAsp_Inst_Def @eh @classrefname),(@idOccDefVal,IdAsp_Val_Var)] ]
    | InstanceUseImplicitly
        loc             .   idOccDef    =   IdOcc @instancerefname IdOcc_Inst
                        .   idOccDefGam =   gamUnit @idOccDef (IdDefOcc @idOccDef (IdAsp_Inst_Def @eh @classrefname) @lhs.nmLev @range)
    | Default
        loc             .   idOccDef    =   IdOcc @defaultname IdOcc_Dflt
                        .   idOccDefGam =   gamUnit @idOccDef (IdDefOcc @idOccDef (IdAsp_Dflt_Def @eh) @lhs.nmLev @range)
%%]
%%[11
    | Type
        loc             .   idOccDef    =   IdOcc @typerefname IdOcc_Type
                        .   idOccDefGam =   gamUnit @idOccDef (IdDefOcc @idOccDef (IdAsp_Type_Def @eh) @lhs.nmLev @simpletype.range)
%%]
%%[5
    | Data Newtype
%%]
%%[9
      Class
%%]
%%[11
      Type
%%]
%%[5
        loc             .   idOccDefGamInside
                                        =   assocLToGam [ (o,IdDefOcc o IdAsp_Type_Var @nmLev @simpletype.range) | n <- @simpletype.typevariables, let o = IdOcc n IdOcc_Type ]
%%]
%%[8
    | ForeignImport ForeignExport
        loc             .   idOccDefGamType
                                        =   tvarS2IdDefOccGam @lhs.nmLev @range @type.freeTvarS
    | ForeignImport
        loc             .   idOccDef    =   IdOcc @refname IdOcc_Val
                        .   idOccDefGam =   gamUnit @idOccDef (IdDefOcc @idOccDef (IdAsp_Val_FFI @eh) @lhs.nmLev @range)
%%]
%%[88
    | ForeignExport -- ??
        loc             .   idOccDef    =   IdOcc @refname IdOcc_Val
                        .   idOccDefGam =   gamUnit @idOccDef (IdDefOcc @idOccDef IdAsp_Val_Var @lhs.nmLev @range)
%%]

%%[1
SEM FunctionBinding
    | FunctionBinding
        loc             .   idOccDef    =   IdOcc @lefthandside.refname IdOcc_Val
                        .   idOccDefGam =   gamUnit @idOccDef (IdDefOcc @idOccDef (IdAsp_Val_Fun @lefthandside.eh @righthandside.eh) @lhs.nmLev @range)
%%]

%%[1
SEM Pattern
    | Variable As
        loc             .   idOccDef    =   IdOcc @refname IdOcc_Val
                        .   idOccDefGam =   gamUnit @idOccDef (IdDefOcc @idOccDef IdAsp_Val_Var @lhs.nmLev @range)
    | As
        lhs             .   idOccDefGam =   @idOccDefGam `gamAddGam` @pattern.idOccDefGam
%%[[4
    | Typed
        loc             .   idOccDefGamType
                                        =   tvarS2IdDefOccGam @lhs.nmLev @range @type.freeTvarS
%%]
%%]

%%[3
SEM Expression
    | Typed
        loc             .   idOccDefGamType
                                        =   tvarS2IdDefOccGam @lhs.nmLev @range @type.freeTvarS
%%]

%%[4
SEM Type
    | Forall Exists
        loc             .   idOccDefGamInside
                                        =   tvarL2IdDefOccGam @lhs.nmLev @range @typevariables
%%]

%%[9
SEM ContextItem
    | Forall
        loc             .   idOccDefGamInside
                                        =   tvarL2IdDefOccGam @lhs.nmLev @range @typevariables
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Identifiers in scope
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[1
ATTR AllNT [ idGam: IdDefOccGam | | ]
%%]

%%[5
ATTR
  AllQualifier
%%[[9
  Statement
%%]
    [ | | idGam: IdDefOccGam ]
%%]

%%[1.AGItf.idGam
SEM AGItf
    | AGItf
        loc             .   idGam       =   tyGam2IdDefOccGam initTyGam
%%[[6
                                            `gamUnion`
                                            kiGam2IdDefOccGam initKiGam
%%]
%%]

%%[8 -1.AGItf.idGam
ATTR AGItf [ idGam: IdDefOccGam | | ]
%%]

%%[1
SEM Body
    | Body
        loc             .   idGam       =   gamAddGam @declarations.idOccDefGam @lhs.idGam
%%]

%%[1
SEM Expression
    | Let
        loc             .   idGam       =   gamAddGam @declarations.idOccDefGam @lhs.idGam
    | Lambda
        expression      .   idGam       =   gamAddGam @patterns.idOccDefGam @lhs.idGam
%%[[3
    | Typed
        type            .   idGam       =   gamAddGam @idOccDefGamType @lhs.idGam
%%]
%%[[5
    | Comprehension
        expression      .   idGam       =   @qualifiers.idGam
        qualifiers      .   idGam       =   @lhs.idGam
%%]
%%]

%%[4
SEM Pattern
    | Typed
        type            .   idGam       =   gamAddGam @idOccDefGamType @lhs.idGam
%%]

%%[3
SEM Declaration
    | TypeSignature
        type            .   idGam       =   gamAddGam @idOccDefGamType @lhs.idGam
%%[[5
    | Data Newtype
        loc             .   idGam       =   gamAddGam @idOccDefGamType @lhs.idGam
%%]
%%[[9
    | Class
        loc             .   idGam       =   gamAddGam @idOccDefGamType @lhs.idGam
                        .   idOccDefGamInstForClass
                                        =   fst $ gamPartition (\_ d -> case doccAsp d of {IdAsp_Inst_Def _ n | n == @classrefname -> True ; _ -> False}) $ @lhs.idGam
%%]
%%]

%%[1
SEM FunctionBinding
    | FunctionBinding
        righthandside   .   idGam       =   gamAddGam @lefthandside.idOccDefGam @lhs.idGam
%%]

%%[1
SEM RightHandSide
    | Expression
%%[[5
      Guarded
%%]
        loc             .   idGam       =   gamAddGam @where.idOccDefGam @lhs.idGam
%%]

%%[5
SEM Alternative
    | Alternative
        righthandside   .   idGam       =   gamAddGam @pattern.idOccDefGam @lhs.idGam

SEM Qualifier
    | Let
        loc             .   idGam       =   gamAddGam @declarations.idOccDefGam @lhs.idGam
    | Generator
        lhs             .   idGam       =   gamAddGam @pattern.idOccDefGam @lhs.idGam
%%]

%%[9
SEM Statement
    | Let
        loc             .   idGam       =   gamAddGam @declarations.idOccDefGam @lhs.idGam
    | Generator
        lhs             .   idGam       =   gamAddGam @pattern.idOccDefGam @lhs.idGam
%%]

%%[4
SEM Type
    | Forall Exists
        loc             .   idGam       =   gamAddGam @idOccDefGamInside @lhs.idGam
%%]

%%[9
SEM ContextItem
    | Forall
        loc             .   idGam       =   gamAddGam @idOccDefGamInside @lhs.idGam
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Identifier use's: lookup+gather of uses of defs
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[1 hs
mkUseOccGam :: IdDefOccGam -> [HsName] -> IdOccKind -> IdAspect -> Range -> IdUseOccGam
mkUseOccGam idGam names kind asp rng
  = gamUnions [ mkUse idGam n kind asp rng | n <- names ]
  where mkUse idGam name kind asp rng
          = idUseOccGam
          where idOccUse    = IdOcc name kind
                mbDef       = gamLookup idOccUse idGam
                idUseOccGam = gamUnit idOccUse (IdUseOcc idOccUse asp rng (doccForUse mbDef))
%%]

%%[1
ATTR AllNT [ | | idUseOccGam USE {`gamAddGam`} {emptyGam}: IdUseOccGam ]
%%]

%%[1
SEM Expression
    | Variable
        loc             .   idAsp       =   IdAsp_Val_Var
    | Constructor
%%[[7
      RecordConstruction
%%]
        loc             .   idAsp       =   IdAsp_Val_Con
    | Variable Constructor
%%[[7
      RecordConstruction
%%]
        loc             .   idUseOccGam =   mkUseOccGam @lhs.idGam [@refname] IdOcc_Val @idAsp @range
    | Negate
        loc             .   idUseOccGam =   mkUseOccGam @lhs.idGam [hsnNegate] IdOcc_Val IdAsp_Val_Var @range
        lhs             .   idUseOccGam =   gamUnions [@idUseOccGam,@expression.idUseOccGam]
%%[[5
    | List
        loc             .   idUseOccGam =   mkUseOccGam @lhs.idGam [hsnListCons,hsnListNil] IdOcc_Val IdAsp_Val_Con @range
        lhs             .   idUseOccGam =   gamUnions [@idUseOccGam,@expressions.idUseOccGam]
    | Enum
        loc             .   idUseOccGam =   mkUseOccGam @lhs.idGam [@enumNm] IdOcc_Val IdAsp_Val_Var @range
        lhs             .   idUseOccGam =   gamUnions [@idUseOccGam,@from.idUseOccGam,@then.idUseOccGam,@to.idUseOccGam]
    | If
        loc             .   idUseOccGam =   mkUseOccGam @lhs.idGam [hsnTrue,hsnFalse] IdOcc_Val IdAsp_Val_Var @range
                                            `gamUnion` mkUseOccGam @lhs.idGam [hsnBool] IdOcc_Type IdAsp_Type_Con @range
        lhs             .   idUseOccGam =   gamUnions [@idUseOccGam,@guardExpression.idUseOccGam,@thenExpression.idUseOccGam,@elseExpression.idUseOccGam]
%%]
%%]

%%[99
SEM Literal
    | Int
        loc             .   idUseOccGam =   mkUseOccGam @lhs.idGam [hsnFromInteger] IdOcc_Val IdAsp_Val_Var @range
    | Float
        loc             .   idUseOccGam =   mkUseOccGam @lhs.idGam [hsnMkRatio,hsnFromRational] IdOcc_Val IdAsp_Val_Var @range
%%]

%%[5
SEM Qualifier
    | Guard
        loc             .   idUseOccGam =   mkUseOccGam @lhs.idGam [hsnListNil,hsnTrue,hsnFalse] IdOcc_Val IdAsp_Val_Var @range
                                            `gamUnion` mkUseOccGam @lhs.idGam [hsnBool] IdOcc_Type IdAsp_Type_Con @range
        lhs             .   idUseOccGam =   gamUnions [@idUseOccGam,@guard.idUseOccGam]
    | Generator
        loc             .   idUseOccGam =   mkUseOccGam @lhs.idGam [hsnConcatMap,hsnListNil] IdOcc_Val IdAsp_Val_Var @range
        lhs             .   idUseOccGam =   gamUnions [@idUseOccGam,@pattern.idUseOccGam,@expression.idUseOccGam]
    | Empty
        loc             .   idUseOccGam =   mkUseOccGam @lhs.idGam [hsnListCons,hsnListNil] IdOcc_Val IdAsp_Val_Var @range
%%]

%%[5
SEM GuardedExpression
    | GuardedExpression
        loc             .   idUseOccGam =   mkUseOccGam @lhs.idGam [hsnTrue,hsnFalse] IdOcc_Val IdAsp_Val_Var @range
                                            `gamUnion` mkUseOccGam @lhs.idGam [hsnBool] IdOcc_Type IdAsp_Type_Con @range
        lhs             .   idUseOccGam =   gamUnions [@idUseOccGam,@guard.idUseOccGam,@expression.idUseOccGam]
%%]

%%[1
SEM Pattern
    | Constructor
%%[[5
      InfixConstructor
%%]
        loc             .   idUseOccGam =   mkUseOccGam @lhs.idGam [@conNm] IdOcc_Val IdAsp_Val_Con @range
    | Constructor
        lhs             .   idUseOccGam =   gamUnions [@idUseOccGam,@patterns.idUseOccGam]
%%[[5
    | InfixConstructor
        lhs             .   idUseOccGam =   gamUnions [@idUseOccGam,@leftPattern.idUseOccGam,@rightPattern.idUseOccGam]
    | List
        loc             .   idUseOccGam =   mkUseOccGam @lhs.idGam [hsnListCons,hsnListNil] IdOcc_Val IdAsp_Val_Con @range
        lhs             .   idUseOccGam =   gamUnions [@idUseOccGam,@patterns.idUseOccGam]
%%]
%%]

%%[1
SEM Type
    | Constructor
        loc             .   idAsp       =   IdAsp_Type_Con
%%[[3
    | Variable NamedWildcard
        loc             .   idAsp       =   IdAsp_Type_Var
%%]
    | Constructor
%%[[3
      Variable NamedWildcard
%%]
        loc             .   idUseOccGam =   mkUseOccGam @lhs.idGam [@name] IdOcc_Type @idAsp @range
%%]

%%[9
SEM ContextItem
    | Class
        loc             .   idUseOccGam =   mkUseOccGam @lhs.idGam [@refname] IdOcc_Class IdAsp_Class_Class @range
        lhs             .   idUseOccGam =   gamUnions [@idUseOccGam,@types.idUseOccGam]

SEM Deriving
    | Deriving
        loc             .   idUseOccGam =   mkUseOccGam @lhs.idGam [@refname] IdOcc_Class IdAsp_Class_Class @range

SEM Declaration
    | Instance InstanceUseImplicitly
        loc             .   idUseOccGamInst
                                        =   mkUseOccGam @lhs.idGam [@classrefname] IdOcc_Class IdAsp_Class_Class @range
%%]

%%[9
SEM Statement
    | Expression
        loc             .   idUseOccGam =   mkUseOccGam @lhs.idGam [hsnMonadSeq] IdOcc_Val IdAsp_Val_Var @range
        lhs             .   idUseOccGam =   @idUseOccGam `gamUnion` @expression.idUseOccGam
    | Generator
        loc             .   idUseOccGam =   mkUseOccGam @lhs.idGam [hsnMonadBind,hsnMonadFail] IdOcc_Val IdAsp_Val_Var @range
        lhs             .   idUseOccGam =   gamUnions [@idUseOccGam,@pattern.idUseOccGam,@expression.idUseOccGam]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Identifier use's: splitting according to level + def'd check + dependencies
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[1 hs
type IdDpdMp = Map.Map IdOcc [IdOcc]

idDpdMpSingleton :: IdOcc -> IdOcc -> IdDpdMp
idDpdMpSingleton f t = Map.singleton f [t]

idDpdMpUnions :: [IdDpdMp] -> IdDpdMp
idDpdMpUnions = Map.unionsWith (++)

idDpdMpUnion :: IdDpdMp -> IdDpdMp -> IdDpdMp
idDpdMpUnion = Map.unionWith (++)

idToOccL2DpdMp :: [IdOcc] -> AssocL IdOcc x -> IdDpdMp
idToOccL2DpdMp fs l
  = if null ts then Map.empty else idDpdMpUnions [ Map.singleton f ts | f <- fs ]
  where ts = assocLKeys l

idToOccGam2DpdMp :: [IdOcc] -> Gam IdOcc x -> IdDpdMp
idToOccGam2DpdMp fs l
  = idToOccL2DpdMp fs (gamToAssocL l)

idFrOccGam2DpdMp :: Gam IdOcc x -> [IdOcc] -> IdDpdMp
idFrOccGam2DpdMp g ts
  = if null ts then Map.empty else idDpdMpUnions [ Map.singleton f ts | (f,_) <- gamToAssocL g ]
%%]

%%[1
ATTR AllDeclaration AllFunctionBinding [ | | idDpdMp USE {`idDpdMpUnion`} {Map.empty}: IdDpdMp ]
ATTR AllNT [ | | undefOccGam USE {`gamUnion`} {emptyGam}: IdUseOccGam ]
%%]

%%[1
SEM FunctionBinding
    | FunctionBinding
        loc             .   (idUseOccGam,idUseHereOccL,_,undefOccGam)
                                        =   splitIdUseOccGam @lhs.nmLev
                                                 (gamUnions [@lefthandside.idUseOccGam,@righthandside.idUseOccGam])
                        .   idDpdMp     =   idToOccL2DpdMp [@idOccDef] @idUseHereOccL
        lhs             .   undefOccGam =   gamUnions [@undefOccGam,@lefthandside.undefOccGam,@righthandside.undefOccGam]

SEM Declaration
    | TypeSignature
        loc             .   (idUseOccGam,idUseHereOccL,_,undefOccGam)
                                        =   splitIdUseOccGam @lhs.nmLev @type.idUseOccGam
                        .   idDpdMp     =   idToOccL2DpdMp (gamKeys @idOccDefGam) @idUseHereOccL
        lhs             .   undefOccGam =   gamUnions [@undefOccGam,@type.undefOccGam]
    | PatternBinding
        loc             .   (idUseOccGam,idUseHereOccL,_,undefOccGam)
                                        =   splitIdUseOccGam @lhs.nmLev @righthandside.idUseOccGam
                        .   idDpdMp     =   idToOccL2DpdMp [@idOccDef] @idUseHereOccL
                                            `idDpdMpUnion`
                                            idToOccL2DpdMp [@idOccDef] (gamToAssocL @pattern.idOccDefGam)
                                            `idDpdMpUnion`
                                            idFrOccGam2DpdMp @pattern.idOccDefGam [@idOccDef]
        lhs             .   undefOccGam =   gamUnions [@undefOccGam,@righthandside.undefOccGam]
%%[[5
    | Data Newtype
        loc             .   (idUseOccGam,idUseHereOccL,_,undefOccGam)
                                        =   splitIdUseOccGam @lhs.nmLev
                                                (@constructors.idUseOccGam
%%[[9
                                                 `gamUnion` @context.idUseOccGam `gamUnion` @derivings.idUseOccGam
%%]
                                                )
                        .   idDpdMp     =   idToOccL2DpdMp [@idOccDef] @idUseHereOccL
                                            `idDpdMpUnion`
                                            idFrOccGam2DpdMp @idOccDefGamConstrs [@idOccDef]
%%]
%%[[8
    | ForeignImport
        loc             .   (idUseOccGam,idUseHereOccL,_,undefOccGam)
                                        =   splitIdUseOccGam @lhs.nmLev @type.idUseOccGam
                        .   idDpdMp     =   idToOccL2DpdMp [@idOccDef] @idUseHereOccL
        lhs             .   undefOccGam =   gamUnions [@undefOccGam,@type.undefOccGam]
%%]
%%[[9
    | Class
        loc             .   (idUseOccGam,idUseHereOccL,_,undefOccGam)
                                        =   splitIdUseOccGam @lhs.nmLev
                                                (gamUnions [@context.idUseOccGam,@where.idUseOccGam])
                        .   idDpdMp     =   idDpdMpUnions
                                                [ idToOccL2DpdMp [@idOccDef] @idUseHereOccL
                                                , idToOccGam2DpdMp [@idOccDef] @idOccDefGamSigAsVar
                                                , idToOccGam2DpdMp [@idOccDef] @idOccDefGamInstForClass
                                                , idFrOccGam2DpdMp @idOccDefGamSigAsVar [@idOccDef]
                                                , @where.idDpdMp
                                                ]
        lhs             .   undefOccGam =   gamUnions [@undefOccGam,@where.undefOccGam]
    | Instance
        loc             .   (idUseOccGam,idUseHereOccL,_,undefOccGam)
                                        =   splitIdUseOccGam @lhs.nmLev
                                                (gamUnions [@idUseOccGamInst,@context.idUseOccGam,@types.idUseOccGam,@where.idUseOccGam])
                        .   idDpdMp     =   idToOccL2DpdMp [@idOccDef] @idUseHereOccL
                                            `idDpdMpUnion`
                                            idDpdMpSingleton @idOccDefVal @idOccDef
                                            `idDpdMpUnion`
                                            @where.idDpdMp
        lhs             .   undefOccGam =   gamUnions [@undefOccGam,@where.undefOccGam]
    | InstanceUseImplicitly
        loc             .   (idUseOccGam,idUseHereOccL,_,undefOccGam)
                                        =   splitIdUseOccGam @lhs.nmLev
                                                (gamUnions [@idUseOccGamInst,@types.idUseOccGam,@expression.idUseOccGam])
                        .   idDpdMp     =   idToOccL2DpdMp [@idOccDef] @idUseHereOccL
    | Default
        loc             .   (idUseOccGam,idUseHereOccL,_,undefOccGam)
                                        =   splitIdUseOccGam @lhs.nmLev @types.idUseOccGam
                        .   idDpdMp     =   idToOccL2DpdMp [@idOccDef] @idUseHereOccL
%%]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Split of class decls into sigs + value bindings
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[9
%%]
SEM Declaration
    | Class
        loc             .   (idOccDefSigGam,idOccDefValGam)
                                        =   gamPartition (\_ d -> case doccAsp d of {IdAsp_Val_Sig _ -> True ; _ -> False})
                                                         @where.idOccDefGam

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Ordering according to dependencies
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[1 hs
idDpdMp2SccOrder :: IdDefOccGam -> IdDpdMp -> [[IdOcc]]
idDpdMp2SccOrder gam mp
  = dgSCCToList gr
  where dflt = idDpdMpUnions [ idDpdMpSingleton o o | o <- gamKeys gam ] `Map.difference` mp
        gr = mkDpdGrFromEdgesMp (idDpdMpUnions [mp,dflt])
%%]

%%[1
SEM Body
    | Body
        loc             .   sccOrder    =   idDpdMp2SccOrder @declarations.idOccDefGam @declarations.idDpdMp
%%]

%%[1
SEM Expression
    | Let
        loc             .   sccOrder    =   idDpdMp2SccOrder @declarations.idOccDefGam @declarations.idDpdMp
%%]

%%[1
SEM RightHandSide
    | Expression
%%[[5
      Guarded
%%]
        loc             .   sccOrder    =   idDpdMp2SccOrder @where.idOccDefGam @where.idDpdMp
%%]

%%[5
SEM Qualifier
    | Let
        loc             .   sccOrder    =   idDpdMp2SccOrder @declarations.idOccDefGam @declarations.idDpdMp
%%]

%%[9
SEM Statement
    | Let
        loc             .   sccOrder    =   idDpdMp2SccOrder @declarations.idOccDefGam @declarations.idDpdMp
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% SCC reordered eh's (i.e. declarations)          
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[1 hs
mkIdDefEH :: IdDefOcc -> [EH.Decl]
mkIdDefEH def
  = case doccAsp def of
      IdAsp_Val_Pat decl
        -> [decl]
      IdAsp_Val_Sig decl
        -> [decl]
      IdAsp_Val_Fun lhs rhs
        -> [decl]
        where (h,t) = hdAndTl lhs
              decl  = rngLift (doccRange def) EH.Decl_Val h (foldr (rngLift (doccRange def) EH.Expr_Lam) rhs t)
%%[[5
      IdAsp_Type_Def decl
        -> [decl]
%%]
%%[[8
      IdAsp_Val_FFI decl
        -> [decl]
%%]
%%[[9
      IdAsp_Class_Def decl
        -> [decl]
      IdAsp_Inst_Def decl _
        -> [decl]
      IdAsp_Dflt_Def decl
        -> [] -- [decl]
%%]
      _ -> []
%%]

%%[1.mergeFunDefL hs
mergeFunDefL :: [IdDefOcc] -> ([IdDefOcc],[Err])
mergeFunDefL ds
  = case ds of
      [_] -> (ds,[])
      (d:_:_)
          -> ([d],[Err_NamesDupIntrod [ioccNm $ doccOcc $ d]])
      _   -> ([],[])
%%]

%%[5 -1.mergeFunDefL hs
mergeFunDefL :: [IdDefOcc] -> ([IdDefOcc],[Err])
mergeFunDefL ds
  = case ds of
      [_] -> (ds,[])
      (IdDefOcc occ (IdAsp_Val_Fun (patf:pats1) _) _ rng : _ : _)
          -> ([d],[])
          where xSz   = length pats1
                xNmL  = [ mkHNm ("x" ++ show i) | i <- [1..xSz] ]
                xPatL = map (rngLift rng EH.PatExpr_Var) xNmL
                b = EH.mkCase rng (mkRngProdOpt rng $ map (rngLift rng EH.Expr_Var) $ xNmL)
                    $ zip
                       [ mkRngProdOpt rng $ tail $ iaspPatL $ doccAsp $ d | d <- ds ]
                       [ iaspBody $ doccAsp $ d | d <- ds ]
                d = IdDefOcc occ (IdAsp_Val_Fun (patf:xPatL) b) 0 rng
      _   -> ([],[])
%%]

%%[1 hs
mkIdOccEH :: IdDefOccGam -> IdOcc -> ([EH.Decl],[Err])
mkIdOccEH idDefOccGam occ
  = case gamLookupDup occ idDefOccGam of
      Just defs
        -> (concatMap mkIdDefEH (otherDefs ++ funDef),errL)
        where (funDefs,otherDefs) = partition (\d -> case doccAsp d of {IdAsp_Val_Fun _ _ -> True ; _ -> False}) defs
              (funDef,errL) = mergeFunDefL funDefs
      _ -> ([],[])

mkIdOccSccEH :: Range -> IdDefOccGam -> Maybe [[IdOcc]] -> (EH.Expr -> EH.Expr,[[EH.Decl]],[Err])
mkIdOccSccEH r g moss
  = foldr mkl (id,[],[]) oss
  where mkl os (mke,d,e)
          = (EH.mkLet r (Just ds) . mke,ds:d,concat es ++ e)
          where (dss,es) = unzip $ map (mkIdOccEH g) $ os
                ds = concat dss
        oss = maybe [gamKeys g] id moss
%%]

%%[1
SEM Body
    | Body
        loc             .   (mkSccLet,_,errReorder)
                                        =   mkIdOccSccEH @range @declarations.idOccDefGam (Just @sccOrder)

SEM Expression
    | Let
        loc             .   (mkSccLet,_,errReorder)
                                        =   mkIdOccSccEH @range @declarations.idOccDefGam (Just @sccOrder)

SEM RightHandSide
    | Expression
%%[[5
      Guarded
%%]
        loc             .   (mkSccLet,_,errReorder)
                                        =   mkIdOccSccEH @range @where.idOccDefGam (Just @sccOrder)
%%]

%%[5
SEM Qualifier
    | Let
        loc             .   (mkSccLet,_,errReorder)
                                        =   mkIdOccSccEH @range @declarations.idOccDefGam (Just @sccOrder)
%%]

%%[9
SEM Declaration
    | Instance
        loc             .   (_,ehReorderedDecls,errReorder)
                                        =   mkIdOccSccEH @range @where.idOccDefGam Nothing
    | Class
        loc             .   (_,ehReorderedDecls,errReorder)
                                        =   mkIdOccSccEH @range @where.idOccDefGam Nothing
%%]
                        .   (_,ehReorderedSigDecls,errReorderSig)
                                        =   mkIdOccSccEH @range @idOccDefSigGam Nothing

%%[9
SEM Statement
    | Let
        loc             .   (mkSccLet,_,errReorder)
                                        =   mkIdOccSccEH @range @declarations.idOccDefGam (Just @sccOrder)
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% 'main' exists?         
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
SEM Body
    | Body
        loc             .   mainExists  =   maybe False (const True) $ gamLookup (IdOcc hsnMain IdOcc_Val) @declarations.idOccDefGam
%%]


