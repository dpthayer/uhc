DONE FULLGRIN

%%[(9 codegen grin) ag import({GrinCode/AbsSyn})
%%]

%%[(9 codegen grin).wrapper
WRAPPER GrAGItf
%%]

%%[(9 codegen grin) hs module {%{EH}GrinCode.Trf.MergeInstance} import(qualified Data.Map as Map)
%%]
%%[(9 codegen grin) hs import(Debug.Trace)
%%]
%%[(8 codegen grin) hs import(Data.Typeable(Typeable), Data.Generics(Data), {%{EH}Base.Serialize}, Control.Monad (ap))
%%]


%%[(9 codegen grin) hs import({%{EH}Base.Common}, {%{EH}Base.Builtin}, {%{EH}GrinCode.Common}, {%{EH}GrinCode}) export(grMergeInstance, InfoMergeInstance)

data InfoMergeInstance = InfoMergeInstance
  { infoClassMap :: ClassMap
  , infoDictMap  :: DictMap
  , infoArityMap :: ArityMap
  , infoSynoMap  :: SynoMap
  } deriving (Show, Data, Typeable)

instance Serialize InfoMergeInstance where
  sput gr = sput (infoClassMap gr) >> sput (infoDictMap gr) >>
            sput (infoArityMap gr) >> sput (infoSynoMap gr)
  sget    = return InfoMergeInstance `ap` sget `ap` sget `ap` sget `ap` sget


grMergeInstance :: [InfoMergeInstance] -> GrModule -> (GrModule, InfoMergeInstance)
grMergeInstance imps code
  = let inh = Inh_GrAGItf
                { startClassMaps_Inh_GrAGItf = map infoClassMap imps
                , startDictMaps_Inh_GrAGItf  = map infoDictMap  imps
                , startArityMaps_Inh_GrAGItf = map infoArityMap imps
                , startSynoMaps_Inh_GrAGItf  = map infoSynoMap  imps
                }
        syn = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf code)) inh
        inf = InfoMergeInstance
                { infoClassMap = finalClassMap_Syn_GrAGItf syn
                , infoDictMap  = finalDictMap_Syn_GrAGItf  syn
                , infoArityMap = finalArityMap_Syn_GrAGItf syn
                , infoSynoMap  = finalSynoMap_Syn_GrAGItf  syn
                }
    in (grTrf_Syn_GrAGItf syn, inf)

%%]

%%[(9 codegen grin)
ATTR GrAGItf [ | | grTrf: GrModule ]
ATTR AllNT   [ | | grTrf: SELF     ]
%%]


%%[(9 codegen grin) hs

type ClassMap = Map.Map HsName [Maybe HsName]
type DictMap  = Map.Map HsName [[HsName]]
type ArityMap = Map.Map HsName (Int, [[Int]])
type SynoMap  = Map.Map HsName HsName

%%]


%%[(9 codegen grin)

ATTR AllBind [ 
             | 
             | collectClassMap USE {`Map.union`} {Map.empty} : {ClassMap} 
               collectArityMap USE {`Map.union`} {Map.empty} : {ArityMap} 
               collectDictMap  USE {`Map.union`} {Map.empty} : {DictMap}
               newBinds        USE {++}          {[]}        : GrBindL
             ]
              
ATTR AllGlobal [ dictMap  :  {DictMap}
                 classMap :  {ClassMap}
                 arityMap :  {ArityMap}
               | 
               | collectSynoMap USE {`Map.union`} {Map.empty} : {SynoMap}
               ]

ATTR GrTag GrVal [ | | mbFunNm : {Maybe HsName} ]


ATTR GrAGItf GrModule
  [ startDictMaps  : {[DictMap]}
    startClassMaps : {[ClassMap]}
    startArityMaps : {[ArityMap]}
    startSynoMaps  : {[SynoMap]}
  |
  | finalDictMap  : {DictMap}
    finalClassMap : {ClassMap}
    finalArityMap : {ArityMap}
    finalSynoMap  : {SynoMap}
  ]


SEM GrModule
  | Mod    globalL.dictMap   = @loc.dictMap
           globalL.classMap  = @loc.classMap
           globalL.arityMap  = @loc.arityMap

           loc.classMap      = Map.unions (@loc.finalClassMap : @lhs.startClassMaps)
           loc.finalClassMap = @bindL.collectClassMap

           loc.arityMap      = Map.unions (@loc.finalArityMap : @lhs.startArityMaps)
           loc.finalArityMap = @bindL.collectArityMap
           
           loc.dictMap       = Map.unions (@loc.finalDictMap : @lhs.startDictMaps)
           loc.finalDictMap  = Map.mapKeys (\k -> (Map.findWithDefault (error ("MergeInstance: no synonym for" ++ show k ++ " in " ++ show @loc.synoMap)) k @loc.synoMap)) @bindL.collectDictMap

           loc.synoMap       = Map.unions (@loc.finalSynoMap : @lhs.startSynoMaps)
           loc.finalSynoMap  = @globalL.collectSynoMap


SEM GrBind
  | Bind    lhs.collectClassMap  =  case @annot of
                                      GrBindAnnClass xs -> Map.singleton @nm xs
                                      _                 -> Map.empty
            lhs.collectArityMap  =  case @annot of
                                      GrBindAnnOverloaded xs -> Map.singleton @nm (length @argNmL - length xs, xs )
                                      GrBindAnnClass _       -> Map.empty
                                      GrBindAnnInstance _    -> Map.empty
                                      _                      -> Map.singleton @nm (length @argNmL            , [] )



SEM GrBind
  | Bind    (lhs.newBinds
            ,lhs.collectDictMap)  =  case @annot of
                                           GrBindAnnInstance xs  -> case @argNmL of
                                                                      [] -> ([], Map.singleton @nm xs)
                                                                      _  -> ([@loc.grTrf], Map.empty)
                                           _                     -> ([@loc.grTrf], Map.empty)
  | Rec     lhs.newBinds = [GrBind_Rec @bindL.grTrf]

SEM GrBindL
  | Nil     lhs.grTrf = []
  | Cons    lhs.grTrf = @hd.newBinds ++ @tl.grTrf

SEM GrGlobal
  | Global  lhs.collectSynoMap  =  maybe Map.empty
                                         (\nm2 -> Map.singleton nm2 @nm)
                                         @val.mbFunNm                             

SEM GrTag
  | Fun     lhs.mbFunNm  =  Just @nm
  | *-Fun   lhs.mbFunNm  =  Nothing

SEM GrVal
  | Node    lhs.mbFunNm  =  if    null @fldL.grTrf
                            then  @tag.mbFunNm
                            else  Nothing
  | *-Node  lhs.mbFunNm  =  Nothing


SEM GrGlobalL
  | Cons     lhs.grTrf  =  case @hd.grTrf of
                             GrGlobal_Global nm1 (GrVal_Node (GrTag_Fun nm2) []) 
                                -> maybe @loc.grTrf
                                         (\([tagNm] : [classNm] : funDefs)
                                             ->                let dfltDefs = Map.findWithDefault (error "class not found") classNm @lhs.classMap
                                                                   arity  = length funDefs
                                                                   tagAnn = GrTagAnn arity arity
                                                                   tag    = GrTag_Con tagAnn 0 tagNm
                                                                   pairs  = mergeFields @lhs.dictMap @lhs.arityMap nm1 funDefs dfltDefs
                                                                   fields = [ v | (v, _     ) <- pairs ]
                                                                   globs  = [ g | (_, Just g) <- pairs ]
                                                                   value  = GrVal_Node tag fields
                                                                   glob   = GrGlobal_Global nm1 value
                                                               in  ( globs ++ [glob] ++ @tl.grTrf)
                                         )
                                         (Map.lookup nm1 @lhs.dictMap)                 
                             _ -> @loc.grTrf



%%]

%%[(9 codegen grin) hs

mergeFields :: DictMap -> ArityMap -> HsName -> [[HsName]] -> [Maybe HsName] -> [(GrVal, Maybe GrGlobal)]
mergeFields    dictMap    am          i         fundefs       defltdefs      =  zipWith3 (mergeField dictMap fundefs am i) [0..] fundefs defltdefs

mergeField :: DictMap -> [[HsName]] -> ArityMap -> HsName -> Int -> [HsName] -> Maybe HsName -> (GrVal, Maybe GrGlobal)
mergeField dictMap fundefs am nm k (v:vs)   _        = makeGlobal dictMap fundefs am nm k (v:vs)
mergeField dictMap fundefs am nm k _        (Just v) = makeGlobal dictMap fundefs am nm k [v]
mergeField dictMap fundefs am nm k _        Nothing  = (GrVal_Var hsnUndefined, Nothing)

makeGlobal :: DictMap -> [[HsName]] -> ArityMap -> HsName -> Int -> [HsName] -> (GrVal, Maybe GrGlobal)
makeGlobal dictMap fundefs am nm k (v:vs) 
   = case Map.lookup v am of
                        Nothing      -> (GrVal_Var v, Nothing)
                        Just (a,dss) -> let a2   = a - length vs
                                            tag  = GrTag_PApp a2 v
                                            args = map f dss
                                            f ds = selectField dictMap fundefs nm ds
                                            node = GrVal_Node tag (map GrVal_Var vs ++ args)
                                            name = hsnUniqifyStr HsNameUniqifier_GloballyUniqueDict (show k) nm -- hsnSuffix nm ('~':show k)
                                        in  (GrVal_Var name, Just (GrGlobal_Global name node))

selectField :: DictMap -> [[HsName]] -> HsName -> [Int] -> GrVal
selectField dictMap fundefs nm []     =  GrVal_Var nm
selectField dictMap fundefs nm (x:xs) =  let (a:_) = fundefs!!x
                                             b = Map.findWithDefault (error ("not found: " ++ show a ++ " being " ++ show x ++ " from " ++ show fundefs )) a dictMap
                                         in selectField dictMap (drop 2 b) a xs

%%]
