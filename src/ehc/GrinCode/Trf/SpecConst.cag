DONE FULLGRIN

%%[doesWhat doclatex

Specialize functions that are called with constant arguments

%%]




%%[(8 codegen grin) ag import({GrinCode/AbsSyn})
%%]
%%[(8 codegen grin) hs import({%{EH}Base.Common}, {%{EH}Base.Builtin}, {%{EH}GrinCode.Common}, {%{EH}GrinCode}, {%{EH}GrinCode.Trf.SubstExpr(substExpr)})
%%]
%%[(8 codegen grin) hs import(qualified Data.Map as Map, qualified Data.Set as Set, Data.Maybe)
%%]
%%[(8 codegen grin) hs import(EH.Util.Utils)
%%]

%%[(8 codegen grin)
WRAPPER GrAGItf
%%]

%%[(8 codegen grin) hs module {%{EH}GrinCode.Trf.SpecConst} export(grSpecConst,InfoSpecConst)

data InfoSpecConst = InfoSpecConst
  { infoExisting  :: Existing
  , infoConstants :: Constants
  , infoBindings  :: Bindings
  } deriving Show

grSpecConst :: [InfoSpecConst] -> GrModule -> (GrModule, InfoSpecConst)
grSpecConst imps grmod
  = let inh = Inh_GrAGItf
                 { startExisting_Inh_GrAGItf = map infoExisting  imps
                 , startConstMap_Inh_GrAGItf = map infoConstants imps
                 }
        syn = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf grmod)) inh
        inf = InfoSpecConst
                 { infoExisting  = finalExisting_Syn_GrAGItf syn
                 , infoConstants = finalConstMap_Syn_GrAGItf syn
                 , infoBindings  = allBindings_Syn_GrAGItf   syn
                 }
 
        -- Produce specialized duplicates
        bindings        = Map.unions (map infoBindings (inf : imps))
        toBeSpecialized = toBeSpecialized_Syn_GrAGItf syn
        duplics         = makeDuplics bindings toBeSpecialized

        -- Transformed GRIN without duplicates
        grTrf           = grTrf_Syn_GrAGItf syn

        -- Merge these
    in (catBindings grTrf duplics, inf)



type Existing         = Map.Map HsName (Map.Map [Maybe HsName] (Int, HsName))
type Specializable    = Map.Map HsName (Set.Set [Maybe HsName])
type ToBeSpecialized  = Existing
type Specialized      = Existing

type Constants        = Map.Map HsName GrVal
type Bindings         = Map.Map HsName GrBind


-- | Make specialized duplicates.
makeDuplics :: Map.Map HsName GrBind -> ToBeSpecialized -> [GrBind]
makeDuplics bindings = concatMap duplBinding . Map.toList
  where duplBinding (nm, mp) = concatMap (uncurry $ duplOne nm) $ Map.toList mp
        duplOne     nm       = makeDuplic (panicJust "SpecConst.makeDuplics" $ Map.lookup nm bindings)


-- | Make a specialization of a given binding called with certain constant
--   arguments. Give the new binding the specified number (in its Specialized
--   annotation) and name.
makeDuplic :: GrBind -> [Maybe HsName] -> (Int, HsName) -> [GrBind]
makeDuplic b@(GrBind_Bind nm ann args body) mbargs (i, nm2)
  = let argPairs = zip args mbargs
        args2    = [ a     | (a,Nothing) <- argPairs ]
        substi = Map.fromList [ (a,b) | (a,Just b ) <- argPairs ] 
        body2  = substExpr substi body
        ann2   = GrBindAnnSpecialized nm i mbargs
    in  [GrBind_Bind nm2 ann2 args2 body2]
makeDuplic _ _ _ = []


-- | Extend a module with extra bindings.
catBindings :: GrModule -> [GrBind] -> GrModule
catBindings (GrModule_Mod nm globl bindl tags) binds
  = GrModule_Mod nm globl (bindl ++ binds) tags


-- | Get the largest number of the existing specializations.
maxExisting :: Existing -> Int
maxExisting = maximum . (0 :) . map fst . concatMap Map.elems . Map.elems

%%]


%%[(8 codegen grin)
ATTR GrAGItf [ | | grTrf: GrModule ]
ATTR AllNT [ | | grTrf: SELF ]
%%]

%%[(8 codegen grin)

-- Collect global constants

ATTR AllGrVal AllGrTag [ | | copy: SELF ]

ATTR AllGlobal [ | | genconstMap USE {`Map.union`} {Map.empty} : {Constants} ]

SEM GrGlobal 
  | Global  lhs.genconstMap = Map.singleton @nm @val.copy

-- Distribute global constants

ATTR GrAGItf GrModule [ startConstMap : {[Constants]} | | finalConstMap : {Constants} ]

ATTR AllBind AllExpr AllGlobal [ constMap : {Constants} | | ]

SEM GrModule
  | Mod   loc.constMap      = Map.unions (@loc.finalConstMap : @lhs.startConstMap)
          loc.finalConstMap = @globalL.genconstMap

-- Collect all bindings

ATTR AllBind [ | | genbindings USE {`Map.union`} {Map.empty} : {Bindings} ]

SEM GrBind
  | Bind  lhs.genbindings = Map.singleton @nm @grTrf

ATTR GrAGItf GrModule [ | | allBindings : {Bindings} ]

SEM GrModule
  | Mod   lhs.allBindings = @bindL.genbindings


-- find the variables in a value list

ATTR GrVal  [ | | mbVar  : {Maybe HsName} ]
ATTR GrValL [ | | mbVars : {[Maybe HsName]} ]

SEM GrVal
  | Var   lhs.mbVar = Just @nm
  | *-Var lhs.mbVar = Nothing
  
SEM GrValL
  | Nil   lhs.mbVars = []
  | Cons  lhs.mbVars = @hd.mbVar : @tl.mbVars 
  

-- Collect existing specializations

ATTR AllBind [ | | collExisting USE {`mapUnionWithMapUnion`} {Map.empty} : {Existing} ]

SEM GrBind
  | Bind   lhs.collExisting  =  case @annot of
                                  GrBindAnnSpecialized nm i xs -> Map.singleton nm (Map.singleton xs (i, @nm))
                                  _                            -> Map.empty

-- Distribute existing specializations

ATTR GrModule GrAGItf [ | | finalExisting : {Existing} ]

ATTR AllBind [ existing : {Existing} | | ]

SEM GrModule
  | Mod   loc.existing    = foldr mapUnionWithMapUnion @loc.finalExisting @lhs.startExisting
          loc.finalExisting = @bindL.collExisting
          loc.firstSpecNmbr = 1 + maxExisting @loc.finalExisting


{
mapUnionWithSetUnion = Map.unionWith Set.union	
mapUnionWithMapUnion = Map.unionWith Map.union	

hasJust :: [Maybe a] -> Bool
hasJust []             = False
hasJust (Just _  : _ ) = True
hasJust (Nothing : xs) = hasJust xs
}


ATTR AllBind AllExpr AllGlobal [ | | specializableCalls USE {`mapUnionWithSetUnion`} {Map.empty} : {Specializable} ]

SEM GrExpr
  | Call  loc.args2 :                {[Maybe HsName]}
          loc.args2 =                let args = @argL.mbVars
                                         args2 = [ maybe Nothing (\arg -> if Map.member arg @lhs.constMap then  mbarg else Nothing ) mbarg  
                                                 | mbarg <- args
                                                 ]
                                     in  args2
                                     
          lhs.specializableCalls =   if hasJust @loc.args2
                                     then Map.singleton @nm (Set.singleton @loc.args2)
                                     else Map.empty
                                          
          lhs.grTrf              =   if hasJust @loc.args2
                                     then let m = fromJust (Map.lookup @nm   @lhs.specializedCalls)
                                              (_, nm2) = fromJust (Map.lookup @loc.args2 m)
                                              args3 = [ a | (a,Nothing) <- zip @argL.grTrf @loc.args2 ]
                                          in  GrExpr_Call nm2 args3
                                     else  @loc.grTrf
                                          

SEM GrVal
  | Node  loc.args2 :                {[Maybe HsName]}
          loc.args2 =                let args = @fldL.mbVars
                                         args2 = [ maybe Nothing (\arg -> if Map.member arg @lhs.constMap then  mbarg else Nothing ) mbarg
                                                 | mbarg <- args
                                                 ]
                                     in  args2
  
          lhs.specializableCalls  =  maybe Map.empty
                                           (\(nm,con,needs) -> if  hasJust @loc.args2
                                                               then -- trace ("Specnode: " ++ show nm ++ show @fldL.mbVars ++ show @loc.args2)
                                                                    (Map.singleton nm (Set.singleton (@loc.args2++replicate needs Nothing)))
                                                               else Map.empty
                                           )
                                           @tag.mbPFName
                                           
          lhs.grTrf               =  maybe @loc.grTrf
                                           (\(nm,con,needs) -> if  hasJust @loc.args2
                                                               then let m = fromJust (Map.lookup  nm        @lhs.specializedCalls)
                                                                        (_,nm2) = fromJust (Map.lookup (@loc.args2++replicate needs Nothing) m)
                                                                        args3 = [ a | (a,Nothing) <- zip @fldL.grTrf @loc.args2 ]
                                                                    in  GrVal_Node (con nm2) args3
                                                               else @loc.grTrf
                                           )
                                           @tag.mbPFName

ATTR GrTag [ | | mbPFName : {Maybe (HsName, HsName->GrTag, Int)} ]

SEM GrTag
  |     Fun        lhs . mbPFName = Just ( @nm, GrTag_Fun        , 0      )
  |     PApp       lhs . mbPFName = Just ( @nm, GrTag_PApp @needs, @needs )
  | * - Fun PApp   lhs . mbPFName = Nothing


-- Collecting and distributing of the different kinds of specialization maps.

ATTR AllBind AllExpr AllGlobal [ specializedCalls : {Specialized} | | ]

ATTR GrAGItf GrModule
  [ startExisting : {[Existing]}
  |
  | toBeSpecialized : {ToBeSpecialized}
  ]

SEM GrModule
  | Mod   globalL.specializedCalls = @loc.allSpec
          bindL  .specializedCalls = @loc.allSpec

          -- All needed specializations.
          loc.specializable        = mapUnionWithSetUnion @globalL.specializableCalls @bindL.specializableCalls

          -- All specialized functions that have to be made.
          loc.toBeSpecialized      = numberSpecs @moduleNm @loc.firstSpecNmbr $ specNonExisting @loc.specializable @loc.existing

          -- All specialized functions that are or will be available.
          loc.allSpec              = mapUnionWithMapUnion @loc.existing @loc.toBeSpecialized

          lhs.grTrf                = @loc.grTrf


{

-- | Remove existing specializations from the set of specializable calls.
specNonExisting :: Specializable -> Existing -> Specializable
specNonExisting = Map.differenceWith diff
  where diff s mp | Set.null ns = Nothing
                  | otherwise   = Just ns
                  where ns = s Set.\\ Map.keysSet mp


-- | Number and name all specializations.
numberSpecs :: HsName -> Int -> Specializable -> ToBeSpecialized
numberSpecs modNm start1 = snd . Map.mapAccumWithKey nrSet start1
  where nrSet start nm set
          = let list          = Set.toList set
                (nrs, (nw:_)) = splitAt (length list) [start..]
                names         = map (\i -> (i, hsnSuffix nm ("~spec~" ++ show modNm ++ "~" ++ show i))) nrs
            in  (nw, Map.fromList $ zip list names)

}



%%]

