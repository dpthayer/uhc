%%[doesWhat doclatex

Specialize functions that are called with constant arguments

%%]




%%[(8 codegen grin) ag import({GrinCode/AbsSyn})
%%]
%%[(8 codegen grin) hs import({%{EH}Base.Common}, {%{EH}Base.Builtin}, {%{EH}GrinCode.Common}, {%{EH}GrinCode}, {%{EH}GrinCode.Trf.SubstExpr(substExpr)})
%%]
%%[(8 codegen grin) hs import(qualified Data.Map as Map, qualified Data.Set as Set, Data.Maybe)
%%]
%%[(8 codegen grin) hs import(EH.Util.Utils)
%%]

%%[(8 codegen grin)
WRAPPER GrAGItf
%%]

%%[(8 codegen grin) hs module {%{EH}GrinCode.Trf.SpecConst} export(specConst)
specConst :: [GrModule] -> GrModule -> GrModule
specConst imports grmod
  = let ext    = existingSpecs grmod
        exts   = Map.unionsWith Map.union (ext : map existingSpecs imports)
        consts = Map.unionsWith (panic "SpecConst.specConst: constants")
                  $ map allConsts   (grmod : imports)
        binds  = Map.unionsWith (panic "SpecConst.specConst: bindings")
                  $ map allBindings (grmod : imports)

        syn    = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf grmod))
                         (Inh_GrAGItf
                          { startExisting_Inh_GrAGItf = exts
                          , startSpecNmbr_Inh_GrAGItf = maxExisting ext + 1
                          , startConstMap_Inh_GrAGItf = consts
                          })

        -- Produce specialized duplicates
        toBeSpecialized = toBeSpecialized_Syn_GrAGItf syn
        duplics         = makeDuplics binds toBeSpecialized

        -- Transformed GRIN without duplicates
        grTrf           = grTrf_Syn_GrAGItf syn

        -- Merge these
    in catBindings grTrf duplics



type Existing         = Map.Map HsName (Map.Map [Maybe HsName] (Int, HsName))
type Specializable    = Map.Map HsName (Set.Set [Maybe HsName])
type ToBeSpecialized  = Existing
type Specialized      = Existing

type Constants        = Map.Map HsName GrVal
type Bindings         = Map.Map HsName GrBind


-- | Make specialized duplicates.
makeDuplics :: Map.Map HsName GrBind -> ToBeSpecialized -> [GrBind]
makeDuplics bindings = concatMap duplBinding . Map.toList
  where duplBinding (nm, mp) = concatMap (uncurry $ duplOne nm) $ Map.toList mp
        duplOne     nm       = makeDuplic (panicJust "SpecConst.makeDuplics" $ Map.lookup nm bindings)


-- | Make a specialization of a given binding called with certain constant
--   arguments. Give the new binding the specified number (in its Specialized
--   annotation) and name.
makeDuplic :: GrBind -> [Maybe HsName] -> (Int, HsName) -> [GrBind]
makeDuplic b@(GrBind_Bind nm ann args body) mbargs (i, nm2)
  = let argPairs = zip args mbargs
        args2    = [ a     | (a,Nothing) <- argPairs ]
        substi = Map.fromList [ (a,b) | (a,Just b ) <- argPairs ] 
        body2  = substExpr substi body
        ann2   = GrBindAnnSpecialized nm i mbargs
    in  [GrBind_Bind nm2 ann2 args2 body2]
makeDuplic _ _ _ = []


-- | Extend a module with extra bindings.
catBindings :: GrModule -> [GrBind] -> GrModule
catBindings (GrModule_Mod nm globl bindl tags) binds
  = GrModule_Mod nm globl (bindl ++ binds) tags


-- | Get the largest number of the existing specializations.
maxExisting :: Existing -> Int
maxExisting = maximum . (0 :) . map fst . concatMap Map.elems . Map.elems


-- | Collect all existing specialized functions from a module.
existingSpecs :: GrModule -> Existing
existingSpecs (GrModule_Mod _ _ bindl _) = Map.unionsWith Map.union $ map ex bindl
  where ex (GrBind_Bind nm ann args bod)
          = case ann of
              GrBindAnnSpecialized nmOrig num argsSpec -> Map.singleton nmOrig (Map.singleton argsSpec (num,nm))
              _                                        -> Map.empty
        ex _
          = Map.empty
  -- TODO we don't look into GrBind_Rec, because we always put specialized
  -- functions on the top level. This might we wrong.


-- | Collect all bindings in a convenient Map.
allBindings :: GrModule -> Bindings
allBindings (GrModule_Mod _ _ bindl _) = allBindings' bindl
  where allBindings' = Map.unionsWith (panic "SpecConst.allBindings") . map al
        al b@(GrBind_Bind nm _ _ _) = Map.singleton nm b
        al b@(GrBind_Rec  bl      ) = allBindings' bl
        al _                        = Map.empty


-- | Collect all constants.
allConsts :: GrModule -> Constants
allConsts (GrModule_Mod _ globl _ _) = Map.unionsWith (panic "SpecConst.allConsts") $ map cs globl
  where cs (GrGlobal_Global nm val)  = Map.singleton nm val


%%]


%%[(8 codegen grin)
ATTR GrAGItf [ | | grTrf: GrModule ]
ATTR AllNT [ | | grTrf: SELF ]
%%]

%%[(8 codegen grin)

-- Distribute global constants

ATTR AllBind AllExpr AllGlobal [ constMap : {Constants} | | ]

ATTR GrAGItf GrModule [ startConstMap : {Constants} | | ]

SEM GrModule
  | Mod   globalL.constMap  = @lhs.startConstMap
          bindL.constMap    = @lhs.startConstMap


-- find the variables in a value list

ATTR GrVal  [ | | mbVar  : {Maybe HsName} ]
ATTR GrValL [ | | mbVars : {[Maybe HsName]} ]

SEM GrVal
  | Var   lhs.mbVar = Just @nm
  | *-Var lhs.mbVar = Nothing
  
SEM GrValL
  | Nil   lhs.mbVars = []
  | Cons  lhs.mbVars = @hd.mbVar : @tl.mbVars 
  


{
mapUnionWithSetUnion = Map.unionWith Set.union	
mapUnionWithMapUnion = Map.unionWith Map.union	

hasJust :: [Maybe a] -> Bool
hasJust []             = False
hasJust (Just _  : _ ) = True
hasJust (Nothing : xs) = hasJust xs
}


ATTR AllBind AllExpr AllGlobal [ | | specializableCalls USE {`mapUnionWithSetUnion`} {Map.empty} : {Specializable} ]

SEM GrExpr
  | Call  loc.args2 :                {[Maybe HsName]}
          loc.args2 =                let args = @argL.mbVars
                                         args2 = [ maybe Nothing (\arg -> if Map.member arg @lhs.constMap then  mbarg else Nothing ) mbarg  
                                                 | mbarg <- args
                                                 ]
                                     in  args2
                                     
          lhs.specializableCalls =   if hasJust @loc.args2
                                     then Map.singleton @nm (Set.singleton @loc.args2)
                                     else Map.empty
                                          
          lhs.grTrf              =   if hasJust @loc.args2
                                     then let m = fromJust (Map.lookup @nm   @lhs.specializedCalls)
                                              (_, nm2) = fromJust (Map.lookup @loc.args2 m)
                                              args3 = [ a | (a,Nothing) <- zip @argL.grTrf @loc.args2 ]
                                          in  GrExpr_Call nm2 args3
                                     else  @loc.grTrf
                                          

SEM GrVal
  | Node  loc.args2 :                {[Maybe HsName]}
          loc.args2 =                let args = @fldL.mbVars
                                         args2 = [ maybe Nothing (\arg -> if Map.member arg @lhs.constMap then  mbarg else Nothing ) mbarg
                                                 | mbarg <- args
                                                 ]
                                     in  args2
  
          lhs.specializableCalls  =  maybe Map.empty
                                           (\(nm,con,needs) -> if  hasJust @loc.args2
                                                               then -- trace ("Specnode: " ++ show nm ++ show @fldL.mbVars ++ show @loc.args2)
                                                                    (Map.singleton nm (Set.singleton (@loc.args2++replicate needs Nothing)))
                                                               else Map.empty
                                           )
                                           @tag.mbPFName
                                           
          lhs.grTrf               =  maybe @loc.grTrf
                                           (\(nm,con,needs) -> if  hasJust @loc.args2
                                                               then let m = fromJust (Map.lookup  nm        @lhs.specializedCalls)
                                                                        (_,nm2) = fromJust (Map.lookup (@loc.args2++replicate needs Nothing) m)
                                                                        args3 = [ a | (a,Nothing) <- zip @fldL.grTrf @loc.args2 ]
                                                                    in  GrVal_Node (con nm2) args3
                                                               else @loc.grTrf
                                           )
                                           @tag.mbPFName

ATTR GrTag [ | | mbPFName : {Maybe (HsName, HsName->GrTag, Int)} ]

SEM GrTag
  |     Fun        lhs . mbPFName = Just ( @nm, GrTag_Fun        , 0      )
  |     PApp       lhs . mbPFName = Just ( @nm, GrTag_PApp @needs, @needs )
  | * - Fun PApp   lhs . mbPFName = Nothing


-- Collecting and distributing of the different kinds of specialization maps.

ATTR AllBind AllExpr AllGlobal [ specializedCalls : {Specialized} | | ]

ATTR GrAGItf GrModule
  [ startSpecNmbr : {Int} 
    startExisting : {Existing}
  |
  | toBeSpecialized : {ToBeSpecialized}
  ]

SEM GrModule
  | Mod   globalL.specializedCalls = @loc.allSpec
          bindL  .specializedCalls = @loc.allSpec
          loc.specializable        = mapUnionWithSetUnion @globalL.specializableCalls @bindL.specializableCalls
          loc.toBeSpecialized      = numberSpecs @moduleNm @lhs.startSpecNmbr $ specNonExisting @loc.specializable @loc.allExist
          loc.allExist             = @lhs.startExisting
          loc.allSpec              = mapUnionWithMapUnion @loc.allExist @loc.toBeSpecialized
          lhs.toBeSpecialized      = @loc.toBeSpecialized

          lhs.grTrf                = @loc.grTrf


{

-- | Remove existing specializations from the set of specializable calls.
specNonExisting :: Specializable -> Existing -> Specializable
specNonExisting = Map.differenceWith diff
  where diff s mp | Set.null ns = Nothing
                  | otherwise   = Just ns
                  where ns = s Set.\\ Map.keysSet mp


-- | Number and name all specializations.
numberSpecs :: HsName -> Int -> Specializable -> ToBeSpecialized
numberSpecs modNm start1 = snd . Map.mapAccumWithKey nrSet start1
  where nrSet start nm set
          = let list          = Set.toList set
                (nrs, (nw:_)) = splitAt (length list) [start..]
                names         = map (\i -> (i, hsnSuffix nm ("~spec~" ++ show modNm ++ "~" ++ show i))) nrs
            in  (nw, Map.fromList $ zip list names)

}



%%]

