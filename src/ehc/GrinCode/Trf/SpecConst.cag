%%[doesWhat doclatex

Specialize functions that are called with constant arguments

%%]




%%[(8 codegen grin) ag import({GrinCode/AbsSyn})
%%]
%%[(8 codegen grin) hs import({%{EH}Base.Common}, {%{EH}Base.Builtin}, {%{EH}GrinCode.Common}, {%{EH}GrinCode}, {%{EH}GrinCode.Trf.SubstExpr(substExpr)})
%%]
%%[(8 codegen grin) hs import(qualified Data.Map as Map, qualified Data.Set as Set, Data.Maybe)
%%]
%%[(8 codegen grin) hs import(EH.Util.Utils)
%%]

%%[(8 codegen grin)
WRAPPER GrAGItf
%%]

%%[(8 codegen grin) hs module {%{EH}GrinCode.Trf.SpecConst} export(specConst)
specConst :: [GrModule] -> GrModule -> GrModule
specConst imports grmod
  = let ext    = existingSpecs grmod
        exts   = Map.unionsWith Map.union (ext : map existingSpecs imports)
        maxNr  = maximum (0 : concatMap Map.elems (Map.elems ext))
        consts = Map.unionsWith (panic "SpecConst.specConst: constants")  $ map allConsts   (grmod : imports)
        binds  = Map.unionsWith (\a b -> panic $ "SpecConst.specConst: bindings: " ++ show a ++ " " ++ show b ++ " | " ++ show grmod ++ "/" ++ show imports)   $ map allBindings (grmod : imports)
        t = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf grmod))
                         (Inh_GrAGItf
                          { startExisting_Inh_GrAGItf = exts
                          , startSpecNmbr_Inh_GrAGItf = maxNr + 1
                          , startConstMap_Inh_GrAGItf = consts
                          })
        toBeSpec   = toBeSpec_Syn_GrAGItf t
        duplicates = concatMap (uncurry dupl) $ Map.toList toBeSpec
        dupl nm mp = concatMap (uncurry $ makeDuplic (fakeBind nm $ Map.lookup nm binds)) $ Map.toList mp
    in plakBindings (grTrf_Syn_GrAGItf t) duplicates


fakeBind :: HsName -> Maybe GrBind -> GrBind
fakeBind _ (Just b) = b
fakeBind nm Nothing = GrBind_Bind fakenm GrBindAnnNormal (map fakearg [0..]) (GrExpr_Throw fakenm)
  where fakenm    = hsnSuffix nm "~fake"
        fakearg i = hsnSuffix nm ("~fakearg!" ++ show i)

plakBindings :: GrModule -> [GrBind] -> GrModule
plakBindings (GrModule_Mod nm globl bindl iets) binds
  = GrModule_Mod nm globl (bindl ++ binds) iets

existingSpecs :: GrModule -> Existing
existingSpecs (GrModule_Mod _ _ bindl _) = Map.unionsWith Map.union $ map ex bindl
  where ex (GrBind_Bind nm ann args bod)
          = case ann of
              GrBindAnnSpecialized nmOrig num argsSpec -> Map.singleton nm (Map.singleton argsSpec num)
              _                                        -> Map.empty
        ex _
          = Map.empty
  -- GrBind_Rec ?

allBindings :: GrModule -> Map.Map HsName GrBind
allBindings (GrModule_Mod _ _ bindl _) = allBindings' bindl
  where allBindings' = Map.unionsWith (panic "SpecConst.allBindings") . map al
        al b@(GrBind_Bind nm _ _ _) = Map.singleton nm b
        al b@(GrBind_Rec  bl      ) = allBindings' bl
        al _                        = Map.empty

allConsts :: GrModule -> Constants
allConsts (GrModule_Mod _ globl _ _) = Map.unionsWith (panic "SpecConst.allConsts") $ map cs globl
  where cs (GrGlobal_Global nm val)  = Map.singleton nm val


type Existing  = Map.Map HsName (Map.Map [Maybe HsName] Int)
type Constants = Map.Map HsName GrVal
type Specialized = Existing
type Specializable = Map.Map HsName (Set.Set [Maybe HsName])

%%]


%%[(8 codegen grin)
ATTR GrAGItf [ | | grTrf: GrModule ]
ATTR AllNT [ | | grTrf: SELF ]
%%]

%%[(8 codegen grin)

-- collect global constants

ATTR AllBind AllExpr AllGlobal [ constMap : {Constants} | | ]

ATTR GrAGItf GrModule [ startConstMap : {Constants} | | ]

SEM GrModule
  | Mod   globalL.constMap  = @lhs.startConstMap
          bindL.constMap    = @lhs.startConstMap


-- find the variables in a value list

ATTR GrVal  [ | | mbVar  : {Maybe HsName} ]
ATTR GrValL [ | | mbVars : {[Maybe HsName]} ]

SEM GrVal
  | Var   lhs.mbVar = Just @nm
  | *-Var lhs.mbVar = Nothing
  
SEM GrValL
  | Nil   lhs.mbVars = []
  | Cons  lhs.mbVars = @hd.mbVar : @tl.mbVars 
  

-- distribute existing specializations

ATTR AllBind [ existing : {Existing} | | ]

ATTR GrAGItf GrModule [ startExisting : {Existing} | | ]


-- collect specializable calls


{
mapUnionWithSetUnion = Map.unionWith Set.union	
mapUnionWithMapUnion = Map.unionWith Map.union	

hasJust :: [Maybe a] -> Bool
hasJust []             = False
hasJust (Just _  : _ ) = True
hasJust (Nothing : xs) = hasJust xs
}


ATTR AllBind AllExpr AllGlobal [ | | specializableCalls USE {`mapUnionWithSetUnion`} {Map.empty} : {Specializable} ]

SEM GrExpr
  | Call  loc.args2 :                {[Maybe HsName]}
          loc.args2 =                let args = @argL.mbVars
                                         args2 = [ maybe Nothing (\arg -> if Map.member arg @lhs.constMap then  mbarg else Nothing ) mbarg  
                                                 | mbarg <- args
                                                 ]
                                     in  args2
                                     
          lhs.specializableCalls =   if hasJust @loc.args2
                                     then Map.singleton @nm (Set.singleton @loc.args2)
                                     else Map.empty
                                          
          lhs.grTrf              =   if hasJust @loc.args2
                                     then let m = fromJust (Map.lookup @nm   @lhs.specializedCalls)
                                              i = fromJust (Map.lookup @loc.args2 m)
                                              nm2 = hsnSuffix @nm ("~spec" ++ show i)
                                              args3 = [ a | (a,Nothing) <- zip @argL.grTrf @loc.args2 ]
                                          in  GrExpr_Call nm2 args3
                                     else  @loc.grTrf
                                          

SEM GrVal
  | Node  loc.args2 :                {[Maybe HsName]}
          loc.args2 =                let args = @fldL.mbVars
                                         args2 = [ maybe Nothing (\arg -> if Map.member arg @lhs.constMap then  mbarg else Nothing ) mbarg
                                                 | mbarg <- args
                                                 ]
                                     in  args2
  
          lhs.specializableCalls  =  maybe Map.empty
                                           (\(nm,con,needs) -> if  hasJust @loc.args2
                                                               then -- trace ("Specnode: " ++ show nm ++ show @fldL.mbVars ++ show @loc.args2)
                                                                    (Map.singleton nm (Set.singleton (@loc.args2++replicate needs Nothing)))
                                                               else Map.empty
                                           )
                                           @tag.mbPFName
                                           
          lhs.grTrf               =  maybe @loc.grTrf
                                           (\(nm,con,needs) -> if  hasJust @loc.args2
                                                               then let m = fromJust (Map.lookup  nm        @lhs.specializedCalls)
                                                                        i = fromJust (Map.lookup (@loc.args2++replicate needs Nothing) m)
                                                                        nm2 = hsnSuffix nm ("~spec" ++ show i)
                                                                        args3 = [ a | (a,Nothing) <- zip @fldL.grTrf @loc.args2 ]
                                                                    in  GrVal_Node (con nm2) args3
                                                               else @loc.grTrf
                                           )
                                           @tag.mbPFName

ATTR GrTag [ | | mbPFName : {Maybe (HsName, HsName->GrTag, Int)} ]

SEM GrTag
  |     Fun        lhs . mbPFName = Just ( @nm, GrTag_Fun        , 0      )
  |     PApp       lhs . mbPFName = Just ( @nm, GrTag_PApp @needs, @needs )
  | * - Fun PApp   lhs . mbPFName = Nothing



ATTR AllBind AllExpr AllGlobal [ specializedCalls : {Specialized} | | ]

ATTR GrAGItf GrModule [ startSpecNmbr : {Int} | | toBeSpec : {Specialized} ]

SEM GrModule
  | Mod   globalL.specializedCalls = @loc.allSpec
          bindL  .specializedCalls = @loc.allSpec
          loc.specializable = mapUnionWithSetUnion @globalL.specializableCalls @bindL.specializableCalls
          loc.toBeSpec      = numberSpecs @lhs.startSpecNmbr $ specNonExisting @loc.specializable @loc.allExist
          loc.allExist      = @lhs.startExisting
          loc.allSpec       = mapUnionWithMapUnion @loc.allExist @loc.toBeSpec
          lhs.toBeSpec      = @loc.toBeSpec

          lhs.grTrf = -- trace ("existing: " ++ show @bindL.collExisting ++ "\nspecializable: " ++ show @loc.spc) 
                      @loc.grTrf

{
specNonExisting :: Specializable -> Existing -> Specializable
specNonExisting = Map.differenceWith diff
  where diff s mp | Set.null ns = Nothing
                  | otherwise   = Just ns
                  where ns = s Set.\\ Map.keysSet mp

-- mapAccum :: (a -> b -> (a, c)) -> a -> Map k b -> (a, Map k c)

numberSpecs :: Int -> Specializable -> Existing
numberSpecs start1 = snd . Map.mapAccum nrSet start1
  where nrSet start set
          = let list          = Set.toList set
                (nrs, (nw:_)) = splitAt (length list) [start..]
            in  (nw, Map.fromList $ zip list nrs)

-- numberSpecs start = number . concatMap (uncurry one) . Map.toList
--   where one nm = zip (repeat nm) . Set.toList
--         number = zipWith (\(a,b) i -> (a,(b,i))) [start..]
-- 
-- numberSpecs start = Map.map toMap
--   where toMap = Map.fromList . flip zip [start..] . Set.toList


numberset :: (Ord a, Show a) => (Map.Map HsName (Map.Map a Int)) -> HsName -> Set.Set a -> Map.Map a Int	
numberset exi nm s =  let p = Map.findWithDefault Map.empty nm exi
                          q = Set.filter (\e -> maybe True (const False) (Map.lookup e p)) s
                          n = if Map.null p then 1 else 1 + maximum (Map.elems p)
                          r = Map.fromList (zip (Set.toList q) [n..])
                      in  -- trace ("numberset " ++ show nm ++ show p ++ show r) 
                                (Map.union p r)
}


{
-- makeDuplics :: Existing -> Specialized -> GrBind -> [GrBind]
-- makeDuplics existing infomap b@(GrBind_Bind nm ann args body)
--   =  let  -- mbmap = Map.lookup nm infomap
--           -- pairs  = maybe [] Map.toAscList mbmap
--           pairs = Map.toAscList (Map.findWithDefault Map.empty nm infomap)
--           exi   = Map.findWithDefault Map.empty nm existing
--      in   [  let nm2   = hsnSuffix nm ("~spec" ++ show i)
--                  argPairs = zip args mbargs
--                  args2  =              [ a     | (a,Nothing) <- argPairs ]
--                  substi = Map.fromList [ (a,b) | (a,Just b ) <- argPairs ] 
--                  body2  = substExpr substi body
--                  ann2   = GrBindAnnSpecialized nm i mbargs
--              in  GrBind_Bind nm2 ann2 args2 body2
--           |  (mbargs, i) <- pairs
--           ,  Map.notMember mbargs exi 
--           ]
-- makeDuplics existing infomap b@(GrBind_Rec bs) = []

makeDuplic :: GrBind -> [Maybe HsName] -> Int -> [GrBind]
makeDuplic b@(GrBind_Bind nm ann args body) mbargs i
  = let nm2 = hsnSuffix nm ("~spec" ++ show i)
        argPairs = zip args mbargs
        args2    = [ a     | (a,Nothing) <- argPairs ]
        substi = Map.fromList [ (a,b) | (a,Just b ) <- argPairs ] 
        body2  = substExpr substi body
        ann2   = GrBindAnnSpecialized nm i mbargs
    in  [GrBind_Bind nm2 ann2 args2 body2]
makeDuplic _ _ _ = []

}



%%]

