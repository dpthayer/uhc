%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Inline
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[doesWhat doclatex

Replace references to global values with their actual code.
Use of the following are inlined:
one-time used functions and values, if not exported;
wrappers for primitives (to allow their inline replacement with operators);
wrappers for constructors;
small enough functions (not yet done).

Requires FlattenSeq to be the next transformation.

%%]

Implementation:
Free vars are gathered and passed topdown via 'fviMp', bound to a count
and type of usage. Based on this inline candidates are selected, passed
in 'inlMp'. Inlined names are returned in 'gathInlNmS' and passed in
'inlNmS' which determines whether a binding can be removed, together
with other criteria (not exported).

Tricky:
Recursive inlining is accomplished by letting 'inlMp' holding
transformed code. A bit of cycle, so only non mutual recursive values
are allowed to participate. Inlining mutual recursive values would lead
to a loop.

%%[(8 codegen grin) ag import({GrinCode/AbsSyn})
%%]

%%[(8 codegen grin) hs module {%{EH}GrinCode.Trf.Inline}
%%]

%%[(8 codegen grin) hs import(qualified EH.Util.FastSeq as Seq,qualified Data.Set as Set,qualified Data.Map as Map,Data.Maybe)
%%]

%%[(8 codegen grin) hs import({%{EH}Base.Builtin}, {%{EH}Base.Common}, {%{EH}GrinCode.Common}, {%{EH}GrinCode})
%%]

%%[(20 codegen grin) hs import({%{EH}GrinCode.FreeVars})
%%]

-- for debugging:
%%[(8 codegen grin) hs import(EH.Util.Pretty,EH.Util.Utils)
%%]

%%[(8 codegen grin) hs import({%{EH}GrinCode.Trf.AliasRename})
%%]

%%[(8 codegen grin) hs import(qualified {%{EH}Config} as Cfg)
%%]

%%[(8 codegen grin) ag import({GrinCode/Trf/CommonAliasAG}, {GrinCode/Trf/CommonFreeVar}, {GrinCode/Trf/CommonWillEval})
%%]

%%[(8 codegen grin).grInline hs export(grInline)
grInline :: Bool -> GrModule -> (Maybe GrModule)
grInline allow grmod
  = if Map.null (gathInlMp_Syn_GrAGItf t) then Nothing else Just (trf_Syn_GrAGItf t)
  where t = wrap_GrAGItf (sem_GrAGItf $ GrAGItf_AGItf grmod)
            $ Inh_GrAGItf
                { allowOmitBind_Inh_GrAGItf = allow
                }
            
%%]

-- for debugging:
%%[(8 codegen grin) hs import(EH.Util.Pretty,EH.Util.Utils)
%%]
%%[(8 codegen grin) hs import({%{EH}Base.Debug})
%%]

--Added
%%[(8 codegen grin) hs import(qualified Data.Graph as Graph,qualified Data.Tree as Tree,qualified Debug.Trace as Trace,Data.List)
%%]

%%[(8 codegen grin) ag import({GrinCode/InsideCase})
%%]
                       

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Wrapper
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin).wrapper
WRAPPER GrAGItf
%%]

%%[(20 codegen grin) -8.grInline hs export(grInline)
grInline :: Bool -> HsNameS -> GrInlMp -> GrModule -> (Maybe GrModule,GrInlMp)
grInline allow expNmS inlMp grmod
  = (if (not (changed_Syn_GrAGItf t)) then Nothing else Just (trf_Syn_GrAGItf t)
    ,gathInlMp_Syn_GrAGItf t)
  where t = wrap_GrAGItf (sem_GrAGItf $ GrAGItf_AGItf grmod)
            $ Inh_GrAGItf
                { expNmS_Inh_GrAGItf = expNmS
                , inlMp_Inh_GrAGItf = inlMp
                , allowOmitBind_Inh_GrAGItf = allow
                }
%%]

There is a cyclic dependency, but it is by design:

*** UU.AG warning  ***
problem  : Direct circular dependency pattern for inherited attribute inlMp
            and synthesized attribute gathInlMp of nonterminal GrBindL
pattern  : see help
help     : The following attributes formed the cycle:
           GrModule.Mod, inherited attribute bindL.inlMp ("build/8/lib-grinc/GRIN8/GrinCode/Trf/Inline.ag"(line 92, column 33))
           GrBindL.Cons, inherited attribute lhs.inlMp
           GrBindL.Cons, inherited attribute hd.inlMp ("build/8/lib-grinc/GRIN8/GrinCode/Trf/Inline.ag"(line 54, column 26))
           GrBind.Bind, inherited attribute lhs.inlMp
           GrBind.Bind, inherited attribute expr.inlMp ("build/8/lib-grinc/GRIN8/GrinCode/Trf/Inline.ag"(line 54, column 26))
           GrExpr.App, inherited attribute lhs.inlMp
           GrExpr.App, synthesized attribute lhs.trf ("build/8/lib-grinc/GRIN8/GrinCode/Trf/Inline.ag"(line 152, column 22))
           GrBind.Bind, synthesized attribute expr.trf
           GrBind.Bind, synthesized attribute lhs.gathInlMp ("build/8/lib-grinc/GRIN8/GrinCode/Trf/Inline.ag"(line 57, column 22))
           GrBindL.Cons, synthesized attribute hd.gathInlMp
           GrBindL.Cons, synthesized attribute lhs.gathInlMp ("build/8/lib-grinc/GRIN8/GrinCode/Trf/Inline.ag"(line 53, column 20))
           GrModule.Mod, synthesized attribute bindL.gathInlMp
           GrModule.Mod, inherited attribute bindL.inlMp ("build/8/lib-grinc/GRIN8/GrinCode/Trf/Inline.ag"(line 92, column 33))

%%[(8 codegen grin)
PRAGMA nocycle
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Globally used vars
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(20 codegen grin)
ATTR GrAGItf GrModule AllBind [ expNmS: HsNameS | | ]
ATTR GrAGItf AllNT  [ | | changed USE {||} {False} : {Bool} ]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Introduced global names
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(20 codegen grin)
ATTR AllBind [ | | introNmS USE {`Set.union`} {Set.empty}: {Set.Set HsName} ]

SEM GrBind
  | Bind        lhs         .   introNmS        =   Set.singleton @nm
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Free var, usage info
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin)
ATTR AllBind [ fviMp: FvInfoMp | | ]

SEM GrModule
  | Mod         bindL       .   fviMp           =   @bindL.gathFviMp
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Will eval defined here because could not be factored out
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin)
SEM GrBind
  | Bind        expr        .   willUseFor      =   Set.empty
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Control whether omitting of bindings is allowed
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin)
ATTR GrAGItf GrModule AllBind [ allowOmitBind : {Bool} | | ]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Inlining recursive functions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin)
{

toNode nm nms = (nm,nm,nms)

-- Find the loopbreaker for inlining recursive functions, but don't loop.
-- TODO topological sorting. Fix the right scc instead of arbitrary.
-- TODO heuristic for choosing loopbreaker.
type GraphData = [(HsName, HsName, [HsName])]       
calcLoopBreakers :: GraphData -> [HsName]
calcLoopBreakers graph = 
    let sccs :: [[HsName]]
        sccs = map Graph.flattenSCC (Graph.stronglyConnComp graph)
        isDirectRecursive name = let (a,b,edges) = fromJust (find (\(name2,_,_) -> name == name2) graph)
                                 in  elem name edges
        nonTrivialSccs = filter (\l -> length l > 1 || isDirectRecursive (head l) ) sccs
        loopBreaker = head (head nonTrivialSccs)                   
    in  if    (null nonTrivialSccs)
        then  []
        else  let newGraph = map (map3 (filter (/= loopBreaker))) graph
                  map3 f (a,b,c) = (a,b,f c)
                  validEdge (a,b) = b /= loopBreaker 
              in  (loopBreaker : calcLoopBreakers newGraph)
}

ATTR AllBind [ | | dependencies USE {++} {[]}: {[(HsName,[HsName])]} ]
ATTR AllBind [ loopBreakers: {[HsName]} | |  ]
ATTR AllBind [ inhBindingNames : {[HsName]} |  |  ]
ATTR AllBind [  |  | synBindingNames USE {++} {[]} : {[HsName]} ]

SEM GrModule | Mod  bindL.loopBreakers    = []
                    bindL.inhBindingNames = []

SEM GrBind
  | Bind    lhs.dependencies        = (\d -> Trace.trace ("bindingNames = " ++ show @lhs.inhBindingNames 
                                        -- ++ "\ngathMp = " ++ show @loc.gathFviMp 
                                        ++ "\ndependencies = " ++ show d) d) $
                                        [(@nm,filter (\name -> Map.member name @gathFviMp) @lhs.inhBindingNames)]
            lhs.synBindingNames     = [@nm]
  | Rec     bindL.loopBreakers      = (\b -> Trace.trace ("\nrecursive bind found,names are:\n" ++ show @bindL.synBindingNames
                                        ++ "\n loopbreakers are:" ++ show b) b) $
                                      let graphData = map (\(nm,dependency) -> toNode nm dependency) @bindL.dependencies
                                      in  (calcLoopBreakers graphData) ++ @lhs.loopBreakers
            bindL.inhBindingNames   = @bindL.synBindingNames
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Inlineable functions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin)
ATTR AllBind [ | | gathInlMp USE {`Map.union`} {Map.empty}: GrInlMp ]
ATTR AllGrExpr AllBind [ inlMp: GrInlMp | | ]

-- CAF: Constant applicative function, a function without parameters, for example Pi.
--J: make the descision to inline a binding or not.
-- CAF's are treated special, because the can easily result in work duplication
-- for example: costly calculation of PI.

SEM GrBind
  | Bind  (lhs.gathInlMp,loc.omitBind)    
              =  let  isLoopBreaker = elem @nm @lhs.loopBreakers
                 in   case Map.lookup @nm @lhs.fviMp of
                        -- a once used function can be inlined and its binding removed
                        Just (FvInfo 1 use)
                          -- once used, not CAF and not exported
                          | not @isCAF
                            && FvUse_Call `Set.member` use
%%[[20
                            && not (@nm `Set.member` @lhs.expNmS)         -- only inline if not exported as global value
                            -- inline possible but keep the bind. (Code duplication).
%%]]                                                          
                            -> (Map.singleton @nm (GrInl_Call @argNmL @expr.trf isLoopBreaker), True)
                        Just (FvInfo 1 use)                               -- a once used, evaluated value can be inlined and its binding removed
                          | @isCAF
                            && willUseForEval @nm @expr.willUseForMp
                            && FvUse_Val `Set.member` use
%%[[20
                            && not (@nm `Set.member` @lhs.expNmS)         -- only inline if not exported as global value
%%]]
                            -> (Map.singleton @nm (GrInl_CAF @expr.trf isLoopBreaker), True)
                        _ | not @isCAF
                        -- bindings that are used once or more and that aren't a CAF.
                        -- TODO: improve this descision for inlining bindings which are used more than once
                          -- for example:
                          -- - how many time used (if possible)
                          -- - determine the cost of the function   (with heuristics?)
                          -- - How important is the usage: highorder functions? arguments to recursive groups?
                          -- - Not inline all cases if used more than once?
                            && (  @expr.isFFIWrapper                  -- wrappers are inlined
                               || @expr.isConWrapper
                               || @expr.inlineCost <= 10              -- and low cost values as well
                               )
                               -- TODO: This is now only the size, so only code-duplication is only looked at, not work duplication.
                            -> (Map.singleton @nm (GrInl_Call @argNmL @expr.trf isLoopBreaker), False)    --False because the bind is used more often.
                          | otherwise

                            -> (Map.empty, False) -- don't inline
                                                  
%%]

%%[(8 codegen grin)
ATTR GrExpr [ | | isFFIWrapper USE {||} {False}: Bool ]

SEM GrExpr
  | FFI         lhs         .   isFFIWrapper    =   True
%%]

%%[(8 codegen grin)
ATTR GrExpr [ | | isConWrapper: Bool ]

SEM GrExpr
  | Unit         lhs        .   isConWrapper    =   True
  | * - Unit     lhs        .   isConWrapper    =   False
%%]

%%[(8 codegen grin)
ATTR AllGrExpr [ | | inlineCost USE {+} {1}: Int ]
%%]

%%[(8 codegen grin).inlMp.init
SEM GrModule
  | Mod         bindL       .   inlMp           =   @bindL.gathInlMp
%%]

%%[(20 codegen grin) hs
inlMayExport :: HsNameS -> HsNameS -> HsName -> GrInl -> Bool
inlMayExport onlyInThisModule expNmS n inl
  = case inl of
      GrInl_Call _ e _
        -> n `Set.member` expNmS
           && Set.null (onlyInThisModule `Set.intersection` Map.keysSet (grFreeVars e))
      _ -> False
%%]

%%[(20 codegen grin) -8.inlMp.init
ATTR GrAGItf GrModule [ inlMp: GrInlMp | | gathInlMp: GrInlMp ]

SEM GrModule
  | Mod         bindL       .   inlMp           =   @bindL.gathInlMp `Map.union` @lhs.inlMp
                lhs         .   gathInlMp       =   let onlyInThisModule = @bindL.introNmS `Set.difference` @lhs.expNmS
                                                    in  Map.filterWithKey (inlMayExport onlyInThisModule @lhs.expNmS) @bindL.gathInlMp
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Which names are inlined
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin)
ATTR AllGrExpr AllBind [ | | gathInlNmS USE {`Set.union`} {Set.empty}: FvS ]
ATTR AllBind [ inlNmS: FvS | | ]

SEM GrModule
  | Mod         loc         .   inlNmS          =   @bindL.gathInlNmS
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% GrVal as name
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin)
ATTR AllGrVal [ | | asNmL USE {++} {[]}: {[Maybe HsName]} ]

SEM GrVal
  | Var         lhs         .   asNmL           =   [Just @nm]
  | * - Var     lhs         .   asNmL           =   [Nothing]
  
-- TODO: How to handle NodeAdapt?
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Inside a CAF?
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin)
ATTR AllGrExpr [ isCAF: Bool | | ]

SEM GrBind
  | Bind        loc         .   isCAF           =   null @argNmL
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Uniq
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin)
ATTR AllGrExpr AllBind [ | uniq: Int | ]

SEM GrExpr
  | Call		lhs			.	uniq			=	@lhs.uniq+1

SEM GrModule
  | Mod         loc         .   uniq            =   0
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Transformation: inline
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin)
ATTR GrAGItf [ | | trf: GrModule ]
ATTR AllNT [ | | trf: SELF ]
%%]

%%[(8 codegen grin) hs
inlGrVar :: GrInlMp -> [HsName] -> (GrExpr -> GrExpr,FvS)
inlGrVar inlMp nmL
  = (foldr (.) id mks,Set.unions inls)
  where inl nm = case Map.lookup nm inlMp of
                   Just (GrInl_CAF e _) -> (GrExpr_Seq e (GrPatLam_Var nm),Set.singleton nm)
                   _ -> (id,Set.empty)
        (mks,inls) = unzip $ map inl nmL

inlNmsAreInlineable :: [Maybe HsName] -> Bool
inlNmsAreInlineable = and . map isJust

inlRename :: Int -> [Maybe HsName] -> [HsName] -> GrExpr -> GrExpr
inlRename uniq asFrom as e
  = grAliasRename (Just $ (`hsnSuffix` show uniq)) (mkNmAliasMp $ zip as (map fromJust asFrom)) e
%%]
  = grAliasRename (Map.fromList $ zipWith (\a n -> (a,NmAlias_Nm n)) as (map fromJust asFrom)) e

%%[(8 codegen grin)
SEM GrExpr
  | Call        loc         .   (grVarTrf,grVarInlNmS)
                                                =   if @lhs.isCAF
                                                    then inlGrVar @lhs.inlMp (Map.keys @argL.gathFviMp)
                                                    else (id,Set.empty)
%%]

%%[(8 codegen grin)
SEM GrExpr
  | Call        (lhs.trf,loc.gathInlNmS,lhs.changed)  
                    =   case Map.lookup @nm @lhs.inlMp of
                              Just (GrInl_Call as e lb) | inlNmsAreInlineable @argL.asNmL 
                                                          && (not lb || 
                                                            ((if @lhs.insideCase 
                                                            then Trace.trace ("\ndidn't inline cause of insideCase: " ++ show @lhs.insideCase) 
                                                            else id) $
                                                            not @lhs.insideCase))
                                -> Trace.trace ("inlining call " ++ show @nm) $
                                   ( @grVarTrf $ inlRename @lhs.uniq @argL.asNmL as e
                                   , Set.insert @nm @grVarInlNmS
                                   , True)
                              _ -> (@grVarTrf @trf, @grVarInlNmS, False)
  | App         (lhs.trf,loc.gathInlNmS,lhs.changed)        
                  =   if @lhs.isCAF
                      then let (grVarTrf,grVarInlNmS) = inlGrVar @lhs.inlMp (@nm : Map.keys @argL.gathFviMp)
                           in  (grVarTrf @trf, grVarInlNmS, True)
                      else (@trf, Set.empty, False)
  | Eval        (lhs.trf,loc.gathInlNmS,lhs.changed)        
                  =   case Map.lookup @nm @lhs.inlMp of
                          Just (GrInl_CAF e lb) | @lhs.isCAF && not lb
                            -> (e, Set.singleton @nm, True)
                          _ -> (@trf, Set.empty, False)
%%]

%%[(8 codegen grin)
ATTR AllBind [ | | trfSq USE {Seq.:++:} {Seq.empty}: {Seq.FastSeq GrBind} ]

SEM GrModule
  | Mod         lhs         .   trf             =   GrModule_Mod @moduleNm @globalL.trf (Seq.toList @bindL.trfSq) @tagsMp

SEM GrBind
  | Bind        lhs         .   trfSq           =   if @lhs.allowOmitBind && @loc.omitBind && @nm `Set.member` @lhs.inlNmS
                                                    then Seq.empty
                                                    else Seq.singleton @trf
  | Rec         lhs         .   trfSq           =   Seq.singleton $ GrBind_Rec $ Seq.toList @bindL.trfSq
%%]
