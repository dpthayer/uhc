%%[doesWhat doclatex

Traverse a Grin-program it and collect constraint equations which characterize the abstract values of all variables.
Then solve the equations, and return the resulting abstract environment: the \emph{HptMap}.
As an additional Int result, return the number of iterations that it took to solve the equations.

This is not a transformation, but a phase that establishes the HPT table.
%%]

%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]
%%[(8 codegen grin) ag import({GrinCode/AbsSyn})
%%]
%%[(8 codegen grin).wrapper
WRAPPER GrAGItf
%%]
%%[(8 codegen grin) hs module {%{EH}GrinCode.PointsToAnalysis}
%%]
%%[(8 codegen grin) hs import(qualified Data.Map as Map, qualified Data.Set as Set, Data.Maybe, Data.List(transpose, union), Data.Monoid, Data.Array(assocs))
%%]
%%[(8 codegen grin) hs import({%{EH}Base.Common}, {%{EH}GrinCode})
%%]
%%[(8 codegen grin) hs import({%{EH}GrinCode.Common}, {%{EH}GrinCode.SolveEqs})
%%]
%%[(8 codegen grin) hs import(Debug.Trace, EH.Util.Utils (panicJust))
%%]
%%[(8 codegen grin) hs import(Data.Typeable(Typeable), Data.Generics(Data), {%{EH}Base.Binary}, {%{EH}Base.Serialize}, Control.Monad (ap))
%%]


%%[(8 codegen grin) hs export(heapPointsToAnalysis, PartialHptResult, FinalHptResult(..), VarMap)

data PartialHptResult = PartialHptResult
  { partialEquations   :: EquationsG    HsName
  , partialLimitations :: LimitationsG  HsName
  , partialParamMap    :: ParamMap      HsName
  , partialHptMap      :: PartialHptMap HsName
  } deriving (Show, Data, Typeable)

instance Binary PartialHptResult where
  put res = do
    put $ partialEquations   res
    put $ partialLimitations res
    put $ partialParamMap    res
    put $ partialHptMap      res
  get = return PartialHptResult `ap` get `ap` get `ap` get `ap` get

instance Serialize PartialHptResult where
  sput = sputPlain
  sget = sgetPlain

type ParamMap var = Map.Map var [var]

mergePHR :: PartialHptResult -> PartialHptResult -> PartialHptResult
mergePHR p1 p2 = PartialHptResult
  { partialEquations   = union (partialEquations p1) (partialEquations p2)
  , partialLimitations = union (partialLimitations p1) (partialLimitations p2)
  , partialParamMap    = Map.union (partialParamMap p1) (partialParamMap p2)
  , partialHptMap      = Map.unionWith mappend (partialHptMap p1) (partialHptMap p2)
  }

instance Monoid PartialHptResult where
  mempty = PartialHptResult
    { partialEquations   = []
    , partialLimitations = []
    , partialParamMap    = Map.empty
    , partialHptMap      = Map.empty
    }
  mappend = mergePHR


data FinalHptResult = FinalHptResult
  { finalHptMap :: HptMap
  , finalVarMap :: VarMap
  } deriving (Show, Data, Typeable)

-- instance Serialize FinalHptResult where
--   sput res = do
--     sput $ finalHptMap res
--     sput $ finalVarMap res
--   sget = return FinalHptResult `ap` sget `ap` sget


type VarMap   = Map.Map HsName  Int
type NameMap  = Map.Map Int     HsName

mkVarMap :: PartialHptMap HsName -> (Int, VarMap)
mkVarMap = Map.mapAccum num 0
  where num i _ = (succ i, i)

mkNameMap :: VarMap -> NameMap
mkNameMap = Map.fromList . map swap . Map.toList
  where swap (a,b) = (b,a)

convertHptMap :: (Show a, Ord a, Ord b) =>
                  Map.Map a b -> PartialHptMap a -> PartialHptMap b
convertHptMap mp = Map.map (mapAbstractValue conv) . Map.mapKeys conv
  where conv = forceLookup mp

convertEquations :: (Show a, Ord a) =>
                    Map.Map a b -> EquationsG a -> EquationsG b
convertEquations mp = fmap (fmap conv)
  where conv = forceLookup mp

convertParamMap :: (Show a, Ord a, Ord b) =>
                    Map.Map a b -> ParamMap a -> ParamMap b
convertParamMap mp = Map.map (map conv) . Map.mapKeys conv
  where conv = forceLookup mp

forceLookup :: (Ord a, Show a) => Map.Map a b -> a -> b
forceLookup mp a
  = panicJust ("PointsToAnalysis.forceLookup: no entry for " ++ show a)
    $ Map.lookup a mp

{-
Main module entry point:
-}

heapPointsToAnalysis :: String -> [PartialHptResult] -> GrModule -> (Int, PartialHptResult, FinalHptResult)
heapPointsToAnalysis modNm imps grmod
  = let -- combine imported stuff
        infoImps = mconcat imps
        
        -- traverse the tree
        inh = Inh_GrAGItf
          { startParamMap_Inh_GrAGItf = partialParamMap infoImps
          }
        syn = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf grmod)) inh
        
        -- get synthesized attributes
        allVars     = allVars_Syn_GrAGItf syn
        info        = PartialHptResult
          { partialEquations   = equations_Syn_GrAGItf syn
          , partialLimitations = limitations_Syn_GrAGItf syn
          , partialParamMap    = finalParamMap_Syn_GrAGItf syn
          , partialHptMap      = Map.fromList $ map (\v -> (v, AbsBottom)) $ Set.toList allVars
          }

        allInfo     = info `mappend` infoImps
        
        (len, varMap) = mkVarMap (partialHptMap allInfo)
        equations     = convertEquations varMap (partialEquations allInfo)
        hptMapStart   = convertHptMap varMap    (partialHptMap allInfo)
        -- hptArray      = array (0, len - 1) (Map.toList hptMapStart)

        -- limitations = limitations_Syn_GrAGItf syn
        -- lenEnv      = maxVar_Syn_GrAGItf syn + 1
        -- useCountMap = Map.filter (>1) (useCountMap_Syn_GrAGItf syn)
        -- multiplyUsed = map fst (Map.toList useCountMap)
        multiplyUsed    = []  -- TODO
        limitations     = []  -- TODO
        parMap          = convertParamMap varMap (partialParamMap allInfo)

        -- now solve the equations
        (iters, hptMapSolved) = solveEquations modNm len multiplyUsed equations limitations varMap parMap hptMapStart
        hptMapSolvedP = convertHptMap (mkNameMap varMap) $ Map.fromList $ assocs hptMapSolved

        infoFinal       = info { partialHptMap = hptMapSolvedP }
        final           = FinalHptResult
          { finalHptMap = hptMapSolved
          , finalVarMap = varMap
          }
        
    in  (iters, infoFinal, final)


-- partialHPTAnalysis :: String -> [PartialHptResult] -> GrModule -> (Int, PartialHptResult)
-- partialHPTAnalysis modNm imps grmod
--   = let  (iters, info, _, _) = heapPointsToAnalysis modNm imps grmod
--     in   (iters, info)

%%]

%%%%%%%%%%%%%%%%%%%%%
%% Main attributes %%
%%%%%%%%%%%%%%%%%%%%%
%%[(8 codegen grin)
{- 
The overall goal is to collect equations that express
what constraints variables satisfy.
-}

ATTR GrAGItf GrModule AllDef AllGrExpr [ | | equations   USE {++} {[]} : {EquationsG HsName}
                                             limitations USE {++} {[]} : {LimitationsG HsName}
                                       ]


{
mapUnionWithPlus :: Map.Map HsName Int -> Map.Map HsName Int -> Map.Map HsName Int
mapUnionWithPlus = Map.unionWith (+)
}

ATTR GrAGItf GrModule AllDef AllExpr   [ | | useCountMap USE {`mapUnionWithPlus`} {Map.empty} : {Map.Map HsName Int} ]

ATTR GrExpr [ | | isEval : {Bool} ]

SEM GrExpr
   | Eval   lhs.isEval = True
   | *-Eval lhs.isEval = False

SEM GrVal
  | Var      lhs.useCountMap = Map.singleton @nm 1
  
SEM GrExpr
  | Eval     lhs.useCountMap = Map.singleton @nm 1
  | Seq      lhs.useCountMap = if @expr.isEval
                               then Map.unionWith const @expr.useCountMap @body.useCountMap
                               else Map.unionWith (+)   @expr.useCountMap @body.useCountMap


ATTR AllGrPat
     AllGrExpr
     AllBind
     AllGlobal
     GrModule
     GrAGItf   [ | | allVars USE {`Set.union`} {Set.empty} : {Set.Set HsName} ]

SEM GrVar
  | Var    lhs . allVars =  Set.singleton @nm

SEM GrPatAlt
  | Node   lhs . allVars =  Set.fromList @fldL
  
SEM GrGlobal
  | Global lhs . allVars =  Set.singleton @nm

SEM GrBind
  | Bind   lhs . allVars =  @expr.allVars `Set.union` Set.fromList (@nm : @loc.exceptVar : @argNmL)

SEM GrPatLam
  | Var
    BasicNode
    EnumNode
    OpaqueNode
    PtrNode  
    BasicAnnot
    EnumAnnot
    OpaqueAnnot
    PtrAnnot     lhs . allVars = Set.singleton @nm


ATTR GrAGItf [ startParamMap : {ParamMap HsName} | | finalParamMap : {ParamMap HsName} ]

SEM GrAGItf
  | AGItf  lhs.equations = [ IsEqual x y
                           | (funnm, args) <- @module.allCalls
                           , let parnms = panicJust "PointsToAnalysis.GrAGItf.equations"
                                          $ Map.lookup funnm @loc.finalParamMap
                           , (x, Just y) <- zip parnms args
                           ]
                           ++  @module.equations

           loc.finalParamMap = Map.union @module.paramMap @lhs.startParamMap
%%]

%%[(8 codegen grin)
ATTR AllGrVal AllGrTag  [ | | self : SELF ]
%%]




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% value and pattern nodes  %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%[(8 codegen grin) hs
-- A grin value is either a single variable or a complete node denotation (with known tag)
data NodeInfo a 
  =  InVar   HsName 
  |  InNode  GrTag [a]
  |  InBasic HsName
  |  InEnum  HsName [GrTag]
  |  InPtr   HsName
  deriving Show
  
fromInVar :: NodeInfo a -> HsName
fromInVar (InVar v)  = v
fromInVar _          = error "HPT: Apply arguments should all be variables"  

%%]

%%[(8 codegen grin).valInfo

ATTR GrBindL GrBind GrExpr GrPatLam GrAltL GrAlt [ tagsMp : {Map.Map HsName [GrTag]} | | ] 


ATTR GrVal             [ | | valInfo : { NodeInfo (Maybe HsName) }  var   : { Maybe HsName } ]
ATTR GrValL            [ | | valsInfo: {[NodeInfo (Maybe HsName)]}  vars  : {[Maybe HsName]} ]
ATTR GrPatAlt GrPatLam [ | | patInfo : { NodeInfo        HsName  }  tag   : { Maybe GrTag}     ]
ATTR GrVar             [ | | tag     : GrTag                          var   : { HsName }       ]
ATTR GrVarL            [ | | headTag : GrTag                          vars  : {[HsName]}       ]


SEM GrModule
  | Mod        bindL.tagsMp = @tagsMp

SEM GrVal
  | Tag        lhs.valInfo  =  InNode  @tag.self []
  | Var        lhs.valInfo  =  InVar   @nm
  | Node       lhs.valInfo  =  InNode  @tag.self @fldL.vars
  | BasicNode  lhs.valInfo  =  InNode  @tag.self [Just @nm]
  | EnumNode   lhs.valInfo  =  InEnum  @nm []
  | OpaqueNode lhs.valInfo  =  InNode  GrTag_Unboxed [Just @nm]
  | PtrNode    lhs.valInfo  =  InPtr   @nm
  | Empty
    LitInt
    LitStr
    VarNode
%%[[10
    NodeAdapt 
%%]]
              lhs.valInfo  =  error $ "HPT: valinfo: " ++ show @loc.self ++ " has no known tag"
              

SEM GrValL
  | Cons      lhs.valsInfo  =  @hd.valInfo : @tl.valsInfo
  | Nil       lhs.valsInfo  =  []

SEM GrVal
  | Var      lhs.var  =  Just @nm
  | * - Var  lhs.var  =  Nothing

SEM GrValL
  | Cons     lhs.vars  =  @hd.var : @tl.vars
  | Nil      lhs.vars  =  []

SEM GrPatAlt
  | LitInt     lhs.patInfo  =  error "HPT: patInfo: literal"
  | Tag        lhs.patInfo  =  InNode @tag.self []
               lhs.tag      =  Just @tag.self
  | Node       lhs.patInfo  =  InNode @tag.self @fldL
               lhs.tag      =  Just @tag.self
  | Otherwise  lhs.patInfo  =  error "HPT: patInfo: Otherwise"
%%[[10
  | NodeSplit  lhs.patInfo  =  error "HPT: patInfo: nodesplit"
%%]]
  | * - Tag Node lhs.tag =  Nothing

SEM GrPatLam
  | Empty      lhs.patInfo  =  InVar wildcardNm
  | Var        lhs.patInfo  =  InVar @nm
  | VarNode    lhs.patInfo  =  InNode (@fldL.headTag) (tail @fldL.vars)
               lhs.tag      =  Just @fldL.headTag
  | BasicNode
    BasicAnnot lhs.patInfo  =  InBasic @nm
  | OpaqueNode
    OpaqueAnnot lhs.patInfo =  InBasic @nm
  | EnumNode    lhs.patInfo =  InEnum @nm []   -- any tag is possible
  | EnumAnnot   lhs.patInfo =  InEnum @nm (Map.findWithDefault (error ("PointsToAnalysis: EnumAnnot " ++ show @tycon ++ " not found")) @tycon @lhs.tagsMp)
  | PtrNode     lhs.patInfo =  InPtr  @nm
  | PtrAnnot    lhs.patInfo =  maybe (InPtr  @nm) 
                                     -- only show the error, don't stop (debugging)
                                     -- (error "PointsToAnalysis: cant analyze FFI returning pointer") 
                                     (trace ("PointsToAnalysis: can't analyze FFI returning pointer: " ++ show @tycon ++ "/" ++ show @nm) $ const $ InPtr @nm)
                                     (Map.lookup @tycon @lhs.tagsMp)
  | * - VarNode lhs.tag     =  Nothing

SEM GrVarL  
  | Cons         lhs.headTag  =  @hd.tag
  | Nil          lhs.headTag  =  error "GrVarL headtag"
  
SEM GrVarL
  | Nil          lhs.vars  =  []
  | Cons         lhs.vars  =  @hd.var : @tl.vars  

SEM GrVar
  | KnownTag     lhs.tag   =  @tag.self
  | * - KnownTag lhs.tag   =  error "GrVar tag"
  | Var          lhs.var   =  @nm
  | Ignore       lhs.var   =  wildcardNm -- TODO Was 0. Is dit een goede vervanging?
  | KnownTag     lhs.var   =  error "var taken from KnownTag"

%%]

%%[(8 codegen grin) hs

lookupTags tagsMp tycon = maybe []
                                id
                                (Map.lookup tycon tagsMp)

%%]


%%%%%%%%%%%%%%%%%%%%%%%%
%% Target Information %%
%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin).targetInformation
{- 
Target information is either:
- the variable to which an expression is bound in a Sequence
- the result of a binding
- nothing (in the body of a Case and a Catch)
-}

ATTR AllGrExpr [ targetInfo: {NodeInfo HsName} | | ]

SEM GrBind
  | Bind  expr     . targetInfo  = InVar @nm

SEM GrExpr
  | Seq    expr    . targetInfo  = @pat.patInfo
           body    . targetInfo  = @lhs.targetInfo


-- The value of the scrutinee is passed down to all alternatives
ATTR AllAlt [ valInfo: {NodeInfo (Maybe HsName)} | | ]


%%]


%%%%%%%%%%
%% Unit %%
%%%%%%%%%%
%%[(8 codegen grin).unit
{-
There are eight cases, depending on the structure of target and source
If the target is a variable, we generate a single equation for it
 - if the source is a variable as well, the equation states that they should be the same
 - if the source is a node, the equation states that the variable refers to the node
If the target is a node, we generate a list of equations: one for each variable in the target
 - if the source is a variable, selections are created
 - if the source is a node, corresponding elements are equated
Plus some special cases for InEnum and InBasic. Todo: InOpq
-}

SEM GrExpr
  | Unit 
    UpdateUnit
               loc.equations1 = case (@lhs.targetInfo, @val.valInfo) of
                                 (InVar tvar        ,  InVar svar        )  -> [IsEqual tvar svar]
                                 (InVar tvar        ,  InNode stag snms  )  -> [IsConstruction tvar stag snms Nothing]
                                 (InVar tvar        ,  InPtr svar        )  -> []  -- [IsEqual tvar svar] -- error ("PointsToAnalysis: cant copy or return the pointer " ++ show svar ++ " to " ++ show tvar)
                                 (InNode ttag tnms  ,  InVar svar        )  -> buildSelectEquations svar ttag tnms
                                 (InNode ttag tnms  ,  InNode stag snms  )  -> buildUnifyEquations  snms tnms
                                 (InVar tvar        ,  InEnum svar _     )  -> [ IsEnumeration tvar svar ]
                                 (InBasic tvar      ,  _                 )  -> [ IsBasic tvar ]
                                 (InEnum  tvar ttags,  _                 )  -> [ IsTags  tvar ttags ]
                                 (InPtr   tvar      ,  InNode stag snms  )  -> [ IsPointer tvar stag snms ]

                                 
  | UpdateUnit loc.equations2 =  [ IsEqual @nm  (fromJust @val.var) ]
  | Unit       lhs.equations  =  @loc.equations1
  | UpdateUnit lhs.equations  =  @loc.equations2 ++ @loc.equations1

                                                       
%%]
%%[(8 codegen grin).unitaux hs

buildSelectEquations :: HsName -> GrTag -> [HsName] -> EquationsG HsName
buildSelectEquations svar ttag tnms
  = [ IsSelection tvar svar i ttag
    | (tvar,i) <- zip tnms [0..]
    , tvar /= wildcardNm
    ]

buildUnifyEquations :: [Maybe HsName] -> [HsName] -> EquationsG HsName
buildUnifyEquations snms tnms
  = [ case mbSvar of
       Nothing    -> IsBasic tvar
       Just svar  -> IsEqual tvar svar
    | (tvar,mbSvar) <- zip tnms snms
    , tvar /= wildcardNm
    ]

%%]


%%%%%%%%%%%
%% Store %%
%%%%%%%%%%%
%%[(8 codegen grin).store
{-
A heap-equation is generated, which associates the heaplocation with the node to be stored.
An equation is generated, which states that the targetvariable is known to be associated with this heaplocation.
-}

{
tagFun :: GrTag -> Maybe HsName
tagFun (GrTag_Fun nm)  =  Just nm     -- track overwrite results of Fun
tagFun (GrTag_App nm)  =  Just nm     -- also track overwrite results of App
tagFun _               =  Nothing
    
}


SEM GrExpr
  | Store  lhs . equations   =  case (@lhs.targetInfo,@val.valInfo) of
                                  (InVar tvar, InNode stag snms)  -> [IsPointer tvar stag snms] ++ maybe [] (\n->[IsUpdate tvar n]) (tagFun stag)
                                  _                 -> error "HPT: destination of Store should be a variable, source a node"

{-
A global definition is similar to a Store expression
-}

SEM GrGlobal
  | Global lhs . equations   =  case @val.valInfo of
                                  InNode stag snms  -> [ IsPointer @nm stag snms ] ++ maybe [] (\n->[IsUpdate @nm n]) (tagFun stag)
                                  _                 -> error "HPT: source of Global should be a node"
%%]

%%%%%%%%%%%%%%%%%%%%%%
%% Case Alternative %%
%%%%%%%%%%%%%%%%%%%%%%
%%[(8 codegen grin).alt

ATTR AllAlt [ | | tags USE {++} {[]} : {[GrTag]} ]


ATTR GrExpr [ | | makeLimited : {GrTag->LimitationsG HsName} ]


SEM GrExpr
  | Case         lhs . limitations  =  maybe []
                                             (\v -> [ (v, @altL.tags) ])
                                             @val.var
                                       ++ @altL.limitations

  | Seq          lhs . limitations  =  (maybe []
                                              (\t -> @expr.makeLimited t)
                                              @pat.tag
                                       )
                                       ++ @expr.limitations
                                       ++ @body.limitations

  | Unit         lhs . makeLimited  =  \t -> maybe []
                                                   (\v -> [ (v, [t]) ])
                                                   @val.var
  | * - Unit     lhs . makeLimited  =  \t -> []
  
SEM GrAlt
  | Alt          lhs . tags         =  maybe []
                                             (\t -> [t])
                                             @pat.tag

{-
In every alternative,
a select-equation is generated for each variable in the pattern: the values are selected from the scrutinee
-}
SEM GrAlt
  | Alt  lhs . equations  =  case (@pat.patInfo, @lhs.valInfo) of
                               (InNode ttag tnms, InVar svar)  -> buildSelectEquations svar ttag tnms
                               (InNode ttag tnms, InNode stag snms  ) -> if ttag==stag 
                                                                         then buildUnifyEquations  snms tnms
                                                                         else []
                               (_               , InEnum _ _)  -> []
                               (pat             , val       )  -> error ("HPT: Alternative scrutinee " ++ show val ++ " must be a variable, pattern " ++ show pat ++ " a node")
                             ++ @expr.equations
       
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Fetch, Update, FetchUpdate %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%[(8 codegen grin).fetch
SEM GrExpr
  | FetchNode    lhs . equations =  case @lhs.targetInfo of
                                      InVar tvar  -> [ IsEvaluation tvar @nm tvar ]   -- TODO: third parameter is not sensible when exceptions are really used
                                      _           -> error "HPT: FetchNode target should be a variable"
  | FetchUpdate  lhs . equations =  [ IsEqual @dst @src ]
  | FetchField   lhs . equations =  case @lhs.targetInfo of
                                      InVar tvar  ->  [ IsSelection tvar @nm @offset (fromJust @mbTag) ]
                                      _           -> error "HPT: FetchField target should be a variable"
  
%%]




%%%%%%%%%%
%% Call %%
%%%%%%%%%%
%%[(8 codegen grin).call
{-
If the target is a single variable, it is required to have the same value as the function result.
If the target is a node denotation, a select-equation is generated for each variable in the node.
-}
SEM GrExpr
  | Call  loc  .  exceptions  =  hsnUniqify HsNameUniqifier_Exception @nm : @lhs.exceptions
          lhs  .  equations   =  case @lhs.targetInfo of
                                   InVar  tvar       -> [ IsEqual tvar @nm ]
                                   InNode ttag tnms  -> buildSelectEquations @nm ttag tnms
                                   InEnum tvar ttags -> [ IsTags tvar ttags ]
                                   InBasic tvar      -> [ IsBasic tvar ]
                                   InPtr  tvar       -> [ IsPointer tvar GrTag_Hole []  ]
                                   -- _                 -> error ("unknown target " ++ show @lhs.targetInfo ++ " in call to " ++ show @nm)
%%]


%%%%%%%%%%
%% FFI %%%
%%%%%%%%%%
%%[(8 codegen grin).ffi

SEM GrExpr
  | FFI  loc . nodemap   =  Map.fromList ( [ (con, if con==GrTag_Unboxed then [Set.empty] else [] ) | con <- [] {- 20080228 AD: @tagL.self -} ] )
         lhs . equations =  case @lhs.targetInfo of
                              InNode ttag tnms   -> map IsBasic tnms
                              InBasic tvar       -> [ IsBasic tvar ]
                              InEnum  tvar ttags -> [ IsTags tvar ttags ]
                              InPtr   tvar       -> [ IsPointer tvar GrTag_Hole []  ]
                              InVar   tvar       -> [ IsImpossible tvar ]
                              -- ti                 -> error ("FFI - unknown targetinfo " ++ show ti)


%%]

%%%%%%%%%%
%% Eval %%
%%%%%%%%%%
%%[(8 codegen grin).eval
{-
A single equation is generated, associating the targetvariable with the evaluation result of the function
-}
SEM GrExpr
  | Eval  lhs . equations = case @lhs.targetInfo of
                              InVar tvar         -> [ IsEvaluation tvar @nm @lhs.exceptVar ]
                              InBasic tvar       -> [ IsBasic tvar ]
                              InEnum  tvar ttags -> [ IsTags tvar ttags ]
                              InPtr tvar         -> [ IsPointer tvar GrTag_Hole []  ]
                              _                  -> error ("HPT: Eval target " ++ show @lhs.targetInfo ++ " should be a variable or Basic/Enum display")
%%]



%%%%%%%%%%%
%% Apply %%
%%%%%%%%%%%
%%[(8 codegen grin).apply
SEM GrExpr
  | App  lhs . equations = case @lhs.targetInfo of
                             InVar tvar -> [ IsApplication tvar (@nm : map fromInVar @argL.valsInfo) @lhs.exceptVar ]
                             _          -> error "HPT: Apply target should be a variable"
%%]


%%%%%%%%%%%%%%%%%%
%% Throw, Catch %%
%%%%%%%%%%%%%%%%%%
%%[(8 codegen grin).throw
SEM GrExpr
  | Throw  loc     .  exceptions =  @nm : @lhs.exceptions
           lhs     .  equations  =  case @lhs.targetInfo of
                                      InVar tvar  -> []
                                      _           -> []

  | Catch  body    . exceptions  =  []
                   . exceptVar   =  @handlerVar
           handler . exceptions  =  @lhs.exceptions
           lhs     . exceptions  =  @handler.exceptions
           loc     . exceptEqs   =  [ IsEqual @handlerVar e | e <- @body.exceptions ]
                   . handlerVar  =  @arg

SEM GrExpr
  | Catch  lhs   .  equations   =   @loc.exceptEqs ++ @body.equations ++ @handler.equations

-- Exceptions not caught in the same binding, and support for exceptions which can only found while analysing (eval calls)
ATTR AllGrExpr [ exceptVar: HsName | exceptions: {[HsName]} | ]

SEM GrBind
  | Bind  expr    . exceptions  =  []
          loc     . exceptVar   =  hsnUniqify HsNameUniqifier_Exception @nm
          loc     . exceptEqs   =  [ IsEqual @exceptVar e | e <- @expr.exceptions ]
          lhs     . equations   =  @loc.exceptEqs ++ @expr.equations
%%]


%%%%%%%%%%%%%
%% Actuals %%
%%%%%%%%%%%%%

%%[(8 codegen grin)
-- Collect all Fun, PApp and App nodes, all function parameters, and all Calls

ATTR AllGrVal AllGrExpr AllDef GrModule [ | | allCalls USE {++} {[]} : {AbstractCallListG HsName} ]
ATTR GrTag                              [ | | mbFPAnr                : {Maybe HsName}        ]
ATTR AllBind GrModule [ | | paramMap USE {`Map.union`} {Map.empty} : {ParamMap HsName} ]


SEM GrBind
  | Bind    lhs.paramMap    = Map.singleton @nm @argNmL

SEM GrVal
  |  Node   lhs . allCalls  =  maybe [] (\n->[(n, @fldL.vars)]) @tag.mbFPAnr

SEM GrExpr
  | Call    lhs . allCalls  =  [ (@nm, @argL.vars) ]

SEM GrTag
  |     Fun PApp App   lhs . mbFPAnr = Just @nm
  | * - Fun PApp App   lhs . mbFPAnr = Nothing
%%]
