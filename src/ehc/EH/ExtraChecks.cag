%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Additional checks
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Duplicate value identifier introductions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[1.dupErrs
SEM Expr
  | Let         loc         .   dupErrs             =   let  nms = assocLKeys $ gamToOnlyDups $ gamTop @decls.patValGam
                                                        in   if null nms then [] else [Err_NamesDupIntrod nms]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Obligatory type signature
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[1.sigMissErrs
SEM Decl
  | Val         loc         .   sigMissErrs         =   @nmErrs
%%]
SEM Decl
  | Val         loc         .   sigMissErrs         =   if @hasTySig then [] else [Err_MissingSig @patExpr.pp]

%%[2 -1.sigMissErrs
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Data type, field labels
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[7
SEM Decl
  | Data        loc         .   inconsistFldErrs    =   let  ft = gamToOnlyDups (@lhs.finTyCnstr |=> @constrs.fldSelGam)
                                                             wrong tl = foHasErrs fo
                                                                      where fo = fitsInFold unifyFIOpts @fe uidStart $ map (tyArrowRes . vgiTy) $ tl
                                                             nms = [ f | (f,tl) <- ft, wrong tl ]
                                                        in   if null nms then [] else [Err_InconsistentIntros "data field" nms]

SEM DataConstr
  | Constr      loc         .   dupErrs             =   let  nms = assocLKeys $ gamToOnlyDups @fields.fldSelGam
                                                        in   if null nms then [] else [Err_NamesDupIntrod nms]
%%]

%%[7
SEM Expr
  | DataFields  loc         .   fldMissErrs         =   case @dataFieldExpr.mbDti of
                                                          Just dti | not (Set.null m)
                                                            -> [Err_MissingDataFields (Set.toList m) (dtiConNm dti)]
                                                            where m = Map.keysSet (dtiFldMp dti) `Set.difference` Set.fromList @fldL
                                                          _ | null @dtiInFldL -> [Err_MissingAnyDataField @fldL (dgiTyNm @dgi)]
                                                            | otherwise       -> []
                            .   fldDupErrs          =   let fs = [ f | (f:_:_) <- group @fldL ]
                                                        in  if null fs then [] else [Err_DuplicateDataFields fs]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Predicates
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[9 hs
checkClNms :: HsNameS -> [Err]
checkClNms s = if Set.null s then [] else [mkErr_NamesNotIntrod "class" (Set.toList s)]
%%]

%%[9
SEM AGItf
  | AGItf       loc         .   predNotPrfErrs      =   if ehcCfgClassViaCHR @lhs.opts
                                                        then if Map.null @chrSolveMainRemCnstrMp
                                                             then []
                                                             else [Err_NotProvenPreds $ map (cpoPr . cnstrPred) $ Map.keys @chrSolveMainRemCnstrMp]
                                                        else if null @expr.gathPredL
                                                             then []
                                                             else [Err_NotProvenPreds $ map poPr $ @expr.gathPredL]

SEM Decl
  | Instance    loc         .   predNotPrfErrs      =   if null @supPrfArgPrOccL && null @prfArgPrOccL 
                                                        then []
                                                        else [Err_NotProvenPreds $ map poPr (@prfArgPrOccL ++ @supPrfArgPrOccL)]
                            .   valNoSigErrs        =   let ns = gamKeys (gamTop @decls.patValGam) \\ gamKeys @tySigGam
                                                        in  if null ns
                                                            then []
                                                            else [Err_ValWithoutSig ns]
  | InstanceIntro
                loc         .   predErrs            =   if null (ftv @prExpr.ty) then [] else [Err_TyHasFreeTVars @prExpr.ty]

SEM PrExpr
  | Class       loc         .   nmErrs              =   checkClNms @clMissNmS

SEM Expr
  | AppImpl LamImpl
                loc         .   nmErrs              =   []
  | Let         loc         .   predNotPrfErrs      =   if ehcCfgClassViaCHR @lhs.opts && not (Map.null @toAssumeNeverCnstrMp)
                                                        then [Err_NotProvenPreds $ map (cpoPr . cnstrPred) $ Map.keys @toAssumeNeverCnstrMp]
                                                        else []
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Predicates
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[95
SEM Decl
  | Instance    loc         .   derivErrs           =   let mke m = [Err_NoDerivForData @derivHdDataTy @instClsNm m]
                                                            hasFlds = any (\t -> ctagArity t > 0)
                                                        in  case ( Map.lookup @instClsNm @derivMp
                                                                 , @instVariant
                                                                 , panicJust "Decl.Instance.dataGamTagsOfTy" $ dataGamTagsOfTy (tgiTy @derivDataTGI) @lhs.dataGam
                                                                 )
                                                            of
                                                              (Nothing,InstDeriving,_)
                                                                -> [Err_NoDerivFor @tyPrExpr.pp]
                                                              (_,InstDeriving,[])
                                                                -> mke "has no constructors"
                                                              (_,InstDeriving,ctags)
                                                                | @instClsNm == ehbnClassEnum (ehcOptBuiltinNames @lhs.opts)
                                                                  && hasFlds ctags
                                                                  -> mke "has a constructor with >0 fields"
                                                              (_,InstDeriving,ctags@(_:_:_))
                                                                | @instClsNm == ehbnClassBounded (ehcOptBuiltinNames @lhs.opts)
                                                                  && hasFlds ctags
                                                                  -> mke "has >1 constructors, of which >0 with fields"
                                                              _ -> []
%%]
