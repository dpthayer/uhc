%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Pretty printed source
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[20 hs
hiNV' :: String -> HsName -> PP_Doc -> PP_Doc
hiNV' k n v = k >#< ppForHI n >-< indent 1 ("=" >#< v)

hiNV :: String -> HsName -> [PP_Doc] -> PP_Doc
hiNV k n v = hiNV' k n (ppCurlysSemisBlock v)
%%]

%%[20
ATTR AllNT AGItf [ | | pp USE {>-<} {empty} : PP_Doc ]
%%]

%%[20
SEM Module
    | Module
        lhs         .   pp          =   hiNV "module" @nm @bindings.ppL

SEM Binding
    | Stamp
        lhs         .   pp          =   let ps :: Show a => a -> PP_Doc
                                            ps = pp . show
                                            pc :: PP a => a -> PP_Doc
                                            pc = const empty -- ("--" >#<)
                                        in  hiNV "stamp" hsnUnknown
                                              [ ps @srcTimestamp        >#< pc "time of compiler build"
                                              , ps @srcSig              >#< pc "cryptographic hash of compiler sources"
                                              , ps @srcVersionMajor     >#< pc "version major"
                                              , ps @srcVersionMinor     >#< pc "version minor"
                                              , ps @srcVersionQuality   >#< pc "build stability"
                                              , ps @srcVersionSvn       >#< pc "svn of compiler build"
                                              , ps @compileFlags        >#< pc "compile flags of which difference implies recompile"
                                              , ps @hash                >#< pc "hash for faster equality check of this info, not yet used"
                                              ]
    | Fixity
        lhs         .   pp          =   hiNV "fixity" @nm [pp @prio,pp @fixity]
    | Export
        lhs         .   pp          =   hiNV' "export" hsnUnknown (ppForHI @exports)
    | Ids
        lhs         .   pp          =   hiNV "iddef" hsnUnknown (map (\(o,d) -> ppCurlysSemisBlock [ppForHI o,ppForHI d]) @idOccs)
    | Arities
        lhs         .   pp          =   hiNV "arity" hsnUnknown (map (\(n,a) -> ppCurlysSemisBlock [ppForHI n,pp a]) @idArities)
    | GrInlines
        lhs         .   pp          =   hiNV "grInline" hsnUnknown (map (\(n,(a,g)) -> ppCurlysSemisBlock [ppForHI n,ppCurlysSemisBlock $ map (ppForHI) a,ppCurly (ppForHI g)]) @inlMp)
    | Val
        lhs         .   pp          =   hiNV "value" @nm [ppForHI @ty]
    | DataCon
        lhs         .   pp          =   let ppCTag t = ppCommas [pp (ctagTag' t),pp (ctagArity t),pp (ctagMaxArity t)]
                                            ppFldMp fm = [ ppForHI f >#< "=" >#< pp o | (f,o) <- fm ]
                                        in  hiNV "data" @nm
                                              [ ppCurlysSemisBlock
                                                $ map (\(n,(t,fm)) -> ppForHI n >#< "=" >#< ppCurlysSemisBlock (ppCTag t : ppFldMp fm))
                                                $ @tags
                                              , pp @isNewtype
                                              ]
    | Ty
        lhs         .   pp          =   hiNV "type" @nm [ppForHI @ty,ppForHI @ki]
    | Class
        lhs         .   pp          =   hiNV "class" @nm [ppForHI @prToEvidTy,ppForHI @ki,ppForHI @ruleTy,ppForHI @nmEvid]
    | CHRStore
    	lhs			.	pp			=	hiNV' "chrstore" hsnUnknown $ ppCurlysSemisBlock $ map ppForHI @chrs
%%]
    | Instance
        lhs         .   pp          =   hiNV "instance" @nm @rules.ppL

%%[20
ATTR
  Bindings
    [ | | ppL: {[PP_Doc]} ]

SEM Bindings
    | Cons
        lhs         .   ppL         =   @hd.pp : @tl.ppL
    | Nil
        lhs         .   ppL         =   []
%%]
