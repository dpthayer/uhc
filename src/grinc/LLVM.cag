%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[8 hs module {%{GRIN}LLVM}
{- 
  In this module we extend the LLVM AG bindings with some normal Haskell
  data types and helper functions. Furthermore, we this module is the interface
  to the LLVM AG data and functions
   
  The following data is defined in this module:
    * Compare Operators (CmpOp)
    * Binary operators (BinOp)
    * Different type of variables (Var)
    * LLVM types (LLVMType)
    
  Note: This module is developed in a demand driven way. It is no complete
        LLVM binding library in Haskell!
-}
%%]

%%[8 hs export( LLVMModule(..), Func(..), FuncDecl(..), Stmt(..), Expression(..), Alt(..), Funcs, FuncDecls , Stmts, Alts, CmpOp(..), BinOp(..), Var(..), LLVMType(..), i64, i32, i8, i1, isGlobal, getName, getPlainName, getType, pLift, pLower, isInt, isPointer)
%%]

%%[8 import({LLVM/AbsSyn})
%%]

%%[8 hs
{- 
  LLVM Compare functions, parameter of the Compare Constructor of type
  Expression
-}
data CmpOp
  = CMPEQ
  | CMPNE
  | CMPUGT
  | CMPUGE
  | CMPULT
  | CMPULE
  | CMPSGT
  | CMPSGE
  | CMPSLT
  | CMPSLE
  deriving (Eq)

{- 
  The show instance shows the LLVM IR textual representation
-}
instance Show CmpOp where
  show CMPEQ  = "eq"
  show CMPNE  = "ne"
  show CMPUGT = "ugt"
  show CMPUGE = "uge"
  show CMPULT = "ult"
  show CMPULE = "ule"
  show CMPSGT = "sgt"
  show CMPSGE = "sge"
  show CMPSLT = "slt"
  show CMPSLE = "sle"
%%]

%%[8 hs
{- 
  LLVM Binary operators, parameter of the BinOp Constructor of type
  Expression
-}
data BinOp
  = ADD
  | SHL
  | SHR
  | AND
  | OR
  deriving (Eq)

{- 
  The show instance shows the LLVM IR textual representation
-}
instance Show BinOp where
  show ADD = "add"
  show SHL = "shl"
  show SHR = "ashr"
  show AND = "and"
  show OR  = "or"
%%]

%%[8 hs
{-
  LLVM Variables
    - GlobalVar references to variables with a global scope
    - LocalVar references to variables local for a function or parameters
    - Constant refers to an integer constant as (i64 32)
    - StrConstantant defines a string as local constant.
-}
data Var
  = GlobalVar   String LLVMType
  | LocalVar    String LLVMType
  | Constant    Int    LLVMType
  | StrConstant String LLVMType
  deriving (Eq)
  
{-
  Show the LLVM IR textual representation.
-}  
instance Show Var where
  show x                = show (getType x) ++ " " ++ getName x
  
{-
  Test if a Var is global.
-}  
isGlobal :: Var -> Bool
isGlobal (GlobalVar _ _) = True
isGlobal _               = False  
  
{-
  Return the variable name or value of the constant
  in LLVM IR textual representation.
-}
getName :: Var -> String
getName (GlobalVar x _)    = "@" ++ x
getName (LocalVar  x _)    = "%" ++ x
getName (Constant  x _)    = show x
getName (StrConstant  x _) = x 

{-
  Return the variable name or value of the constant
  in a plain textual representation
-}
getPlainName :: Var -> String
getPlainName (GlobalVar x _)    = x
getPlainName (LocalVar  x _)    = x
getPlainName (Constant  x _)    = show x
getPlainName (StrConstant  x _) = x   

{-
  Return the type of the variable
-}
getType :: Var -> LLVMType
getType (GlobalVar _ y)    = y
getType (LocalVar _ y)     = y
getType (Constant _ y)     = y  
getType (StrConstant _ y)  = y  
%%]

%%[8 hs
{-
  Data type for possible types of LLVM expressions.
-}
data LLVMType
  = LLInt Int
  | Pointer LLVMType
  | Array Int LLVMType
  | Label
  | Void
  deriving (Eq)
 
{-
  Shortcuts for often used LLVMType values
-} 
i64 = LLInt 64
i32 = LLInt 32
i8  = LLInt 8
i1  = LLInt 1
 
{-
  Show the LLVM IR textual representation.
-}    
instance Show LLVMType where
  show (LLInt size)       = "i" ++ show size
  show (Pointer x)        = show x ++ "*"
  show (Array nr tp)      = "[ " ++ show nr ++ " x " ++ show tp ++ "]"       
  show Label              = "label"
  show Void               = "void"
  
{- 
  Add a pointer indirection to the supplied type. The Label and Void LLVMType
  cannot be lifted.
-}   
pLift :: LLVMType -> LLVMType
pLift (Label) = error "Labels are unliftable"
pLift (Void)  = error "Voids are unliftable"
pLift x       = Pointer x

{-
  Remove the pointer indirection of the supplied type. Only Pointer constructors
  can be lowered.
-}
pLower :: LLVMType -> LLVMType
pLower (Pointer x) = x
pLower x           = error $ show x ++ " is a unlowerable type, need a pointer"

{-
  Test if the given LLVMType is an integer
-}
isInt :: LLVMType -> Bool
isInt (LLInt _) = True
isInt _         = False

{-
  Test if the given LLVMType is a pointer
-}
isPointer :: LLVMType -> Bool
isPointer (Pointer _) = True
isPointer _           = False
%%]