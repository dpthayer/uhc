%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[8 hs module {%{GRIN}Silly.ToLLVM} export(silly2llvm)
%%]
%%[8 hs import({%{GRIN}LLVM})
%%]
%%[8 hs import({%{GRIN}Silly})
%%]
%%[8 hs import({%{EH}Base.Common})
%%]
%%[8 hs import({%{GRIN}ConfigDefines})
%%]
%%[8 import({Silly/AbsSyn})
%%]
%%[8 hs import(qualified Data.Map)
%%]
%%[8
WRAPPER SilModule
%%]

%%[8 hs
{-|
  Transform a 'SilModule' to a 'LLVMModule'. In this module, we use cells which
  have the size @sizeof(intptr_t)@, so that we can store both integers and
  pointers in them and cast freely.
-} 
silly2llvm :: SilModule -> LLVMModule
silly2llvm silmod = 
  let -- LLVMType of integers
      intType    = if sizeofPointer == 8 
                   then i64
                   else i32
      -- LLVMType of pointers to integers.
      ptrType    = pLift intType
      -- Global variables are always pointers to pointers to integers.
      gblType    = pLift ptrType
      t = wrap_SilModule (sem_SilModule silmod)
                         (Inh_SilModule { intType_Inh_SilModule = intType 
                                        , pointerType_Inh_SilModule = ptrType
                                        , globalType_Inh_SilModule = gblType
                                        , gUniq_Inh_SilModule = uidStart
                                        } 
                         )
   in llvmCode_Syn_SilModule t
%%]

%%[8
{
type TypedExpression = (Expression,LLVMType)
}

ATTR SilModule
     [ | | llvmCode : {LLVMModule} ]

ATTR Functions
     [ | | llvmCode : {Funcs} ]

ATTR Function
     [ | | llvmCode : {Func} ] 
   
ATTR Statements Statement
     Values Value
     Variables Variable
     [ | | llvmCode : {Stmts} ]
     
ATTR Values
     Variables
     [ | | llvmVar : {[Var]} ]

ATTR Value
     Variable
     [ | | llvmVar : {Var} ]   
 
ATTR Alternatives
     [ | | jumpTargets : {[(Var,Var,Stmts)]} ]
     
ATTR Alternative
     [ | | jumpTarget : {(Var,Var,Stmts)} ] 
     
ATTR Constant    
     [ | | llvmVar : {Var} ]  
     
ATTR AllNT
     [ gUniq: UID | | ]      
           
SEM SilModule
  | SilModule   lhs.llvmCode = LLVMModule_LLVMModule @loc.comment
                                                     @loc.constants 
                                                     @loc.globals 
                                                     ( @loc.printfDecl
                                                     : gcInitFuncDecl
                                                     : gcMallocFuncDecl @lhs.intType
                                                     : gcMallocUncollectableFuncDecl @lhs.intType
                                                     : primPatternMatchFailureFuncDecl
                                                     : @functions.externFuncs 
                                                     )
                                                     ( @loc.main 
                                                     : @functions.llvmCode 
                                                     )
                                                     
                loc.comment  = map (\(s,i) -> s ++ "->" ++ show i) @constants  
                loc.constants= ( GlobalVar "STR_RES" (Array 22 i8)
                               , StrConstant (string2CString "%lld\\0A")
                                          (Array 6 i8)
                               )
                               : @functions.constants
                loc.globals  = GlobalVar "RP" (@lhs.globalType) :
                               mkVarList GlobalVar @variables @lhs.globalType                              
                loc.printfDecl =
                               FuncDecl_FuncDecl "printf" i32 True
                                                 [(LocalVar "str" (pLift i8))]                                               
                loc.main     = Func_Func 
                                 (FuncDecl_FuncDecl "main" i32 False []) False
                                 [ Stmt_Assignment 
                                     (LocalVar "rpArr" @lhs.pointerType)
                                     (mkMalloc True @lhs.intType 
                                                    (1 + @functions.maxRPSize)
                                     )
                                 , Stmt_Store
                                     (LocalVar "rpArr" @lhs.pointerType)
                                     (GlobalVar "RP" @lhs.globalType)
                                 , Stmt_Call
                                     (FuncDecl_FuncDecl "initialize" Void False [])
                                     False []
                                 , Stmt_Call
                                     (FuncDecl_FuncDecl "fun_main" Void False [])
                                     False []
                                , Stmt_Assignment
                                     (LocalVar "rp.1" @lhs.pointerType)
                                     (Expression_GetElemPtr
                                       (LocalVar "rpArr" @lhs.pointerType) [1]
                                     )
                                 , Stmt_Assignment
                                     (LocalVar "rp.1.val" @lhs.intType)
                                     (Expression_Load 
                                       (LocalVar "rp.1" @lhs.pointerType)
                                     )
                                , Stmt_Assignment
                                     (LocalVar "cast.str.res" (pLift i8))
                                     (Expression_GetElemPtr 
                                       (GlobalVar "STR_RES" (pLift $ Array 6 i8))
                                       [0,0]
                                     )  
                                 , Stmt_Call
                                     @loc.printfDecl True
                                     [ LocalVar "cast.str.res" (pLift i8)
                                     , LocalVar "rp.1.val" @lhs.intType
                                     ] 
                                 , Stmt_Return (Constant 0 i32)  
                                 ]                    
                               
SEM Functions
  | Cons        lhs.llvmCode = @hd.llvmCode : @tl.llvmCode
 
                (tl.gUniq, hd.gUniq) = 
                               mkNewLevUID @lhs.gUniq
  | Nil         lhs.llvmCode = []

SEM Function
  | Function    lhs.llvmCode = let locals = map (\nm -> Stmt_Assignment 
                                                          (LocalVar (hs2str nm) @lhs.pointerType)
                                                          (Expression_Alloca @lhs.intType 1)
                                                ) @locals
                                in Func_Func @loc.fnDecl True $
                                   locals ++ @body.llvmCode
 
SEM Statements
  | Cons        lhs.llvmCode = @hd.llvmCode ++ @tl.llvmCode
                
                (tl.gUniq, hd.gUniq) = 
                               mkNewLevUID @lhs.gUniq
                
  | Nil         lhs.llvmCode = []
  
SEM Statement
  -- A Silly assign will translate to a store. We have the following steps
  --   * If the RHS is an expression, assign the RHS to a fresh var
  --   * Do the same for the LHS
  --   * check if the LHS is a pointertype, otherwise cast to pointer
  --   * check if the RHS type fits in the pointertype of the LHS, otherwise
  --     cast the LHS
  --   * Store
  | Assignment  lhs.llvmCode = @source.llvmCode ++ @dest.llvmCode ++ @loc.lhsptrCode ++ @loc.fitsCode ++
                               [Stmt_Store @loc.fitsVar @loc.lhsptrVar] 
                
                loc.uniqSeed  : {UID}
                loc.uniqNr1   : {UID}
                loc.uniqNr2   : {UID}
                (loc.uniqSeed, dest.gUniq, source.gUniq) =
                               mkNewLevUID2 @lhs.gUniq 
                
                loc.(uniqNr1,lhsptrVar,lhsptrCode) =
                               cast2ptr @loc.uniqSeed @dest.llvmVar @lhs.pointerType
                loc.(uniqNr2,fitsVar,fitsCode) =
                               makeFitting @loc.uniqNr1 @source.llvmVar @loc.lhsptrVar                                         

  | Assignment2 lhs.llvmCode = @source.llvmCode ++ @dest1.llvmCode ++ @loc.dest1ptrCode ++ @loc.fits1Code ++
                               [ Stmt_Store @loc.fits1Var @loc.dest1ptrVar ] ++
                               @dest2.llvmCode ++ @loc.dest2ptrCode ++ @loc.fits2Code ++
                               [ Stmt_Store @loc.fits2Var @loc.dest2ptrVar] 
                
                loc.uniqSeed  : {UID}
                loc.uniqNr1   : {UID}
                loc.uniqNr2   : {UID}
                loc.uniqNr3   : {UID}
                loc.uniqNr4   : {UID}
                (loc.uniqSeed, dest1.gUniq, dest2.gUniq, source.gUniq) =
                               mkNewLevUID3 @lhs.gUniq 
                               
                loc.(uniqNr1,dest1ptrVar,dest1ptrCode) =
                               cast2ptr @loc.uniqSeed @dest1.llvmVar @lhs.pointerType
                loc.(uniqNr2,dest2ptrVar,dest2ptrCode) =
                               cast2ptr @loc.uniqNr1 @dest2.llvmVar @lhs.pointerType                                        
                loc.(uniqNr3,fits1Var,fits1Code) =
                               makeFitting @loc.uniqNr2 @source.llvmVar @loc.dest1ptrVar
                loc.(uniqNr4,fits2Var,fits2Code) =
                               makeFitting @loc.uniqNr3 @source.llvmVar @loc.dest2ptrVar  

  | Call        lhs.llvmCode = let fDecl = Data.Map.findWithDefault 
                                             (error $ "No such function: " ++ hs2str @name)
                                             (hs2str @name) @lhs.fnAvailDecls
                                in @args.llvmCode ++
                                   @loc.castCode ++
                                   [ Stmt_Call fDecl @tailJumps @loc.castVars ]
 
                loc.uniqSeed  : {UID}
                loc.gUniq     : {UID}
                (loc.uniqSeed, args.gUniq) =
                               mkNewLevUID @lhs.gUniq 
                           
                -- Some arguments can be pointers and need to be casted
                -- to inttypes 
                loc.(uniqNr1,castVars,castCode) =  
                               foldr (\x xs -> let (nr,val,stmt) =
                                                     cast2int (fstTup3 xs) x @lhs.intType
                                                in ( nr, val : sndTup3 xs, stmt ++ (trdTup3 xs) ) ) 
                                     (@loc.uniqSeed,[],[]) @args.llvmVar  
                                   
  | Comment     lhs.llvmCode = [Stmt_Comment @comment]
  
  | If          lhs.llvmCode = @scrutinee.llvmCode ++
                               @loc.scrutToIntCode ++
                               @loc.scrutUnboxCode ++
                               @loc.cmpCode ++ 
                               [ Stmt_BranchIf 
                                 @loc.cmpVar
                                 @loc.fstLabel @loc.sndLabel
                               ] ++
                               @loc.fstStmts ++ 
                               [ Stmt_Branch @loc.resumeLabel] ++
                               @loc.sndStmts ++
                               [ Stmt_Branch @loc.resumeLabel
                               , Stmt_Label  @loc.resumeLabel
                               ]
  
                loc.(fstConst,fstLabel,fstStmts) =
                                     @loc.fstAlt
                loc.(sndConst,sndLabel,sndStmts) =
                                     @loc.sndAlt                     
                loc.(fstAlt,sndAlt) =
                               let f (x:y:[]) = (x,y)
                                   f _ = error "Not exactly 2 alts for If"
                                in f @body.jumpTargets                                              
                                
                loc.uniqSeed  : {UID}
                loc.uniqNr1   : {UID}
                loc.uniqNr2   : {UID}
                loc.uniqNr3   : {UID}
                loc.uniqNr4   : {UID}
                (loc.uniqSeed, scrutinee.gUniq, body.gUniq) =
                               mkNewLevUID2 @lhs.gUniq 
                               
                loc.(uniqNr1, scrutToIntVar, scrutToIntCode) =
                              cast2int @loc.uniqSeed @scrutinee.llvmVar @lhs.intType

                loc.(uniqNr2, scrutUnboxVar, scrutUnboxCode) =                               
                              assign2var @loc.uniqNr1 ( Expression_BinOp AND @loc.scrutToIntVar 
                                                                         (Constant 1 @lhs.intType)
                                                      , @lhs.intType )
                               
                loc.(uniqNr3, cmpVar, cmpCode) =
                              assign2var @loc.uniqNr2 ( Expression_Compare CMPEQ @loc.scrutUnboxVar @loc.fstConst, i1)               
                               
                loc.(uniqNr4, resumeLabel) =
                               newFresh @loc.uniqNr3 Label              

  | Switch      lhs.llvmCode = @scrutinee.llvmCode ++
                               [ Stmt_Switch @scrutinee.llvmVar @loc.defaultLabel @loc.targets ] ++ 
                               @loc.altStmts ++ @loc.defaultBody ++ 
                               [ Stmt_Branch @loc.resumeLabel] ++
                               [ Stmt_Label  @loc.resumeLabel ]
                    
                loc.altStmts = concatMap (( ++ [Stmt_Branch @loc.resumeLabel]) . 
                                          trdTup3)
                                   @body.jumpTargets  
                
                loc.targets = map (\(x,y,z) -> (x,y)) @body.jumpTargets
                                                                            
                loc.uniqSeed  : {UID}
                loc.uniqNr1   : {UID}
                loc.uniqNr2   : {UID}
                (loc.uniqSeed, scrutinee.gUniq, body.gUniq) =
                               mkNewLevUID2 @lhs.gUniq 
                               
                loc.(uniqNr1, resumeLabel) =
                               newFresh @loc.uniqSeed Label
                               
                loc.(uniqNr2, defaultLabel, defaultBody) =
                               defaultCase @loc.uniqNr1   
                               
  | Jump        lhs.llvmCode = error $ "Generated jump instructions not allowed"
                                     ++ " in LLVM. Is -g set to 0?"
  
  | Label       lhs.llvmCode = error $ "Generated label instructions not"
                                     ++ " allowed in LLVM. Is -g set to 0?"
  
  | Return      lhs.llvmCode = [Stmt_Return $ LocalVar (error "ReturnNoVar") Void ]  
                                    
  | Smart       lhs.llvmCode = error "Smart should be generated for ASM only"
                                    
  | * - Assignment Assignment2 Call Comment If Jump Label Return Smart Switch
                lhs.llvmCode = error "Unimplemented Statement"

SEM Alternatives
  | Cons        lhs.jumpTargets = 
                               @hd.jumpTarget : @tl.jumpTargets              
                (tl.gUniq, hd.gUniq) = 
                               mkNewLevUID @lhs.gUniq
                               
  | Nil         lhs.jumpTargets = 
                               []
                
SEM Alternative
  | Alternative lhs.jumpTarget = 
                               ( @when.llvmVar
                               , @loc.label
                               , Stmt_Label @loc.label : @body.llvmCode
                               )
                                        
                loc.uniqSeed  : {UID}
                loc.gUniq     : {UID}
                (loc.uniqSeed, body.gUniq) =
                               mkNewLevUID @lhs.gUniq                     
                (loc.uniqNr1, loc.label) = 
                               newFresh @loc.uniqSeed Label              
 
SEM Values
  | Cons        lhs.llvmVar  = @hd.llvmVar : @tl.llvmVar
                lhs.llvmCode = @hd.llvmCode ++ @tl.llvmCode
                (tl.gUniq, hd.gUniq) = 
                               mkNewLevUID @lhs.gUniq
                               
  | Nil         lhs.llvmVar  = [] 
                lhs.llvmCode = []       
       
SEM Value
  {-|
    Assign a Malloc to a fresh variable
  -}
  | Alloc       lhs.llvmVar  = @loc.llvmVar
                lhs.llvmCode = @loc.llvmCode
                
                loc.(uniqNr1,llvmVar,llvmCode) =
                               assign2var @lhs.gUniq (mkMalloc False @lhs.intType @size, @lhs.pointerType)

  {-|
    Perform the required arithmic (>>1) on the inherited llvmVar
  -} 
  | BoxVar      lhs.llvmVar  = @loc.llvmVar
                lhs.llvmCode = @var.llvmCode ++ @loc.loadCode ++ @loc.llvmCode
                                               
                (loc.uniqSeed,var.gUniq) =
                               mkNewLevUID @lhs.gUniq 
     
                loc.(uniqNr1,loadedVar,loadCode) =
                               load2value @loc.uniqSeed @var.llvmVar     
                               
                loc.(uniqNr2,llvmVar,llvmCode) =
                               assign2var @loc.uniqNr1 ( Expression_BinOp SHR @loc.loadedVar (Constant 1 @lhs.intType)
                                                       , getType @loc.loadedVar )                                    
  
  {-|
    For a call we need to do the following steps:
      * Cast the parameter values to integers
      * Assign the result of the call to a fresh variable
  -}                             
  | Call        lhs.llvmVar  = @loc.llvmVar
                lhs.llvmCode = @args.llvmCode ++ @loc.castCode ++ @loc.llvmCode
 
                loc.fnDecl  = FuncDecl_FuncDecl @name @lhs.intType False @loc.formalParams
 
                loc.uniqSeed  : {UID}
                (loc.uniqSeed, args.gUniq) =
                               mkNewLevUID @lhs.gUniq 
                           
                -- Some arguments can be pointers and need to be casted
                -- to inttypes 
                loc.(uniqNr1,castVars,castCode) =  
                               foldr (\x xs -> let (nr,val,stmt) = cast2int (fstTup3 xs) x @lhs.intType
                                                in (nr, val : sndTup3 xs, stmt ++ (trdTup3 xs)) ) 
                                     (@loc.uniqSeed,[],[]) @args.llvmVar 
                      
                -- Assign the call expression to a fresh variable
                --                     
                loc.(uniqNr2,llvmVar,llvmCode) =
                               assign2var @loc.uniqNr1 (Expression_Call @loc.fnDecl False @loc.castVars, @lhs.intType)
                                                   
                -- We generate the formal parameters by generating new names
                -- for the actual ones
                loc.(uniqNr3,formalParams) =  
                               foldr (\x xs -> let (nr,fresh) = newFresh (fst xs) (getType x)
                                                in (nr, fresh : (snd xs)) ) 
                                     (@loc.uniqNr2,[]) @loc.castVars

  {-|
    A Con just wraps a constant. No actions needed.
  -}
  | Con         lhs.llvmVar  = @con.llvmVar
                lhs.llvmCode = []
  
  {-|
    Perform the required arithmic ((<<1) | 0x01) on the inherited llvmVar
  -} 
  | UnboxCon    lhs.llvmVar  = @loc.orVar
                lhs.llvmCode = @con.llvmCode ++ @loc.shlCode ++ @loc.orCode                      
                                               
                loc.uniqSeed  : {UID}
                (loc.uniqSeed,con.gUniq) =
                               mkNewLevUID @lhs.gUniq                            
                loc.(uniqNr1,shlVar,shlCode) =
                               assign2var @loc.uniqSeed ( Expression_BinOp SHL @con.llvmVar (Constant 1 @lhs.intType)
                                                        , getType @con.llvmVar)
                loc.(uniqNr2,orVar,orCode) =
                               assign2var @loc.uniqNr1 ( Expression_BinOp OR @loc.shlVar (Constant 1 @lhs.intType)
                                                       , getType @loc.shlVar )                                        

  {-|
    The llvmVar inherited from the @var child needs to be loaded to an integer value
  -}                                                                               
  | Var         lhs.llvmVar  = @loc.llvmVar
                lhs.llvmCode = @var.llvmCode ++ @loc.llvmCode                

                (loc.uniqSeed, var.gUniq) =
                               mkNewLevUID @lhs.gUniq
               
                loc.(uniqNr1,llvmVar,llvmCode) =                
                               if getType @var.llvmVar /= @lhs.intType
                               then load @loc.uniqSeed @var.llvmVar
                               else (@loc.uniqSeed,@var.llvmVar,[])                              
                
  | * - Alloc BoxVar Call Con Var UnboxCon
                lhs.llvmVar  = error $ "No Label, Cast or Offset Value expected"
                lhs.llvmCode = error $ "No Label, Cast or Offset Value expected"       
 
SEM Variables
  | Cons        lhs.llvmVar  = @hd.llvmVar : @tl.llvmVar
                lhs.llvmCode = @hd.llvmCode ++ @tl.llvmCode
  | Nil         lhs.llvmVar  = [] 
                lhs.llvmCode = [] 
                
SEM Variable
  | Global      lhs.llvmVar  = GlobalVar (hs2str @name) @lhs.globalType
                lhs.llvmCode = []
                
  | Local       lhs.llvmVar  = LocalVar (hs2str @name) @lhs.pointerType                                        
                lhs.llvmCode = []               
  
  | Param       lhs.llvmVar  = LocalVar (hs2str @name) @lhs.intType                                       
                lhs.llvmCode = []                                                    
                                               
  | RP          lhs.llvmVar  = GlobalVar "RP" @lhs.globalType 
                lhs.llvmCode = []
                
  | Subs        lhs.llvmVar  = @loc.offsetVar
                lhs.llvmCode = @array.llvmCode ++ @loc.loadCode ++ @loc.ptrCode ++ @loc.offsetCode 

                (loc.uniqSeed, array.gUniq) =
                               mkNewLevUID @lhs.gUniq
                                               
                loc.(uniqNr1,loadVar,loadCode) =
                               if isGlobal @array.llvmVar || @array.isLocal
                               then load @loc.uniqSeed @array.llvmVar
                               else (@loc.uniqSeed, @array.llvmVar, []) 
                loc.(uniqNr2,ptrVar,ptrCode) =
                               cast2ptr @loc.uniqNr1 @loc.loadVar @lhs.pointerType  
                loc.(uniqNr3,offsetVar,offsetCode) =
                               assign2var @loc.uniqNr2 (Expression_GetElemPtr @loc.ptrVar [@index], getType @loc.ptrVar)
 
   | * - Global Local Param RP Subs
                lhs.llvmVar  = error "Variable contains an impossible construct"
                lhs.llvmCode = error "Variable contains an impossible construct"                                                                                                           
                
SEM Constant
  | LiteralInt  lhs.llvmVar  = Constant @value @lhs.intType
  | LiteralStr  lhs.llvmVar  = @loc.llvmVar
                loc.llvmVar  : {Var}
                loc.llvmVar  = GlobalVar (getPlainName @loc.varNm)
                                         (getType @loc.varNm)
                loc.(gUniq,varNm)    
                             = newFresh @lhs.gUniq (pLift @loc.strType)
  | Alias       lhs.llvmVar  = let value = Data.Map.findWithDefault
                                             (error "Alias not in constantmap")
                                             @name @lhs.constantMap 
                                in Constant value @lhs.intType                                                                 
%%]

%%[8
--------------------------------------------------------------------------------
-- Passing up the signatures of the functions declared and the functions 
-- defined in this module. If we have the set of these functions, we can 
-- query them for Calls and we can warn if undeclared/undefined functions are
-- called
--------------------------------------------------------------------------------
ATTR Functions Function
     Statements Statement
     Alternatives Alternative
     Values Value
     Variables Variable
     [ fnAvailDecls : {Data.Map.Map String FuncDecl} | | ]

ATTR Functions
     [ | | fnDecls : {[(String,FuncDecl)]} ]

ATTR Function
     [ | | fnDecl : {(String,FuncDecl)} ]

SEM SilModule
  | SilModule   functions.fnAvailDecls
                           = Data.Map.fromList @functions.fnDecls

SEM Functions
  | Cons        lhs.fnDecls
                           = @hd.fnDecl : @tl.fnDecls
  | Nil         lhs.fnDecls
                           = []

SEM Function
  | Function    lhs.fnDecl = (hs2str @name, @loc.fnDecl)
                loc.fnDecl : {FuncDecl}
                loc.fnDecl = let prms = mkVarList LocalVar @parameters 
                                                           @lhs.intType
                              in FuncDecl_FuncDecl (hs2str @name) Void False prms
%%]
  
%%[8
--------------------------------------------------------------------------------
-- Passing up the string constants used in functions 
--------------------------------------------------------------------------------
ATTR Functions Function
     Statements Statement
     Alternatives Alternative
     Values Value
     Variables Variable
     Constant
     [ | | constants USE {++} {[]}: {[(Var,Var)]} ]

SEM Constant
  | LiteralStr  lhs.constants = [ ( @loc.llvmVar 
                                  , @loc.cstring
                                  )
                                ]
                loc.cstring   = StrConstant (string2CString @value)
                                            @loc.strType 
                loc.strType   = Array (length @value + 1) i8
  | * - LiteralStr
                lhs.constants = [ ]
%%]

%%[8
--------------------------------------------------------------------------------
-- Passing down platform depended types.
--------------------------------------------------------------------------------

ATTR AllNT
     [ intType, pointerType, globalType : {LLVMType} | | ]
%%]

%%[8
--------------------------------------------------------------------------------
-- We pass down a map, containing the alias name and the 
-- corresponding Int value of constructor tags
--------------------------------------------------------------------------------
ATTR Functions Function 
     Statements Statement
     Alternatives Alternative
     Values Value
     Variables Variable
     Constant
     [ constantMap : {Data.Map.Map String Int} | | ]

SEM SilModule
  | SilModule   functions.constantMap = Data.Map.fromList @constants
%%]

%%[8
--------------------------------------------------------------------------------
-- TODO: Update comment
--------------------------------------------------------------------------------
ATTR Variable
     [ | | isLocal : {Bool} ]
                          
SEM Variable
  | Local       lhs.isLocal  = True
  | * - Local
                lhs.isLocal  = False                           
%%]

%%[8
--------------------------------------------------------------------------------
-- Pass the max size of the closure that is stored in RP up
-- so that we can initialize it at the start up.
--------------------------------------------------------------------------------
ATTR Functions Function 
     Statements Statement
     Alternatives Alternative
     Values Value
     Variables Variable
     [ | | maxRPSize USE {`max`} {0}: {Int} ]

SEM Variable
  | Subs        lhs.maxRPSize =
                             if @array.isRP then @index else 0  

ATTR Variable
     [ | | isRP : {Bool} ]
                          
SEM Variable
  | RP          lhs.isRP   = True
  | * - RP
                lhs.isRP   = False                           
%%]

%%[8
--------------------------------------------------------------------------------
-- Pass function declarations that are defined exetern
--------------------------------------------------------------------------------
ATTR Functions Function 
     Statements Statement
     Alternatives Alternative
     Values Value
     Variables Variable
     [ | | externFuncs USE {++} {[]}: {[FuncDecl]} ]
                       
SEM Value
  | Call        lhs.externFuncs = [@loc.fnDecl]                  
%%]

%%[8
{
--------------------------------------------------------------------------------
-- Misc functions
--------------------------------------------------------------------------------
-- Shortcut method to fetch the string representation of a HsName
hs2str :: HsName -> String
hs2str = hsnShowAlphanumeric

-- Get the first element of a 3 tuple
fstTup3 :: (a,b,c) -> a
fstTup3 (x,_,_) = x

-- Get the second element of a 3 tuple
sndTup3 :: (a,b,c) -> b
sndTup3 (_,x,_) = x

-- Get the third element of a 3 tuple
trdTup3 :: (a,b,c) -> c
trdTup3 (_,_,x) = x

primPatternMatchFailureFuncDecl :: FuncDecl
primPatternMatchFailureFuncDecl =
  FuncDecl_FuncDecl "primPatternMatchFailure" Void False [] 

gcInitFuncDecl :: FuncDecl
gcInitFuncDecl =
  FuncDecl_FuncDecl "llvmgc_init" Void False []
  
gcMallocFuncDecl :: LLVMType -> FuncDecl
gcMallocFuncDecl intType =
  FuncDecl_FuncDecl "llvmgc_malloc" (pLift intType) False [(LocalVar "x" intType)] 

gcMallocUncollectableFuncDecl :: LLVMType -> FuncDecl
gcMallocUncollectableFuncDecl intType =
  FuncDecl_FuncDecl "llvmgc_malloc_uncollectable" (pLift intType) 
                    False [(LocalVar "x" intType)] 

defaultCase :: UID -> (UID,Var,Stmts)
defaultCase nr =
  let (nr1, fresh1) = newFresh nr Label
   in (nr1, fresh1, [ Stmt_Label fresh1
                    , Stmt_Call primPatternMatchFailureFuncDecl
                                           False []
                    ])
                    
mkMalloc :: Bool -> LLVMType -> Int -> Expression
mkMalloc unCollectable intType nrInts =
  if rtsUseGC
  then let size = nrInts * sizeofPointer
        in if unCollectable
           then Expression_Call (gcMallocUncollectableFuncDecl intType) 
                                False [Constant size intType]
           else Expression_Call (gcMallocFuncDecl intType)
                                False [Constant size intType]
  else Expression_Malloc intType nrInts

-- Make a list of variables with a given constructor, a list of HsNames and
-- one type
-- used primary for parameter lists
mkVarList :: (String -> LLVMType -> Var) -> [HsName] -> LLVMType -> [Var]
mkVarList constr names tp =
  zipWith (\x y -> constr (hs2str x) y) names (repeat tp)
   
cast2int :: UID -> Var -> LLVMType -> (UID,Var,Stmts)   
cast2int nr var intType =
  if isInt (getType var)
  then (nr,var,[])
  else let (nr', fresh) = newFresh nr intType
        in (nr', fresh, [Stmt_Assignment fresh $ Expression_Cast var intType])
        
cast2ptr :: UID -> Var -> LLVMType -> (UID,Var,Stmts)
cast2ptr nr var ptrType
  | isPointer (getType var) =
    (nr,var,[])
  | otherwise =
    let (nr', fresh) = newFresh nr ptrType
     in (nr', fresh, [Stmt_Assignment fresh $ Expression_Cast var ptrType])         
 
makeFitting :: UID -> Var -> Var -> (UID,Var,Stmts)
makeFitting nr what hole 
  -- Case 1 it already fits
  | getType what == pLower (getType hole) =
    (nr,what,[])
  | otherwise = 
    let targetType   = pLower $ getType hole 
        (nr', fresh) = newFresh nr targetType
     in (nr', fresh, [Stmt_Assignment fresh $ Expression_Cast what targetType])

-- Build a new fresh local variable
newFresh :: UID -> LLVMType -> (UID,Var)
newFresh nr tp = 
  (uidNext nr, LocalVar ("fresh" ++ show nr) tp)

assign2var :: UID -> TypedExpression -> (UID,Var,Stmts)
assign2var nr (expr,tp) =
  let (nr', fresh) = newFresh nr tp
   in (nr', fresh, [Stmt_Assignment fresh expr])
   
-- Load a given Var
load :: UID -> Var -> (UID,Var,Stmts)
load nr var =
  let loadType     = pLower (getType var)
      (nr', fresh) = newFresh nr loadType
   in (nr', fresh, [Stmt_Assignment fresh (Expression_Load var)])
   
load2value :: UID -> Var -> (UID,Var,Stmts)
load2value nr var 
  | isInt (getType var) = (nr,var,[])
  | otherwise           =
    let (nr1,var1,stmts1) = load nr var
        (nr2,var2,stmts2) = load2value nr1 var1
     in (nr2,var2, stmts1 ++ stmts2)       

-- Add c prefix for a string, add explict quotes and terminate with \0
-- hello -> c"hello\0"
string2CString :: String -> String
string2CString str =
  "c\"" ++ str ++ "\\00\""
}
%%]
