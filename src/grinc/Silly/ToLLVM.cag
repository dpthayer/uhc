%%[0 hs
{
{-| 
  This module transforms a 'SilModule' to a 'LLVMModule' via an AG
  transformation. TODO more about the transformation later.
-}
}
%%]

%%[8 hs module {%{GRIN}Silly.ToLLVM}
%%]
%%[8 hs import({%{GRIN}LLVM})
%%]
%%[8 hs import({%{GRIN}Silly})
%%]
%%[8 hs import({%{EH}Base.Common})
%%]
%%[8 hs import({%{EH}Base.Opts})
%%]
%%[8 hs import({%{GRIN}ConfigDefines})
%%]
%%[8 import({Silly/AbsSyn})
%%]
%%[8 hs import(qualified Data.Map)
%%]
%%[8 hs import(qualified Data.List)
%%]
%%[8
WRAPPER SilModule
%%]

%%[8 hs export( silly2llvm )
{-|
  Transform a 'SilModule' to a 'LLVMModule'. In this module, we use cells which
  have the size @sizeof(intptr_t)@, so that we can store both integers and
  pointers in them and cast freely.
-} 
silly2llvm :: EHCOpts -> SilModule -> LLVMModule
silly2llvm opts silmod = 
  let -- LLVMType of integers
      intType    = if sizeofPointer == 8 
                   then i64
                   else i32
      -- LLVMType of pointers to integers.
      ptrType    = pLift intType
      -- Global variables are always pointers to pointers to integers.
      gblType    = pLift ptrType
      t = wrap_SilModule (sem_SilModule silmod)
                         (Inh_SilModule { intType_Inh_SilModule = intType 
                                        , pointerType_Inh_SilModule = ptrType
                                        , globalType_Inh_SilModule = gblType
                                        , gUniq_Inh_SilModule = uidStart
                                        , opts_Inh_SilModule = opts
                                        } 
                         )
   in llvmCode_Syn_SilModule t
%%]

%%[8
ATTR AllNT
    [ opts : {EHCOpts} | | ]

ATTR SilModule
     [ | | llvmCode : {LLVMModule} ]

ATTR Functions
     [ | | llvmCode : {LLVMFunctions} ]

ATTR Function
     [ | | llvmCode : {LLVMFunction} ] 
   
ATTR Statements Statement Alternative
     Values Value Variables Variable
     [ | | llvmCode : {LLVMStatements} ]
  
ATTR Alternatives
     [ | | llvmCode : {[LLVMStatements]} ]  
     
ATTR Values
     Variables
     [ | | llvmVar : {[LLVMVar]} ]

ATTR Value Variable Constant
     [ | | llvmVar : {LLVMVar} ]   
 
ATTR Alternatives
     [ | | jumpTargets : {[(LLVMVar,LLVMVar)]} ]
     
ATTR Alternative
     [ | | jumpTarget : {(LLVMVar,LLVMVar)} ]  
     
ATTR AllNT
     [ gUniq: UID | | ]      
           
SEM SilModule
  | SilModule   lhs.llvmCode = LLVMModule_LLVMModule @loc.comment
                                                     (@loc.constants : @functions.constants) 
                                                     @loc.globals 
                                                     ( stdlibPrintfFuncDecl : gcInitFuncDecl
                                                     : gcPrintStatsFuncDecl
                                                     : gcMallocFuncDecl @lhs.intType
                                                     : gcMallocUncollectableFuncDecl @lhs.intType
                                                     : primPatternMatchFailureFuncDecl : @functions.externFuncs 
                                                     )
                                                     ( @loc.main : @functions.llvmCode )
                                                     
                loc.comment  = map (\(s,i) -> s ++ "->" ++ show i) @constants  
                loc.resultStr = if sizeofPointer == 8
                                then "%lld\n"
                                else "%d\n"
                loc.constants= ( GlobalVar "STR_RES" (stringType @loc.resultStr)
                               , StrConstant (string2CString @loc.resultStr) (stringType @loc.resultStr)
                               ) 
                loc.globals  = GlobalVar "RP" (@lhs.globalType) : mkVarList GlobalVar @variables @lhs.globalType                                                                          
                loc.main     = LLVMFunction_Func mainFuncDecl ExternallyVisible
                                 [ LLVMStatement_Assignment (LocalVar "rpArr" @lhs.pointerType)
                                     (mkMalloc True @lhs.intType (1 + @functions.maxRPIndex))
                                 , LLVMStatement_Store (LocalVar "rpArr" @lhs.pointerType) (GlobalVar "RP" @lhs.globalType)
                                 , LLVMStatement_Call initializeFuncDecl StdCall []
%%[[8
                                 , LLVMStatement_Call fun_mainFuncDecl StdCall []
%%][99
                                 , LLVMStatement_Call fun_mainFullProgFuncDecl StdCall []
%%]]                                 
                                 , LLVMStatement_Call fun_mainFuncDecl StdCall []
                                 , LLVMStatement_Call gcPrintStatsFuncDecl StdCall []
                                 , LLVMStatement_Assignment (LocalVar "rp.1" @lhs.pointerType)
                                     (LLVMExpression_GetElemPtr (LocalVar "rpArr" @lhs.pointerType) [1] )
                                 , LLVMStatement_Assignment (LocalVar "rp.1.val" @lhs.intType)
                                     (LLVMExpression_Load (LocalVar "rp.1" @lhs.pointerType))
                                , LLVMStatement_Assignment (LocalVar "cast.str.res" (pLift i8))
                                     (LLVMExpression_GetElemPtr (GlobalVar "STR_RES" (pLift $ stringType @loc.resultStr)) [0,0])  
                                 , LLVMStatement_Call stdlibPrintfFuncDecl TailCall
                                     [ LocalVar "cast.str.res" (pLift i8), LocalVar "rp.1.val" @lhs.intType ] 
                                 , LLVMStatement_Return (Constant 0 i32)  
                                 ]                    
                               
SEM Functions
  | Cons        lhs.llvmCode = @hd.llvmCode : @tl.llvmCode
 
                (tl.gUniq, hd.gUniq) = 
                               mkNewLevUID @lhs.gUniq
  | Nil         lhs.llvmCode = []

SEM Function
  | Function    lhs.llvmCode = let locals = map (\nm -> LLVMStatement_Assignment (LocalVar (hs2str nm) @lhs.pointerType)
                                                         (LLVMExpression_Alloca @lhs.intType 1) ) @locals
                                   enter  = [ LLVMStatement_Assignment (LocalVar "enter.str" (pLift i8))
                                                                       (LLVMExpression_GetElemPtr @loc.globalVarEnter [0,0])
                                            , LLVMStatement_Call stdlibPrintfFuncDecl StdCall 
                                                                 [ (LocalVar "enter.str" (pLift i8)) ]
                                            ]
                                   exit   = [ LLVMStatement_Assignment (LocalVar "exit.str" (pLift i8))
                                                                       (LLVMExpression_GetElemPtr @loc.globalVarExit [0,0])
                                            , LLVMStatement_Call stdlibPrintfFuncDecl StdCall 
                                                                 [ (LocalVar "exit.str" (pLift i8)) ]
                                            ]
                                in if ehcOptGenTrace @lhs.opts
                                   then LLVMFunction_Func @loc.fnDecl Internal $ enter ++ locals ++ (init @body.llvmCode)
                                                                                 ++ exit ++ [(last @body.llvmCode)]
                                   else LLVMFunction_Func @loc.fnDecl Internal $ locals ++ @body.llvmCode
 
SEM Statements
  | Cons        lhs.llvmCode = @hd.llvmCode ++ @tl.llvmCode
                
                (tl.gUniq, hd.gUniq) = 
                               mkNewLevUID @lhs.gUniq
                
  | Nil         lhs.llvmCode = []
  
SEM Statement
  -- A Silly assign will translate to a store. We have the following steps
  --   * If the RHS is an expression, assign the RHS to a fresh var
  --   * Do the same for the LHS
  --   * check if the LHS is a pointertype, otherwise cast to pointer
  --   * check if the RHS type fits in the pointertype of the LHS, otherwise
  --     cast the LHS
  --   * Store
  | Assignment  lhs.llvmCode = @source.llvmCode ++ @dest.llvmCode ++ @loc.lhsptrCode ++ @loc.fitsCode ++
                               [LLVMStatement_Store @loc.fitsVar @loc.lhsptrVar] 
                
                loc.uniqSeed  : {UID}
                loc.uniqNr1   : {UID}
                loc.uniqNr2   : {UID}
                (loc.uniqSeed, dest.gUniq, source.gUniq) =
                               mkNewLevUID2 @lhs.gUniq 
                
                loc.(uniqNr1,lhsptrVar,lhsptrCode) =
                               cast2ptr @loc.uniqSeed @dest.llvmVar @lhs.pointerType
                loc.(uniqNr2,fitsVar,fitsCode) =
                               makeFitting @loc.uniqNr1 @source.llvmVar @loc.lhsptrVar                                         

  | Assignment2 lhs.llvmCode = @source.llvmCode ++ @dest1.llvmCode ++ @loc.dest1ptrCode ++ @loc.fits1Code ++
                               [ LLVMStatement_Store @loc.fits1Var @loc.dest1ptrVar ] ++
                               @dest2.llvmCode ++ @loc.dest2ptrCode ++ @loc.fits2Code ++
                               [ LLVMStatement_Store @loc.fits2Var @loc.dest2ptrVar] 
                
                loc.uniqSeed  : {UID}
                loc.uniqNr1   : {UID}
                loc.uniqNr2   : {UID}
                loc.uniqNr3   : {UID}
                loc.uniqNr4   : {UID}
                (loc.uniqSeed, dest1.gUniq, dest2.gUniq, source.gUniq) =
                               mkNewLevUID3 @lhs.gUniq 
                               
                loc.(uniqNr1,dest1ptrVar,dest1ptrCode) =
                               cast2ptr @loc.uniqSeed @dest1.llvmVar @lhs.pointerType
                loc.(uniqNr2,dest2ptrVar,dest2ptrCode) =
                               cast2ptr @loc.uniqNr1 @dest2.llvmVar @lhs.pointerType                                        
                loc.(uniqNr3,fits1Var,fits1Code) =
                               makeFitting @loc.uniqNr2 @source.llvmVar @loc.dest1ptrVar
                loc.(uniqNr4,fits2Var,fits2Code) =
                               makeFitting @loc.uniqNr3 @source.llvmVar @loc.dest2ptrVar  

  | Call        lhs.llvmCode = let fDecl = Data.Map.findWithDefault 
                                             (error $ "No such function: " ++ hs2str @name)
                                             (hs2str @name) @lhs.fnAvailDecls
                                in @args.llvmCode ++
                                   @loc.castCode ++
                                   ( if ehcOptGenTrace @lhs.opts
                                     then ([ LLVMStatement_Assignment @loc.fresh (LLVMExpression_GetElemPtr @loc.global [0,0])
                                           , LLVMStatement_Call stdlibPrintfFuncDecl StdCall (@loc.fresh : @loc.castVars) ] ++)
                                     else ([] ++)
                                   )
                                   [ LLVMStatement_Call fDecl (bool2calltype @tailJumps) @loc.castVars ]
 
                loc.uniqSeed  : {UID}
                loc.gUniq     : {UID}
                (loc.uniqSeed, args.gUniq) =
                               mkNewLevUID @lhs.gUniq 
                           
                -- Some arguments can be pointers and need to be casted
                -- to inttypes 
                loc.(uniqNr1,castVars,castCode) =  
                               foldr (\x xs -> let (nr,val,stmt) = cast2int (getUID xs) x @lhs.intType
                                                in ( nr, val : getVars xs, stmt ++ (getCode xs) ) ) 
                                     (@loc.uniqSeed,[],[]) @args.llvmVar

                loc.(uniqNr2,fresh) = newFresh @loc.uniqNr1 (pLift i8)
               
                lhs.constants = if ehcOptGenTrace @lhs.opts
                                then (@loc.global, @loc.strConst) : @args.constants
                                else @args.constants
                loc.global   = let (_,var) = newFresh @loc.uniqNr2 (pLift $ stringType @loc.callStr)
                                in GlobalVar (getPlainName var) (getType var)
                loc.strConst = StrConstant (string2CString @loc.callStr) (stringType @loc.callStr)  
                loc.callStr  = "Call " ++ hs2str @name ++ " " ++ concat (Data.List.intersperse " " (replicate (length @loc.castVars) "%d")) ++ "\n"    
                               
  | Comment     lhs.llvmCode = [LLVMStatement_Comment @comment]
  
  | If          lhs.llvmCode = @scrutinee.llvmCode ++ @loc.scrutToIntCode ++ @loc.scrutUnboxCode ++ @loc.cmpCode ++ 
                               [ LLVMStatement_BranchIf @loc.cmpVar @loc.fstLabel @loc.sndLabel ] ++                               
                               @loc.altCode ++
                               [ LLVMStatement_Label  @loc.resumeLabel]
                               
                loc.altCode  = concatMap ( ++ [LLVMStatement_Branch @loc.resumeLabel] ) @body.llvmCode                  
                loc.(fstAlt,sndAlt) =
                               let f (x:y:[]) = (x,y)
                                   f _ = error "Not exactly 2 alts for If"
                                in f @body.jumpTargets                                              
                loc.(fstConst,fstLabel) =
                                     @loc.fstAlt
                loc.(sndConst,sndLabel) =
                                     @loc.sndAlt  
                                                                     
                loc.uniqSeed  : {UID}
                loc.uniqNr1   : {UID}
                loc.uniqNr2   : {UID}
                loc.uniqNr3   : {UID}
                loc.uniqNr4   : {UID}
                (loc.uniqSeed, scrutinee.gUniq, body.gUniq) =
                               mkNewLevUID2 @lhs.gUniq 
                               
                loc.(uniqNr1, scrutToIntVar, scrutToIntCode) =
                              cast2int @loc.uniqSeed @scrutinee.llvmVar @lhs.intType

                loc.(uniqNr2, scrutUnboxVar, scrutUnboxCode) =                               
                              assign2var @loc.uniqNr1 ( LLVMExpression_BinOp AND @loc.scrutToIntVar 
                                                                         (Constant 1 @lhs.intType)
                                                      , @lhs.intType )
                               
                loc.(uniqNr3, cmpVar, cmpCode) =
                              assign2var @loc.uniqNr2 ( LLVMExpression_Compare CMPEQ @loc.scrutUnboxVar @loc.fstConst
                                                      , i1)               
                               
                loc.(uniqNr4, resumeLabel) =
                               newFresh @loc.uniqNr3 Label              

  | Switch      lhs.llvmCode = @scrutinee.llvmCode ++
                               [ LLVMStatement_Switch @scrutinee.llvmVar @loc.defaultLabel @loc.targets ] ++ 
                               @loc.altLLVMStatements ++ @loc.defaultBody ++ 
                               [ LLVMStatement_Branch @loc.resumeLabel] ++
                               [ LLVMStatement_Label  @loc.resumeLabel ]
                    
                loc.altLLVMStatements = concatMap ( ++ [LLVMStatement_Branch @loc.resumeLabel] ) @body.llvmCode  
                
                loc.targets = @body.jumpTargets
                                                                            
                loc.uniqSeed  : {UID}
                loc.uniqNr1   : {UID}
                loc.uniqNr2   : {UID}
                (loc.uniqSeed, scrutinee.gUniq, body.gUniq) =
                               mkNewLevUID2 @lhs.gUniq 
                               
                loc.(uniqNr1, resumeLabel) =
                               newFresh @loc.uniqSeed Label
                               
                loc.(uniqNr2, defaultLabel, defaultBody) =
                               defaultCase @loc.uniqNr1   
                               
  | Jump        lhs.llvmCode = error $ "Generated jump instructions not allowed"
                                     ++ " in LLVM. Is -g set to 0?"
  
  | Label       lhs.llvmCode = error $ "Generated label instructions not"
                                     ++ " allowed in LLVM. Is -g set to 0?"
  
  | Return      lhs.llvmCode = [LLVMStatement_Return $ LocalVar (error "ReturnNoVar") Void ]  
                                    
  | Smart       lhs.llvmCode = error "Smart should be generated for ASM only"
                                    
  | * - Assignment Assignment2 Call Comment If Jump Label Return Smart Switch
                lhs.llvmCode = error "Unimplemented Statement"

SEM Alternatives
  | Cons        lhs.llvmCode = @hd.llvmCode : @tl.llvmCode
                lhs.jumpTargets = 
                               @hd.jumpTarget : @tl.jumpTargets              
                (tl.gUniq, hd.gUniq) = 
                               mkNewLevUID @lhs.gUniq
                               
  | Nil         lhs.llvmCode = []
                lhs.jumpTargets = 
                               []
                
SEM Alternative
  | Alternative lhs.llvmCode = LLVMStatement_Label @loc.label : @body.llvmCode
                lhs.jumpTarget = (@when.llvmVar, @loc.label)
                                        
                loc.uniqSeed  : {UID}
                loc.gUniq     : {UID}
                (loc.uniqSeed, body.gUniq) =
                               mkNewLevUID @lhs.gUniq                     
                (loc.uniqNr1, loc.label) = 
                               newFresh @loc.uniqSeed Label              
 
SEM Values
  | Cons        lhs.llvmVar  = @hd.llvmVar : @tl.llvmVar
                lhs.llvmCode = @hd.llvmCode ++ @tl.llvmCode
                (tl.gUniq, hd.gUniq) = 
                               mkNewLevUID @lhs.gUniq
                               
  | Nil         lhs.llvmVar  = [] 
                lhs.llvmCode = []       
       
SEM Value
  {-|
    Assign a Malloc to a fresh variable
  -}
  | Alloc       lhs.llvmVar  = @loc.llvmVar
                lhs.llvmCode = @loc.llvmCode
                
                loc.(uniqNr1,llvmVar,llvmCode) =
                               assign2var @lhs.gUniq (mkMalloc False @lhs.intType @size, @lhs.pointerType)

  {-|
    Perform the required arithmic (>>1) on the inherited llvmVar
  -} 
  | BoxVar      lhs.llvmVar  = @loc.llvmVar
                lhs.llvmCode = @var.llvmCode ++ @loc.loadCode ++ @loc.llvmCode
                                               
                (loc.uniqSeed,var.gUniq) =
                               mkNewLevUID @lhs.gUniq 
     
                loc.(uniqNr1,loadedVar,loadCode) =
                               load2value @loc.uniqSeed @var.llvmVar     
                               
                loc.(uniqNr2,llvmVar,llvmCode) =
                               assign2var @loc.uniqNr1 ( LLVMExpression_BinOp SHR @loc.loadedVar (Constant 1 @lhs.intType)
                                                       , getType @loc.loadedVar )                                    
  
  {-|
    For a call we need to do the following steps:
      * Cast the parameter values to integers
      * Assign the result of the call to a fresh variable
  -}                             
  | Call        lhs.llvmVar  = @loc.llvmVar
                lhs.llvmCode = @args.llvmCode ++ @loc.castCode ++ @loc.llvmCode
 
                loc.fnDecl  = LLVMFunctionDecl_LLVMFunctionDecl @name @lhs.intType FixedArgs @loc.formalParams
 
                loc.uniqSeed  : {UID}
                (loc.uniqSeed, args.gUniq) =
                               mkNewLevUID @lhs.gUniq 
                           
                -- Some arguments can be pointers and need to be casted
                -- to inttypes 
                loc.(uniqNr1,castVars,castCode) =  
                               foldr (\x xs -> let (nr,val,stmt) = cast2int (getUID xs) x @lhs.intType
                                                in (nr, val : getVars xs, stmt ++ (getCode xs)) ) 
                                     (@loc.uniqSeed,[],[]) @args.llvmVar 
                      
                -- Assign the call expression to a fresh variable
                --                     
                loc.(uniqNr2,llvmVar,llvmCode) =
                               assign2var @loc.uniqNr1 (LLVMExpression_Call @loc.fnDecl StdCall @loc.castVars, @lhs.intType)
                                                   
                -- We generate the formal parameters by generating new names
                -- for the actual ones
                loc.(uniqNr3,formalParams) =  
                               foldr (\x xs -> let (nr,fresh) = newFresh (fst xs) (getType x)
                                                in (nr, fresh : (snd xs)) ) 
                                     (@loc.uniqNr2,[]) @loc.castVars

  {-|
    A Con just wraps a constant. No actions needed.
  -}
  | Con         lhs.llvmVar  = @con.llvmVar
                lhs.llvmCode = []
  
  {-|
    Perform the required arithmic ((<<1) | 0x01) on the inherited llvmVar
  -} 
  | UnboxCon    lhs.llvmVar  = @loc.orVar
                lhs.llvmCode = @con.llvmCode ++ @loc.shlCode ++ @loc.orCode                      
                                               
                loc.uniqSeed  : {UID}
                (loc.uniqSeed,con.gUniq) =
                               mkNewLevUID @lhs.gUniq                            
                loc.(uniqNr1,shlVar,shlCode) =
                               assign2var @loc.uniqSeed ( LLVMExpression_BinOp SHL @con.llvmVar (Constant 1 @lhs.intType)
                                                        , getType @con.llvmVar)
                loc.(uniqNr2,orVar,orCode) =
                               assign2var @loc.uniqNr1 ( LLVMExpression_BinOp OR @loc.shlVar (Constant 1 @lhs.intType)
                                                       , getType @loc.shlVar )                                        

  {-|
    The llvmVar inherited from the @var child needs to be loaded to an integer value
  -}                                                                               
  | Var         lhs.llvmVar  = @loc.llvmVar
                lhs.llvmCode = @var.llvmCode ++ @loc.llvmCode                

                (loc.uniqSeed, var.gUniq) =
                               mkNewLevUID @lhs.gUniq
               
                loc.(uniqNr1,llvmVar,llvmCode) =                
                               if getType @var.llvmVar /= @lhs.intType
                               then load @loc.uniqSeed @var.llvmVar
                               else (@loc.uniqSeed,@var.llvmVar,[])                              
                
  | * - Alloc BoxVar Call Con Var UnboxCon
                lhs.llvmVar  = error $ "No Label, Cast or Offset Value expected"
                lhs.llvmCode = error $ "No Label, Cast or Offset Value expected"       
 
SEM Variables
  | Cons        lhs.llvmVar  = @hd.llvmVar : @tl.llvmVar
                lhs.llvmCode = @hd.llvmCode ++ @tl.llvmCode
  | Nil         lhs.llvmVar  = [] 
                lhs.llvmCode = [] 
                
SEM Variable
  | Global      lhs.llvmVar  = GlobalVar (hs2str @name) @lhs.globalType
                lhs.llvmCode = []
                
  | Local       lhs.llvmVar  = LocalVar (hs2str @name) @lhs.pointerType                                        
                lhs.llvmCode = []               
  
  | Param       lhs.llvmVar  = LocalVar (hs2str @name) @lhs.intType                                       
                lhs.llvmCode = []                                                    
                                               
  | RP          lhs.llvmVar  = GlobalVar "RP" @lhs.globalType 
                lhs.llvmCode = []
                
  | Subs        lhs.llvmVar  = @loc.offsetVar
                lhs.llvmCode = @array.llvmCode ++ @loc.loadCode ++ @loc.ptrCode ++ @loc.offsetCode 

                (loc.uniqSeed, array.gUniq) =
                               mkNewLevUID @lhs.gUniq
                         
                -- Tricky!                      
                loc.(uniqNr1,loadVar,loadCode) =
                               if isGlobal @array.llvmVar || @array.isLocal
                               then load @loc.uniqSeed @array.llvmVar
                               else (@loc.uniqSeed, @array.llvmVar, []) 
                loc.(uniqNr2,ptrVar,ptrCode) =
                               cast2ptr @loc.uniqNr1 @loc.loadVar @lhs.pointerType  
                loc.(uniqNr3,offsetVar,offsetCode) =
                               assign2var @loc.uniqNr2 (LLVMExpression_GetElemPtr @loc.ptrVar [@index], getType @loc.ptrVar)
 
   | * - Global Local Param RP Subs
                lhs.llvmVar  = error "Variable contains an impossible construct"
                lhs.llvmCode = error "Variable contains an impossible construct"                                                                                                           
                
SEM Constant
  | LiteralInt  lhs.llvmVar  = Constant @value @lhs.intType
  | LiteralStr  lhs.llvmVar  = @loc.llvmVar
                loc.llvmVar  : {LLVMVar}
                loc.llvmVar  = GlobalVar (getPlainName @loc.varNm)
                                         (getType @loc.varNm)
                loc.(gUniq,varNm)    
                             = newFresh @lhs.gUniq (pLift @loc.strType)
  | Alias       lhs.llvmVar  = let value = Data.Map.findWithDefault
                                             (error "Alias not in constantmap")
                                             @name @lhs.constantMap 
                                in Constant value @lhs.intType                                                                 
%%]

%%[8
--------------------------------------------------------------------------------
-- Passing up the signatures of the functions declared and the functions 
-- defined in this module. If we have the set of these functions, we can 
-- query them for Calls and we can warn if undeclared/undefined functions are
-- called
--------------------------------------------------------------------------------
ATTR Functions Function
     Statements Statement
     Alternatives Alternative
     Values Value
     Variables Variable
     [ fnAvailDecls : {Data.Map.Map String LLVMFunctionDecl} | | ]

ATTR Functions
     [ | | fnDecls : {[(String,LLVMFunctionDecl)]} ]

ATTR Function
     [ | | fnDecl : {(String,LLVMFunctionDecl)} ]

SEM SilModule
  | SilModule   functions.fnAvailDecls
                           = Data.Map.fromList @functions.fnDecls

SEM Functions
  | Cons        lhs.fnDecls
                           = @hd.fnDecl : @tl.fnDecls
  | Nil         lhs.fnDecls
                           = []

SEM Function
  | Function    lhs.fnDecl = (hs2str @name, @loc.fnDecl)
                loc.fnDecl : {LLVMFunctionDecl}
                loc.fnDecl = let prms = mkVarList LocalVar @parameters 
                                                           @lhs.intType
                              in LLVMFunctionDecl_LLVMFunctionDecl (hs2str @name) Void FixedArgs prms
%%]
  
%%[8
--------------------------------------------------------------------------------
-- Passing up the string constants used in functions 
--------------------------------------------------------------------------------
ATTR Functions Function
     Statements Statement
     Alternatives Alternative
     Values Value
     Variables Variable
     Constant
     [ | | constants USE {++} {[]}: {[(LLVMVar,LLVMVar)]} ]

SEM Function
  | Function    lhs.constants      = if ehcOptGenTrace @lhs.opts
                                     then ( @loc.globalVarEnter, @loc.cstringEnter ) : 
                                          ( @loc.globalVarExit,  @loc.cstringExit  ) : @body.constants
                                     else @body.constants
                loc.globalVarEnter = let (uniq,var) = newFresh @lhs.gUniq (pLift $ stringType @loc.enter)
                                      in GlobalVar (getPlainName var) (getType var)
                loc.cstringEnter   = StrConstant (string2CString @loc.enter) (stringType @loc.enter)
                loc.enter          = "[ENTER]" ++ hs2str @name ++ "\n" 
                
                loc.globalVarExit  = let (uniq,var) = newFresh (uidNext @lhs.gUniq) (pLift $ stringType @loc.exit)
                                      in GlobalVar (getPlainName var) (getType var)
                loc.cstringExit    = StrConstant (string2CString @loc.exit) (stringType @loc.exit)
                loc.exit           = "[EXIT]" ++ hs2str @name ++ "\n"

SEM Constant
  | LiteralStr  lhs.constants = [ ( @loc.llvmVar , @loc.cstring) ]
                loc.cstring   = StrConstant (string2CString @value)
                                            @loc.strType 
                loc.strType   = Array (length @value + 1) i8
  | * - LiteralStr
                lhs.constants = [ ]
%%]

%%[8
--------------------------------------------------------------------------------
-- Passing down platform depended types.
--------------------------------------------------------------------------------

ATTR AllNT
     [ intType, pointerType, globalType : {LLVMType} | | ]
%%]

%%[8
--------------------------------------------------------------------------------
-- We pass down a map, containing the alias name and the 
-- corresponding Int value of constructor tags
--------------------------------------------------------------------------------
ATTR Functions Function 
     Statements Statement
     Alternatives Alternative
     Values Value
     Variables Variable
     Constant
     [ constantMap : {Data.Map.Map String Int} | | ]

SEM SilModule
  | SilModule   functions.constantMap = Data.Map.fromList @constants
%%]

%%[8
--------------------------------------------------------------------------------
-- TODO: Update comment
--------------------------------------------------------------------------------
ATTR Variable
     [ | | isLocal : {Bool} ]
                          
SEM Variable
  | Local       lhs.isLocal  = True
  | * - Local
                lhs.isLocal  = False                           
%%]

%%[8
--------------------------------------------------------------------------------
-- Pass the max size of the closure that is stored in RP up
-- so that we can initialize it at the start up.
--------------------------------------------------------------------------------
ATTR Functions Function 
     Statements Statement
     Alternatives Alternative
     Values Value
     Variables Variable
     [ | | maxRPIndex USE {`max`} {0}: {Int} ]

SEM Variable
  | Subs        lhs.maxRPIndex =
                             if @array.isRP then @index else 0  

ATTR Variable
     [ | | isRP : {Bool} ]
                          
SEM Variable
  | RP          lhs.isRP   = True
  | * - RP
                lhs.isRP   = False                           
%%]

%%[8
--------------------------------------------------------------------------------
-- Pass function declarations that are defined extern
--------------------------------------------------------------------------------
ATTR Functions Function 
     Statements Statement
     Alternatives Alternative
     Values Value
     Variables Variable
     [ | | externFuncs USE {++} {[]}: {[LLVMFunctionDecl]} ]
                       
SEM Value
  | Call        lhs.externFuncs = [@loc.fnDecl]                  
%%]

%%[8
{
-------------------------------------------------------------------------------
-- Functions for extraction of values from the (UID,[LLVMVar],LLVMStatements) 
-- tuples as used in 'LLVMExpression_Call' and 'LLVMStatement_Call' argument 
-- preparation.
-------------------------------------------------------------------------------
{-|
Return the 'UID' element from the tuple. 
-}
getUID :: (UID,[LLVMVar],LLVMStatements) -> UID
getUID (x,_,_) = x

{-|
Return the ['LLVMVar'] element from the tuple. 
-}
getVars :: (UID,[LLVMVar],LLVMStatements) -> [LLVMVar]
getVars (_,x,_) = x

{-|
Return the 'LLVMStatements' element from the tuple. 
-}
getCode :: (UID,[LLVMVar],LLVMStatements) -> LLVMStatements
getCode (_,_,x) = x
}
%%]

%%[8
{
-------------------------------------------------------------------------------
-- Some 'LLVMLLVMFunctionDecl_LLVMFunctionDecltionDecl's for usage in calls and forward declarations.
-------------------------------------------------------------------------------
{-|
Function declaration for the entry point of the binary.
-}
mainFuncDecl :: LLVMFunctionDecl
mainFuncDecl =
  LLVMFunctionDecl_LLVMFunctionDecl "main" i32 FixedArgs []

{-|
Function declaration for the Silly generated initialize function.
-}
initializeFuncDecl :: LLVMFunctionDecl
initializeFuncDecl =
  LLVMFunctionDecl_LLVMFunctionDecl "initialize" Void FixedArgs []

{-|
Function declaration for the GRIN generated fun_main function.
-}
fun_mainFuncDecl :: LLVMFunctionDecl
fun_mainFuncDecl =
  LLVMFunctionDecl_LLVMFunctionDecl "fun_main" Void FixedArgs []
  
fun_mainFullProgFuncDecl =  
  LLVMFunctionDecl_LLVMFunctionDecl "fun_mainFullProg" Void FixedArgs []

{-|
Function declaration of printf from the standard C library.
-}
stdlibPrintfFuncDecl :: LLVMFunctionDecl
stdlibPrintfFuncDecl = 
  LLVMFunctionDecl_LLVMFunctionDecl "printf" i32 VarArgs [(LocalVar "str" (pLift i8))]

{-|
Function declaration for a run-time function that reports an pattern match
failure and terminates the program.
-}
primPatternMatchFailureFuncDecl :: LLVMFunctionDecl
primPatternMatchFailureFuncDecl =
  LLVMFunctionDecl_LLVMFunctionDecl "primPatternMatchFailure" Void FixedArgs [] 

{-|
Function declaration for a run-time function that initializes the garbage
collector.
-}
gcInitFuncDecl :: LLVMFunctionDecl
gcInitFuncDecl =
  LLVMFunctionDecl_LLVMFunctionDecl "llvmgc_init" Void FixedArgs []
  
{-|
Function declaration for a run-time malloc function that is managed by the
garbage collector. The 'LLVMType' is used as argument type and for the
return type, supporting both 32 and 64 bit memory allocation.
-}  
gcMallocFuncDecl :: LLVMType -> LLVMFunctionDecl
gcMallocFuncDecl intType =
  LLVMFunctionDecl_LLVMFunctionDecl "llvmgc_malloc" (pLift intType) FixedArgs [(LocalVar "x" intType)] 

{-|
Function declaration for a run-time function that mallocs a piece of memory that
is added as root for garbage collection (in addition to the stack). The 'LLVMType' is used as 
argument type and for the return type, supporting both 32 and 64 bit memory allocation.
-}
gcMallocUncollectableFuncDecl :: LLVMType -> LLVMFunctionDecl
gcMallocUncollectableFuncDecl intType =
  LLVMFunctionDecl_LLVMFunctionDecl "llvmgc_malloc_uncollectable" (pLift intType) FixedArgs [(LocalVar "x" intType)] 

gcPrintStatsFuncDecl :: LLVMFunctionDecl
gcPrintStatsFuncDecl =
  LLVMFunctionDecl_LLVMFunctionDecl "llvmc_print_statistics" Void FixedArgs []
}
%%]

%%[8
{
-------------------------------------------------------------------------------
-- Cast functions
-------------------------------------------------------------------------------
{-|
Cast a 'LLVMVar' to the given 'LLVMType' 'LLVMInt' type. Note: There is no check
on the 'LLVMType' if it is an integer type. If you pass an non integer type,
then the result of the cast is undefined.
-}
cast2int :: UID -> LLVMVar -> LLVMType -> (UID,LLVMVar,LLVMStatements)   
cast2int nr var intType =
  if isInt (getType var)
  then (nr,var,[])
  else let (nr', fresh) = newFresh nr intType
        in (nr', fresh, [LLVMStatement_Assignment fresh $ LLVMExpression_Cast var intType])
 
{-|
Cast a 'LLVMVar' to the given 'LLVMType' 'Pointer' type. Note: There is no check
on the 'LLVMType' if it is a pointer type. If you pass an non pointer type,
then the result of the cast is undefined.
-}       
cast2ptr :: UID -> LLVMVar -> LLVMType -> (UID,LLVMVar,LLVMStatements)
cast2ptr nr var ptrType
  | isPointer (getType var) =
    (nr,var,[])
  | otherwise =
    let (nr', fresh) = newFresh nr ptrType
     in (nr', fresh, [LLVMStatement_Assignment fresh $ LLVMExpression_Cast var ptrType])         

{-|
Cast a 'LLVMVar' in such a way that is fits in the location as defined by the second
'LLVMVar'. For example, the first var is an i32 and the second var is an i32**. Then
a cast will be generated to transform the first var to an i32*.
-}   
makeFitting :: UID -> LLVMVar -> LLVMVar -> (UID,LLVMVar,LLVMStatements)
makeFitting nr what hole 
  -- Case 1 it already fits, no casting needed
  | getType what == pLower (getType hole) =
    (nr,what,[])
  -- Cast 'what' to the lowered type of 'hole'.
  | otherwise = 
    let targetType   = pLower $ getType hole 
        (nr', fresh) = newFresh nr targetType
     in (nr', fresh, [LLVMStatement_Assignment fresh $ LLVMExpression_Cast what targetType])
}
%%]

%%[8
{
-------------------------------------------------------------------------------
-- Variable loading functions.
-------------------------------------------------------------------------------
{-|
Load a 'LLVMVar'.
-}
load :: UID -> LLVMVar -> (UID,LLVMVar,LLVMStatements)
load nr var =
  let loadType     = pLower (getType var)
      (nr', fresh) = newFresh nr loadType
   in (nr', fresh, [LLVMStatement_Assignment fresh (LLVMExpression_Load var)])
   
{-|
Load a 'LLVMVar' to an integer.
-}   
load2value :: UID -> LLVMVar -> (UID,LLVMVar,LLVMStatements)
load2value nr var 
  | isInt (getType var) = (nr,var,[])
  | otherwise           =
    let (nr1,var1,stmts1) = load nr var
        (nr2,var2,stmts2) = load2value nr1 var1
     in (nr2,var2, stmts1 ++ stmts2)       
}
%%]

%%[8
{
-------------------------------------------------------------------------------
-- Assign an 'LLVMExpression' to a 'LLVMVar'.
-------------------------------------------------------------------------------
{-|
Return a fresh local variable of the requested 'LLVMType'
-}
newFresh :: UID -> LLVMType -> (UID,LLVMVar)
newFresh nr tp = 
  (uidNext nr, LocalVar ("fresh" ++ show nr) tp)

{-|
Assign the given 'LLVMExpression' with the given 'LLVMType' to 
a fresh local 'LLVMVar'.
-}
assign2var :: UID -> (LLVMExpression,LLVMType) -> (UID,LLVMVar,LLVMStatements)
assign2var nr (expr,tp) =
  let (nr', fresh) = newFresh nr tp
   in (nr', fresh, [LLVMStatement_Assignment fresh expr])
}
%%]

%%[8
{
-------------------------------------------------------------------------------
-- Often used constants.
-------------------------------------------------------------------------------
{-|
The default arm for a 'LLVMStatement_Switch'.
-}
defaultCase :: UID -> (UID,LLVMVar,LLVMStatements)
defaultCase nr =
  let (nr1, fresh1) = newFresh nr Label
   in (nr1, fresh1, [ LLVMStatement_Label fresh1, LLVMStatement_Call primPatternMatchFailureFuncDecl StdCall [] ])
}
%%]

%%[8
{
-------------------------------------------------------------------------------
-- Construct LLVM Data
-------------------------------------------------------------------------------
{-|
Create a 'LLVMExpression' that allocates @nr * sizeof( LLVMType )@ bytes.
-}
mkMalloc :: Bool -> LLVMType -> Int -> LLVMExpression
mkMalloc unCollectable intType nr =
  if rtsUseGC
  then let size = nr * sizeofPointer
        in if unCollectable
           then LLVMExpression_Call (gcMallocUncollectableFuncDecl intType) StdCall [Constant size intType]
           else LLVMExpression_Call (gcMallocFuncDecl intType) StdCall [Constant size intType]
  else LLVMExpression_Malloc intType nr
}
%%]

%%[8
{
-------------------------------------------------------------------------------
-- Auxiliary functions
-------------------------------------------------------------------------------
{-|
Fetch the string representation of a 'HsName'
-}
hs2str :: HsName -> String
hs2str = hsnShowAlphanumeric

{-|
Return a list of variables with a given constructor, a list of HsNames and
one type. used primary for parameter lists
-}
mkVarList :: (String -> LLVMType -> LLVMVar) -> [HsName] -> LLVMType -> [LLVMVar]
mkVarList constr names tp =
  zipWith (\x y -> constr (hs2str x) y) names (repeat tp)

{-|
Convert a Haskell string to a LLVM C string by adding a c prefix, adding 
explict quotes and terminate with \\0

@hello -> c\"hello\\0\"@
-}
string2CString :: String -> String
string2CString str =
  "c\"" ++ str ++ "\\00\""
 
{-|
Generate the C type of a Haskell string. For example \"Hello World\" would result
in an @Array 12 i8@.
-} 
stringType :: String -> LLVMType
stringType str =
  Array (length str + 1) i8
 
{-|
Convert a Bool to a 'LLVMCallType', True indicating a 'TailCall' while any other
value indicates 'StdCall'
-} 
bool2calltype :: Bool -> LLVMCallType
bool2calltype (True)  = TailCall
bool2calltype (False) = StdCall 
}
%%]
