%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Prettyprint Grin ByteCode program as C
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs module {%{GRIN}GrinByteCode.PrettyC} import(UU.Pretty,EH.Util.PPUtils,{%{EH}Base.Common},{%{EH}Base.Opts},qualified {%{GRIN}Config} as Cfg,{%{GRIN}GrinByteCode})
%%]

%%[8 hs import(UU.Pretty,EH.Util.PPUtils,{%{EH}Base.Common},{%{EH}Base.Opts},qualified {%{GRIN}Config} as Cfg,{%{GRIN}GrinByteCode})
%%]

%%[8 hs import(Data.Maybe,Data.Bits,EH.Util.FastSeq,EH.Util.Utils,qualified Data.Map as Map)
%%]

%%[8 hs export(ppGBModAsC)
%%]

%%[8 import({GrinByteCode/AbsSyn})
%%]

%%[8 hs
ppGBModAsC :: EHCOpts -> Module -> PP_Doc
ppGBModAsC opts m
  = let t = wrap_AGItf (sem_AGItf (AGItf_AGItf m))
                       (Inh_AGItf {opts_Inh_AGItf = opts}
                       )
    in  pp_Syn_AGItf t
%%]

%%[8
WRAPPER AGItf
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% General info
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR AGItf Module [ opts: EHCOpts | | ]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Utils
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs
ppCmtC :: PP a => a -> PP_Doc
ppCmtC x = "/*" >#< pp x >#< "*/"

ppHex :: Integral a => Int -> a -> PP_Doc
ppHex prec x = head $ ppHex' Nothing prec x

ppHex' :: Integral a => Maybe Int -> Int -> a -> [PP_Doc]
ppHex' split prec x
  = case split of
      Nothing  -> ["0x" >|< h]
      Just spl -> map ("0x" >|<) $ s h
               where s l = case splitAt spl l of
                             ([],_ ) -> []
                             (l1,l2) -> l1 : s l2
  where h = strHex prec x
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Code offset
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR Instr Instrs AllImm [ | cLoc: Int | ]

SEM Module
  | Mod         instrs      .   cLoc        =   0

SEM Imm
  | Int         lhs         .   cLoc        =   @lhs.cLoc + @sz

SEM Instr
  | LdGlobal    loc         .   linkCLoc    =   @lhs.cLoc + 1
  | Label       loc         .   labelCLoc   =   @lhs.cLoc
  | LabelRef    loc         .   labelCLocAft=   @lhs.cLoc + Cfg.gbLabelOffsetSize

SEM Instr
  | Ld          imm         .   cLoc        =   @lhs.cLoc + 1
  | LdGlobal    lhs         .   cLoc        =   @linkCLoc + fromInteger Cfg.sizeofGrWord
  | LabelRef    lhs         .   cLoc        =   @labelCLocAft
  | TailCall RetCall
                nArgMine    .   cLoc        =   @lhs.cLoc + 2
  | CaseCall    nCases      .   cLoc        =   @lhs.cLoc + 2
  | Halt        lhs         .   cLoc        =   @lhs.cLoc + 2
  | AllocStore Fetch Call Eval Apply
                lhs         .   cLoc        =   @lhs.cLoc + 1
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Labels
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR AllInstr [ | | locRefs USE {:++:} {FSeqNil}: {FastSeq (LocRef,Int)} ]

SEM Instr
  | Label       lhs         .   locRefs     =   FSeq (@locRef,@labelCLoc)
%%]

%%[8 hs
type LabelMp = Map.Map LabelId Int
%%]

%%[8
ATTR AllInstr [ | | gathLabelMp USE {`Map.union`} {Map.empty}: LabelMp ]

SEM Instr
  | Label       lhs         .   gathLabelMp =   if lrefIsLabel @locRef then Map.singleton (lrefId @locRef) @labelCLoc else Map.empty
%%]

%%[8
ATTR AllInstr [ labelMp: LabelMp | | ]

SEM Module
  | Mod         loc         .   labelMp     =   @instrs.gathLabelMp
%%]

%%[8
SEM Instr
  | LabelRef    loc         .   refOff      =   (panicJust "Instr.LabelRef.refOff" $ Map.lookup (lrefId @locRef) @lhs.labelMp) - @labelCLocAft
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Link entries
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR AllInstr [ | | links USE {:++:} {FSeqNil}: {FastSeq (Link,Int)} ]

SEM Instr
  | LdGlobal    lhs         .   links       =   FSeq (@link,@linkCLoc)
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% PP as code
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs
ppHexL :: [PP_Doc] -> PP_Doc
ppHexL
  = ppCommas . cvt
  where cvt = if Cfg.machineIsBigEndian then id else reverse

ppArr :: PP a => [a] -> PP_Doc
ppArr l = indent 2 (ppCurlysCommasBlock l >#< ";")

ppCast :: String -> PP_Doc -> PP_Doc
ppCast t v = ppParens $ ppParens t >|< ppParens v

ppCnst :: PP_Doc -> Const -> PP_Doc
ppCnst ct (ConstStr i) = ppCast "GB_Word" ("&" >|< ct >|< "[" >|< i >|< "]")

ppLine :: PP_Doc -> PP_Doc
ppLine p = p >-< text ""

ppFun :: (PP h, PP b) => h -> b -> PP_Doc
ppFun h b = h >#< "{" >-< indent 2 b >-< "}"

ppArrAt :: (PP a,PP o) => a -> o -> PP_Doc
ppArrAt a o = a >|< "[" >|< o >|< "]"

ppAddrArrAt :: (PP a,PP o) => a -> o -> PP_Doc
ppAddrArrAt a o = "&" >|< ppArrAt a o

mkPre :: String -> String
mkPre = (++ "_")

ppTbl :: String -> PP_Doc -> [PP_Doc] -> PP_Doc
ppTbl tp nm tbl = ppLine $ "static" >#< tp >#< nm >|< "[] =" >-< ppArr tbl
%%]

%%[8
ATTR AllNT AGItf [ | | pp USE {>-<} {empty}: PP_Doc ]
%%]

%%[8
SEM Module
  | Mod         loc         .   moduleNmPre             =   mkPre @moduleNm
                            .   ppNm                    =   \n -> @moduleNmPre >|< n
                            .   ppNmStringTbl           =   @ppNm "strings"
                            .   ppNmByteCodeTbl         =   @ppNm "bytecode"
                            .   ppNmConstTbl            =   @ppNm "constants"
                            .   ppNmLinkEntriesTbl      =   @ppNm "linkEntries"
                            .   ppNmGlobEntriesTbl      =   @ppNm "globalEntries"
                            .   ppNmCafEntriesTbl       =   @ppNm "cafEntries"
                            .   ppNmFixOffsetsTbl       =   @ppNm "fixOffsets"
                            .   strNmInitF              =   "initModuleTables"
                            .   ppNmInitF               =   @ppNm @strNmInitF
                            .   ppNmMainInit2F          =   @ppNm "main_GB_Init2"
                            .   ppNmMainCAFEntry        =   @ppNm "mainEntryPtr"

                lhs         .   pp          =   let top     = ppLine $ ppCmtC ("bytecode in C encoding for module" >#< @moduleNm) >-< "#include \"rts.h\""
                                                    strings = ppTbl "char*" @ppNmStringTbl (map (pp.show) @stringL)
                                                    consts  = ppTbl "GB_Word" @ppNmConstTbl (map (ppCnst @ppNmStringTbl) @constL)
                                                    bcode   = ppTbl "GB_Byte" @ppNmByteCodeTbl @instrs.ppL
                                                    linkL   = toList @instrs.links
                                                    links   = ppTbl "GB_LinkEntry" @ppNmLinkEntriesTbl
                                                                (map (\(l,c)
                                                                       -> ppCurlysCommasBlock
                                                                            [ pp $ fromEnum $ linkTbl l, pp $ linkInx l
%%[[12
                                                                            , pp $ linkMod l
%%]]
                                                                            , ppAddrArrAt @ppNmByteCodeTbl c
                                                                            ]
                                                                     )
                                                                 $ linkL
                                                                )
                                                    centries= ppTbl "GB_BytePtr" @ppNmGlobEntriesTbl
                                                                [ ppAddrArrAt @ppNmByteCodeTbl c | (LocRef_CodeEntry _,c) <- sortOn fst $ toList @instrs.locRefs ]
                                                    cafs    = ppTbl "GB_BytePtr*" @ppNmCafEntriesTbl
                                                                [ ppAddrArrAt @ppNmGlobEntriesTbl i | i <- @cafEntryL ]
                                                    fixOffL = [ (fromJust c,sz) | (FixOffset l sz) <- @fixOffsetL, let c = Map.lookup l @labelMp, isJust c ]
                                                    fixoffs = ppTbl "GB_FixOffset" @ppNmFixOffsetsTbl
                                                                [ ppCurlysCommasBlock [ppCast "GB_Offset*" $ ppAddrArrAt @ppNmByteCodeTbl c,pp sz] | (c,sz) <- fixOffL ]
                                                    initf   = ppLine $ ppCmtC "Initialization"
                                                                       >-< ppFun ("void" >#< @ppNmInitF >|< "()")
                                                                                 ("gb_InitTables" >|< ppParensCommasBlock args >#< ";")
                                                            where args = [ pp @instrs.cLoc, @ppNmByteCodeTbl
                                                                         , pp (length linkL), @ppNmLinkEntriesTbl
                                                                         , @ppNmGlobEntriesTbl
                                                                         , pp (length @cafEntryL), @ppNmCafEntriesTbl
                                                                         , pp (length fixOffL), @ppNmFixOffsetsTbl
                                                                         , @ppNmConstTbl
                                                                         ]
                                                    init2mf = ppLine $ ppFun ("void" >#< @ppNmMainInit2F >|< "()")
                                                                             ( vlist [ mkPre m >|< @strNmInitF >|< "() ;" | m <- [@moduleNm] ] )
                                                    maincaf = ppLine $ "static GB_BytePtr*" >#< @ppNmMainCAFEntry >#< "=" >#< ppAddrArrAt @ppNmGlobEntriesTbl @mainCafEntry >#< ";"
                                                    mainf   = ppLine $ ppCmtC "Main entry point"
                                                                       >-< ppFun "int main(int argc, char** argv)"
                                                                                 (    "main_GB_Init1( argc, argv) ;"
                                                                                  >-< @ppNmMainInit2F >|< "( argc, argv) ;"
                                                                                  >-< "main_GB_Run( argc, argv, gb_code_Startup, Cast(GB_Word,*" >|< @ppNmMainCAFEntry >|< ") ) ;"
                                                                                  >-< "return main_GB_Exit( argc, argv) ;"
                                                                                 )
                                                    etc     = if ehcOptEmitLlc @lhs.opts
                                                              then empty
                                                              else ppLine $ ppCmtC "Dummy defs for Silly"
                                                                   >-< "void fun_main(void){}" >-< "void initialize(void){}"
                                                in  top
                                                    >-< strings
                                                    >-< consts
                                                    >-< bcode
                                                    >-< centries
                                                    >-< cafs
                                                    >-< maincaf
                                                    >-< links
                                                    >-< fixoffs
                                                    >-< initf
                                                    >-< init2mf
                                                    >-< etc
                                                    >-< mainf
%%]

%%[8 hs
ppLink :: (Integral c) => Int -> c -> PP_Doc
ppLink sz = ppHexL . ppHex' (Just 2) (sz * 2)
%%]

%%[8
SEM Instr
  | Ld          lhs         .   pp          =   ppCommas [ppHex 2 @enc,@imm.pp]
  | AllocStore Fetch Call Eval Apply
                lhs         .   pp          =   ppCommas [ppHex 2 @enc]
  | TailCall RetCall
                lhs         .   pp          =   ppCommas [ppHex 2 @enc,ppHex 2 @enc2,@nArgMine.pp,@nArgSurr.pp,@retOffSurr.pp]
  | CaseCall    lhs         .   pp          =   ppCommas [ppHex 2 @enc,ppHex 2 @enc2,@nCases.pp]
  | Ann         lhs         .   pp          =   @instr.pp >#< ppCmtC @ann
  | Halt        lhs         .   pp          =   ppCommas [ppHex 2 @ext,ppHex 2 @enc]
  | LdGlobal    lhs         .   pp          =   ppCommas [ppHex 2 @enc, ppLink (fromInteger Cfg.sizeofGrWord) $ linkInx @link]
  | LabelRef    lhs         .   pp          =   ppCommas [ppLink Cfg.gbLabelOffsetSize @refOff]
%%]

%%[8
SEM Imm
  | Int         loc         .   (ppL,sz)    =   case @lhs.immSz of
                                                  InsOp_ImmSz_Bits08 -> (ppHex' (Just 2)  2 @int,1)
                                                  InsOp_ImmSz_Bits16 -> (ppHex' (Just 2)  4 @int,2)
                                                  InsOp_ImmSz_Bits32 -> (ppHex' (Just 2)  8 @int,4)
                                                  InsOp_ImmSz_Bits64 -> (ppHex' (Just 2) 16 @int,8)
                lhs         .   pp          =   ppHexL @ppL
%%]

%%[8
ATTR Instrs [ | | ppL : {[PP_Doc]} ]

SEM Instrs
  | Nil         lhs         .   ppL         =   []
  | Cons        lhs         .   ppL         =   if @hd.hasCode
                                                then (ppCmtC (@lhs.cLoc >|< ":" >#< @hd.mn) >|< @lhs.ppExtra >-< indent 3 @hd.pp) : @tl.ppL
                                                else @tl.ppL
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Generates code?
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR Instr [ | | hasCode: Bool ]

SEM Instr
  | Meta Label  lhs         .   hasCode     =   False
  | * - Meta Label
                lhs         .   hasCode     =   True
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Additional comment
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR Instr Meta [ | | ppExtra USE {>|<} {empty}: PP_Doc ]
ATTR Instrs [ ppExtra: PP_Doc | | ]

SEM Meta
  | CmtHeader   lhs         .   ppExtra     =   indent 40 (ppCmtC ("[" >#< @ann >#< "]"))

SEM Instr
  | Label       lhs         .   ppExtra     =   ppCmtC ("[ .lbl" >#< lrefId @locRef >#< "]")

SEM Instrs
  | Cons        tl          .   ppExtra     =   @hd.ppExtra

SEM Module
  | Mod         instrs      .   ppExtra     =   empty
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% PP as mnemonic
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR AllInsOp Instr Imm [ | | mn USE {>|<} {empty}: PP_Doc ]
%%]

%%[8
SEM Instr
  | Ld          lhs         .   mn          =   "l"             >|< @ind.mn >|< @locDst.mn >|< @locSrc.mn >|< @immSz.mn >#< @imm.mn
  | AllocStore  lhs         .   mn          =   "allocstore"    >|< @locSrc.mn
  | Fetch       lhs         .   mn          =   "fetch"         >|< @locSrc.mn
  | Call        lhs         .   mn          =   "call"          >|< @locSrc.mn
  | TailCall    lhs         .   mn          =   "tailcall"      >|< @locSrc.mn >|< @nArgMineSz.mn >|< @nArgSurrSz.mn >|< @retOffSurrSz.mn >#< @nArgMine.mn >#< @nArgSurr.mn >#< @retOffSurr.mn
  | CaseCall    lhs         .   mn          =   "casecall"      >|< @nCasesSz.mn >#< @nCases.mn
  | RetCall     lhs         .   mn          =   "retcall"       >|< @nArgMineSz.mn >|< @nArgSurrSz.mn >|< @retOffSurrSz.mn >#< @nArgMine.mn >#< @nArgSurr.mn >#< @retOffSurr.mn
  | Eval        lhs         .   mn          =   "eval"          >|< @locSrc.mn
  | Apply       lhs         .   mn          =   "apply"         >|< @locSrc.mn
  | Halt        lhs         .   mn          =   pp "halt"
  | LdGlobal    lhs         .   mn          =   pp "ldg"
  | LabelRef    lhs         .   mn          =   ".ref"          >#< lrefId @locRef

SEM Imm
  | Int         lhs         .   mn          =   case @lhs.immSz of
                                                  InsOp_ImmSz_Bits08 -> ppHex  2 @int
                                                  InsOp_ImmSz_Bits16 -> ppHex  4 @int
                                                  InsOp_ImmSz_Bits32 -> ppHex  8 @int
                                                  InsOp_ImmSz_Bits64 -> ppHex 16 @int

SEM InsOp_LocE
  | TOS         lhs         .   mn          =   pp "t"
  | Reg         lhs         .   mn          =   pp "r"
  | Imm         lhs         .   mn          =   pp "i"
  | PC          lhs         .   mn          =   pp "p"

SEM InsOp_LocB
  | TOS         lhs         .   mn          =   pp "t"
  | Reg         lhs         .   mn          =   pp "r"

SEM InsOp_LocO
  | TOS         lhs         .   mn          =   pp "t"
  | Reg         lhs         .   mn          =   pp "r"
  | SP          lhs         .   mn          =   pp "s"
  | PC          lhs         .   mn          =   pp "p"

SEM InsOp_TyOp
  | Add         lhs         .   mn          =   pp "a"
  | Sub         lhs         .   mn          =   pp "s"
  | Mul         lhs         .   mn          =   pp "m"
  | Div         lhs         .   mn          =   pp "d"

SEM InsOp_DataOp
  | Int1        lhs         .   mn          =   pp "i1"
  | Int2        lhs         .   mn          =   pp "i2"
  | Float1      lhs         .   mn          =   pp "f1"
  | Float2      lhs         .   mn          =   pp "f2"

SEM InsOp_ImmSz
  | Bits08      lhs         .   mn          =   pp "08"
  | Bits16      lhs         .   mn          =   pp "16"
  | Bits32      lhs         .   mn          =   pp "32"
  | Bits64      lhs         .   mn          =   pp "64"

SEM InsOp_Deref
  | Zero        lhs         .   mn          =   pp "0"
  | One         lhs         .   mn          =   pp "1"
  | Two         lhs         .   mn          =   pp "2"
  | Int         lhs         .   mn          =   pp "i"

%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Encodings, must be similar to rts/src/grinbc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR AllInsOp Meta [ | | enc: Int ]

SEM Instr
  | Ld          loc         .   enc         =   0x00 .|. (@ind.enc `shiftL` 5) .|. (@locDst.enc `shiftL` 4) .|. (@locSrc.enc `shiftL` 2) .|. (@immSz.enc)
  | AllocStore  loc         .   enc         =   0xEC .|. (@locSrc.enc)
  | Fetch       loc         .   enc         =   0xEE .|. (@locSrc.enc)
  | Call        loc         .   enc         =   0xC0 .|. (@locSrc.enc)
  | TailCall    loc         .   enc         =   0xC2 .|. (@locSrc.enc)
  | RetCall     loc         .   enc         =   0xC4
  | CaseCall    loc         .   enc         =   0xC6
  | TailCall RetCall
                loc         .   enc2        =   (@nArgMineSz.enc `shiftL` 4) .|. (@nArgSurrSz.enc `shiftL` 2) .|. (@retOffSurrSz.enc)
  | CaseCall    loc         .   enc2        =   (@nCasesSz.enc)
  | Eval        loc         .   enc         =   0xE0 .|. (@locSrc.enc)
  | Apply       loc         .   enc         =   0xE2 .|. (@locSrc.enc)
  | LdGlobal    loc         .   enc         =   0xFC
  | Halt        loc         .   ext         =   0xFE
                            .   enc         =   0xFF

SEM Meta
  | CmtHeader   loc         .   enc         =   0xFF

SEM InsOp_LocE
  | TOS         lhs         .   enc         =   0
  | Reg         lhs         .   enc         =   1
  | Imm         lhs         .   enc         =   2
  | PC          lhs         .   enc         =   3

SEM InsOp_LocB
  | TOS         lhs         .   enc         =   0
  | Reg         lhs         .   enc         =   1

SEM InsOp_LocO
  | TOS         lhs         .   enc         =   0
  | Reg         lhs         .   enc         =   1
  | SP          lhs         .   enc         =   2
  | PC          lhs         .   enc         =   3

SEM InsOp_TyOp
  | Add         lhs         .   enc         =   0
  | Sub         lhs         .   enc         =   1
  | Mul         lhs         .   enc         =   2
  | Div         lhs         .   enc         =   3

SEM InsOp_DataOp
  | Int1        lhs         .   enc         =   0
  | Int2        lhs         .   enc         =   1
  | Float1      lhs         .   enc         =   2
  | Float2      lhs         .   enc         =   3

SEM InsOp_ImmSz
  | Bits08      lhs         .   enc         =   0
  | Bits16      lhs         .   enc         =   1
  | Bits32      lhs         .   enc         =   2
  | Bits64      lhs         .   enc         =   3

SEM InsOp_Deref
  | Zero        lhs         .   enc         =   0
  | One         lhs         .   enc         =   1
  | Two         lhs         .   enc         =   2
  | Int         lhs         .   enc         =   3
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% How to pp, context
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR Imm [ immSz: InsOp_ImmSz | | ]

SEM Instr
  | Ld          imm         .   immSz       =   @immSz.self
  | TailCall RetCall
                nArgMine    .   immSz       =   @nArgMineSz.self
                nArgSurr    .   immSz       =   @nArgSurrSz.self
                retOffSurr  .   immSz       =   @retOffSurrSz.self
  | CaseCall    nCases      .   immSz       =   @nCasesSz.self
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Replica's, SELF
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR InsOp_ImmSz [ | | self: SELF ]
%%]

