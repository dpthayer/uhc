%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Prettyprint Grin ByteCode program as C
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs module {%{GRIN}GrinByteCode.PrettyC} import(UU.Pretty,EH.Util.PPUtils,{%{EH}Base.Common},{%{EH}Base.Opts},qualified {%{GRIN}Config} as Cfg,{%{GRIN}GrinByteCode})
%%]

%%[8 hs import(Data.Bits,EH.Util.FastSeq)
%%]

%%[8 hs export(ppGBModAsC)
%%]

%%[8 import({GrinByteCode/AbsSyn})
%%]

%%[8 hs
ppGBModAsC :: EHCOpts -> Module -> PP_Doc
ppGBModAsC opts m
  = let t = wrap_AGItf (sem_AGItf (AGItf_AGItf m))
                       (Inh_AGItf
                       )
    in  pp_Syn_AGItf t
%%]

%%[8
WRAPPER AGItf
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Utils
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs
ppCmtC :: PP a => a -> PP_Doc
ppCmtC x = "/*" >#< pp x >#< "*/"

ppHex :: Integral a => Int -> a -> PP_Doc
ppHex prec x = head $ ppHex' Nothing prec x

ppHex' :: Integral a => Maybe Int -> Int -> a -> [PP_Doc]
ppHex' split prec x
  = case split of
      Nothing  -> ["0x" >|< h]
      Just spl -> map ("0x" >|<) $ s h
               where s l = case splitAt spl l of
                             ([],_ ) -> []
                             (l1,l2) -> l1 : s l2
  where h = strHex prec x
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Code offset
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR Instr Instrs AllImm [ | cLoc: Int | ]

SEM Module
  | Mod         instrs      .   cLoc        =   0

SEM Imm
  | Int         lhs         .   cLoc        =   @lhs.cLoc + @sz

SEM Instr
  | Ld          imm         .   cLoc        =   @lhs.cLoc + 1
  | LdGlobal    loc         .   linkCLoc    =   @lhs.cLoc + 1
                lhs         .   cLoc        =   @linkCLoc + fromInteger Cfg.sizeofGrWord
  | TailCall    nArgMine    .   cLoc        =   @lhs.cLoc + 2
  | Halt        lhs         .   cLoc        =   @lhs.cLoc + 2
  | * - Ld TailCall Ann LdGlobal Halt Meta
                lhs         .   cLoc        =   @lhs.cLoc + 1
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Link entries
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR AllInstr AllImm [ | | links USE {:++:} {FSeqNil}: {FastSeq (Link,Int)} ]

SEM Instr
  | LdGlobal    lhs         .   links       =   FSeq (@link,@linkCLoc)
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% PP as code
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs
ppHexL :: [PP_Doc] -> PP_Doc
ppHexL
  = ppCommas . cvt
  where cvt = if Cfg.machineIsBigEndian then id else reverse

ppArr :: PP a => [a] -> PP_Doc
ppArr l = indent 2 (ppCurlysCommasBlock l >#< ";")

ppCnst :: PP_Doc -> Const -> PP_Doc
ppCnst ct (ConstStr i) = ppParens "GB_Word" >|< ppParens ("&" >|< ct >|< "[" >|< i >|< "]")

ppLine :: PP_Doc -> PP_Doc
ppLine p = p >-< text ""

ppFun :: (PP h, PP b) => h -> b -> PP_Doc
ppFun h b = h >#< "{" >-< indent 2 b >-< "}"

mkPre :: String -> String
mkPre = (++ "_")
%%]

%%[8
ATTR AllNT AGItf [ | | pp USE {>-<} {empty}: PP_Doc ]
%%]

%%[8
SEM Module
  | Mod         loc         .   moduleNmPre =   mkPre @moduleNm
                            .   ppNm        =   \n -> @moduleNmPre >|< n
                            .   ppNmSTbl    =   @ppNm "strings"
                            .   ppNmBCTbl   =   @ppNm "bytecode"
                            .   ppNmCTbl    =   @ppNm "constants"
                            .   ppNmBCTblSz =   @ppNmBCTbl >|< "Sz"
                            .   ppNmLTbl    =   @ppNm "linkEntries"
                            .   strNmInitF  =   "initTbls"
                            .   ppNmInitF   =   @ppNm @strNmInitF
                            .   ppNmMainInit2F
                                            =   @ppNm "main_GB_Init2"
                            .   ppNmLTblSz  =   @ppNmLTbl >|< "Sz"
                lhs         .   pp          =   let top     = ppLine $ ppCmtC ("bytecode in C encoding for module" >#< @moduleNm) >-< "#include \"rts.h\""
                                                    strings = ppLine $ "static char*" >#< @ppNmSTbl >|< "[] =" >-< ppArr (map (pp.show) @stringL)
                                                    consts  = ppLine $ "static GB_Word" >#< @ppNmCTbl >|< "[] =" >-< ppArr (map (ppCnst @ppNmSTbl) @constL)
                                                    bcode   = ppLine $ "static GB_Byte" >#< @ppNmBCTbl >|< "[] =" >-< ppArr (@instrs.ppL)
                                                                       >-< "static int" >#< @ppNmBCTblSz >#< "=" >#< @instrs.cLoc >#< ";"
                                                    links   = ppLine $ "static GB_LinkEntry" >#< @ppNmLTbl >|< "[] ="
                                                                       >-< ppArr (map (\(l,c) -> ppCurlysCommasBlock [pp $ linkMod l, pp $ fromEnum $ linkTbl l, pp $ linkInx l, "&" >|< @ppNmBCTbl >|< "[" >|< c >|< "]"])
                                                                                  $ linkL
                                                                                 )
                                                                       >-< "static int" >#< @ppNmLTblSz >#< "=" >#< length linkL >#< ";"
                                                            where linkL = toList @instrs.links
                                                    initf   = ppLine $ ppCmtC "Initialization"
                                                                       >-< ppFun ("void" >#< @ppNmInitF >|< "()")
                                                                                 ("gb_InitTbls(" >#< ppCommas [@ppNmLTblSz, @ppNmLTbl, @ppNmCTbl] >#< ") ;")
                                                    init2mf = ppLine $ ppFun ("void" >#< @ppNmMainInit2F >|< "()")
                                                                             ( vlist [ mkPre m >|< @strNmInitF >|< "() ;" | m <- [@moduleNm] ] )
                                                    mainf   = ppLine $ ppCmtC "Main entry point"
                                                                       >-< ppFun "int main(int argc, char** argv)"
                                                                                 (    "main_GB_Init1( argc, argv) ;"
                                                                                  >-< @ppNmMainInit2F >|< "( argc, argv) ;"
                                                                                  >-< "main_GB_Run( argc, argv) ;"
                                                                                  >-< "return main_GB_Exit( argc, argv) ;"
                                                                                 )
                                                in  top
                                                    >-< strings
                                                    >-< consts
                                                    >-< bcode
                                                    >-< links
                                                    >-< initf
                                                    >-< init2mf
                                                    >-< mainf
%%]

%%[8
SEM Instr
  | Ld          lhs         .   pp          =   ppCommas [ppHex 2 @enc,@imm.pp]
  | AllocStore Call Eval Apply
                lhs         .   pp          =   ppCommas [ppHex 2 @enc]
  | TailCall    lhs         .   pp          =   ppCommas [ppHex 2 @enc,ppHex 2 @enc2,@nArgMine.pp,@nArgSurr.pp,@retOffSurr.pp]
  | Ann         lhs         .   pp          =   @instr.pp >#< ppCmtC @ann
  | Halt        lhs         .   pp          =   ppCommas [ppHex 2 @ext,ppHex 2 @enc]
  | LdGlobal    lhs         .   pp          =   ppCommas [ppHex 2 @enc, ppHexL $ ppHex' (Just 2) (fromInteger $ Cfg.sizeofGrWord * 2) (linkInx @link)]
%%]

%%[8
SEM Imm
  | Int         loc         .   (ppL,sz)    =   case @lhs.immSz of
                                                  InsOp_ImmSz_Bits08 -> (ppHex' (Just 2)  2 @int,1)
                                                  InsOp_ImmSz_Bits16 -> (ppHex' (Just 2)  4 @int,2)
                                                  InsOp_ImmSz_Bits32 -> (ppHex' (Just 2)  8 @int,4)
                                                  InsOp_ImmSz_Bits64 -> (ppHex' (Just 2) 16 @int,8)
                lhs         .   pp          =   ppHexL @ppL
%%]

%%[8
ATTR Instrs [ | | ppL : {[PP_Doc]} ]

SEM Instrs
  | Nil         lhs         .   ppL         =   []
  | Cons        lhs         .   ppL         =   if @hd.hasCode
                                                then (ppCmtC (@lhs.cLoc >|< ":" >#< @hd.mn) >|< @lhs.ppExtra >-< indent 3 @hd.pp) : @tl.ppL
                                                else @tl.ppL
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Generates code?
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR Instr [ | | hasCode: Bool ]

SEM Instr
  | Meta        lhs         .   hasCode     =   False
  | * - Meta    lhs         .   hasCode     =   True
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Additional comment
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR Instr Meta [ | | ppExtra USE {>|<} {empty}: PP_Doc ]
ATTR Instrs [ ppExtra: PP_Doc | | ]

SEM Meta
  | CmtHeader   lhs         .   ppExtra     =   indent 40 (ppCmtC ("[" >#< @ann >#< "]"))

SEM Instrs
  | Cons        tl          .   ppExtra     =   @hd.ppExtra

SEM Module
  | Mod         instrs      .   ppExtra     =   empty
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% PP as mnemonic
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR AllInsOp Instr Imm [ | | mn USE {>|<} {empty}: PP_Doc ]
%%]

%%[8
SEM Instr
  | Ld          lhs         .   mn          =   "l"             >|< @ind.mn >|< @locDst.mn >|< @locSrc.mn >|< @immSz.mn >#< @imm.mn
  | AllocStore  lhs         .   mn          =   "allocstore"    >|< @locSrc.mn
  | Call        lhs         .   mn          =   "call"          >|< @locSrc.mn
  | TailCall    lhs         .   mn          =   "tailcall"      >|< @locSrc.mn >|< @nArgMineSz.mn >|< @nArgSurrSz.mn >|< @retOffSurrSz.mn >#< @nArgMine.mn >#< @nArgSurr.mn >#< @retOffSurr.mn
  | Eval        lhs         .   mn          =   "eval"          >|< @locSrc.mn
  | Apply       lhs         .   mn          =   "apply"         >|< @locSrc.mn
  | Halt        lhs         .   mn          =   pp "halt"
  | LdGlobal    lhs         .   mn          =   pp "ldg"

SEM Imm
  | Int         lhs         .   mn          =   case @lhs.immSz of
                                                  InsOp_ImmSz_Bits08 -> ppHex  2 @int
                                                  InsOp_ImmSz_Bits16 -> ppHex  4 @int
                                                  InsOp_ImmSz_Bits32 -> ppHex  8 @int
                                                  InsOp_ImmSz_Bits64 -> ppHex 16 @int

SEM InsOp_LocE
  | TOS         lhs         .   mn          =   pp "t"
  | Reg         lhs         .   mn          =   pp "r"
  | Imm         lhs         .   mn          =   pp "i"
  | PC          lhs         .   mn          =   pp "p"

SEM InsOp_LocB
  | TOS         lhs         .   mn          =   pp "t"
  | Reg         lhs         .   mn          =   pp "r"

SEM InsOp_LocO
  | TOS         lhs         .   mn          =   pp "t"
  | Reg         lhs         .   mn          =   pp "r"
  | SP          lhs         .   mn          =   pp "s"
  | PC          lhs         .   mn          =   pp "p"

SEM InsOp_TyOp
  | Add         lhs         .   mn          =   pp "a"
  | Sub         lhs         .   mn          =   pp "s"
  | Mul         lhs         .   mn          =   pp "m"
  | Div         lhs         .   mn          =   pp "d"

SEM InsOp_DataOp
  | Int1        lhs         .   mn          =   pp "i1"
  | Int2        lhs         .   mn          =   pp "i2"
  | Float1      lhs         .   mn          =   pp "f1"
  | Float2      lhs         .   mn          =   pp "f2"

SEM InsOp_ImmSz
  | Bits08      lhs         .   mn          =   pp "08"
  | Bits16      lhs         .   mn          =   pp "16"
  | Bits32      lhs         .   mn          =   pp "32"
  | Bits64      lhs         .   mn          =   pp "64"

SEM InsOp_Deref
  | Zero        lhs         .   mn          =   pp "0"
  | One         lhs         .   mn          =   pp "1"
  | Two         lhs         .   mn          =   pp "2"
  | Int         lhs         .   mn          =   pp "i"

%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Encodings, must be similar to rts/src/grinbc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR AllInsOp Meta [ | | enc: Int ]

SEM Instr
  | Ld          loc         .   enc         =   0x00 .|. (@ind.enc `shiftL` 5) .|. (@locDst.enc `shiftL` 4) .|. (@locSrc.enc `shiftL` 2) .|. (@immSz.enc)
  | AllocStore  loc         .   enc         =   0xEC .|. (@locSrc.enc)
  | Call        loc         .   enc         =   0xC0 .|. (@locSrc.enc)
  | TailCall    loc         .   enc         =   0xC2 .|. (@locSrc.enc)
                            .   enc2        =   (@nArgMineSz.enc `shiftL` 4) .|. (@nArgSurrSz.enc `shiftL` 2) .|. (@retOffSurrSz.enc)
  | Eval        loc         .   enc         =   0xE0 .|. (@locSrc.enc)
  | Apply       loc         .   enc         =   0xE2 .|. (@locSrc.enc)
  | LdGlobal    loc         .   enc         =   0xFC
  | Halt        loc         .   ext         =   0xFE
                            .   enc         =   0xFF

SEM Meta
  | CmtHeader   loc         .   enc         =   0xFF

SEM InsOp_LocE
  | TOS         lhs         .   enc         =   0
  | Reg         lhs         .   enc         =   1
  | Imm         lhs         .   enc         =   2
  | PC          lhs         .   enc         =   3

SEM InsOp_LocB
  | TOS         lhs         .   enc         =   0
  | Reg         lhs         .   enc         =   1

SEM InsOp_LocO
  | TOS         lhs         .   enc         =   0
  | Reg         lhs         .   enc         =   1
  | SP          lhs         .   enc         =   2
  | PC          lhs         .   enc         =   3

SEM InsOp_TyOp
  | Add         lhs         .   enc         =   0
  | Sub         lhs         .   enc         =   1
  | Mul         lhs         .   enc         =   2
  | Div         lhs         .   enc         =   3

SEM InsOp_DataOp
  | Int1        lhs         .   enc         =   0
  | Int2        lhs         .   enc         =   1
  | Float1      lhs         .   enc         =   2
  | Float2      lhs         .   enc         =   3

SEM InsOp_ImmSz
  | Bits08      lhs         .   enc         =   0
  | Bits16      lhs         .   enc         =   1
  | Bits32      lhs         .   enc         =   2
  | Bits64      lhs         .   enc         =   3

SEM InsOp_Deref
  | Zero        lhs         .   enc         =   0
  | One         lhs         .   enc         =   1
  | Two         lhs         .   enc         =   2
  | Int         lhs         .   enc         =   3
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% How to pp, context
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR Imm [ immSz: InsOp_ImmSz | | ]

SEM Instr
  | Ld          imm         .   immSz       =   @immSz.self
  | TailCall    nArgMine    .   immSz       =   @nArgMineSz.self
                nArgSurr    .   immSz       =   @nArgSurrSz.self
                retOffSurr  .   immSz       =   @retOffSurrSz.self
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Replica's, SELF
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR InsOp_ImmSz [ | | self: SELF ]
%%]

