%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Prettyprint Grin ByteCode program as C
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs module {%{GRIN}GrinByteCode.ToC} import(UU.Pretty,EH.Util.PPUtils,{%{EH}Base.Common},{%{EH}Base.Opts},qualified {%{GRIN}Config} as Cfg,{%{GRIN}GrinByteCode})
%%]

%%[8 hs import(UU.Pretty,EH.Util.PPUtils,{%{EH}Base.Common},{%{EH}Base.Opts},qualified {%{GRIN}Config} as Cfg,{%{GRIN}GrinByteCode})
%%]

%%[8 hs import(Data.Maybe,Data.Char,Data.Bits,EH.Util.FastSeq,EH.Util.Utils,qualified Data.Map as Map)
%%]

%%[8 hs export(gbmod2C)
%%]

%%[8 import({GrinByteCode/AbsSyn})
%%]

%%[8.gbmod2C hs
gbmod2C :: EHCOpts -> Module -> PP_Doc
gbmod2C opts m
  = let t = wrap_AGItf (sem_AGItf (AGItf_AGItf m))
                       (Inh_AGItf {opts_Inh_AGItf = opts}
                       )
    in  pp_Syn_AGItf t
%%]

%%[12 -8.gbmod2C hs
gbmod2C :: EHCOpts -> Module -> (PP_Doc,PP_Doc)
gbmod2C opts m
  = let t = wrap_AGItf (sem_AGItf (AGItf_AGItf m))
                       (Inh_AGItf {opts_Inh_AGItf = opts}
                       )
    in  (pp_Syn_AGItf t,ppMain_Syn_AGItf t)
%%]

%%[8
WRAPPER AGItf
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% General info
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR AGItf Module [ opts: EHCOpts | | ]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Utils
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs
ppCmtC :: PP a => a -> PP_Doc
ppCmtC x = "/*" >#< pp x >#< "*/"

ppHex :: Integral a => Int -> a -> PP_Doc
ppHex prec x = head $ ppHex' Nothing prec x

ppHex' :: Integral a => Maybe Int -> Int -> a -> [PP_Doc]
ppHex' split prec x
  = case split of
      Nothing  -> ["0x" >|< h]
      Just spl -> map ("0x" >|<) $ s h
               where s l = case splitAt spl l of
                             ([],_ ) -> []
                             (l1,l2) -> l1 : s l2
  where h = strHex prec x
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Code offset
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR Instr Instrs AllImm [ | cLoc: Int | ]

SEM Module
  | Mod         instrs      .   cLoc        =   0

SEM Imm
  | Int         lhs         .   cLoc        =   @lhs.cLoc + @sz

SEM Instr
  | LdGlobal    loc         .   linkCLoc    =   @lhs.cLoc + 1
  | Label       loc         .   labelCLoc   =   @lhs.cLoc
  | LabelRef    loc         .   labelCLocAft=   @lhs.cLoc + Cfg.gbLabelOffsetSize
  | RetCase     loc         .   labelCLocAft=   @retOffSurr.cLoc + Cfg.gbLabelOffsetSize

SEM Instr
  | Ld          imm         .   cLoc        =   @lhs.cLoc + 1
  | Op          imm         .   cLoc        =   @lhs.cLoc + 2
  | LdGlobal    lhs         .   cLoc        =   @linkCLoc + fromInteger Cfg.sizeofGrWord
  | LabelRef RetCase
                lhs         .   cLoc        =   @labelCLocAft
  | TailCall RetCall
                nArgMine    .   cLoc        =   @lhs.cLoc + 2
  | CaseCall FetchUpdate
                lhs         .   cLoc        =   @lhs.cLoc + 1
  | CallC       nArg        .   cLoc        =   @lhs.cLoc + 2
  | TailEval    nArgSurr    .   cLoc        =   @lhs.cLoc + 2
  | RetCase     nRes        .   cLoc        =   @lhs.cLoc + 2
  | Halt        lhs         .   cLoc        =   @lhs.cLoc + 2
  | AllocStore Fetch Call Eval Apply
                lhs         .   cLoc        =   @lhs.cLoc + 1
%%]
  | CaseCall    nCases      .   cLoc        =   @lhs.cLoc + 2

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Labels
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR AllInstr [ | | locRefs USE {:++:} {FSeqNil}: {FastSeq (LocRef,Int)} ]

SEM Instr
  | Label       lhs         .   locRefs     =   FSeq (@locRef,@labelCLoc)
%%]

%%[8 hs
type LabelMp = Map.Map LabelId Int
%%]

%%[8
ATTR AllInstr [ | | gathLabelMp USE {`Map.union`} {Map.empty}: LabelMp ]

SEM Instr
  | Label       lhs         .   gathLabelMp =   if lrefIsLabel @locRef then Map.singleton (lrefId @locRef) @labelCLoc else Map.empty
%%]

%%[8
ATTR AllInstr [ labelMp: LabelMp | | ]

SEM Module
  | Mod         loc         .   labelMp     =   @instrs.gathLabelMp
%%]

%%[8
SEM Instr
  | RetCase     loc         .   locRef      =   @contLocRef
  | LabelRef RetCase
                loc         .   refOff      =   (panicJust "Instr.{LabelRef,RetCase}.refOff"
                                                 $ Map.lookup (lrefId @locRef) @lhs.labelMp) - @labelCLocAft
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Link entries
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR AllInstr [ | | links USE {:++:} {FSeqNil}: {FastSeq (Link,Int)} ]

SEM Instr
  | LdGlobal    lhs         .   links       =   FSeq (@link,@linkCLoc)
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% PP as code
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs
ppHexL :: [PP_Doc] -> PP_Doc
ppHexL
  = ppCommas . cvt
  where cvt = if Cfg.machineIsBigEndian then id else reverse

ppArr :: PP a => [a] -> PP_Doc
ppArr l = indent 2 (ppCurlysCommasBlock l >#< ";")

ppCast :: String -> PP_Doc -> PP_Doc
ppCast t v = ppParens $ ppParens t >|< ppParens v

ppCnst :: PP_Doc -> Const -> PP_Doc
ppCnst st (Const_Str       i) = ppCast "GB_Word" $ ppAddrArrAt st i
ppCnst _  (Const_CFunction n) = ppCast "GB_Word" $ ppAddrOf ("gb_" ++ n)

ppLine :: PP_Doc -> PP_Doc
ppLine p = p >-< text ""

ppFun :: (PP h, PP b) => h -> b -> PP_Doc
ppFun h b = h >#< "{" >-< indent 2 b >-< "}"

ppArrAt :: (PP a,PP o) => a -> o -> PP_Doc
ppArrAt a o = a >|< "[" >|< o >|< "]"

ppAddrOf :: PP a => a -> PP_Doc
ppAddrOf a = "&" >|< ppParens a

ppAddrArrAt :: (PP a,PP o) => a -> o -> PP_Doc
ppAddrArrAt a o = ppAddrOf $ ppArrAt a o

mkPre :: String -> String
mkPre = (++ "_")

ppTbl :: String -> PP_Doc -> [PP_Doc] -> PP_Doc
ppTbl tp nm tbl = ppLine $ "static" >#< tp >#< nm >|< "[] =" >-< ppArr tbl
%%]

%%[8
ATTR AllNT AGItf [ | | pp USE {>-<} {empty}: PP_Doc ]
%%]

%%[12
ATTR Module AGItf [ | | ppMain: PP_Doc ]
%%]

%%[8
SEM Module
  | Mod         loc         .   moduleNmPre             =   mkPre @moduleNm
                            .   ppNm                    =   \n -> @moduleNmPre >|< n
                            .   ppNmAString             =   @ppNm "string"
                            .   ppNmStringTbl           =   @ppNm "strings"
                            .   ppNmByteCodeTbl         =   @ppNm "bytecode"
                            .   ppNmConstTbl            =   @ppNm "constants"
                            .   ppNmLinkEntriesTbl      =   @ppNm "linkEntries"
                            .   ppNmGlobEntriesTbl      =   @ppNm "globalEntries"
                            .   ppNmCafEntriesTbl       =   @ppNm "cafEntries"
                            .   ppNmFixOffsetsTbl       =   @ppNm "fixOffsets"
                            .   strNmInitF              =   "initModule"
                            .   ppNmInitF               =   @ppNm @strNmInitF
                            .   ppNmMainCAFEntry        =   @ppNm "mainEntryPtr"
%%[[12
                            .   strNmExpNode            =   "expNode"
                            .   ppNmModEntriesTbl       =   @ppNm "moduleEntries"
                            .   ppNmImpNode             =   @ppNm "impNode"
                            .   ppNmExpNode             =   @ppNm @strNmExpNode
%%]]

%%[[8
                lhs         .   pp          
%%][12
                lhs         .   (pp,ppMain)
%%]]
                                            =   let top     = ppLine $ ppCmtC ("bytecode in C encoding for module" >#< @moduleNm) >-< "#include \"rts.h\""
                                                    strNmL  = [ (@ppNmAString >|< i,ppStringAsHex s >#< ppCmtC (take 15 s)) | (i,s) <- zip [(0::Int)..] @stringL ]
                                                    strings = vlist [ "static char" >#< n >|< "[] =" >#< s >#< ";" | (n,s) <- strNmL ]
                                                              >-< ppTbl "char*" @ppNmStringTbl [ n | (n,_) <- strNmL ]
                                                    consts  = ppTbl "GB_Word" @ppNmConstTbl (map (ppCnst @ppNmStringTbl) @constL)
                                                    bcode   = ppTbl "GB_Byte" @ppNmByteCodeTbl @instrs.ppL
                                                    linkL   = toList @instrs.links
                                                    links   = ppTbl "GB_LinkEntry" @ppNmLinkEntriesTbl
                                                                (map (\(l,c)
                                                                       -> ppCurlysCommasBlock
                                                                            [ pp $ fromEnum $ linkTbl l, pp $ linkInx l
%%[[12
                                                                            , pp $ linkMod l
%%]]
                                                                            , ppCast "GB_Ptr" $ ppAddrArrAt @ppNmByteCodeTbl c
                                                                            ]
                                                                     )
                                                                 $ linkL
                                                                )
                                                    centries= ppTbl "GB_BytePtr" @ppNmGlobEntriesTbl
                                                                [ ppAddrArrAt @ppNmByteCodeTbl c | (LocRef_CodeEntry _,c) <- sortOn fst $ toList @instrs.locRefs ]
                                                    cafs    = ppTbl "GB_BytePtr*" @ppNmCafEntriesTbl
                                                                [ ppAddrArrAt @ppNmGlobEntriesTbl i | i <- @cafEntryL ]
                                                    fixOffL = [ (fromJust c,sz) | (FixOffset l sz) <- @fixOffsetL, let c = Map.lookup l @labelMp, isJust c ]
                                                    fixoffs = ppTbl "GB_FixOffset" @ppNmFixOffsetsTbl
                                                                [ ppCurlysCommasBlock [ppCast "GB_Offset*" $ ppAddrArrAt @ppNmByteCodeTbl c,pp sz] | (c,sz) <- fixOffL ]
                                                    initf   = ppLine $ ppCmtC "Initialization"
                                                                       >-< ppFun ("void" >#< @ppNmInitF >|<
%%[[8
                                                                                  "()"
%%][12
                                                                                  "(GB_ModEntry* modTbl)"
%%]]
                                                                                 )
                                                                                 ("gb_InitTables" >|< ppParensCommasBlock args >#< ";")
                                                            where args = [ pp @instrs.cLoc, @ppNmByteCodeTbl
                                                                         , pp (length linkL), @ppNmLinkEntriesTbl
                                                                         , @ppNmGlobEntriesTbl
                                                                         , pp (length @cafEntryL), @ppNmCafEntriesTbl
                                                                         , pp (length fixOffL), @ppNmFixOffsetsTbl
                                                                         , @ppNmConstTbl
%%[[12
                                                                         , ppAddrOf @ppNmImpNode
                                                                         , ppAddrOf @ppNmExpNode
                                                                         , pp "modTbl"
%%]]
                                                                         ]
                                                    maincaf = ppLine $ "static GB_BytePtr*" >#< @ppNmMainCAFEntry >#< "="
                                                                       >#< ppAddrArrAt @ppNmGlobEntriesTbl @mainCafEntry >#< ";"
                                                    mainf   = ppLine $ ppCmtC "Main entry point"
                                                                       >-< ppFun "int main(int argc, char** argv)"
                                                                                 (    "int nRtsOpts = 0 ;"
                                                                                  >-< "main_GB_Init1( argc, argv, &nRtsOpts ) ;"
                                                                                  >-< "gb_Opt_TraceSteps =" >#< ehcOptGenTrace @lhs.opts >#< ";"
                                                                                  >-< "argc -= nRtsOpts ; argv += nRtsOpts ;"
%%[[8
                                                                                  >-< @ppNmInitF >|< "()" >#< ";"
%%][12
                                                                                  >-< (vlist $ map (\(_,m) -> mkPre m >|< @strNmInitF >|< ppParens @ppNmModEntriesTbl >#< ";") $ @allImpModNmL)
%%]]
                                                                                  >-< "main_GB_Run( argc, argv, gb_code_Eval, Cast(GB_Word,*" >|< @ppNmMainCAFEntry >|< ") ) ;"
                                                                                  >-< "return main_GB_Exit( argc, argv) ;"
                                                                                 )
                                                    etc     = if ehcOptEmitLlc @lhs.opts
                                                              then empty
                                                              else ppLine $ ppCmtC "Dummy defs for Silly"
                                                                   >-< "void fun_main(void){}" >-< "void initialize(void){}"
%%[[12
                                                    impnd   = ppLine $ "static GB_Node" >#< @ppNmImpNode >#< "="
                                                                       >-< ppArr [ "GB_MkConHeader(" >|< length @impModNmL >|<  ",0)"
                                                                                 , ppCurlysCommasBlock $ map (\(n,m) -> "Cast(GB_Word,\"" >|< m >|< "\")" >#< ppCmtC n) $ @impModNmL
                                                                                 ]
                                                    expnd   = ppLine $ "GB_Node" >#< @ppNmExpNode >#< "="
                                                                       >-< ppArr [ "GB_MkConHeader(" >|< length @expEntryL >|<  ",0)"
                                                                                 , ppCurlysCommasBlock $ map (\(n,o) -> o >#< ppCmtC n) $ @expEntryL
                                                                                 ]
                                                    externs = ppLine $ vlist
                                                                     $ map (\(_,m) -> "extern void" >#< mkPre m >|< @strNmInitF >|< "(GB_ModEntry*)" >#< ";"
                                                                                      >-< "extern GB_Node" >#< mkPre m >|< @strNmExpNode >#< ";"
                                                                           )
                                                                     $ @allImpModNmL
                                                    mods    = ppTbl "GB_ModEntry" @ppNmModEntriesTbl
                                                                ( [ ppCurlysCommasBlock [pp $ show m,ppAddrOf $ mkPre m >|< @strNmExpNode] | (_,m) <- @allImpModNmL]
                                                                  ++ [ppCurlysCommasBlock (replicate 2 $ pp $ "NULL")]
                                                                )
%%]]
                                                in  ( top
                                                      >-< bcode
                                                      >-< strings
                                                      >-< consts
                                                      >-< centries
                                                      >-< cafs
%%[[12
                                                      >-< impnd
                                                      >-< expnd
%%]]
                                                      >-< links
                                                      >-< fixoffs
                                                      >-< initf
%%[[8
                                                      >-< maincaf
                                                      >-< etc
                                                      >-< mainf
%%][12
                                                    , maincaf
                                                      >-< externs
                                                      >-< mods
                                                      >-< etc
                                                      >-< mainf
%%]]
                                                    )
%%]

%%[8 hs
ppStringAsHex :: String -> PP_Doc
ppStringAsHex s = ppCurlysCommasBlock [ ppHex' (Just 2) 2 (ord c) | c <- s ++ [chr 0] ]

ppLink :: (Integral c) => Int -> c -> PP_Doc
ppLink sz = ppHexL . ppHex' (Just 2) (sz * 2)
%%]

%%[8
SEM Instr
  | Ld          lhs         .   pp          =   ppCommas [ppHex 2 @enc,@imm.pp]
  | AllocStore Fetch Call Eval Apply
                lhs         .   pp          =   ppCommas [ppHex 2 @enc]
  | TailCall RetCall
                lhs         .   pp          =   ppCommas [ppHex 2 @enc,ppHex 2 @enc2,@nArgMine.pp,@nArgSurr.pp,@retOffSurr.pp]
  | TailEval    lhs         .   pp          =   ppCommas [ppHex 2 @enc,ppHex 2 @enc2,@nArgSurr.pp,@retOffSurr.pp]
  | CaseCall FetchUpdate
                lhs         .   pp          =   ppCommas [ppHex 2 @enc]
  | CallC       lhs         .   pp          =   ppCommas [ppHex 2 @enc,ppHex 2 @enc2,@nArg.pp]
  | RetCase     lhs         .   pp          =   ppCommas [ppHex 2 @enc,ppHex 2 @enc2,@nRes.pp,@retOffSurr.pp,ppLink Cfg.gbLabelOffsetSize @refOff]
  | Op          lhs         .   pp          =   ppCommas [ppHex 2 @enc,ppHex 2 @enc2,@imm.pp]
  | Ann         lhs         .   pp          =   @instr.pp >#< ppCmtC @ann
  | Halt        lhs         .   pp          =   ppCommas [ppHex 2 @enc,ppHex 2 @enc2]
  | LdGlobal    lhs         .   pp          =   ppCommas [ppHex 2 @enc, ppLink (fromInteger Cfg.sizeofGrWord) $ linkInx @link]
  | LabelRef    lhs         .   pp          =   ppCommas [ppLink Cfg.gbLabelOffsetSize @refOff]
%%]
  | CaseCall    lhs         .   pp          =   ppCommas [ppHex 2 @enc,ppHex 2 @enc2,@nCases.pp]

%%[8
SEM Imm
  | Int         loc         .   (ppL,sz)    =   case @lhs.immSz of
                                                  InsOp_ImmSz_Bits08 -> (ppHex' (Just 2)  2 @int,1)
                                                  InsOp_ImmSz_Bits16 -> (ppHex' (Just 2)  4 @int,2)
                                                  InsOp_ImmSz_Bits32 -> (ppHex' (Just 2)  8 @int,4)
                                                  InsOp_ImmSz_Bits64 -> (ppHex' (Just 2) 16 @int,8)
                lhs         .   pp          =   ppHexL @ppL
%%]

%%[8
ATTR Instrs [ | | ppL : {[PP_Doc]} ]

SEM Instrs
  | Nil         lhs         .   ppL         =   []
  | Cons        lhs         .   ppL         =   if @hd.hasCode
                                                then (ppCmtC (@lhs.cLoc >|< ":" >#< @hd.mn) >|< @lhs.ppExtra >-< indent 3 @hd.pp) : @tl.ppL
                                                else @tl.ppL
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Generates code?
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR Instr [ | | hasCode: Bool ]

SEM Instr
  | Meta Label  lhs         .   hasCode     =   False
  | * - Meta Label
                lhs         .   hasCode     =   True
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Additional comment
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR Instr Meta [ | | ppExtra USE {>|<} {empty}: PP_Doc ]
ATTR Instrs [ ppExtra: PP_Doc | | ]

SEM Meta
  | CmtHeader   lhs         .   ppExtra     =   indent 40 (ppCmtC ("[" >#< @ann >#< "]"))

SEM Instr
  | Label       lhs         .   ppExtra     =   ppCmtC ("[ .lbl" >#< lrefId @locRef >#< "]")

SEM Instrs
  | Cons        tl          .   ppExtra     =   @hd.ppExtra

SEM Module
  | Mod         instrs      .   ppExtra     =   empty
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% PP as mnemonic
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR AllInsOp Instr Imm [ | | mn USE {>|<} {empty}: PP_Doc ]
%%]

%%[8
SEM Instr
  | Ld          lhs         .   mn          =   "l"             >|< @ind.mn >|< @locDst.mn >|< @locSrc.mn >|< @immSz.mn >#< @imm.mn
  | AllocStore  lhs         .   mn          =   "allocstore"    >|< @locSrc.mn
  | Fetch       lhs         .   mn          =   "fetch"         >|< @locSrc.mn
  | Call        lhs         .   mn          =   "call"          >|< @locSrc.mn
  | TailCall    lhs         .   mn          =   "tailcall"      >|< @locSrc.mn >|< @nArgMineSz.mn >|< @nArgSurrSz.mn >|< @retOffSurrSz.mn >#< @nArgMine.mn >#< @nArgSurr.mn >#< @retOffSurr.mn
  | TailEval    lhs         .   mn          =   "taileval"      >|< @locSrc.mn >|< @nArgSurrSz.mn >|< @retOffSurrSz.mn >#< @nArgSurr.mn >#< @retOffSurr.mn
  | CaseCall    lhs         .   mn          =   pp "casecall"
  | FetchUpdate lhs         .   mn          =   pp "fetchupd"
  | CallC       lhs         .   mn          =   "callc"         >|< @nArgSz.mn >#< @nArg.mn
  | RetCall     lhs         .   mn          =   "retcall"       >|< @nArgMineSz.mn >|< @nArgSurrSz.mn >|< @retOffSurrSz.mn >#< @nArgMine.mn >#< @nArgSurr.mn >#< @retOffSurr.mn
  | RetCase     lhs         .   mn          =   "retcase"       >|< @nResSz.mn >|< @retOffSurrSz.mn >#< @nResSz.mn >#< @retOffSurr.mn >#< lrefId @locRef
  | Eval        lhs         .   mn          =   "eval"          >|< @locSrc.mn
  | Apply       lhs         .   mn          =   "apply"         >|< @locSrc.mn
  | Halt        lhs         .   mn          =   pp "halt"
  | LdGlobal    lhs         .   mn          =   pp "ldg"
  | Op          lhs         .   mn          =   "o"             >|< @op.mn >|< @locDst.mn >|< @opndTy.mn >|< @ind.mn >|< @locSrc.mn >|< @immSz.mn >#< @imm.mn
  | LabelRef    lhs         .   mn          =   ".ref"          >#< lrefId @locRef

SEM Imm
  | Int         lhs         .   mn          =   case @lhs.immSz of
                                                  InsOp_ImmSz_Bits08 -> ppHex  2 @int
                                                  InsOp_ImmSz_Bits16 -> ppHex  4 @int
                                                  InsOp_ImmSz_Bits32 -> ppHex  8 @int
                                                  InsOp_ImmSz_Bits64 -> ppHex 16 @int

SEM InsOp_LocE
  | TOS         lhs         .   mn          =   pp "t"
  | Reg         lhs         .   mn          =   pp "r"
  | Imm         lhs         .   mn          =   pp "i"
  | PC          lhs         .   mn          =   pp "p"

SEM InsOp_LocB
  | TOS         lhs         .   mn          =   pp "t"
  | Reg         lhs         .   mn          =   pp "r"

SEM InsOp_LocO
  | TOS         lhs         .   mn          =   pp "t"
  | Reg         lhs         .   mn          =   pp "r"
  | SP          lhs         .   mn          =   pp "s"
  | PC          lhs         .   mn          =   pp "p"

SEM InsOp_TyOp
  | Add         lhs         .   mn          =   pp "a"
  | Sub         lhs         .   mn          =   pp "s"
  | Mul         lhs         .   mn          =   pp "m"
  | Div         lhs         .   mn          =   pp "d"

SEM InsOp_DataOp
  | Int1        lhs         .   mn          =   pp "i1"
  | Int2        lhs         .   mn          =   pp "i2"
  | Float1      lhs         .   mn          =   pp "f1"
  | Float2      lhs         .   mn          =   pp "f2"
  | IntWord     lhs         .   mn          =   pp "iw"
  | IntInf      lhs         .   mn          =   pp "ii"

SEM InsOp_ImmSz
  | Bits08      lhs         .   mn          =   pp "08"
  | Bits16      lhs         .   mn          =   pp "16"
  | Bits32      lhs         .   mn          =   pp "32"
  | Bits64      lhs         .   mn          =   pp "64"

SEM InsOp_Deref
  | Zero        lhs         .   mn          =   pp "0"
  | One         lhs         .   mn          =   pp "1"
  | Two         lhs         .   mn          =   pp "2"
  | Int         lhs         .   mn          =   pp "i"

%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Encodings, must be similar to rts/src/grinbc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR AllInsOp Meta [ | | enc: Int ]

SEM Instr
  | Ld          loc         .   enc         =   0x00 .|. (@ind.enc `shiftL` 5) .|. (@locDst.enc `shiftL` 4) .|. (@locSrc.enc `shiftL` 2) .|. (@immSz.enc)
  | Op          loc         .   enc         =   0xB0 .|. (@op.enc `shiftL` 2) .|. (@locDst.enc)
  | Call        loc         .   enc         =   0xC0 .|. (@locSrc.enc)
  | TailCall    loc         .   enc         =   0xC2 .|. (@locSrc.enc)
  | RetCall     loc         .   enc         =   0xC4
  | RetCase     loc         .   enc         =   0xC5
  | CaseCall    loc         .   enc         =   0xC6
  | CallC       loc         .   enc         =   0xC7
  | Eval        loc         .   enc         =   0xE0 .|. (@locSrc.enc)
  | TailEval    loc         .   enc         =   0xE4 .|. (@locSrc.enc)
  | Apply       loc         .   enc         =   0xE2 .|. (@locSrc.enc)
  | AllocStore  loc         .   enc         =   0xEC .|. (@locSrc.enc)
  | Fetch       loc         .   enc         =   0xEE .|. (@locSrc.enc)
  | FetchUpdate loc         .   enc         =   0xF9
  | LdGlobal    loc         .   enc         =   0xFC
  | Halt        loc         .   enc         =   0xFE

SEM Instr
  | TailCall RetCall
                loc         .   enc2        =   (@nArgMineSz.enc `shiftL` 4) .|. (@nArgSurrSz.enc `shiftL` 2) .|. (@retOffSurrSz.enc)
  | CallC       loc         .   enc2        =   (@nArgSz.enc)
  | TailEval    loc         .   enc2        =   (@nArgSurrSz.enc `shiftL` 2) .|. (@retOffSurrSz.enc)
  | RetCase     loc         .   enc2        =   (@nResSz.enc `shiftL` 2) .|. (@retOffSurrSz.enc)
  | Op          loc         .   enc2        =   (@opndTy.enc `shiftL` 5) .|. (@ind.enc `shiftL` 4) .|. (@locSrc.enc `shiftL` 2) .|. (@immSz.enc)
  | Halt        loc         .   enc2        =   0xFF

SEM Meta
  | CmtHeader   loc         .   enc         =   0xFF

SEM InsOp_LocE
  | TOS         lhs         .   enc         =   0
  | Reg         lhs         .   enc         =   1
  | Imm         lhs         .   enc         =   2
  | PC          lhs         .   enc         =   3

SEM InsOp_LocB
  | TOS         lhs         .   enc         =   0
  | Reg         lhs         .   enc         =   1

SEM InsOp_LocO
  | TOS         lhs         .   enc         =   0
  | Reg         lhs         .   enc         =   1
  | SP          lhs         .   enc         =   2
  | PC          lhs         .   enc         =   3

SEM InsOp_TyOp
  | Add         lhs         .   enc         =   0
  | Sub         lhs         .   enc         =   1
  | Mul         lhs         .   enc         =   2
  | Div         lhs         .   enc         =   3

SEM InsOp_DataOp
  | Int1        lhs         .   enc         =   0
  | Int2        lhs         .   enc         =   1
  | Float1      lhs         .   enc         =   2
  | Float2      lhs         .   enc         =   3
  | IntWord     lhs         .   enc         =   4
  | IntInf      lhs         .   enc         =   5

SEM InsOp_ImmSz
  | Bits08      lhs         .   enc         =   0
  | Bits16      lhs         .   enc         =   1
  | Bits32      lhs         .   enc         =   2
  | Bits64      lhs         .   enc         =   3

SEM InsOp_Deref
  | Zero        lhs         .   enc         =   0
  | One         lhs         .   enc         =   1
  | Two         lhs         .   enc         =   2
  | Int         lhs         .   enc         =   3
%%]
  | CaseCall    loc         .   enc2        =   (@nCasesSz.enc)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% How to pp, context
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR Imm [ immSz: InsOp_ImmSz | | ]

SEM Instr
  | Ld          imm         .   immSz       =   @immSz.self
  | Op          imm         .   immSz       =   @immSz.self
  | TailCall RetCall
                nArgMine    .   immSz       =   @nArgMineSz.self
                nArgSurr    .   immSz       =   @nArgSurrSz.self
                retOffSurr  .   immSz       =   @retOffSurrSz.self
  | TailEval    nArgSurr    .   immSz       =   @nArgSurrSz.self
                retOffSurr  .   immSz       =   @retOffSurrSz.self
  | CallC       nArg        .   immSz       =   @nArgSz.self
  | RetCase     nRes        .   immSz       =   @nResSz.self
                retOffSurr  .   immSz       =   @retOffSurrSz.self
%%]
  | CaseCall    nCases      .   immSz       =   @nCasesSz.self

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Replica's, SELF
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR InsOp_ImmSz [ | | self: SELF ]
%%]

