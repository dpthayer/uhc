%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell importable interface to Grin ByteCode
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs module {%{GRIN}GrinByteCode} import({%{EH}Base.Common},{%{EH}GrinCode},qualified {%{GRIN}Config} as Cfg)
%%]

%%[8 hs import(UU.Pretty,Data.Bits,EH.Util.FastSeq,qualified Data.Map as Map)
%%]

%%[8 hs export(AGItf(..),Module(..),Instr(..), Instrs, Meta(..))
%%]

%%[8 hs export(InsOp_LocE(..), InsOp_LocB(..), InsOp_LocO(..), InsOp_TyOp(..), InsOp_DataOp(..), InsOp_ImmSz(..), InsOp_Deref(..), Imm(..))
%%]

%%[8 import({GrinByteCode/AbsSyn})
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Additional datastructures, not incorporated as AST
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Instruction sequence

%%[8 hs export(InsSeq)
type InsSeq = FastSeq Instr
%%]

Constants

%%[8 hs export(Const(..))
data Const
  = ConstStr { constInx :: Int }
  deriving(Eq,Ord,Show)

%%]

Link items, to be resolved at runtime initialization.

%%[8 hs export(Link(..),LinkTbl(..))
data LinkTbl
  = LinkTbl_Const | LinkTbl_CodeEntry
  deriving (Show,Eq,Ord,Enum)

data Link
  = Link { linkMod :: Int, linkTbl :: LinkTbl, linkInx :: Int }
  deriving Show
%%]

Reference to defining location in code

%%[8 hs export(LocRef(..),LabelId,newLabelId,lrefIsLabel)
type LabelId = Int

newLabelId :: LabelId -> (LabelId,LabelId)
newLabelId l = (l+1,l)

lrefIsLabel :: LocRef -> Bool
lrefIsLabel (LocRef_Label _) = True
lrefIsLabel _                = False

data LocRef
  = LocRef_CodeEntry 	Int							-- resolved at initialization runtime, translates to
  | LocRef_Label 		{ lrefId :: LabelId }		-- resolved before runtime, translates to offsets
  deriving (Eq,Ord)
%%]

%%[8 hs export(FixOffset(..))
data FixOffset
  = FixOffset	LabelId Int
  deriving Show
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Named value access
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs export(ValAccess(..),ValAccessGam)
data ValAccess
  = Val_LocalOffset     Int
  | Val_GlobEntry       { vaEntryInx :: Int }
--  | Val_GlobConst       HsName 
  deriving Show

instance PP ValAccess where
  pp = pp . show

type ValAccessGam = Map.Map HsName ValAccess
%%]

%%[8 hs export(nmLd)
nmLd :: ValAccessGam -> Int -> Int -> HsName -> (InsSeq,Int)
nmLd vag modNmConstInx stkDepth nm
  = case Map.lookup nm vag of
      Just va
        -> case va of
             Val_LocalOffset o
               -> (FSeq $ ann nm $ ldl (stkDepth - o), 1)
             Val_GlobEntry o
               -> (FSeq $ ann nm $ ldg (Link modNmConstInx LinkTbl_CodeEntry o), 1)
             -- _ -> dflt
      _ -> (FSeq $ ann ("dummy ld for" >#< nm) $ ldl stkDepth, 1)
  where dflt = (FSeqNil,0)

%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Constants
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs
pow2 :: Int -> Integer
pow2 x = 1 `shiftL` x

pow2' :: Int -> (Integer,Integer,Integer)
pow2' x
  = (p,-p,p-1)
  where p = pow2 x

(pow2_7 ,pow2_7neg ,pow2_7sub1 ) = pow2' 7
(pow2_8 ,pow2_8neg ,pow2_8sub1 ) = pow2' 8

(pow2_15,pow2_15neg,pow2_15sub1) = pow2' 15
(pow2_16,pow2_16neg,pow2_16sub1) = pow2' 16

(pow2_31,pow2_31neg,pow2_31sub1) = pow2' 31
(pow2_32,pow2_32neg,pow2_32sub1) = pow2' 32

(pow2_63,pow2_63neg,pow2_63sub1) = pow2' 63
(pow2_64,pow2_64neg,pow2_64sub1) = pow2' 64
%%]

%%[8 hs
mask2 :: Int -> Integer
mask2 x = pow2 x - 1

[mask2_8,mask2_16,mask2_32,mask2_64] = map mask2 [8,16,32,64]
%%]

%%[8 hs export(nrWord2Byte)
nrWord2Byte :: Integral c => c -> c
nrWord2Byte sz
  = sz * wSz
  where wSz = fromInteger Cfg.sizeofGrWord
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Constructing
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs
imm :: Integral c => c -> (InsOp_ImmSz,Imm)
imm c
  = (s,Imm_Int i)
  where (s,i)
          = case toInteger c of
              i | i <  0 -> (s, i .&. m)
                         where (s,m) = case i of
                                         i | i >= pow2_7neg  -> (InsOp_ImmSz_Bits08,mask2_8 )
                                           | i >= pow2_15neg -> (InsOp_ImmSz_Bits16,mask2_16)
                                           | i >= pow2_31neg -> (InsOp_ImmSz_Bits32,mask2_32)
                                           | otherwise       -> (InsOp_ImmSz_Bits64,mask2_64)
              i | i >= 0 -> (s, i .&. mask2_64)
                         where s = case i of
                                     i | i < pow2_7sub1  -> InsOp_ImmSz_Bits08
                                       | i < pow2_15sub1 -> InsOp_ImmSz_Bits16
                                       | i < pow2_31sub1 -> InsOp_ImmSz_Bits32
                                       | otherwise       -> InsOp_ImmSz_Bits64
%%]

%%[8 hs export(ldc,ldl,ldg,ldi)
ld :: Integral c => InsOp_Deref -> InsOp_LocB -> InsOp_LocE -> c -> Instr
ld ind locB locE c
  = Instr_Ld ind locB locE s i
  where (s,i) = imm c

ldc :: Integral c => c -> Instr
ldc = ld InsOp_Deref_Zero InsOp_LocB_TOS InsOp_LocE_Imm

ldi :: Integral c => c -> Instr
ldi = ld InsOp_Deref_Int InsOp_LocB_TOS InsOp_LocE_Imm

ldl :: Integral c => c -> Instr
ldl c = ld InsOp_Deref_One InsOp_LocB_TOS InsOp_LocE_TOS (nrWord2Byte c)

ldg :: Link -> Instr
ldg l = Instr_LdGlobal l
%%]

%%[8 hs export(labelref,label)
labelref :: LocRef -> Instr
labelref l = Instr_LabelRef l

label :: LocRef -> Instr
label l = Instr_Label l
%%]

%%[8 hs export(allocstore,fetch,ndStore)
allocstore :: InsOp_LocB -> Instr
allocstore locB = Instr_AllocStore locB

fetch :: InsOp_LocB -> Instr
fetch locB = Instr_Fetch locB

ndStore :: Int -> (InsSeq,Int)
ndStore sz = (FSeqL [ldc (nrWord2Byte sz),ann "alloc+store" $ allocstore InsOp_LocB_TOS], 1)
%%]

%%[8 hs export(eval,apply,taileval)
eval :: InsOp_LocB -> Instr
eval locB = Instr_Eval locB

taileval :: Integral c => InsOp_LocB -> c -> c -> Instr
taileval locB nArgSurr retOffSurr
  = Instr_TailEval locB s1 s2 i1 i2
  where (s1,i1) = imm $ nrWord2Byte nArgSurr
        (s2,i2) = imm $ nrWord2Byte retOffSurr

apply :: InsOp_LocB -> Instr
apply locB = Instr_Apply locB
%%]

%%[8 hs export(call,retcall,tailcall,casecall,retcase)
call :: InsOp_LocB -> Instr
call locB = Instr_Call locB

rettailcall :: Integral c => (InsOp_ImmSz -> InsOp_ImmSz -> InsOp_ImmSz -> Imm -> Imm -> Imm -> Instr) -> c -> c -> c -> Instr
rettailcall mk nArgMine nArgSurr retOffSurr
  = mk s1 s2 s3 i1 i2 i3
  where (s1,i1) = imm $ nrWord2Byte nArgMine
        (s2,i2) = imm $ nrWord2Byte nArgSurr
        (s3,i3) = imm $ nrWord2Byte retOffSurr

retcall :: Integral c => c -> c -> c -> Instr
retcall = rettailcall Instr_RetCall

tailcall :: Integral c => InsOp_LocB -> c -> c -> c -> Instr
tailcall locB = rettailcall (Instr_TailCall locB)

casecall :: Integral c => c -> Instr
casecall nSizes
  = Instr_CaseCall s1 i1
  where (s1,i1) = imm nSizes

retcase :: Integral c => c -> c -> LocRef -> Instr
retcase nRes retOffSurr l
  = Instr_RetCase s1 s2 i1 i2 l
  where (s1,i1) = imm $ nrWord2Byte nRes
        (s2,i2) = imm $ nrWord2Byte retOffSurr
%%]

%%[8 hs export(meta,ann)
meta :: PP a => a -> Instr
meta a = Instr_Meta $ Meta_CmtHeader $ pp a

ann :: PP a => a -> Instr -> Instr
ann a = Instr_Ann $ pp a
%%]

Offsets should coincide with def of GB_NodeHeader, src/rts/grinbc/grinbc

%%[8 hs export(tag)
[tgShSize,tgShNdEv,tgShCateg]
  = if Cfg.use32Bits then [16,15,13::Int] else [32,31,29]

tag :: ValAccessGam -> Int -> Int -> GrTag -> Int -> (InsSeq,Int)
tag vag modNmConstInx stkDepth gt sz
  = case gt of
      GrTag_Lit categ tg nm
        -> (tins :++: FSeqL [ldc tword],tinc+1)
        where (needEval,categ',tg',tins,tinc)
                = case categ of
                    GrTagCon      -> (0,0,tg,FSeqNil,0)
                    GrTagHole     -> (0,0,tg,FSeqNil,0)
                    GrTagRec      -> (0,0,tg,FSeqNil,0)
                    GrTagApp      -> (1,1,tg,FSeqNil,0)
                    GrTagFun      -> (1,0,tg,ins,inc)
                                  where (ins,inc) = nmLd vag modNmConstInx stkDepth nm
                    GrTagPApp m   -> (0,1,m ,ins,inc)
                                  where (ins,inc) = nmLd vag modNmConstInx stkDepth nm
              tword = (toInteger (sz+tinc+1) `shiftL` tgShSize) .|. needEval `shiftL` tgShNdEv .|. categ' `shiftL` tgShCateg .|. toInteger tg'
      _ -> (FSeqNil,0)
%%]
tag' :: ValAccessGam -> GrTagCateg -> Int -> Int -> Integer
tag' vag categ tg sz
  = (toInteger sz `shiftL` tgShSize) .|. needEval `shiftL` tgShNdEv .|. categ' `shiftL` tgShCateg .|. toInteger tg'
  where (needEval,categ',tg')
          = case categ of
              GrTagCon      -> (0,0,tg)
              GrTagHole     -> (0,0,tg)
              GrTagRec      -> (0,0,tg)
              GrTagApp      -> (1,1,tg)
              GrTagFun      -> (1,0,tg)
              GrTagPApp m   -> (0,1,m )

%%[8 hs export(halt)
halt :: Instr
halt = Instr_Halt
%%]


