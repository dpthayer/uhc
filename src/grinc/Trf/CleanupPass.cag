cleanup EHC generated GRIN:
- eval and apply functions not needed (their semantics are builtin)
- better F-tag than P0-tag (altough they are aliases)
- primThrow and primCatch are not primitives, but ehc does not support the grin statements

%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[8 import({GrinCode/AbsSyn})
%%]

%%[8.wrapper
WRAPPER GrAGItf
%%]

%%[8 hs module Trf.CleanupPass import(qualified Data.Set as Set)
%%]

%%[8 hs import({%{EH}Base.Common}, {%{GRIN}GRINCCommon}, {%{EH}GrinCode}) export(cleanupPass)
cleanupPass :: GrModule -> GrModule
cleanupPass grmod = let t = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf grmod))
                                         (Inh_GrAGItf)
                    in grTrf_Syn_GrAGItf t
%%]

%%[8
ATTR GrAGItf [ | | grTrf: GrModule ]
ATTR AllGrNT [ | | grTrf: SELF ]

SEM GrModule
  | Mod  lhs  .  grTrf         =  GrModule_Mod @baseName @newGlobals @bindL.grTrf @ctagsMp @newEvalTagMp @applyTagMp
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%% Eval and Apply are builtin %%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8.dropEvalApply
SEM GrBind [ | | dropBinding: Bool ]
  | Bind  lhs  . dropBinding  =  @nm `elem` [evalNm, evalNr,  applyNm, applyNr]
  | Rec   lhs  . dropBinding  =  False


SEM GrBindL [ | | count: Int ]
  | Cons  lhs  .  grTrf  =  if @hd.dropBinding
                            then @tl.grTrf
                            else @hd.grTrf : @tl.grTrf
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%% F-Tag  <==> P0-Tag %%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Ehc outputs P0-tags instead of F-Tags in some situations, we rewrite them to F-Tags

%%[8.P0tag_TO_Ftag
SEM GrTag
  | Lit  lhs  .  grTrf  = GrTag_Lit (if @categ == GrTagPApp 0 then GrTagFun else @categ) @int @nm
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%% Add Global variables %%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Introduce global variables: each binding without arguments must have a
corresponding global variable. (CAF's)
Note: EHC does not generate these yet

%%[8.caf import("../GrCAFNames")
SEM GrModule
  | Mod  loc  .  newGlobals  =  let buildGlobalVar n  =  GrGlobal_Global n (GrVal_Node (GrTag_Lit GrTagFun 0 n) 
                                                                                       [GrVal_LitInt 0]
                                                                           )
                                    globalL           =  map buildGlobalVar @cafNames
                                in if null @globalL.grTrf then globalL else @globalL.grTrf
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%% Fix Primitives to Exception statements %%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8.hackPrimToExceptionStatments

-- we need an node which eval interprets as 'throw exception'
SEM GrModule
  | Mod  loc  .  newEvalTagMp  =  ((throwTag,1), EvApTagThrow) : @evalTagMp

SEM GrBind
  | Bind  lhs  .  grTrf    =  GrBind_Bind @nm @argNmL @newExpr
          loc  .  newExpr  =  if @nm == HNm "_catch" then buildCatchExpr @argNmL 
                              else if @nm == HNm "_throw" then buildThrowExpr @argNmL
                              else @expr.grTrf
%%]

%%[8.hackPrimToExceptionStatments hs
buildThrowExpr [exceptNm] = GrExpr_Throw exceptNm

buildCatchExpr [tryNm, handlerNm] = let  exceptNm = hsnPrefix "except_ptr@" handlerNm
                                         evalNm   = hsnPrefix "except_node@" handlerNm
                                    in GrExpr_Catch (GrExpr_Eval tryNm)
                                                    exceptNm
                                                    (GrExpr_Seq (GrExpr_Eval handlerNm)
                                                                (GrPat_Var evalNm)
                                                                (GrExpr_App evalNm [GrVal_Var exceptNm])
                                                    )
%%]

% vim:ts=4:et:ai:
