%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Code generation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%[8

ATTR GrAGItf GrModule GrGlobalL GrGlobal GrBindL GrBind GrExpr GrAlt GrAltL [ hptMap : {HptMap} | | ]

ATTR GrAGItf GrModule   [ | | silModule                  : {SilModule}    ]
ATTR GrBindL GrBind     [ | | functions    USE {++} {[]} : {Functions}    ]
ATTR GrExpr             [ | | stats        USE {++} {[]} : {Statements}   ]
ATTR GrAltL             [ | | alternatives               : {Alternatives} ]
ATTR GrAlt              [ | | alternative                : {Alternative}  ]
ATTR GrVal GrPat GrTag  [ | | value                      : {Value}        ]
ATTR GrPat GrTag        [ | | constant                   : {Constant}     ]
ATTR GrValL GrVal       [ | | values                     : {Values}       ]
ATTR GrGlobal GrGlobalL [ | | initStats    USE {++} {[]} : {Statements}
                              names        USE {++} {[]} : {[String]}     ]

ATTR GrExpr GrAlt GrAltL [ numberParameters : {Int}
                         |
                         | localsF USE {.} {id}: {[HsName]->[HsName]}
                           maxChildParameters USE {`max`} {0} : {Int}
                           tailJumps USE {&&} {True} : {Bool}
                         ]

ATTR GrBindL GrBind GrExpr GrAlt GrAltL GrGlobal GrGlobalL [ maxConstrParameters : {Int} | | ]

ATTR GrValL [ | | length : {Int} ]
SEM GrValL
  | Nil lhs.length = 0
  | Cons lhs.length = 1 + @tl.length

%%]

%%[8
SEM GrModule
  | Mod lhs.silModule    =   SilModule_SilModule
                                (tagConstants @evalTagMp)   -- constants
                                @globalL.names              -- variables
                                ( Function_Function "initialize" False [] []
                                                    ( Statement_Assignment Variable_BP (Value_Con (Constant_LiteralInt 0))
                                                    : @globalL.initStats
                                                    )
                                : @bindL.functions            -- functions
                                )

        loc . maxConstrParameters = foldr max 0 (map (ctagArity.snd) (concat (map snd @ctagsMp)))


SEM GrBind
  | Bind   lhs.functions =  [ Function_Function
                                -- name
                                (hsnShowAlphanumeric @nm)
                                @expr.tailJumps
                                -- parameters
                                (    if @lhs.optOwnParameters then [] else @loc.params
                                )
                                -- locals
                                (   (if @lhs.optOwnLocals     then [] else @loc.locals)
                                ++  (if @lhs.optOwnParameters then @loc.params else [])
                                )
                                -- body
                                (  (if   @lhs.optOwnParameters && not (null @argNmL)
                                    then Statement_Comment "Parameters"
                                         : zipWith Statement_Assignment
                                                   (map Variable_Var @loc.params)
                                                   (map (arrayValue Variable_SP) [-1,-2..])
                                    else []
                                   )
                                ++ (if   @loc.ownAllocation
                                    then [ Statement_Enter (if @lhs.optOwnLocals     then length @loc.locals       else 0)
                                                           (if @lhs.optOwnParameters then @expr.maxChildParameters else 0)
                                         ]
                                    else []
                                   )
                                ++ @expr.stats
                                ++ ( if @loc.ownAllocation && not @expr.tailJumps
                                     then [Statement_Leave 0]
                                     else []
                                   )
                                )
                            ]

          expr . numberParameters = length @argNmL
          loc  . locals = filter (\n->n/="_" && n/="x0") (map hsnShowAlphanumeric (@expr.localsF []))
          loc  . params = map hsnShowAlphanumeric @argNmL
          loc  . ownAllocation = @lhs.optOwnParameters || @lhs.optOwnLocals

SEM GrExpr
 | Seq     lhs.stats  = @expr.stats
                        ++ @body.stats

 | Unit    lhs.stats  = Statement_Comment "Unit"
                        : [ Statement_Assignment v e
                          | (v,e) <-zip  (if @isLastExpr
                                          then [arrayVariab Variable_RP i | i <- [0..] ]
                                          else [Variable_Var (hsnShowAlphanumeric x)  | x <- @lhs.targets]
                                         )
                                         @val.values
                          , v/=Variable_Var "_" && v/=Variable_Var "x0"
                          ]


 | Store   lhs.stats  = let ph = head @lhs.targets
                            vs = @val.values
                            n  = length vs
                            --n2 = @lhs.maxConstrParameters
                            n2 = maximum (map (length.snd) (getNodes (absFetch @lhs.hptMap ph)))
                        in Statement_Comment "Store"
                           : store (hsnShowAlphanumeric ph) n n2 vs

           lhs.localsF = (@lhs.targets ++)

 | FetchUpdate 
           lhs.stats  = let p = hsnShowAlphanumeric @dst
                            q = hsnShowAlphanumeric @src
                            -- it would be nice to use hptMap to determine size, and hptMap can now be used even after changing numbered variables back to names
                            n = maximum (map (length.snd) (getNodes (absFetch @lhs.hptMap @src)))
                            -- n = 9
                         in Statement_Comment "FetchUpdate"
                            : zipWith Statement_Assignment
                                     (map (arrayVariab (Variable_Var p)) [0..n])
                                     (map (arrayValue  (Variable_Var q)) [0..n])



 | Update  lhs.stats  = let p = hsnShowAlphanumeric @nm
                            vs = @val.values
                         in Statement_Comment "Update"
                            : zipWith Statement_Assignment
                                      (map (arrayVariab (Variable_Var p)) [0..])
                                      vs

 | Fetch   lhs.stats  = Statement_Comment "Fetch"
                        : Statement_Assignment (Variable_Var (hsnShowAlphanumeric (head @lhs.targets)))
                                               (case @mbOffset of
                                                 Just offset -> (arrayValue (Variable_Var (hsnShowAlphanumeric @nm)) offset)
                                                 Nothing     -> error "cant generate code for Fetch without offset"
                                               )
                        : []

           lhs.localsF = (@lhs.targets ++)

 | Case    lhs.stats  = Statement_Comment "Case"
                        : Statement_Switch @val.value
                                           @altL.alternatives
                        : []

           lhs.localsF = (@lhs.targets ++) . @altL.localsF

 | Call    lhs.stats  = if @isLastExpr && @lhs.optJumpTailCalls
                         then (   Statement_Comment "Call (Tail)"
                              :   zipWith Statement_Assignment
                                          (map (arrayVariab Variable_RP) [1..])
                                          @argL.values
                              )
                              ++
                              (   Statement_Leave (@argL.length - @lhs.numberParameters)
                              :   zipWith Statement_Assignment
                                          (map (arrayVariab Variable_SP) [-1,-2..])
                                          (map (arrayValue  Variable_RP) [1 .. @argL.length])
                              )
                              ++ [Statement_Jump (hsnShowAlphanumeric @nm)]
                         else (   Statement_Comment "Call (Normal)"
                              :   (if @lhs.optOwnParameters
                                   then (  zipWith Statement_Assignment
                                                   (map (arrayVariab Variable_SP) [-1,-2..])
                                                   @argL.values
                                        ++ [Statement_Call (hsnShowAlphanumeric @nm) [] ]
                                        )
                                   else [Statement_Call (hsnShowAlphanumeric @nm) @argL.values ]
                                  )
                              ++ [ Statement_Assignment v e
                                 | (v,e) <-zip  [Variable_Var (hsnShowAlphanumeric x)  | x <- @lhs.targets]
                                                (map (arrayValue Variable_RP) [0..])
                                 , v/=Variable_Var "_" && v/=Variable_Var "x0"
                                 ]                                         
                                         
                              )

           lhs.localsF = (@lhs.targets ++)
           lhs.maxChildParameters = @argL.length

 | FFI     lhs.stats  = Statement_Comment "FFI"
                        : Statement_Assignment
                               (if @isLastExpr
                                then (arrayVariab Variable_RP 0)
                                else (Variable_Var (hsnShowAlphanumeric (head @lhs.targets)))
                               )
                               (Value_Call @nm (map (Value_Var . Variable_Var . hsnShowAlphanumeric) @argL))
                        : []

           lhs.localsF = (@lhs.targets ++)

 | App     lhs.stats  = [Statement_Comment "App: SHOULDNT"]
 | Eval    lhs.stats  = [Statement_Comment "Eval: SHOULDNT"]
 | Throw   lhs.stats  = [Statement_Comment "Throw: TODO"]
 | Catch   lhs.stats  = [Statement_Comment "Catch: TODO"]


SEM GrAltL
  | Nil    lhs.alternatives = []
  | Cons   lhs.alternatives = @hd.alternative : @tl.alternatives

SEM GrAlt
 | Alt     lhs.alternative = Alternative_Alternative @pat.constant
                                                     @expr.stats


SEM GrGlobal
%%[[8
 | Global  loc.globNm      = @nm
%%][12
 | Global  loc.globNm      = hsnToGlobal @nm
%%]]
 		   lhs.names       = [hsnShowAlphanumeric @globNm]
           lhs.initStats   = let vs = @val.values
                                 n  = length vs
                                 --n2 = @lhs.maxConstrParameters
                                 n2 = maximum (map (length.snd) (getNodes (absFetch @lhs.hptMap @globNm)))
                             in  store (hsnShowAlphanumeric @globNm) n n2 vs



SEM GrVal
 | LitInt  lhs.value  = Value_Con (Constant_LiteralInt @int)
 | LitStr  lhs.value  = Value_Con (Constant_LiteralStr @str)
%%[[8
 | Var     loc.value  = Value_Var (Variable_Var (hsnShowAlphanumeric @nm))
%%][12
 | Var     loc.value  = Value_Var (Variable_Var (hsnShowAlphanumeric $ hsnToGlobal @nm))
%%]]
           lhs.value  = @loc.value
           lhs.values = [@loc.value]
 | Tag     lhs.value  = @tag.value
 | Node    lhs.values = @tag.value : @fldL.values
 | * - LitInt LitStr Var Tag
           lhs.value  = error "GrVal:other value"
 | * - Node Var
           lhs.values = error "GrVal:other values"

SEM GrValL
 | Nil    lhs.values = []
 | Cons   lhs.values = @hd.value : @tl.values

SEM GrTag
 | Lit     loc.constant = Constant_Alias (tagName @categ @nm)
           lhs.constant = @loc.constant
           lhs.value    = Value_Con (@loc.constant)
 | Var     lhs.value    = Value_Var (Variable_Var (hsnShowAlphanumeric @nm))
 | Unboxed lhs.value    = error "GrTag:Unboxed value"
 | Any     lhs.value    = error "GrTag:Any value"
 | * - Lit lhs.constant = error "GrTag:other constant"

SEM GrPat
 | Tag     lhs.value    = @tag.value
           lhs.constant = @tag.constant
 | * - Tag lhs.value    = error "GrPat:other value"
           lhs.constant = error "GrPat:other constant"



SEM GrExpr
 | Seq     lhs.tailJumps = @body.tailJumps
 | Call    lhs.tailJumps = @isLastExpr && @lhs.optJumpTailCalls
 | Case    lhs.tailJumps = @altL.tailJumps
 | * - Seq Call Case
           lhs.tailJumps = False


%%]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Determining the target
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%[8

ATTR AllGrExpr [ targets : {[HsName]} | | ]
ATTR GrPat GrTag [ | |  patternNames: {[HsName]} ]

SEM GrBind
  | Bind     expr . targets = []

SEM GrExpr
  | Seq      expr . targets = @pat.patternNames
             body . targets = @lhs.targets

SEM GrPat
  | Var   lhs  .  patternNames = [@nm]
  | Node  lhs  .  patternNames = @tag.patternNames ++ @fldL
  | * - Var Node Tag  lhs  .  patternNames  =  []

SEM GrTag
  | Var      lhs  .  patternNames  = [@nm]
  | Unboxed  lhs  .  patternNames  = []
  | * - Var Unboxed lhs  .  patternNames  = [wildcardNr]
%%]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Options to adapt the structure of the generated code
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%[8
ATTR GrAGItf GrModule GrBind GrBindL GrExpr GrAlt GrAltL
  [ optJumpTailCalls : {Bool} -- when True, tail calls are implemented with a goto
    optOwnParameters : {Bool} -- when True, parameter passing is via the Stack datastructure
    optOwnLocals     : {Bool} -- when True, local variables are allocated on the Stack datastructure
  | | ]

-- Force OwnParameters when JumpTailCalls
SEM GrModule
  | Mod bindL.optOwnParameters = @lhs.optOwnParameters || @lhs.optJumpTailCalls
%%]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Auxiliary Haskell
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%[8 hs

-- n1 is the number of parameters of the tag
-- n2 is the maximum number of parameters of all constructorfunctions
-- tags other than C may be overwritten later with a C-tag, which might have more parameters.
-- We anticipate here for the maximum number of parameters.
-- Obvious improvement: do not take the global maximum, but only the maximum over the constructors
-- that are actually possible for this function.
-- Source of this information could be the Haskell-type, or the Grin HPT-analysis.

allocate :: Char -> Int -> Int -> Value
allocate 'C' n1 _  = Value_Alloc n1
allocate _   n1 n2 = Value_Alloc (max n1 n2)
       
-- tagcat is "C" for constructors, "F" for function thunks, "P" for partialapp thunks etc.
tagcat :: [Value] -> Char
tagcat (Value_Con (Constant_Alias (c:_)):_) = c

store :: String -> Int -> Int -> [Value] -> Statements
store pn n1 n2 vs
       =  Statement_Assignment (Variable_Var pn) (allocate (tagcat vs) n1 n2)
          : zipWith Statement_Assignment
                    (map (arrayVariab (Variable_Var pn)) [0..])
                    vs

arrayValue :: Variable -> Int -> Value
arrayValue a i = Value_Var (Variable_Subs a (Constant_LiteralInt i))

arrayVariab :: Variable -> Int -> Variable
arrayVariab a i = Variable_Subs a (Constant_LiteralInt i)

tagConstants :: EvApTagMp -> [(String,Int)]
tagConstants eas
 = let f ((t,s),k) n = (showGrTag t,n)
   in  zipWith f eas [0..]



showGrTagCateg :: GrTagCateg -> String
showGrTagCateg (GrTagPApp need) = "P" ++ show need ++ "_"
showGrTagCateg x = show x


tagName categ nm = showGrTagCateg categ ++ hsnShowAlphanumeric nm

showGrTag :: GrTag -> String
showGrTag (GrTag_Lit categ n nm) = tagName categ nm
showGrTag (GrTag_Var nm) = hsnShowAlphanumeric nm
showGrTag (GrTag_Unboxed) = "GrTag:Unboxed"
showGrTag (GrTag_Any    ) = "GrTag:Any"

%%]
