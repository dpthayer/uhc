%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Code generation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%[8

ATTR GrAGItf GrModule GrGlobalL GrGlobal GrBindL GrBind GrExpr GrAlt GrAltL [ hptMap : {HptMap} | | ]

ATTR GrAGItf GrModule   [ | | silModule                  : {SilModule}    ]
ATTR GrBindL GrBind     [ | | functions    USE {++} {[]} : {Functions}    ]
ATTR GrExpr             [ | | stats        USE {++} {[]} : {Statements}   ]
ATTR GrAltL             [ | | alternatives               : {Alternatives} ]
ATTR GrAlt              [ | | alternative                : {Alternative}  ]
ATTR GrVal GrPat GrTag  [ | | value                      : {Value}        ]
ATTR GrPat GrTag        [ | | constant                   : {Constant}     ]
ATTR GrValL GrVal       [ | | values                     : {Values}       ]
ATTR GrGlobal GrGlobalL [ | | initStats    USE {++} {[]} : {Statements}
                              names        USE {++} {[]} : {[String]}     ]

ATTR GrExpr GrAlt GrAltL [ numberParameters : {Int}
                           distance : {Int}
                         |
                         | localsF USE {.} {id}: {[HsName]->[HsName]}
                           tailJumps USE {&&} {True} : {Bool}
                         ]

ATTR GrBindL GrBind GrExpr GrAlt GrAltL GrGlobal GrGlobalL [ maxConstrParameters : {Int} | | ]
ATTR GrExpr GrAlt GrAltL GrGlobal GrGlobalL GrValL GrVal GrTag GrTagL GrAdaptL GrAdapt GrPat GrPatL GrSplitL GrSplit [ embed : {EmbedFunction} | | ]

ATTR GrTagL [ | | mbOnlyTagValue : {Maybe Value}  isEmpty : {Bool} ]

ATTR GrAlt GrAltL [ | | hasAnies USE {||} {False} : {Bool} ]
ATTR GrPat GrTag  [ | | isAny: {Bool} ]
ATTR GrTag GrVal  [ | | isUnboxed: {Bool} ]


SEM GrTagL
  | Nil            lhs . isEmpty        = True
                   lhs . mbOnlyTagValue = Nothing
  | Cons           lhs . isEmpty        = False
                   lhs . mbOnlyTagValue = if @tl.isEmpty
                                           then Just @hd.value
                                           else Nothing

SEM GrAlt
  | Alt            loc . hasAnies = @pat.isAny
 
SEM GrTag
  | Any            lhs . isAny = True
  | * - Any        lhs . isAny = False
  | Unboxed        lhs . isUnboxed = True
  | * - Unboxed    lhs . isUnboxed = False

SEM GrVal
  | Node           lhs . isUnboxed = @tag.isUnboxed
  | * - Node       lhs . isUnboxed = False

SEM GrPat          
  | Tag            lhs . isAny = @tag.isAny
  | * - Tag        lhs . isAny = False
  

ATTR GrValL [ | | length : {Int} ]
SEM GrValL
  | Nil lhs.length = 0
  | Cons lhs.length = 1 + @tl.length


ATTR GrBind GrBindL GrExpr GrAlt GrAltL
         [  |  retNr : {Int} |  ]



ATTR GrExpr GrAltL GrAlt
  [ realNodes: {[HsName]} | | ]
  
ATTR GrExpr
  [  | | mbExtraRealNode: {Maybe HsName} ]


SEM GrExpr
  | FetchField      lhs.mbExtraRealNode = if  @offset==0
                                           then Just @nm
                                           else Nothing
  | * - FetchField  lhs.mbExtraRealNode = Nothing
  
SEM GrExpr
  | Seq             body.realNodes      = maybe id (:) @expr.mbExtraRealNode $ @lhs.realNodes

SEM GrBind
  | Bind            expr.realNodes      = []




%%]

%%[8
SEM GrModule
  | Mod lhs.silModule    =   SilModule_SilModule
                                (tagConstants @evalTagMp)   -- constants
                                @globalL.names              -- variables
                                ( Function_Function "initialize" False [] []
                                                    ( @globalL.initStats
                                                    ++ [ Statement_Return 2 1
                                                       ]
                                                    )
                                : @bindL.functions            -- functions
                                )

        loc . maxConstrParameters = foldr max 0 (map (ctagArity.snd) (concat (map snd @ctagsMp)))
        globalL . embed = embed Map.empty
        bindL . retNr   = 3






SEM GrBind
  | Bind   lhs.functions =  [ Function_Function
                                -- name
                                (hsnShowAlphanumeric @nm)
                                @expr.tailJumps
                                -- parameters
                                (   if @lhs.optOwnParameters then [] else @loc.paramsStr
                                )
                                -- locals
                                (   if @lhs.optOwnLocals     
                                     then [] 
                                     else (   @loc.localsStr
                                          ++  (if @lhs.optOwnParameters then @loc.paramsStr else [])
                                          )
                                )
                                -- body
                                (  (if   @lhs.optOwnParameters && not @lhs.optOwnLocals && not (null @argNmL)
                                    then Statement_Comment ["Parameters"]
                                         : zipWith Statement_Assignment
                                                   (map (Variable_Param undefined) @loc.paramsStr)
                                                   (map (arrayValue Variable_SP) [2..])
                                    else []
                                   )
                                ++ (if   @loc.ownAllocation
                                    then [ Statement_Increment  Variable_SP (Value_Con (Constant_LiteralInt (- @loc.distance)))
                                         , Statement_Comment (map (showEmbedPair @loc.distance @lhs.hptMap) @loc.embedList)
                                         ]
                                    else []
                                   )
                                ++ @expr.stats
                                )
                            ]

          expr . numberParameters = length @argNmL
          expr . embed    = (if @lhs.optOwnLocals then (embed2 @loc.distance) else embed) @loc.embedMap
          loc  . distance = @loc.nLocals + @loc.roomForCcalls
          loc  . embedList= @loc.paramsTup ++ @loc.localsTup
          loc  . embedMap = Map.fromList @loc.embedList
          loc  . localsHs  = filter (\(HNmNr n _)->n/=0) (@expr.localsF [])
          loc  . paramsHs  = @argNmL
          loc  . localsStr = map hsnShowAlphanumeric @loc.localsHs
          loc  . paramsStr = map hsnShowAlphanumeric @loc.paramsHs
          loc  . localsTup = zipWith (makeEmbedTupel Variable_Local) [1..] @loc.localsHs
          loc  . paramsTup = zipWith (makeEmbedTupel Variable_Param) [1..] @loc.paramsHs
          loc  . ownAllocation = @lhs.optOwnParameters || @lhs.optOwnLocals
          loc  . nLocals      = if @lhs.optOwnLocals     then length @loc.localsHs     else 0
          loc  . nParams      = if @lhs.optOwnParameters then length @loc.paramsHs     else 0
          loc  . roomForCcalls= 2
          

SEM GrExpr
 | Seq     lhs.stats  = @expr.stats
                        ++ @body.stats

 | Unit    lhs.stats  = if @isLastExpr
                         then Statement_Comment ["Unit (Yielding)"]
                              : if @lhs.optOwnParameters || @lhs.optOwnLocals
                                 then let dp = @lhs.distance+ @lhs.numberParameters
                                          smartTups = zip [dp+1,dp ..] (@val.values ++ [Value_Var (Variable_Subs Variable_SP (Constant_LiteralInt (@lhs.distance+1))) | @loc.moveRet ])
                                      in  smartAssignment (filter hasRealVal smartTups)
                                          ++ [ Statement_Return (@lhs.distance+ @lhs.numberParameters+2) (max @loc.nMyRes @lhs.numberParameters + 1)
                                             ]
                                 else [ Statement_Assignment v e
                                      | (v,e) <-zip [arrayVariab Variable_RP i | i <- [0..] ]
                                                    @val.values
                                      ]
                         else Statement_Comment ["Unit (Internal)"]
                              : [ Statement_Assignment v e
                                | (v,e) <-zip [@lhs.embed x | x <- @lhs.targets]
                                              @val.values
                                , isRealVar v
                                ]                         
                          
           loc.nMyRes = length (@val.values)
           loc.moveRet= @loc.nMyRes > @lhs.numberParameters


 | FFI     lhs.stats  = if @isLastExpr
                         then Statement_Comment ["FFI (Yielding)"]
                              : if @lhs.optOwnParameters || @lhs.optOwnLocals
                                 then let dp = @lhs.distance+ @lhs.numberParameters
                                          smartTups = zip [dp+1,dp ..] (@loc.callres ++ [Value_Var (Variable_Subs Variable_SP (Constant_LiteralInt (@lhs.distance+1))) | @loc.moveRet])
                                      in  smartAssignment (filter hasRealVal smartTups)
                                          ++ [ Statement_Return (@lhs.distance+ @lhs.numberParameters+2) (max @loc.nMyRes @lhs.numberParameters + 1)
                                             ]
                                 else [ Statement_Assignment v e
                                      | (v,e) <-zip [arrayVariab Variable_RP i | i <- [0..] ]
                                                    @loc.callres
                                      ]
                         else Statement_Comment ["FFI (Internal)"]
                              : [ Statement_Assignment v e
                                | (v,e) <-zip [@lhs.embed x | x <- @lhs.targets]
                                              @loc.callres
                                , isRealVar v
                                ]                         

           lhs.localsF = (@lhs.targets ++)
           loc.callres = maybe id (:) @resTagL.mbOnlyTagValue $ [Value_Call @nm (map (Value_Var . @lhs.embed) @argL)]
           loc.nMyRes  = length @loc.callres
           loc.moveRet= @loc.nMyRes > @lhs.numberParameters


 | Store   lhs.stats  = let ph = head @lhs.targets
                            vs = @val.values
                            n  = length vs
                            --n2 = @lhs.maxConstrParameters
                            n2 = maximum (map (length.snd) (getNodes (absFetch @lhs.hptMap ph)))
                        in Statement_Comment ["Store"]
                           : store @lhs.embed ph n n2 vs

           lhs.localsF = (@lhs.targets ++)

 | FetchUpdate 
           lhs.stats  = let -- use hptMap to determine size, because hptMap can now be used even after changing numbered variables back to names
                            n = maximum (map (length.snd) (getNodes (absFetch @lhs.hptMap @src)))
                         in Statement_Comment ["FetchUpdate"]
                            : zipWith Statement_Assignment
                                     (map (arrayVariab (@lhs.embed @dst)) [0..n])
                                     (map (arrayValue  (@lhs.embed @src)) [0..n])



 | Update   loc.name   = @lhs.embed @nm
            loc.change = --Statement_Assignment Variable_Ptr (Value_Var @loc.name) :                -- if this line is enabled, uses option 2 instead of option 1
                         zipWith Statement_Assignment
                                 (map (arrayVariab @loc.name) [0..])                                -- option 1
                                 --(map (Variable_Subs Variable_Ptr . Constant_LiteralInt) [0..])   -- option 2
                                 @val.values
            lhs.stats  = Statement_Comment ["Update"] : 
                         if @val.isUnboxed
                          then 
                               @loc.change ++     -- TODO: this line could be deleted if uniqueness analyses revealed that context is unique
                               [ Statement_Assignment @loc.name (Value_UnboxCon (head(tail @val.values))) ]
                          else @loc.change
 | FetchNode
           lhs.stats  = error "FetchNode found while generating Silly"
           lhs.localsF= error "FetchNode found while generating Silly"
           
 | FetchField
           lhs.stats  = [ Statement_Comment ["Fetch"]
                        , Statement_Assignment (@lhs.embed (head @lhs.targets))
                                               (if   @offset==1 && maybe False (==GrTag_Unboxed) @mbTag && not (elem @nm @lhs.realNodes)
                                                then Value_BoxVar (@lhs.embed @nm)
                                                else arrayValue (@lhs.embed @nm) @offset
                                               )
                        ]
           lhs.localsF = (@lhs.targets ++)

 | Case    lhs.stats  = [ Statement_Comment ["Case"]
                        , if @altL.hasAnies
                           then Statement_If     @val.value
                                                 @altL.alternatives
                           else Statement_Switch @val.value
                                                 @altL.alternatives
                        ]
                        
           lhs.localsF = (@lhs.targets ++) . @altL.localsF

 | Call    lhs.stats  = if @isLastExpr && @lhs.optJumpTailCalls
                         then let dp = @lhs.distance+ @lhs.numberParameters
                                  smartTups = zip [dp+1,dp ..] ((reverse @argL.values) ++ map (Value_Var . Variable_Subs Variable_SP . Constant_LiteralInt) [ @lhs.distance+1 , @lhs.distance ] )
                              in  Statement_Comment ["Call (Tail) "]
                                  :  smartAssignment smartTups
                                  ++ [ Statement_Increment  Variable_SP (Value_Con (Constant_LiteralInt (@lhs.distance+ @lhs.numberParameters+2- @loc.nMyParams-2)))
                                     , Statement_Jump (hsnShowAlphanumeric @nm)
                                     ]
                         else (   Statement_Comment ["Call (Normal)"]
                              :   (if @lhs.optOwnParameters
                                   then (  zipWith Statement_Assignment
                                                   (map (arrayVariab Variable_SP) [-1,-2..])
                                                   (  reverse @argL.values
                                                   ++ [ Value_Label ("retlab"++show @lhs.retNr)
                                                      , Value_Var (Variable_SPOffset @lhs.distance)
                                                      ]
                                                   )
                                        ++ [ Statement_Increment  Variable_SP (Value_Con (Constant_LiteralInt (- @loc.nMyParams-2)))
                                           , Statement_Call (hsnShowAlphanumeric @nm) [] 
                                           , Statement_Label ("retlab"++show @lhs.retNr)
                                           ]
                                        )
                                   else [Statement_Call (hsnShowAlphanumeric @nm) @argL.values ]
                                  )
                              ++ [ Statement_Assignment v e
                                 | (v,e) <-zip  [@lhs.embed x  | x <- @lhs.targets]
                                                ( if @lhs.optOwnParameters || @lhs.optOwnLocals
                                                   then map (arrayValue Variable_SP) [-1,-2..]
                                                   else map (arrayValue Variable_RP) [0..]
                                                )
                                 , isRealVar v
                                 ]
                              )

           loc.nMyParams = @argL.length
           lhs.localsF = (@lhs.targets ++)
           lhs.retNr   = @lhs.retNr + 1

 | App     lhs.stats  = [Statement_Comment ["App: SHOULDNT"]]
 | Eval    lhs.stats  = [Statement_Comment ["Eval: SHOULDNT"]]
 | Throw   lhs.stats  = [Statement_Comment ["Throw: TODO"]]
 | Catch   lhs.stats  = [Statement_Comment ["Catch: TODO"]]


SEM GrAltL
  | Nil    lhs.alternatives = []
  | Cons   lhs.alternatives = @hd.alternative : @tl.alternatives

SEM GrAlt
 | Alt     lhs.alternative = Alternative_Alternative @pat.constant
                                                     @expr.stats


SEM GrGlobal
%%[[8
 | Global  loc.globNm      = @nm
%%][12
 | Global  loc.globNm      = hsnToGlobal @nm
%%]]
 		   lhs.names       = [hsnShowAlphanumeric @globNm]
           lhs.initStats   = let vs = @val.values
                                 n  = length vs
                                 n2 = maximum (map (length.snd) (getNodes (absFetch @lhs.hptMap @globNm)))
                             in  store @lhs.embed @globNm n n2 vs



SEM GrVal
 | LitInt  lhs.value  = Value_Con (Constant_LiteralInt @int)
 | LitStr  lhs.value  = Value_Con (Constant_LiteralStr @str)
%%[[8
 | Var     loc.value  = Value_Var (@lhs.embed @nm)
%%][12
 | Var     loc.value  = Value_Var (@lhs.embed (hsnToGlobal @nm))
%%]]
           lhs.value  = @loc.value
           lhs.values = [@loc.value]
 | Tag     lhs.value  = @tag.value
 | Node    lhs.values = @tag.value : @fldL.values
 | * - LitInt LitStr Var Tag
           lhs.value  = error "GrVal:other value"
 | * - Node Var
           lhs.values = error "GrVal:other values"

SEM GrValL
 | Nil    lhs.values = []
 | Cons   lhs.values = @hd.value : @tl.values

SEM GrTag
 | Lit     loc.constant = Constant_Alias (tagName @categ @nm)
           lhs.constant = @loc.constant
           lhs.value    = Value_Con (@loc.constant)
 | Var     lhs.value    = Value_Var (@lhs.embed @nm)
 | Unboxed lhs.value    = Value_Con (Constant_Alias "UNBOXED")
 | Any     lhs.value    = error "GrTag:Any value"
 | Unboxed lhs.constant = Constant_Alias "UNBOXED"
 | Any     lhs.constant = Constant_Alias "ANY"
 | * - Lit Unboxed Any
           lhs.constant = error "GrTag:other constant"

SEM GrPat
 | Tag     lhs.value    = @tag.value
           lhs.constant = @tag.constant
 | * - Tag lhs.value    = error "GrPat:other value"
           lhs.constant = error "GrPat:other constant"



SEM GrExpr
 | Seq     lhs.tailJumps = @body.tailJumps
 | Call    lhs.tailJumps = @isLastExpr && @lhs.optJumpTailCalls
 | Case    lhs.tailJumps = @altL.tailJumps
 | * - Seq Call Case
           lhs.tailJumps = False


%%]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Determining the target
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%[8

ATTR AllGrExpr [ targets : {[HsName]} | | ]
ATTR GrPat GrTag [ | |  patternNames: {[HsName]} ]

SEM GrBind
  | Bind     expr . targets = []

SEM GrExpr
  | Seq      expr . targets = @pat.patternNames
             body . targets = @lhs.targets

SEM GrPat
  | Var   lhs  .  patternNames = [@nm]
  | Node  lhs  .  patternNames = @tag.patternNames ++ @fldL
  | * - Var Node Tag  lhs  .  patternNames  =  []

SEM GrTag
  | Var      lhs  .  patternNames  = [@nm]
  | Unboxed  lhs  .  patternNames  = [wildcardNr]
  | * - Var Unboxed lhs  .  patternNames  = [wildcardNr]
%%]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Options to adapt the structure of the generated code
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%[8


ATTR GrAGItf
  [ opts : {EHCOpts} | | ]

ATTR GrModule GrBind GrBindL GrExpr GrAlt GrAltL
  [ optJumpTailCalls : {Bool} -- when True, tail calls are implemented with a goto
    optOwnParameters : {Bool} -- when True, parameter passing is via the Stack datastructure
    optOwnLocals     : {Bool} -- when True, local variables are allocated on the Stack datastructure
  | | ]

SEM GrAGItf
  | AGItf loc.optOwnParameters   = ehcOptGenOwnParams @lhs.opts
          loc.optOwnLocals       = ehcOptGenOwnLocals @lhs.opts
          loc.optOwnCalls        = ehcOptGenOwnCalls  @lhs.opts
          loc.optGenAsmSP        = ehcOptGenAsmSP     @lhs.opts
          loc.optJumpTailCalls   = ehcOptGenTailCall  @lhs.opts
          -- Force some options to imply some others
          module.optOwnParameters = @loc.optOwnParameters  || @loc.optOwnLocals || @loc.optJumpTailCalls || @loc.optOwnCalls || @loc.optGenAsmSP
          module.optOwnLocals     =                           @loc.optOwnLocals || @loc.optJumpTailCalls || @loc.optOwnCalls || @loc.optGenAsmSP
          
%%]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% The Smart Assignation strategy (probably reinvented a topological sort algorithm here)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%[8 hs

type EIV = Either Int Value
data SmartTree = SmartTree EIV [SmartTree]

smartAssignment :: [(Int,Value)] -> [Statement]
smartAssignment = concat . map smartAss . foldr smartAdd [] . convertTups

convertTups :: [(Int,Value)] -> [(EIV,Int)]
convertTups tups = [ (dependency, destination) 
                   | (destination, value) <- tups
                   , let dependency = smartDep value
                   , either (\n->n/=destination) (\v->True) dependency
                   ]

smartDep :: Value -> EIV
smartDep (Value_Var (Variable_Subs Variable_SP (Constant_LiteralInt n))) = Left n
smartDep v = Right v

smartFind :: EIV -> [SmartTree] -> (SmartTree, [SmartTree])
smartFind n [] =  (SmartTree n [], [])
smartFind n (t@(SmartTree r ks):ts)
  | n==r       =  (t, ts)
  | otherwise  =  let (t2,ts2) = smartFind n ts
                  in (t2, t:ts2)

smartAdd :: (EIV,Int) -> [SmartTree] -> [SmartTree]
smartAdd p@(x,y) ts = let (y2,ts2) = smartFind (Left y) ts
                          (rs,b) = smartIns (x,y2) ts2
                      in  if b
                           then rs
                           else (SmartTree x [y2]) : ts2
                           
smartInsert :: (EIV,SmartTree) -> SmartTree -> (SmartTree,Bool)
smartInsert p@(x,y) t@(SmartTree root kids)
 | x==root   =  (SmartTree root (y:kids), True)
 | otherwise =  let (rs,b) = smartIns p kids
                in  if b
                     then (SmartTree root rs, True)
                     else (t                , False)
                    
smartIns :: (EIV,SmartTree) -> [SmartTree] -> ([SmartTree],Bool)
smartIns p ts = foldr f ([],False) ts
  where f t (rs,True) = (t:rs, True)
        f t (rs,False) = let (r,b) = smartInsert p t
                         in  (r:rs, b)
       
smartElems :: SmartTree -> [Int]
smartElems (SmartTree (Left n) [])   = [n]
smartElems (SmartTree (Left n) kids) = n : concat (map smartElems kids)


auxVar = Variable_Aux
auxVal = Value_Var auxVar

smartAss :: SmartTree -> [Statement]
smartAss t@(SmartTree root kids) 
  =  either
     (\n -> if  n `elem` concat (map smartElems kids)
             then Statement_Assignment auxVar (arrayValue Variable_SP n) 
                  : concat (map (smartChain auxVal) kids)
             else concat (map (smartChain (arrayValue Variable_SP n)) kids)
     )
     (\v -> concat (map (smartChain v) kids)
     )
     root
  
smartChain :: Value -> SmartTree -> [Statement]
smartChain v (SmartTree (Left root) kids) 
   = concat (map (smartChain (arrayValue Variable_SP root)) kids) 
     ++ [ Statement_Assignment (arrayVariab Variable_SP root) v ]
       
%%]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Embedding of parameters and local variables on the stack
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%[8 hs

type EmbedMap = Map.Map Int Variable
type EmbedFunction = HsName->Variable

makeEmbedTupel :: (Int->String->Variable) -> Int -> HsName -> (Int,Variable)
makeEmbedTupel constr k x@(HNmNr n _) = (n, constr k (hsnShowAlphanumeric x))

embed :: EmbedMap -> EmbedFunction
embed m x@(HNmNr n _) = if n==0
                         then Variable_None
                         else maybe (Variable_Global (hsnShowAlphanumeric x))
                                    id
                                    (Map.lookup n m)

embed2 :: Int -> EmbedMap -> EmbedFunction
embed2 d m x@(HNmNr n _) = if n==0
                            then Variable_None
                            else maybe (Variable_Global (hsnShowAlphanumeric x))
                                       (\v -> case v of
                                                Variable_Local n _ -> Variable_Subs Variable_SP (Constant_LiteralInt (d+0-n))
                                                Variable_Param n _ -> Variable_Subs Variable_SP (Constant_LiteralInt (d+1+n))                                                
                                       )
                                       (Map.lookup n m)

showEmbedPair :: Int -> HptMap -> (Int,Variable) -> String
showEmbedPair d h (i, Variable_Param n name) = "Param " ++ show n ++ " \t" ++ postPad 12 name ++ "\tSP[" ++ show (d+1+n) ++ "]\t(" ++ show (getEnvVar h i) ++ ")"
showEmbedPair d h (i, Variable_Local n name) = "Local " ++ show n ++ " \t" ++ postPad 12 name ++ "\tSP[" ++ show (d+0-n) ++ "]\t(" ++ show (getEnvVar h i) ++ ")"

postPad n s = let w = length s
              in  if w>=n then s else s ++ replicate (n-w) ' '
                  

%%]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Other auxiliary Haskell
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%[8 hs

isRealVar Variable_None = False
isRealVar _             = True

hasRealVal (_, Value_Con (Constant_Alias "UNBOXED")) = False
hasRealVal _                                         = True

-- n1 is the number of parameters of the tag
-- n2 is the maximum number of parameters of all constructorfunctions
-- tags other than C may be overwritten later with a C-tag, which might have more parameters.
-- We anticipate here for the maximum number of parameters.
-- Obvious improvement: do not take the global maximum, but only the maximum over the constructors
-- that are actually possible for this function.
-- Source of this information could be the Haskell-type, or the Grin HPT-analysis.

allocate :: Char -> Int -> Int -> Value
allocate 'C' n1 _  = Value_Alloc n1
allocate _   n1 n2 = Value_Alloc (max n1 n2)
       
-- tagcat is "C" for constructors, "F" for function thunks, "P" for partialapp thunks, "U" for unboxed, etc.
tagcat :: [Value] -> Char
tagcat (Value_Con (Constant_Alias (c:_)):_) = c
tagcat _ = ' '

store :: EmbedFunction -> HsName -> Int -> Int -> [Value] -> Statements
store em pn n1 n2 vs
       =  let epn = em pn
              cat = tagcat vs
          in  if    cat=='U'
              then [Statement_Assignment epn (Value_UnboxCon (head (tail vs)))]
              else Statement_Assignment epn (allocate cat n1 n2)
                   : zipWith Statement_Assignment
                             (map (arrayVariab epn) [0..])
                             vs

arrayValue :: Variable -> Int -> Value
arrayValue a i = Value_Var (Variable_Subs a (Constant_LiteralInt i))

arrayVariab :: Variable -> Int -> Variable
arrayVariab a i = Variable_Subs a (Constant_LiteralInt i)

tagConstants :: EvApTagMp -> [(String,Int)]
tagConstants eas
 = let f ((t,s),k) n = (showGrTag t,n)
   in  zipWith f eas [0..]



showGrTagCateg :: GrTagCateg -> String
showGrTagCateg (GrTagPApp need) = "P" ++ show need ++ "_"
showGrTagCateg x = showGrTagCategLetter x


tagName categ nm = showGrTagCateg categ ++ hsnShowAlphanumeric nm

showGrTag :: GrTag -> String
showGrTag (GrTag_Lit categ n nm) = tagName categ nm
showGrTag (GrTag_Var nm) = hsnShowAlphanumeric nm
showGrTag (GrTag_Unboxed) = "GrTag:Unboxed"
showGrTag (GrTag_Any    ) = "GrTag:Any"

%%]
