Make sure a Bind always returns a node (not a pointer)
Also, make sure that a Case always scrutinizes a node.
If not, add an extra Fetch to fetch the contents of a pointer.

Contrariwise, the parameters of "Apply" should always be pointers.
If not, add an extra Store to store the node in a heap location.

TODO: these transformations, particularly the adding of Stores,
wastes unique numbers, because unique is incremented even if the transformation was not necessary.

%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[8 import({GrinCode/AbsSyn})
%%]

%%[8.wrapper
WRAPPER GrAGItf
%%]

%%[8 hs module {%{GRIN}GrinCode.Trf.AddFetch} import(qualified Data.Map as Map)
%%]

%%[8 hs import(Data.Maybe(fromJust), {%{EH}Base.Common}, {%{EH}Base.Builtin},{%{GRIN}GRINCCommon}, {%{EH}GrinCode}) export(addFetch)

addFetch :: (GrModule,Int) -> (GrModule,Int)
addFetch (code,unique)
  = let inh = Inh_GrAGItf {unique_Inh_GrAGItf=unique}
        syn = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf code)) inh
    in  (grTrf_Syn_GrAGItf syn, unique_Syn_GrAGItf syn)

%%]

%%[8
ATTR GrAGItf [ | | grTrf: GrModule ]
ATTR AllNT   [ | | grTrf: SELF ]

ATTR GrExpr  [ | | selfAsNode: GrExpr ]
ATTR GrAlt   [ | | selfAsNode: GrAlt  ]
ATTR GrAltL  [ | | selfAsNode: GrAltL ]

ATTR GrVal   [ | | selfAsPtr:  GrVal  ]
ATTR GrValL  [ | | selfAsPtr:  GrValL ]
ATTR AllGrVal[ | | conversion USE {.} {id}: {GrExpr -> GrExpr} ]

ATTR GrAGItf GrModule AllBind AllGrExpr AllGrVal [ | unique: Int | ]

%%]

%%[8

SEM GrBind
  | Bind   lhs.grTrf               = GrBind_Bind @nm @argNmL @expr.selfAsNode


SEM GrExpr
  | Seq    lhs.selfAsNode          = GrExpr_Seq (if @expr.isNode then @expr.selfAsNode else @expr.grTrf)   -- if @expr claims to be a node, make sure it indeed is so (in Case expressions, some of the branches may not yet be)
                                                @pat.grTrf 
                                                @body.selfAsNode
  
  | Store  lhs.selfAsNode          = GrExpr_Unit @val.grTrf

  | Case   (lhs.selfAsNode, lhs.grTrf, lhs.unique)          
                                   = if @val.isNode
                                     then (GrExpr_Case @val.grTrf @altL.selfAsNode
                                          ,@loc.grTrf
                                          ,@altL.unique
                                          )
                                     else (GrExpr_Seq (GrExpr_FetchNode @val.getName) @loc.newPat (GrExpr_Case @loc.newVal @altL.selfAsNode)
                                          ,GrExpr_Seq (GrExpr_FetchNode @val.getName) @loc.newPat (GrExpr_Case @loc.newVal @altL.grTrf)
                                          ,@altL.unique+1
                                          )
           loc.newVal              = GrVal_Var @loc.newVar
           loc.newVar              = HNmNr @altL.unique Nothing
           loc.newPat              = GrPatLam_Var @loc.newVar
  
  | Unit
    UpdateUnit
           (lhs.selfAsNode, lhs.unique)
                                   = if @val.isNode
                                     then (@loc.grTrf, @lhs.unique)
                                     else (@loc.newExpr, @lhs.unique+1)
  | FetchField
           lhs.selfAsNode          = @loc.newExpr
           lhs.unique              = @lhs.unique+1

  | Unit                                     
    UpdateUnit
    FetchField
           loc.newExpr             = GrExpr_Seq @loc.grTrf @loc.newPat (GrExpr_FetchNode @loc.newVar)
           loc.newVar              = HNmNr @lhs.unique Nothing
           loc.newPat              = GrPatLam_Var @loc.newVar
  | FetchNode
    FetchUpdate
    Call
    FFI
    Eval
    App
    Throw
    Catch  lhs.selfAsNode          = @loc.grTrf                       

  | App    loc.grTrf               = @argL.conversion (GrExpr_App @nm @argL.selfAsPtr)




                                     
  
SEM GrAlt
  | Alt    lhs.selfAsNode          = GrAlt_Alt @pat.grTrf @expr.selfAsNode

SEM GrAltL
  | Nil    lhs.selfAsNode          = []
  | Cons   lhs.selfAsNode          = @hd.selfAsNode : @tl.selfAsNode



ATTR AllGrExpr AllGrVal [ env : {Map.Map HsName Bool} | | isNode : {Bool} ]

SEM GrExpr
  | Seq          lhs.isNode = @body.isNode
  | Unit         lhs.isNode = @val.isNode
  | UpdateUnit   lhs.isNode = @val.isNode
  | Case         lhs.isNode = @altL.isNode
  | FetchNode    lhs.isNode = True
  | FetchUpdate  lhs.isNode = True
  | FetchField   lhs.isNode = False
  | Store        lhs.isNode = False
  | Call         lhs.isNode = True
  | FFI          lhs.isNode = True
  | Eval         lhs.isNode = True
  | App          lhs.isNode = True
  | Throw        lhs.isNode = True
  | Catch        lhs.isNode = True

SEM GrAltL
  | Nil          lhs.isNode = False
  | Cons         lhs.isNode = @hd.isNode || @tl.isNode
  
SEM GrAlt
  | Alt          lhs.isNode = @expr.isNode


SEM GrVal
  | Empty
    LitInt
    LitStr
    Tag          loc.isNode = False
                 lhs.selfAsPtr = @loc.grTrf
  | Node
    VarNode
%%[[10
    NodeAdapt    
%%]]
                 loc.isNode = True
  | Var          loc.isNode = maybe False id (Map.lookup @nm @lhs.env)
  
  | Node
    VarNode
%%[[10
    NodeAdapt    
%%]]
    Var          (lhs.selfAsPtr,lhs.conversion,lhs.unique) = if @loc.isNode
                                                             then let newVar = HNmNr @lhs.unique Nothing
                                                                      newVal = GrVal_Var newVar
                                                                      newPat = GrPatLam_Var newVar
                                                                      newExp = GrExpr_Store @loc.grTrf
                                                                  in  ( newVal
                                                                      , GrExpr_Seq newExp newPat
                                                                      , @lhs.unique+1
                                                                      )
                                                             else     ( @loc.grTrf
                                                                      , id
                                                                      , @lhs.unique
                                                                      )
  

SEM GrValL
  | Nil         lhs.selfAsPtr = []
  | Cons        lhs.selfAsPtr = @hd.selfAsPtr : @tl.selfAsPtr

SEM GrBind
  | Bind         expr.env   = Map.empty
  
SEM GrExpr
  | Seq          expr.env   = @lhs.env 
                 body.env   = Map.insert @pat.boundVar @expr.isNode @lhs.env


ATTR GrPatLam [ | | boundVar : {HsName} ]

SEM GrPatLam
  | Var         lhs.boundVar  = @nm    
  | Empty
    VarNode     lhs.boundVar  = wildcardNm

ATTR GrVal [ | | getName : {HsName} ]

SEM GrVal
  | Var         lhs.getName   = @nm
  | * - Var     lhs.getName   = error "AddFetch: getName from non-Var"

%%]
