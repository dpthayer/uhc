cleanup EHC generated GRIN:
- eval and apply functions not needed (their semantics are builtin)
- better F-tag than P0-tag (altough they are aliases)
- primThrow and primCatch are not primitives, but ehc does not support the grin statements

%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[8 import({GrinCode/AbsSyn})
%%]

%%[8.wrapper
WRAPPER GrAGItf
%%]

%%[8 hs module {%{GRIN}GrinCode.Trf.CleanupPass} import(qualified Data.Set as Set, Char(isUpper))
%%]

%%[8 hs import({%{EH}Base.Common}, {%{GRIN}GRINCCommon}, {%{EH}GrinCode}) export(cleanupPass)
cleanupPass :: GrModule -> GrModule
cleanupPass grmod = let t = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf grmod))
                                         (Inh_GrAGItf)
                    in grTrf_Syn_GrAGItf t
%%]

%%[8
ATTR GrAGItf [ | | grTrf: GrModule ]
ATTR AllGrNT [ | | grTrf: SELF ]

SEM GrModule
  | Mod  lhs  .  grTrf         =  GrModule_Mod @moduleNm @newGlobals @bindL.grTrf @ctagsMp @newEvalTagMp @applyTagMp
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%% Eval and Apply are builtin %%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8.dropEvalApply
SEM GrBind [ | | dropBinding: Bool ]
  | Bind  lhs  . dropBinding  =  @nm `elem` [evalNm, evalNr,  applyNm, applyNr] --  || isUpper (head (show @nm))
  | Rec   lhs  . dropBinding  =  False


SEM GrBindL
  | Cons  lhs  .  grTrf  =  if @hd.dropBinding
                            then @tl.grTrf
                            else @hd.grTrf : @tl.grTrf
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%% F-Tag  <== P0-Tag %%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Ehc outputs P0-tags instead of F-Tags in some situations, we rewrite them to F-Tags
Also, replace F-Tags for constructorfunctions by C-tags

%%[8.P0tag_TO_Ftag

{
isConstructorInitial :: Char -> Bool
isConstructorInitial c = isUpper c || c==':' || c=='['
}



SEM GrTag
  | Lit  lhs  .  grTrf  = GrTag_Lit
                             (if   isConstructorInitial (head (show @nm)) && (@categ==GrTagFun || @categ==GrTagPApp 0)
                              then GrTagCon
                              else
                              if   @categ == GrTagPApp 0
                              then GrTagFun
                              else @categ
                             )
                             @int
                             @nm
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%% Add Global variables %%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Introduce global variables: each binding without arguments must have a
corresponding global variable. (CAF's)
Filter out the constructor functions.

Note: EHC does not generate these yet



%%[8.caf import({GrinCode/CAFNames})
SEM GrModule
  | Mod  loc  .  newGlobals  =  let arity             =  if grinStoreArity
                                                          then [GrVal_LitInt 0]
                                                          else []
                                    buildGlobalVar n  =  GrGlobal_Global n (GrVal_Node (tag n) arity)
                                    tag n             =  let  ts = filter (\x -> n==ctagNm x) @allCTags
                                                         in   if null ts
                                                              then GrTag_Lit GrTagFun 0 n
                                                              else GrTag_Lit GrTagCon (ctagTag (head ts)) n
                                    globalL           =  map buildGlobalVar
                                                             @cafNames
                                in (if null @globalL.grTrf then globalL else @globalL.grTrf)
              .   allCTags    =   [ ct | (_,xs) <- @ctagsMp, (_,ct) <- xs ]

%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%% Fix Primitives to Exception statements %%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8.hackPrimToExceptionStatments

-- we need an node which eval interprets as 'throw exception'
SEM GrModule
  | Mod  loc  .  newEvalTagMp  =  ((throwTag,1), EvApTagThrow) : @evalTagMp

SEM GrBind
  | Bind  lhs  .  grTrf    =  GrBind_Bind @nm @argNmL @newExpr
          loc  .  newExpr  =  if @nm == HNm "_catch" then buildCatchExpr @argNmL
                              else if @nm == HNm "_throw" then buildThrowExpr @argNmL
                              else @expr.grTrf
%%]

%%[8.hackPrimToExceptionStatments hs
buildThrowExpr [exceptNm] = GrExpr_Throw exceptNm

buildCatchExpr [tryNm, handlerNm] = let  exceptNm = hsnPrefix "except_ptr@" handlerNm
                                         evalNm   = hsnPrefix "except_node@" handlerNm
                                    in GrExpr_Catch (GrExpr_Eval tryNm)
                                                    exceptNm
                                                    (GrExpr_Seq (GrExpr_Eval handlerNm)
                                                                (GrPat_Var evalNm)
                                                                (GrExpr_App evalNm [GrVal_Var exceptNm])
                                                    )
%%]
