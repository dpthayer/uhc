%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[8 import({GrinCode/AbsSyn})
%%]

%%[8.wrapper
WRAPPER GrAGItf
%%]

Should be checked later:

%%[8
PRAGMA nocycle
%%]

%%[8 hs module {%{GRIN}GrinCode.Trf.LowerGrin} import({%{EH}Base.Common}, {%{GRIN}GRINCCommon}, qualified Data.Set as Set, qualified Data.Map as Map, Data.List, Data.Monoid, Data.Maybe, {%{EH}GrinCode}) export(lowerGrin)

lowerGrin :: (GrModule,Int,HptMap) -> (GrModule,Int,HptMap)
lowerGrin (input,unique,hptMap)
  = let inh = Inh_GrAGItf {hptMap_Inh_GrAGItf=hptMap, uniq_Inh_GrAGItf=unique}
        syn = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf input)) inh
    in  (grTrf_Syn_GrAGItf syn, uniq_Syn_GrAGItf syn, hptMap_Syn_GrAGItf syn)


addHptInfo hptMap (orig, newNames) = let (tags,fields) = unzip . getNodes $ getEnvVar hptMap orig
                                         padding = AbsBottom
                                         av_vars = map mconcat (transpose $ map (++ repeat padding) fields)
                                         avs     = AbsTags (Set.fromAscList tags) : av_vars
                                     in addEnvVars hptMap (zip newNames avs)
%%]

%%[8
ATTR GrAGItf [ | | grTrf: GrModule  hptMap: HptMap ]
ATTR AllNT [ | nameMapping: RenameMap | grTrf: SELF ]
ATTR GrAGItf AllNT [ hptMap: HptMap | uniq: Int  | ]

SEM GrAGItf
  | AGItf module . nameMapping = []
          lhs    . hptMap      = foldl addHptInfo @lhs.hptMap @module.nameMapping

%%]

%%%%%%%%%%%%%%%%%%%
%% Vectorisation %%
%%%%%%%%%%%%%%%%%%%

%%[8 hs
type IdentOneToMany = (Int,  [Int])
type RenameMap      = [(Int,  [Int])]

newNames :: HptMap -> Int -> HsName -> (Int, [HsName], IdentOneToMany)
newNames hptMap uniq (HNmNr v _) = if v==0
                                   then (uniq, [], (v,[]))
                                   else case getEnvVar hptMap v of
                                          AbsLocs _ _ -> (uniq, repeat $ error "no new names for locations", error "no new mapping for locations")
                                          AbsNodes nl -> let count    = maxNodeSize nl
                                                             newVars  = [uniq .. uniq + count - 1]
                                                         in (uniq + count, map (\n->HNmNr n OrigNone) newVars, (v, newVars))
                                          AbsBottom   -> (uniq+1, [HNmNr uniq OrigNone], (v,[uniq])) -- infinite leftrecursion is the user program can lead to this situation. We don't want to be this analysis to be the show-stopper then.
                                          av          -> error ("LowerGrin: Newnames: abstract value " ++ show av ++ " for " ++ show v ++ " is not locations or nodes but " ++ show av)

-- TODO: use arity information in the ctags map!
maxNodeSize nl = 1 + Map.fold (\args maxSize -> max (length args) maxSize) 0 nl


isWildcard :: HsName -> Bool
isWildcard (HNmNr nr _) = nr==0

isSingleVar :: HptMap -> HsName -> Bool
isSingleVar hptMap (HNmNr nr _) = case getEnvVar hptMap nr of
                                   AbsLocs _ _ -> True
                                   AbsNodes  _ -> False
                                   a           -> if nr==0
                                                  then True
                                                  else False -- error $ "LowerGrin: variable " ++ show nr ++ " is " ++ show a
%%]


%%[8
ATTR AllNT     [ subst : {Map.Map HsName GrVal} | |  ]
ATTR GrPatLam  [ | | subst : {Map.Map HsName GrVal}  ]


SEM GrAGItf
  | AGItf    module . subst    = Map.empty


-- In a lambda pattern  \n  , if HPT says that n refers to a node, replace it by  (\t x y) 
-- and add   n -> (\t x y)  to subst
SEM GrPatLam
  | Var       lhs . (uniq, nameMapping, grTrf, subst) = if isSingleVar @lhs.hptMap @nm
                                                        then ( @lhs.uniq
                                                             , @lhs.nameMapping
                                                             , @loc.grTrf
                                                             , @lhs.subst 
                                                             )
                                                        else let  (uniq2, names, newMap) = newNames @lhs.hptMap @lhs.uniq @nm
                                                                  newPat  =  GrPatLam_VarNode (map GrVar_Var names)
                                                                  newNode =  GrVal_VarNode    (map GrVal_Var names)
                                                             in ( uniq2
                                                                , newMap : @lhs.nameMapping
                                                                , newPat
                                                                , Map.insert @nm newNode @lhs.subst
                                                                )


-- At a case with scrutinee n
-- if n is a simple variable and  n -> (\t x y)  occurs in subst, then replace  n  by  t
--                                                                let scrutSubst = Just (n [x,y])
--                           if   n     does not occur in subst,  let scrutSubst = Just (n,[])
-- if n is compound,                                              let scrutSubst = Nothing

SEM GrExpr
  | Case     loc . (scrutRepl, scrutSubst) = case @val.scrutName of
                                               Nothing -> ( @val.grTrf, Nothing )
                                               Just nm -> case Map.lookup nm @lhs.subst of
                                                            Nothing                     -> ( @val.grTrf  , Just (nm,[]) )
                                                            Just (GrVal_VarNode (t:xs)) -> ( t           , Just (nm,xs) )
             lhs . grTrf      = GrExpr_Case @loc.scrutRepl @altL.grTrf
  
ATTR AllAlt [ scrutSubst: {Maybe (HsName,[GrVal])} | | ]
ATTR GrVal  [ | | scrutName: {Maybe HsName} ]

SEM GrVal
  | Var      lhs . scrutName = Just @nm
  | * - Var  lhs . scrutName = Nothing


-- in each alternative C p q
-- add the following subsitutions:  p->x, q->y, n->(C x y)
-- and change the pattern from (C p q) to C
SEM GrAlt
  | Alt        expr . subst  =  case @lhs.scrutSubst of
                                     Nothing      ->  @lhs.subst
                                     Just (nm,xs) ->  let mappings = zip @pat.patFieldL xs
                                                          newNode  = GrVal_Node @pat.patTag (map snd mappings)
                                                      in  Map.fromList ((nm,newNode) : mappings)  `Map.union`  @lhs.subst
                                                 
               lhs . grTrf  =  GrAlt_Alt @ann (GrPatAlt_Tag @pat.patTag) @expr.grTrf


-- Perform the variable substitution

SEM GrVal
  | Var        lhs . grTrf       = Map.findWithDefault (GrVal_Var @nm) @nm @lhs.subst


SEM GrExpr
  | FetchNode 
    FetchField 
    UpdateUnit
    Eval 
    Throw      loc  . newName   = maybe @nm 
                                        -- (\(GrVal_Var nm) -> nm) 
                                        (\v -> case v of (GrVal_Var nm) -> nm
                                                         _ -> error $ "LowerGrin: not a GrVal_Var: " ++ show v ++ " as replacement of " ++ show @nm
                                        )
                                        (Map.lookup @nm @lhs.subst)
  | FetchNode  lhs  . grTrf     = GrExpr_FetchNode  @newName
  | FetchField lhs  . grTrf     = GrExpr_FetchField @newName @offset @mbTag
  | UpdateUnit lhs  . grTrf     = GrExpr_UpdateUnit @newName @val.grTrf
  | Eval       lhs  . grTrf     = GrExpr_Eval  @newName
  | Throw      lhs  . grTrf     = GrExpr_Throw @newName
%%]



%%[8
-- return the fields of pattern and value to the Alternative node
ATTR GrPatAlt [ | | patFieldL: {[HsName]} patTag: GrTag ]

SEM GrPatAlt
  | Node          lhs  . patFieldL   = @fldL
                  lhs  . patTag      = @tag.grTrf
  | Tag           lhs  . patFieldL   = []
                  lhs  . patTag      = @tag.grTrf
  | * - Node Tag  lhs  . patFieldL   = error "Only Node or Tag values expected in a case"
                  lhs  . patTag      = error "Only Node or Tag values expected in a case"

%%]
