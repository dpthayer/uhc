%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[8 import({GrinCode/AbsSyn})
%%]

%%[8.wrapper
WRAPPER GrAGItf
%%]


%%[8 hs module {%{GRIN}GrinCode.Trf.LowerGrin} import({%{EH}Base.Common}, {%{GRIN}GRINCCommon}, qualified Data.Set as Set, qualified Data.Map as Map, Data.List, Data.Monoid, Data.Maybe, {%{EH}GrinCode}) export(lowerGrin)

lowerGrin :: (GrModule,HptMap) -> (GrModule,HptMap)
lowerGrin (input,hptMap)
  = let inh = Inh_GrAGItf {hptMap_Inh_GrAGItf=hptMap}
        syn = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf input)) inh
    in  (grTrf_Syn_GrAGItf syn, hptMap_Syn_GrAGItf syn)

%%]

%%[8

ATTR AllNT     [ | | grTrf: SELF     ]
ATTR GrAGItf   [ | | grTrf: GrModule ]

ATTR GrPatLam 
     AllGrExpr
     AllBind
     GrModule  [ | | newItems USE {++} {[]} : HptItems ]
ATTR GrAGItf   [ | | hptMap: HptMap ]

ATTR GrAGItf 
     GrModule
     AllBind
     AllGrExpr
     GrPatLam  [ hptMap: HptMap | | ]

ATTR GrModule
     AllBind
     AllGrExpr
     GrPatLam  [ | uniq : Int | ]

SEM GrAGItf
  | AGItf     module . uniq    =  getEnvSize @lhs.hptMap
              lhs    . hptMap  =  addEnvElems @lhs.hptMap (map snd (sort @module.newItems))

%%]

%%%%%%%%%%%%%%%%%%%
%% Vectorisation %%
%%%%%%%%%%%%%%%%%%%

%%[8 hs
type HptItems       = [ (Int,AbstractValue) ]

maximum0 [] = 0
maximum0 xs = maximum xs

newNames :: HptMap -> Int -> HsName -> (Int, [HsName], HptItems)
newNames hptMap uniq (HNmNr v _) 
  = if v==0
    then (uniq, [], [])
    else let (tags,fields) = unzip . getNodes $ getEnvVar hptMap v
             avArgs  = map mconcat (transpose $ map (++ repeat AbsBottom) fields)
             avTag   = AbsTags (Set.fromAscList tags)
             avs     = avTag : takeWhile (/=AbsBottom) avArgs
             count   = length avs   -- 1 + maximum0 (map length fields) -- TODO: use arity information in the ctags map!
             uniq2   = uniq+count
             newNrs = [uniq .. uniq2-1]                                     
         in  (uniq2, map (\n->HNmNr n OrigNone) newNrs, zip newNrs avs)    
    

isSingleVar :: HptMap -> HsName -> Bool
isSingleVar hptMap (HNmNr nr _) 
  = case getEnvVar hptMap nr of
      AbsLocs _ _ -> True
      AbsNodes  _ -> False
      a           -> if nr==0
                     then True
                     else False -- error $ "LowerGrin: variable " ++ show nr ++ " is " ++ show a
%%]


%%[8
ATTR AllNT     [ subst : {Map.Map HsName GrVal} | |  ]
ATTR GrPatLam  [ | | subst : {Map.Map HsName GrVal}  ]


SEM GrAGItf
  | AGItf    module . subst    = Map.empty


-- In a lambda pattern  \n  , if HPT says that n refers to a node, replace it by  (\t x y) 
-- and add   n -> (\t x y)  to subst
SEM GrPatLam
  | Var       lhs . (uniq, newItems, grTrf, subst)    = if isSingleVar @lhs.hptMap @nm
                                                        then ( @lhs.uniq
                                                             , []
                                                             , @loc.grTrf
                                                             , @lhs.subst 
                                                             )
                                                        else let  (uniq2, names, newItems) = newNames @lhs.hptMap @lhs.uniq @nm
                                                                  newPat  =  GrPatLam_VarNode (map GrVar_Var names)
                                                                  newNode =  GrVal_VarNode    (map GrVal_Var names)
                                                             in ( uniq2
                                                                , newItems
                                                                , newPat
                                                                , Map.insert @nm newNode @lhs.subst
                                                                )


-- At a case with scrutinee n
-- if n is a simple variable and  n -> (\t x y)  occurs in subst, then replace  n  by  t
--                                                                let scrutSubst = Just (n [x,y])
--                           if   n     does not occur in subst,  let scrutSubst = Just (n,[])
-- if n is compound,                                              let scrutSubst = Nothing

SEM GrExpr
  | Case     loc . (scrutRepl, scrutSubst) = case @val.scrutName of
                                               Nothing -> ( @val.grTrf, Nothing )
                                               Just nm -> case Map.lookup nm @lhs.subst of
                                                            Nothing                     -> ( @val.grTrf  , Just (nm,[]) )
                                                            Just (GrVal_VarNode (t:xs)) -> ( t           , Just (nm,xs) )
             lhs . grTrf      = GrExpr_Case @loc.scrutRepl @altL.grTrf
  
ATTR AllAlt [ scrutSubst: {Maybe (HsName,[GrVal])} | | ]
ATTR GrVal  [ | | scrutName: {Maybe HsName} ]

SEM GrVal
  | Var      lhs . scrutName = Just @nm
  | * - Var  lhs . scrutName = Nothing


-- in each alternative C p q
-- add the following subsitutions:  p->x, q->y, n->(C x y)
-- and change the pattern from (C p q) to C
SEM GrAlt
  | Alt        expr . subst  =  case @lhs.scrutSubst of
                                     Nothing      ->  @lhs.subst
                                     Just (nm,xs) ->  let mappings = zip @pat.patFieldL xs
                                                          newNode  = GrVal_Node @pat.patTag (map snd mappings)
                                                      in  Map.fromList ((nm,newNode) : mappings)  `Map.union`  @lhs.subst
                                                 
               lhs . grTrf  =  GrAlt_Alt (substann @lhs.subst @ann) (GrPatAlt_Tag @pat.patTag) @expr.grTrf
               
{
substann subst (GrAltAnnCalling a name) = GrAltAnnCalling a (maybe name (\(GrVal_Var nm) -> nm) (Map.lookup name subst))
substann _ ann = ann
}

-- Perform the variable substitution

SEM GrVal
  | Var        lhs . grTrf       = Map.findWithDefault (GrVal_Var @nm) @nm @lhs.subst


SEM GrExpr
  | FetchNode 
    FetchField 
    UpdateUnit
    Eval 
    Throw      loc  . newName   = maybe @nm 
                                        -- (\(GrVal_Var nm) -> nm) 
                                        (\v -> case v of (GrVal_Var nm) -> nm
                                                         _ -> error $ "LowerGrin: not a GrVal_Var: " ++ show v ++ " as replacement of " ++ show @nm
                                        )
                                        (Map.lookup @nm @lhs.subst)
  | FetchNode  lhs  . grTrf     = GrExpr_FetchNode  @newName
  | FetchField lhs  . grTrf     = GrExpr_FetchField @newName @offset @mbTag
  | UpdateUnit lhs  . grTrf     = GrExpr_UpdateUnit @newName @val.grTrf
  | Eval       lhs  . grTrf     = GrExpr_Eval  @newName
  | Throw      lhs  . grTrf     = GrExpr_Throw @newName
%%]



%%[8
-- return the fields of pattern and value to the Alternative node
ATTR GrPatAlt [ | | patFieldL: {[HsName]} patTag: GrTag ]

SEM GrPatAlt
  | Node          lhs  . patFieldL   = @fldL
                  lhs  . patTag      = @tag.grTrf
  | Tag           lhs  . patFieldL   = []
                  lhs  . patTag      = @tag.grTrf
  | * - Node Tag  lhs  . patFieldL   = error "Only Node or Tag values expected in a case"
                  lhs  . patTag      = error "Only Node or Tag values expected in a case"

%%]
