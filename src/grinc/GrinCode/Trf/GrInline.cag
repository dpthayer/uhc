Eliminate Grin "Apply" and "Eval" expressions by inlining equivalent code, based on full-program HPT analysis

%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[8 import({GrinCode/AbsSyn})
%%]
%%[8 import({GrinCode/Trf/CommonArity})
%%]

%%[8.wrapper
WRAPPER GrAGItf
%%]

%%[8 hs module {%{GRIN}GrinCode.Trf.GrInline} export(inlineEA)
%%]
%%[8 hs import(Data.List, Data.Maybe, Data.Monoid(mconcat), qualified Data.Set as Set, qualified Data.Map as Map )
%%]
%%[8 hs import({%{EH}Base.Common}, {%{EH}GrinCode})
%%]
%%[8 hs import({%{GRIN}GRINCCommon(HptMap, getNr, absFetch, getEnvVar, getNodes, addEnvVar, addEnvVars, throwTag, AbstractValue(..))})
%%]
%%[8 hs import(Debug.Trace)
%%]

%%[8 hs
inlineEA :: (GrModule,Int,HptMap) -> (GrModule,Int,HptMap)
inlineEA (code,unique,hptMap)
  = let inh = Inh_GrAGItf {hptMap_Inh_GrAGItf=hptMap, unique_Inh_GrAGItf=unique}
        syn = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf code)) inh
    in  (grTrf_Syn_GrAGItf syn, unique_Syn_GrAGItf syn, hptMap_Syn_GrAGItf syn)

%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Eval code generation %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8.evalCode hs


buildAlternative
 :: GrTag                                                                ->      -- tag
    [AbstractValue]                                                      ->      -- avs
    Int                                                                  ->      -- arity
    EvApTagElt                                                           ->      -- rhsElem
    Int                                                                  ->      -- unique
    (Int -> [HsName]           -> (Int, [(Int,AbstractValue)], [AbstractValue], GrExpr))  ->      -- uf
    (Int -> [HsName] -> HsName -> (Int, [(Int,AbstractValue)], [AbstractValue], GrExpr))  ->      -- vf
    (Int -> [HsName] -> GrTag  -> (Int, [(Int,AbstractValue)], [AbstractValue], GrExpr))  ->      -- tf
    ( Int                                -- new unique number
    , [(Int, AbstractValue)]             -- entries for HPT
    , [AbstractValue]
    , GrAlt                              -- code
    )

buildAlternative tag args arity rhsElem unique uf vf tf =
    let patNames        = map (\e -> HNmNr (fst e) Nothing) entrHead

        uniqHead        = unique + arity
        entrHead        = zip [unique..] args
        codeHead        = GrAlt_Alt (GrPatAlt_Node tag patNames)
        
        (uniqBody,
         entrBody,
         avBody,
         codeBody )     = case rhsElem of
                              EvApTagThrow -> (uniqHead, [], [], GrExpr_Throw (head patNames))
                              EvApTagUnit  -> uf uniqHead patNames
                              EvApTagVar f -> vf uniqHead patNames f
                              EvApTagTag t -> tf uniqHead patNames t

    in (uniqBody, entrHead++entrBody, avBody, codeHead codeBody)



buildEvalAlt
 :: HsName                       ->      -- locatVar
    HsName                       ->      -- fetchVar
    GrTag                        ->      -- tag
    [AbstractValue]              ->      -- av
    Map.Map Int Int              ->      -- arityMap
    HptMap                       ->      -- hptMap
    Int                          ->      -- u
    ( Int                     -- newU
    , [(Int, AbstractValue)]  -- maps
    , [AbstractValue]
    , GrAlt                   -- code
    )

tagEvalRhs t@(GrTag_Fun nm) = if   t == throwTag   -- TODO: test for *numbered* version of throwTag, or even better: make it a real tag instead of abusing #F
                              then EvApTagThrow
                              else EvApTagVar nm
tagEvalRhs (GrTag_App   nm) = EvApTagVar nm
tagEvalRhs _                = EvApTagUnit

buildEvalAlt locatVar fetchVar tag avs arityMap hptMap u
 = buildAlternative tag avs arity rhs u uf vf tf
    where
    arity = tagArity tag arityMap
    rhs   = tagEvalRhs tag
    tf u args t  = error "no tag at the right hand side of eval map expected"
    uf u args    = (u, [], [], GrExpr_Unit (GrVal_Var fetchVar))
    vf u args functVar  
                 = -- process a function call
                   let 
                       -- create new name from unique number
                       boundVar   = HNmNr u Nothing
                       -- wrap the newly created names for use in Grin-values and -patterns
                       boundVal   = GrVal_Var boundVar
                       boundPat   = GrPatLam_Var boundVar
                       emptyPat   = GrPatLam_Empty
                       -- get the abstract value for the function-result and exception-result of the called function
                       functAbsVal= getEnvVar hptMap (getNr functVar)
                       excepAbsVal= getEnvVar hptMap (getNr functVar + 1)
                       -- create an HPT entry for the new variable
                       boundEntry = (getNr boundVar, functAbsVal)
                       -- generate code for the call          
                       callExpr   = GrExpr_Seq (GrExpr_Call functVar $ map GrVal_Var args) boundPat  $
                                    GrExpr_UpdateUnit locatVar boundVal
                   in  if  not (isEmptyAbsVal excepAbsVal)
                       -- do we need to handle exceptions?  
                        then let
                                 -- create some more new names
                                 throwVar   = HNmNr (u+1) Nothing
                                 catchVar   = HNmNr (u+2) Nothing
                                 noVar      = HNmNr 0 Nothing
                                 noPat      = GrPatLam_Var noVar
                                 -- and wrap them for use in Grin
                                 throwVal   = GrVal_Var throwVar
                                 catchVal   = GrVal_Var catchVar
                                 catchPat   = GrPatLam_Var catchVar
                                 -- create HPT entries for the new variables
                                 throwEntry = (getNr throwVar, excepAbsVal)
                                 catchEntry = (getNr catchVar, functAbsVal)
                                 -- create a node for the exception
                                 eNode      = GrVal_Node throwTag [throwVal]
                                 -- generate code for handling the exception
                                 eCode      = GrExpr_Catch callExpr throwVar                        $
                                              GrExpr_Seq (GrExpr_UpdateUnit locatVar eNode) noPat  $
                                              GrExpr_Throw throwVar
                                 handleExpr = GrExpr_Seq eCode catchPat $
                                              GrExpr_Unit catchVal
                             in  (u+3, [ boundEntry, throwEntry, catchEntry ], [], handleExpr )
                        else     (u+1, [ boundEntry ]                        , [], callExpr   )



isEmptyAbsVal AbsBottom      = True
isEmptyAbsVal (AbsLocs xs m) = Set.null xs
isEmptyAbsVal v              = error $ "wrong content of exception variable of binding " ++ show v



evalCode
 :: Int                          ->      -- unique
    Map.Map Int Int              ->      -- arityMap
    HptMap                       ->      -- hptMap
    HsName                       ->      -- locat
    ( Int                                -- uniqueFinal
    , HptMap                             -- updated hptMap
    , GrExpr                             -- generated code
    )

evalCode unique arityMap hptMap locatVar
 = let -- create new name from unique number
       fetchVar      = HNmNr unique Nothing
       -- wrap the newly created names for use in Grin-values and -patterns
       fetchVal      = GrVal_Var fetchVar
       fetchPat      = GrPatLam_Var fetchVar
       -- get the abstract value for the original location
       locatAbsVal   = absFetch hptMap locatVar
       -- create an HPT entry for the new variable
       fetchEntry    = (getNr fetchVar, locatAbsVal)
       -- we must generate code for all possible cases, as found in the abstract value
       cases         = getNodes locatAbsVal
       -- each case can update the unique, generate new HPT entries, and generate code for the alternatives
       -- we start with these:
       uniqStart = unique + 1
       entrStart = [fetchEntry]
       altsStart = []
       -- the results of all cases are accumulated:
       (uniqFinal, entrFinal, altsFinal)  = foldr makeAlt (uniqStart,entrStart,altsStart) cases
       -- where each case is processed by:
       makeAlt (tag, av) (uniqPrev, entrPrev, altsPrev) 
                   = let (uniqNext, entrNext, _, altNext) = buildEvalAlt locatVar fetchVar tag av arityMap hptMap uniqPrev
                     in  (uniqNext, entrNext++entrPrev, altNext:altsPrev)

       code        = GrExpr_Seq (GrExpr_FetchNode locatVar) fetchPat $
                     GrExpr_Case fetchVal altsFinal
   in ( uniqFinal
      , addEnvVars hptMap entrFinal
      , code
      )

%%]




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Apply code generation %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Each argument represent one pass in the applyMap.  When one of the possible
tags maps to an function build a case which calls this function and builds
P-nodes for the other elements. Strip of the number of used arguments and
restart. Otherwise continue until all arguments in an apply call are used and
create a case to build the resulting P-node.

The analysis result of P-nodes 'in between' is not available. We must generate
this from the available information. To that end we must create a new abstract
value which returns the union of the abstract value of each case alternative.

%%[8.applyCode hs

buildApplyAlt
 :: ( ( GrTag                            -- t
      , Int                              -- a
      , [AbstractValue]                  -- avL
      )
    , EvApTagElt                         -- rhs
    )                            ->
    [GrVal]                      ->      -- appArgs
    HptMap                       ->      -- hptMap
    Int                          ->      -- u
    ( Int                                -- newU
    , [(Int, AbstractValue)]             -- newHPT
    , [AbstractValue]
    , GrAlt                              -- alt
    )

buildApplyAlt ((t, a, avL), rhs) appArgs hptMap u
 = buildAlternative t avL a rhs u uf vf tf
    where
    uf u args   = error "no unit at the right hand side of apply map expected"
    vf u args v = let absVal = getEnvVar hptMap (getNr v)
                  in  ( u
                      , []
                      , [absVal]
                      , GrExpr_Call v (map GrVal_Var args ++ appArgs)
                      )
    tf u args t = let val2av v = case v of
                                     GrVal_Var v -> getEnvVar hptMap (getNr v)
                                     otherwise   -> AbsBasic
                      absVal = AbsNodes (Map.singleton t (avL ++ map val2av appArgs))
                  in ( u
                     , []
                     , [absVal]
                     , GrExpr_Unit (GrVal_Node t (map GrVal_Var args ++ appArgs))
                     )



buildApplyCase
 :: Int                          ->      -- unique
    HptMap                       ->      -- hptMap
    HsName                       ->      -- funVar
    [GrVal]                      ->      -- appArgs
    [ ( ( GrTag
        , Int
        , [AbstractValue]
        )
      , EvApTagElt
      )
    ]                            ->      -- nodeList
    ( Int                                -- unique2
    , [(Int, AbstractValue)]             -- hptDelta
    , GrExpr
    , AbstractValue                      -- unionAV
    )

buildApplyCase unique hptMap funVar appArgs nodeList
 =  let makeAlt elem (u, h, e, l)= let (u2, h2, e2, alt) = buildApplyAlt elem appArgs hptMap u
                                   in (u2, h2 ++ h, e2++e, alt:l)
        (unique2, hptDelta, altAvs, alts) = foldr makeAlt (unique, [], [], []) nodeList
    in ( unique2
       , hptDelta
       , GrExpr_Case (GrVal_Var funVar) alts
       , mconcat altAvs
       )

applyCodePart
 :: Int                          ->      -- unique
    Map.Map Int Int              ->      -- arityMap
    HptMap                       ->      -- hptMap
    [(GrTag,[AbstractValue])]    ->      -- nodes
    HsName                       ->      -- appVar
    [GrVal]                      ->      -- appArgs
    ( Int                                -- unique3
    , HptMap                             -- ...
    , GrExpr                             -- ...
    )

applyCodePart unique arityMap hptMap nodes appVar appArgs
  = let

        getNewTag
          :: GrTag -> (Maybe GrTag, Int, EvApTagElt)
        getNewTag t@(GrTag_PApp needs nm)
          = let  arity = tagArity t arityMap
            in   if needs==1
                 then (Nothing, arity,     EvApTagVar nm)
                 else let t2 = GrTag_PApp (needs-1) nm
                      in  (Just t2, arity, EvApTagTag t2)

        getElements
          :: [GrTag]              ->                        -- tags
             [GrVal]              ->                        -- args
             ([GrVal] -> [GrVal]) ->                        -- usedArgsF
             ( [((GrTag,Int,[AbstractValue]), EvApTagElt)]  -- elems
             , [GrVal]                                      -- usedArgs
             , [GrVal]                                      -- restArgs
             )

        getElements tags []              usedArgsF
          = (zip fromInfo $ map EvApTagTag tags, usedArgsF [], [])
        getElements tags (arg:availArgs) usedArgsF
          = let (mbTags, _, elems)  = unzip3 $ map getNewTag tags
                needCode            = any isNothing mbTags
                usedArgsF2          = usedArgsF . (arg:)
             in if needCode
                 then (zip fromInfo elems, usedArgsF2 [], availArgs)
                 else getElements (map (fromJust' "no tag?") mbTags) availArgs usedArgsF2

        (origTags, avs)                      = unzip nodes
        arities                              = map ((\(x,y,z) -> y) . getNewTag . fst) nodes
        fromInfo                             = zip3 origTags arities avs
        (elems, usedArgs, restArgs)          = getElements origTags appArgs id
        (unique2, hptDelta, code, resultAV)  = buildApplyCase unique hptMap appVar usedArgs elems
        hptMap2                              = addEnvVars hptMap hptDelta
        newVar                               = HNmNr unique2 Nothing

    in  if null restArgs
         then (unique2, hptMap2, code)
         else let (unique3, hptMap3, code2)  = applyCodePart (unique2 + 1)
                                                             arityMap
                                                             (addEnvVar hptMap2 unique2 resultAV)
                                                             (filter isPartialApplication $ getNodes resultAV)
                                                             newVar
                                                             restArgs
              in (unique3, hptMap3, GrExpr_Seq code (GrPatLam_Var newVar) code2)



applyCode
 :: Int                          ->      -- unique
    Map.Map Int Int              ->      -- arityMap
    HptMap                       ->      -- hptMap
    HsName                       ->      -- funVar
    [GrVal]                      ->      -- appArgs
    ( Int                                -- unique3
    , HptMap                             -- ...
    , GrExpr                             -- ...
    )

applyCode unique arityMap hptMap funVar appArgs
 =  let nodes = filter isPartialApplication (getNodes (getEnvVar hptMap (getNr funVar)))
    in applyCodePart unique arityMap hptMap nodes funVar appArgs


%%]

%%[8 hs
isPartialApplication ((GrTag_PApp _ _), _) = True
isPartialApplication _ = False

fromJust' s Nothing  = error $ "fromJust: " ++ s
fromJust' _ (Just e) = e
%%]

%%[8
ATTR GrAGItf
     GrModule
     AllBind
     AllGrExpr     [ | unique: Int  hptMap: HptMap | ]
ATTR GrAGItf       [ | | grTrf: GrModule ]
ATTR AllNT         [ | | grTrf: SELF ]

SEM GrExpr
  | Eval  loc  .  (unique, hptMap, grTrf)  = evalCode   @lhs.unique @lhs.arityMap @lhs.hptMap @nm
  | App   loc  .  (unique, hptMap, grTrf)  = applyCode  @lhs.unique @lhs.arityMap @lhs.hptMap @nm @argL.grTrf

%%]
