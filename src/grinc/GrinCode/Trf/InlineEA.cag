InlineEA
Eliminate Grin "App" and "Eval" expressions by inlining equivalent code, based on full-program HPT analysis

     EVAL locat
==>
     FETCHNODE locat ; \node ->
     CASE node OF
     { ident  (#C/c a b) -> UNIT node                     -- for every final tag in HptMap of locat
     ; normal (#F/f a b) -> CALL f a b ; \result  ->      -- for every F- and A-tag in HptMap of locat
                            UPDATEUNIT result locat       -- TODO: update can be omitted when result is unique
     }


     APP node p q
==>
     CASE node OF
     { normal (#P/n/f x y) -> UNIT (#P/m/f x y p q)       -- undersaturated:    n > |p q|  (function needs more arguments than given)
     ; normal (#P/n/f x y) -> CALL f x y p q              -- exactly saturated: n = |p q|
     ; normal (#P/n/f x y) -> CALL f x y p q ;\result ->  -- oversaturated      n < |p q|  (too many arguments given for needs)
                              CASE result OF ...          -- recurse
     }


%%[8 hs module {%{GRIN}GrinCode.Trf.InlineEA} export(inlineEA)
%%]

%%[8 import({GrinCode/AbsSyn})
%%]
%%[8.wrapper
WRAPPER GrAGItf
%%]
%%[8 hs import(Data.List, Data.Maybe, Data.Monoid(mconcat), qualified Data.Set as Set, qualified Data.Map as Map )
%%]
%%[8 hs import({%{EH}Base.Common}, {%{EH}GrinCode})
%%]
%%[8 hs import({%{GRIN}GRINCCommon(HptMap, getNr, absFetch, getEnvVar, getNodes, addEnvVar, addEnvVars, throwTag, AbstractValue(..))})
%%]
%%[8 hs import(Debug.Trace)
%%]

%%[8 hs
inlineEA :: (GrModule,Int,HptMap) -> (GrModule,Int,HptMap)
inlineEA (code,unique,hptMap)
  = let inh = Inh_GrAGItf {hptMap_Inh_GrAGItf=hptMap, unique_Inh_GrAGItf=unique}
        syn = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf code)) inh
    in  (grTrf_Syn_GrAGItf syn, unique_Syn_GrAGItf syn, hptMap_Syn_GrAGItf syn)

%%]


%%[8 hs
unevaluatedName :: GrTag -> Maybe HsName
unevaluatedName (GrTag_Fun nm) = Just nm
unevaluatedName (GrTag_App nm) = Just nm
unevaluatedName _              = Nothing

isPartialApplication ((GrTag_PApp _ _), _) = True
isPartialApplication _ = False

isEmptyAbsVal AbsBottom      = True
isEmptyAbsVal (AbsLocs xs m) = Set.null xs
isEmptyAbsVal v              = error $ "wrong content of exception variable of binding " ++ show v


makeCaseExpression
  :: ([GrAlt] -> GrExpr)                                                  ->   -- given a function to build an Expr from a [Alt]
     (Int -> HptMap ->  (GrTag,[AbstractValue])  -> (Int,HptMap, GrAlt )) ->   -- and   a function to build an Alt from a Node (updating the unique and HptMap)
      Int -> HptMap -> [(GrTag,[AbstractValue])] -> (Int,HptMap, GrExpr)       -- we can construct a function to build a (Case-)Expr from a [Node] (updating the unique and HptMap)

makeCaseExpression buildCase buildAlt unique hptMap nodes
  =  let makeAlt node (uniqPrev, hptPrev,         altsPrev) 
                = let (uniqNext, hptNext, altNext         ) = buildAlt uniqPrev hptPrev node
                  in  (uniqNext, hptNext, altNext:altsPrev)

         (unique2, hptMap2, alts) = foldr makeAlt (unique,hptMap,[]) nodes
     in  (unique2, hptMap2, buildCase alts)

%%]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Eval code generation %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs


buildEvalAlt
 :: 
    HsName                       ->      -- locatName
    HsName                       ->      -- nodeName
    Int                          ->      -- unique
    HptMap                       ->      -- hptMap
    ( GrTag                              -- tag
    , [AbstractValue]                    -- args
    )                            ->
    ( Int                                -- updated unique
    , HptMap                             -- updated hptMap
    , GrAlt                              -- generated code
    )

buildEvalAlt locatName nodeName unique hptMap (tag,args)
 =  let patNames   =  map (\e -> HNmNr (fst e) OrigNone) entrHead
        uniqHead   =  unique + length args
        entrHead   =  zip [unique..] args
        codeHead annot = GrAlt_Alt annot (GrPatAlt_Node tag patNames)
        hptMap2    =  addEnvVars hptMap entrHead
    in  case unevaluatedName tag of
          Nothing -> (uniqHead, hptMap2, codeHead GrAltAnnIdent (GrExpr_Unit (GrVal_Var nodeName)))
          Just f  ->
                   let unique2 = uniqHead
                       args = patNames
                       functName = f
                       -- create new name for the call result
                       resultNr   = unique2
                       resultName = HNmNr resultNr OrigNone
                       -- wrap the newly created names for use in Grin-values and -patterns
                       resultVal  = GrVal_Var resultName
                       resultPat  = GrPatLam_Var resultName
                       emptyPat   = GrPatLam_Empty
                       -- get the abstract value for the function-result and exception-result of the called function
                       resultAbsVal= getEnvVar hptMap (getNr functName)
                       exceptAbsVal= getEnvVar hptMap (getNr functName + 1)
                       -- create an HPT entry for the new variable
                       hptMap3 = addEnvVar hptMap2 resultNr resultAbsVal
                       -- generate code for the call          
                       callExpr   = GrExpr_Seq (GrExpr_Call functName $ map GrVal_Var args) resultPat  $
                                    GrExpr_UpdateUnit locatName resultVal
                   in  if  isEmptyAbsVal exceptAbsVal
                        then (unique2+1, hptMap3, codeHead GrAltAnnNormal callExpr )
                        else -- handling exceptions below (currently not used)
                              let
                                 -- create some more new names
                                 throwVar   = HNmNr (unique2+1) OrigNone
                                 catchVar   = HNmNr (unique2+2) OrigNone
                                 noVar      = HNmNr 0 OrigNone
                                 noPat      = GrPatLam_Var noVar
                                 -- and wrap them for use in Grin
                                 throwVal   = GrVal_Var throwVar
                                 catchVal   = GrVal_Var catchVar
                                 catchPat   = GrPatLam_Var catchVar
                                 -- create HPT entries for the new variables
                                 hptMap4 = addEnvVar hptMap3 (getNr throwVar) exceptAbsVal
                                 hptMap5 = addEnvVar hptMap4 (getNr catchVar) resultAbsVal
                                 -- create a node for the exception
                                 eNode      = GrVal_Node throwTag [throwVal]
                                 -- generate code for handling the exception
                                 eCode      = GrExpr_Catch callExpr throwVar                        $
                                              GrExpr_Seq (GrExpr_UpdateUnit locatName eNode) noPat  $
                                              GrExpr_Throw throwVar
                                 handleExpr = GrExpr_Seq eCode catchPat $
                                              GrExpr_Unit catchVal
                             in  (unique2+3, hptMap5, codeHead GrAltAnnNormal handleExpr )


evalCode
 :: Int                          ->      -- unique
    HptMap                       ->      -- hptMap
    HsName                       ->      -- locatName
    ( Int                                -- updated unique
    , HptMap                             -- updated hptMap
    , GrExpr                             -- generated code
    )

evalCode unique hptMap locatName
 = let -- create new name for the fetched node
       nodeNr        = unique
       nodeName      = HNmNr nodeNr OrigNone
       -- wrap the newly created name for use in Grin-patterns and -values
       nodePat       = GrPatLam_Var nodeName
       nodeVal       = GrVal_Var    nodeName
       -- get the abstract value for the original location
       nodeAbsVal    = absFetch hptMap locatName
       -- we must generate code for all possible nodes, as found in the abstract value
       nodes         = getNodes nodeAbsVal
       codeHead      = GrExpr_Seq (GrExpr_FetchNode locatName) nodePat . GrExpr_Case nodeVal
       
   in  makeCaseExpression codeHead (buildEvalAlt locatName nodeName) (unique+1) (addEnvVar hptMap nodeNr nodeAbsVal) nodes

%%]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Apply code generation %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs

buildApplyAlt
 :: 
    [GrVal]                      ->      -- appArgs
    Int                          ->      -- unique
    HptMap                       ->      -- hptMap
    ( GrTag                              -- tag
    , [AbstractValue]                    -- args
    )                            ->
    ( Int                                -- updated unique
    , HptMap                             -- updated hptMap
    , GrAlt                              -- generated code
    )

buildApplyAlt appArgs unique hptMap (tag@(GrTag_PApp needsParams functName), args)
 = 
    let hasParams       = length args
        getsParams      = length appArgs

        hptDelta        = zip [unique..] args
        patNames        = map (\e -> HNmNr (fst e) OrigNone) hptDelta
        patVars         = map GrVal_Var patNames
    
        unique2         = unique + hasParams
        
        codeHead        = GrAlt_Alt GrAltAnnNormal (GrPatAlt_Node tag patNames)
        hptMap2         = addEnvVars hptMap hptDelta
    in  case compare getsParams needsParams of
          LT -> -- undersaturated
                let newtag = GrTag_PApp (needsParams-getsParams) functName 
                in  (unique2, hptMap2, codeHead $ GrExpr_Unit (GrVal_Node newtag (patVars ++ appArgs)))
          EQ -> -- exactly saturated
                (unique2, hptMap2, codeHead $ GrExpr_Call functName (patVars ++ appArgs))
          GT -> -- oversaturated
                let -- create a new variable to accept the result of the function call
                    resultNr = unique2
                    resultName = HNmNr resultNr OrigNone
                    resultPat  = GrPatLam_Var resultName
                    -- get the abstract value for the function-result of the called function
                    resultAbsVal= getEnvVar hptMap (getNr functName)
                    -- generate code for the function call
                    code1 = GrExpr_Call functName (patVars ++ take needsParams appArgs)
                    (unique3, hptMap3, code2)  = applyCode (unique2 + 1)
                                                           (addEnvVar hptMap2 resultNr resultAbsVal)
                                                           resultName
                                                           (drop needsParams appArgs)
                in  (unique3, hptMap3, codeHead $ GrExpr_Seq code1 resultPat code2 )



applyCode
 :: Int                          ->      -- unique
    HptMap                       ->      -- hptMap
    HsName                       ->      -- nodeName
    [GrVal]                      ->      -- appArgs
    ( Int                                -- updated unique
    , HptMap                             -- updated hptMap
    , GrExpr                             -- generated code
    )

applyCode unique hptMap nodeName appArgs
 = let -- get the abstract value for the original location
       nodeAbsVal = getEnvVar hptMap (getNr nodeName)
       nodeVal    = GrVal_Var nodeName
       -- we must generate code for all possible nodes, as found in the abstract value
       nodes = filter isPartialApplication (getNodes nodeAbsVal)
   in  makeCaseExpression (GrExpr_Case nodeVal) (buildApplyAlt appArgs) unique hptMap nodes

%%]

%%[8
ATTR GrAGItf
     GrModule
     AllBind
     AllGrExpr     [ | unique: Int  hptMap: HptMap | ]
ATTR GrAGItf       [ | | grTrf: GrModule ]
ATTR AllNT         [ | | grTrf: SELF ]

SEM GrExpr
  | Eval  loc.(unique, hptMap, grTrf)  =  evalCode  @lhs.unique @lhs.hptMap @nm
  | App   loc.(unique, hptMap, grTrf)  =  applyCode @lhs.unique @lhs.hptMap @nm @argL.grTrf

%%]
