%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[8 hs module {%{GRIN}GrinCode.GenSilly} import({%{GRIN}Silly}) export(grin2silly)
%%]

%%[8 hs import(UU.Pretty, {%{GRIN}GRINCCommon} hiding (Variable(..)), Data.List(nub), Data.Maybe, {%{EH}GrinCode}, {%{GRIN}Config})
%%]
%%[8 hs import({%{GRIN}Silly})
%%]
%%[8 hs import(EH.Util.Utils,{%{EH}Base.Common} hiding "((<+>))")
%%]
%%[8 hs import(qualified Data.Map as Map, Data.Bits)
%%]

%%[8 import({GrinCode/AbsSyn})
%%]
%%[8 import({GrinCode/LastExpr})
%%]
%%[8 hs import(Debug.Trace)
%%]

%%[8
WRAPPER GrAGItf
%%]

%%[8 hs
grin2silly :: HptMap -> GrModule -> Bool -> Bool -> Bool -> SilModule
grin2silly hptmap gr optJump optPar optLoc
 = let t = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf gr))
                        (Inh_GrAGItf { optJumpTailCalls_Inh_GrAGItf = optJump
                                     , optOwnParameters_Inh_GrAGItf = optPar
                                     , optOwnLocals_Inh_GrAGItf = optLoc
                                     , hptMap_Inh_GrAGItf = hptmap
                                     }
                        )
   in silModule_Syn_GrAGItf t 
%%]

%%[12 hs import({%{EH}Base.Builtin},{%{GRIN}Config})
-- primitive related names which should be globally available, in unqualified form

primGlobalNames :: Set.Set HsName
primGlobalNames
  = Set.fromList
  $ map (hsnPrefix rtsGlobalVarPrefix . hsnQualified)
  $ [ hsnTrue, hsnFalse
%%[[99
    , hsnDataOrderingAltEQ, hsnDataOrderingAltLT, hsnDataOrderingAltGT
%%]]
    ]

hsnToGlobal :: HsName -> HsName
hsnToGlobal n
  = if n2 `Set.member` primGlobalNames then n2 else n
  where n2 = hsnQualified n
%%]

%%[8 import({GrinCode/ToSilly})
%%]
