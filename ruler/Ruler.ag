imports
{
import System
import GetOpt
import Maybe
import Char
import IO
import List
import FiniteMap
import FPath
import Utils
import PPUtils
import UU.Pretty
import UU.Parsing
import UU.Scanner
import UU.Scanner.Position( initPos, Pos )
import qualified UU.DData.Set as Set
import qualified UU.DData.Seq as Seq
}

{
-------------------------------------------------------------------------
-- Main
-------------------------------------------------------------------------

main :: IO ()
main
  = do { args <- getArgs
       ; let oo@(o,n,errs)  = getOpt Permute cmdLineOpts args
             opts           = foldr ($) defaultOpts o
       ; if optHelp opts
         then putStrLn (usageInfo "Usage ruler [options] [file]\n\noptions:" cmdLineOpts)
         else if null errs
              then  doCompile (if null n then emptyFPath else mkFPath (head n)) opts
              else  putStr (head errs)
       }

doCompile :: FPath -> Opts -> IO ()
doCompile fp opts
  = do { (fn,fb,fh)
             <- if fpathIsEmpty fp
                then return ("<stdin>","<stdin>",stdin)
                else do { let fn = fpathToStr fp
                        ; h <- openFile fn ReadMode
                        ; return (fn,fpathToStr (fpathRemoveSuff fp),h)
                        }
       ; tokens <- scanHandle keywordsText keywordsOps specialChars opChars fn fh
       ; pres <- parseIO (pAGItf) tokens
       ; let res = wrap_AGItf pres
                     (Inh_AGItf
                        { opts_Inh_AGItf = opts
                        })
       ; putBld (optLaTeX opts) (ppLaTeX_Syn_AGItf res) 
       ; return ()
       }
  where putBld f b
          = if f
            then putStrLn (disp b 2000 "")
            else return ()

-------------------------------------------------------------------------
-- Options
-------------------------------------------------------------------------

data Opts 
  = Opts
      { optLaTeX        :: Bool
      , optHelp         :: Bool
      , optWrapLhs2tex  :: Bool
      }

defaultOpts
  = Opts
      { optLaTeX        =  False
      , optHelp         =  False
      , optWrapLhs2tex  =  True
      }

cmdLineOpts  
  =  [ Option "l"  ["latex"]     (NoArg oLaTeX)
          "generate code for latex, default=no"
     , Option ""   ["help"]      (NoArg oHelp)
          "output this help"
     , Option ""   ["lhs2tex"]   (OptArg oLhs2tex "yes|no")
          "wrap chunks in lhs2tex's code environment, default=yes (not implemented)"
     ]
  where  oLaTeX          o =  o {optLaTeX = True}
         oLhs2tex    ms  o =  yesno (\f o -> o {optWrapLhs2tex = f}) ms o
         oHelp           o =  o {optHelp = True}
         yesno updO  ms  o =  case ms of
                                Just "yes"  -> updO True o
                                Just "no"   -> updO False o
                                _           -> o


-------------------------------------------------------------------------
-- Scanning
-------------------------------------------------------------------------

specialChars  =  "().`"
opChars       =  "!#$%&*+/<=>?@\\^|-:;,[]{}~"

keywordsText  =  [ "judge", "rule", "rules", "cond", "preamble", "scheme", "view", "let", "in" ]
keywordsOps   =  [ "=", "-", "&", "\\\\" ]

scanHandle :: [String] -> [String] -> String -> String -> FilePath -> Handle -> IO [Token]
scanHandle keywordstxt keywordsops specchars opchars fn fh
  = do  {  txt <- hGetContents fh
        ;  return (scan keywordstxt keywordsops specchars opchars (initPos fn) txt) 
        }

-------------------------------------------------------------------------
-- Parser
-------------------------------------------------------------------------

type MkConAppAlg t = (String -> t,t -> t -> t,t -> t)

mkApp :: MkConAppAlg t -> [t] -> t
mkApp (_,app,top) ts
  = case ts of
      [t]  -> t
      _    -> top t
  where t = foldl1 app ts

pAGItf :: (IsParser p Token) => p T_AGItf
pAGItf
  = let alg                 =   (undefined,sem_JExpr_App,sem_JExpr_AppTop)
        pAGItf              =   sem_AGItf_AGItf <$ pKey "preamble" <*> pString <*> pDecls
        pDecls              =   pFoldr (sem_Decls_Cons,sem_Decls_Nil) pDecl
        pDecl               =   sem_Decl_Scheme <$  pKey "scheme" <*> pNm <* pKey "="
                                                <*> pJExpr <* pKey "="
                                                <*> pJExpr
                                                <*> pViews
                            <|> sem_Decl_Rules <$  pKey "rules" <*> pNm
                                               <*> (Just <$ pKey "." <*> pNm' <|> pSucceed Nothing)
                                               <*> pString <* pKey "=" <*> pRules
        pViews              =   pFoldr (sem_Views_Cons,sem_Views_Nil) pView
        pView               =   sem_View_View <$ pKey "view" <*> pNm' <* pKey "=" <*> pJExprLet
        pRules              =   pFoldr (sem_Rules_Cons,sem_Rules_Nil) pRule
        pRule               =   ((,) <$> (True <$ pKey "&" <|> pSucceed False) <*  pKey "rule" <*> pNm <* pKey "=")
                                <**> (   (\pre post (hor,nm) -> sem_Rule_Rule hor nm pre post) <$> pRExprs <* pKey "-" <*> pRExprs
                                     <|> (\alias (hor,nm) -> sem_Rule_RuleUse hor nm alias) <$ pKey "rule" <*> pList1Sep (pKey ".") pNm'
                                     )
        pNm                 =   pVarid <|> pConid
        pNm'                =   pNm <|> pInteger
        pSym                =   pVarsym <|> pConsym <|> (\q n -> q ++ n ++ q) <$> pKey "`" <*> pNm <* pKey "`"
        pRExprs             =   pFoldr (sem_RExprs_Cons,sem_RExprs_Nil) pRExpr
        pRExpr              =   sem_RExpr_Judge <$> pJudge
                            <|> sem_RExpr_Cond <$ pKey "cond" <*> pJExpr
        pJudge              =   sem_Judge_Judge <$ pKey "judge" <*> pNm <*> pJExpr
        pJExprLet           =   (\d b -> foldr (\(n,v) b -> sem_JExpr_Let n v b) b d) <$ pKey "let" <*> pList ((,) <$> pNm <* pKey "=" <*> pJExpr) <* pKey "in" <*> pJExpr
                            <|> pJExpr
        pJExpr              =   pChainr pOp pJExprApp
                            where pOp = (\s ss -> sem_JExpr_Op s (ss (sem_JExpr_Var s))) <$> pSym <*> pJExprSel
        pJExprApp           =   mkApp alg <$> pList1 (pJExprBase <**> pJExprSel) <|> pSucceed sem_JExpr_Empty
        pJExprBase          =   sem_JExpr_Paren <$> pParens pJExpr
                            <|> sem_JExpr_Var <$> pNm'
                            <|> sem_JExpr_Str <$> pString
                            <|> pParens pJExprEsc
        pJExprEsc           =   (sem_JExpr_StrAsIs . concat) <$> pList1 (foldr1 (<|>) . map pKey $ (["."] ++ keywordsOps ++ keywordsText))
        pJExprMbBase        =   sem_MbJExpr_Just <$> pJExprBase <|> pSucceed sem_MbJExpr_Nothing
        pJExprSel           =   pJExprSel1 <|> pSucceed id
        pJExprSel1          =   (\ss s -> \e -> sem_JExpr_SelTop (sem_JExpr_Sel (ss e) (sem_MbJExpr_Just s))) <$> pDots <*> pJExprBase
                            where pSel' = flip sem_JExpr_Sel <$> pJExprMbBase
                                  pDots = pChainr_ng ((\s -> \_ r -> \e -> r (s e)) <$> pSel') (id <$ pKey ".")
     in pAGItf
}

-------------------------------------------------------------------------
-- Interfacing
-------------------------------------------------------------------------

WRAPPER AGItf

ATTR AGItf [ opts: {Opts} | | ]

-------------------------------------------------------------------------
-- AST
-------------------------------------------------------------------------

DATA AGItf
  | AGItf               preamble    : {String}
                        decls       : Decls

DATA AGRuleItf
  | AGItf               rule        : Rule

DATA Decl
  | Scheme              nm          : {String}
                        jExpr       : JExpr
                        jExprRepl   : JExpr
                        views       : Views
  | Rules               nm          : {String}
                        mbNmSuff    : {Maybe String}
                        info        : {String}
                        rules       : Rules

TYPE Decls = [Decl]

SET AllDecl = Decl Decls

DATA View
  | View                nm          : {String}
                        jExprRepl   : JExpr

TYPE Views = [View]

SET AllView = View Views

DATA Rule
  | Rule                horizontal  : {Bool}
                        nm          : {String}
                        pre         : RExprs
                        post        : RExprs
  | RuleUse             horizontal  : {Bool}
                        nm          : {String}
                        nmAlias     : {[String]}

TYPE Rules = [Rule]

SET AllRule = Rule Rules

DATA Judge
  | Judge               nm          : {String}
                        jExpr       : JExpr

DATA JExpr
  | Op                  nm          : {String}
                        nmExpr      : JExpr
                        lExpr       : JExpr
                        rExpr       : JExpr
  | AppTop              jExpr       : JExpr
  | Let                 nm          : {String}
                        vExpr       : JExpr
                        bExpr       : JExpr
  | App                 lExpr       : JExpr
                        rExpr       : JExpr
  | Var                 nm          : {String}
  | Str                 str         : {String}
  | StrAsIs             str         : {String}
  | Paren               jExpr       : JExpr
  | SelTop              jExpr       : JExpr
  | Sel                 jExpr       : JExpr
                        selMbJExpr  : MbJExpr
  | Empty

DATA MbJExpr
  | Nothing
  | Just                jExpr       : JExpr

SET AllJudge = Judge JExpr

DATA RExpr
  | Judge               judge       : Judge
  | Cond                jExpr       : JExpr

TYPE RExprs = [RExpr]

SET AllRExpr = RExpr RExprs

SET AllNT = AllRExpr AllJudge AllRule AllView AllDecl MbJExpr

-------------------------------------------------------------------------
-- Ty of JExpr
-------------------------------------------------------------------------

{
data JTy
  = JTy_Op      String PP_Doc JTy JTy
  | JTy_Paren   JTy
  | JTy_Var     String
  | JTy_PP      PP_Doc
  | JTy_Any
  deriving Show

ppJTy :: JTy -> PP_Doc
ppJTy t
  = case t of
      JTy_Op _ p l r    -> ppJTy l >#< p >#< ppJTy r
      JTy_Paren t'      -> ppParens (ppJTy t')
      JTy_Var n         -> text (mkLhs2TeXSafe n)
      JTy_PP p          -> p
      JTy_Any           -> text "*"

jtyUnPPify :: JTy -> JTy
jtyUnPPify t
  = case t of
      JTy_Op nm p l r   -> JTy_Op nm p (jtyUnPPify l) (jtyUnPPify r)
      JTy_Paren t'      -> JTy_Paren (jtyUnPPify t')
      JTy_PP p          -> JTy_Any
      _                 -> t

type Binds = FiniteMap String JTy
data FIOut = FIOut {foTy :: JTy, foErrL :: PP_DocL, foCoe :: JTy -> JTy, foBinds :: Binds}

emptyFIOut = FIOut {foTy = JTy_Any, foErrL = [], foCoe = id, foBinds = emptyFM}

foHasErrs :: FIOut -> Bool
foHasErrs = not . null . foErrL

jtyFitsIn :: JTy -> JTy -> FIOut
jtyFitsIn ty1 ty2
  = let res t = emptyFIOut {foTy = t}
        err p = emptyFIOut {foErrL = [p]}
        coe fo c = fo {foCoe = c}
        bnd fo n t = fo {foBinds = addToFM (foBinds fo) n t}
        bnds fo fo1 fo2 = fo {foBinds = foBinds fo `plusFM` foBinds fo1 `plusFM` foBinds fo2}
        f t1 JTy_Any
            = res t1
        f (JTy_Paren t1) (JTy_Paren t2)
            = f t1 t2
        f t1 (JTy_Paren t2)
            = f t1 t2
        f t1 (JTy_Var v2)
            = bnd (res t1) v2 t1
        f (JTy_Op n1 p1 l1 r1) (JTy_Op n2 _ l2 r2)
            | n1 == n2
            = foldr1 (\fo1 fo2 -> if foHasErrs fo1 then fo1 else fo2) [lfo,rfo,bnds (coe (res rt) c) lfo rfo]
            where lfo = f l1 l2
                  rfo = f r1 r2
                  rt  = JTy_Op n1 p1 (foTy lfo) (foTy rfo)
                  c   = \(JTy_Op n p l r) -> JTy_Op n p (foCoe lfo l) (foCoe rfo r)
        f t1 t2
            = err ("RULER error, fitsin:" >#< ppJTy ty1 >#< "<=" >#< ppJTy ty2 >|< ", detail:" >#< ppJTy t1 >#< "<=" >#< ppJTy t2)
     in f ty1 ty2

jtyAppBinds :: Binds -> JTy -> JTy
jtyAppBinds b jt
  = let app t = case t of
                  JTy_Op nm p l r   -> JTy_Op nm p (app l) (app r)
                  JTy_Paren t'      -> JTy_Paren (app t')
                  JTy_Var nm        -> maybe t id (lookupFM b nm)
                  _                 -> t
     in app jt
}


ATTR JExpr [ | | ty: JTy ]

SEM JExpr
  | Op          lhs     .   ty          =   JTy_Op @nm @nmExpr.ppLaTeX @lExpr.ty @rExpr.ty
  | Paren       lhs     .   ty          =   JTy_Paren @jExpr.ty
  | Var         lhs     .   ty          =   JTy_Var @nm
  | AppTop SelTop Str Empty StrAsIs
                lhs     .   ty          =   JTy_PP @ppLaTeX

-------------------------------------------------------------------------
-- Declared stuff (Scheme views)
-------------------------------------------------------------------------

{
data JScmGamInfo = JScmGamInfo {jsiAllViewNmL :: [String], jsiViewNmL :: [String] }
type JScmGam = FiniteMap String JScmGamInfo
}

ATTR AllDecl [ | gathJScmGam: JScmGam | ]
ATTR AllDecl AllRule AllRExpr Judge AllView AGRuleItf [ jScmGam: JScmGam | | ]

SEM Decl
  | Scheme      lhs     .   gathJScmGam =   addToFM @lhs.gathJScmGam @nm
                                                (JScmGamInfo {jsiAllViewNmL= keysFM @viewJFmtGam, jsiViewNmL= map fst @allJFmtMp})

SEM AGItf
  | AGItf       decls   .   gathJScmGam =   emptyFM
                        .   jScmGam     =   @decls.gathJScmGam

-------------------------------------------------------------------------
-- Declared stuff (Judgement fmt)
-------------------------------------------------------------------------

{
data JFmtGamInfo = JFmtGamInfo {jgiTy :: JTy, jgiFullTy :: JTy, jgiReplTy :: JTy, jgiVarGam :: JVarGam }
type JFmtGam = FiniteMap String JFmtGamInfo
}

ATTR AllDecl [ | gathJFmtGam: JFmtGam | ]
ATTR AllView [ | viewJFmtMp: {[(String,JFmtGamInfo)]} | ]
ATTR AllDecl AllRule AllRExpr Judge AllView AGRuleItf [ jFmtGam: JFmtGam | | ]
ATTR AllView [ schemeTy: JTy | | ]

SEM Decl
  | Scheme      loc     .   schemeTy    =   @jExpr.ty
                        .   dfltJFmtMp  =   [("",JFmtGamInfo (jtyUnPPify @schemeTy) @schemeTy @jExprRepl.ty emptyFM)]
                views   .   viewJFmtMp  =   []
                loc     .   allJFmtMp   =   @dfltJFmtMp ++ @views.viewJFmtMp
                        .   viewJFmtGam =   listToFM . map (\(n,f) -> (@nm ++ n,f)) $ @allJFmtMp
                lhs     .   gathJFmtGam =   plusFM @lhs.gathJFmtGam @viewJFmtGam

SEM View
  | View        jExprRepl
                        .   jVarGam     =   emptyFM
                lhs     .   viewJFmtMp  =   (@nm,JFmtGamInfo (jtyUnPPify @lhs.schemeTy) @lhs.schemeTy @jExprRepl.ty @jExprRepl.jVarGam) : @lhs.viewJFmtMp

SEM AGItf
  | AGItf       decls   .   gathJFmtGam =   emptyFM
                        .   jFmtGam     =   @decls.gathJFmtGam

-------------------------------------------------------------------------
-- Checking, retrieving, etc
-------------------------------------------------------------------------

{
mkScmFmt :: String -> (JFmtGamInfo -> JTy) -> JFmtGam -> (JTy,[PP_Doc])
mkScmFmt n t g
  = case lookupFM g n of
      Nothing  -> (JTy_Any,["RULER error, undefined:" >#< n])
      Just jgi -> let fo = jtyFitsIn (t jgi) (jgiTy jgi)
                   in (foBinds fo `jtyAppBinds` jgiReplTy jgi,foErrL fo)
}

SEM Judge
  | Judge       loc     .   (ty,errs)   =   mkScmFmt (@nm ++ @lhs.view) (const @jExpr.ty) @lhs.jFmtGam

SEM Decl
  | Rules       loc     .   (scmTy,errs)=   mkScmFmt @nm jgiFullTy @lhs.jFmtGam
                        .   scmViewNmL  =   maybe [] jsiViewNmL (lookupFM @lhs.jScmGam @nm)

-------------------------------------------------------------------------
-- Selections
-------------------------------------------------------------------------

ATTR JExpr [ | | selL: {[Maybe (String,PP_Doc)]}]

SEM JExpr
  | Sel         lhs     .   selL        =   @selMbJExpr.mbPPLaTeX : @jExpr.selL
  | * - Sel     lhs     .   selL        =   []

-------------------------------------------------------------------------
-- Depth of selection
-------------------------------------------------------------------------

ATTR MbJExpr JExpr [ needToParen: Bool | | ]

SEM JExpr
  | Sel         selMbJExpr  .   needToParen =   False
                jExpr       .   needToParen =   case @selMbJExpr.mbPPLaTeX of
                                                  Just ("_",_) -> False
                                                  _            -> @lhs.needToParen
  | Paren App Op AppTop SelTop Sel
                loc         .   needToParen =   True

SEM Decl
  | Scheme      jExpr       .   needToParen =   True
                jExprRepl   .   needToParen =   True
  
SEM Judge
  | Judge       jExpr       .   needToParen =   True
  
SEM View
  | View        jExprRepl   .   needToParen =   True
  
SEM RExpr
  | Cond        jExpr       .   needToParen =   True
  
-------------------------------------------------------------------------
-- LaTeX/Lhs2TeX
-------------------------------------------------------------------------

{
rulesCmdPre = "rules"

mkLaTeXNm :: String -> String
mkLaTeXNm = map (\c -> if isAlphaNum c then c else '-')

mkLhs2TeXSafe :: String -> String
mkLhs2TeXSafe = concat . map (\c -> if c == '|' then "||" else [c])

mkMBox :: PP_Doc -> PP_Doc
mkMBox p = "\\;\\mbox" >|< ppCurly p

mkVerb :: PP_Doc -> PP_Doc
mkVerb p = ppPacked "@" "@" p

switchLaTeXLhs :: PP a => a -> PP_Doc
switchLaTeXLhs p = ppVBar (" " >|< p >|< " ")

mkInLhs2Tex :: PP_Doc -> PP_Doc
mkInLhs2Tex p = ppVBar (p >|< " ")

ensureTeXMath :: PP_Doc -> PP_Doc
ensureTeXMath = mkTexCmdUse "ensuremath"

ppArg :: PP p => p -> PP_Doc
ppArg p = ppCurly p >|< "%"

mkCmdNmDef :: PP_Doc -> PP_Doc -> PP_Doc
mkCmdNmDef = mkTexCmdDef "rulerCmdDef"

mkCmdNmUse :: PP_Doc -> PP_Doc
mkCmdNmUse = mkTexCmdUse "rulerCmdUse"

}

ATTR AGItf AllDecl AllJudge RExpr AGRuleItf Rule [ | | ppLaTeX USE {>-<} {empty} : PP_Doc ]
ATTR RExprs [ | | ppLaTeXL: PP_DocL ]
ATTR MbJExpr [ | | mbPPLaTeX: {Maybe (String,PP_Doc)} ]
ATTR JExpr [ | | txt USE {`const`} {""}: String ]

SEM AGItf
  | AGItf       lhs     .   ppLaTeX     =   (vlist . map text . lines $ @preamble) >-< @decls.ppLaTeX

SEM Decl
  | Scheme      loc     .   ppScmCmt    =   vlist
                                            . map (\(n,j) -> "%%" >#< n >#< ", template=" >#< ppJTy (jgiFullTy j) >#< ", view=" >#< ppJTy (jgiReplTy j))
                                            . fmToList
                                            $ @viewJFmtGam
                lhs     .   ppLaTeX     =   @ppScmCmt
  | Rules       loc     .   mkNmBase    =   \n -> ppDots ([pp rulesCmdPre,n] ++ maybeToList (fmap pp @mbNmSuff))
                        .   mkNmScm     =   \n -> ppDots [@mkNmBase n,pp "scheme"]
                loc     .   mkPP        =   \vw
                                                ->  let scm = @nm ++ vw
                                                        nBase = @mkNmBase (pp scm)
                                                        nScm = @mkNmScm (pp scm)
                                                        varGam = @lhs.jVarGam `plusFM` maybe emptyFM jgiVarGam (lookupFM @lhs.jFmtGam scm)
                                                        rs = map (\(n,h,c) -> (ppDots [nBase,n],h,ruleEval c vw @lhs.jScmGam @lhs.jFmtGam varGam)) @rules.rules
                                                        ru = concat . map (\(n,h,_) -> [text (if h then "\\qquad" else "\\\\"),mkCmdNmUse n]) $ rs
                                                        ppSc = mkCmdNmDef nScm (ensureTeXMath . mkInLhs2Tex . ppJTy . fst . mkScmFmt scm jgiFullTy $ @lhs.jFmtGam)
                                                        ppRs = vlist (map (\(n,_,c) -> mkCmdNmDef n c) rs)
                                                        ppRu = mkCmdNmDef nBase
                                                                    (    "\\begin{RulesFigure}" >|< ppCurly (mkCmdNmUse nScm) >|< ppCurly (text @info) >|< ppCurly nBase
                                                                     >-< (if null ru then empty else vlist (tail ru))
                                                                     >-< "\\end{RulesFigure}"
                                                                    )
                                                     in ppRs >-< ppSc >-< ppRu
                lhs     .   ppLaTeX     =   vlist . map @mkPP $ @scmViewNmL

SEM Judge
  | Judge       lhs     .   ppLaTeX     =   if null @errs then mkInLhs2Tex (ppJTy @ty) else mkInLhs2Tex (ppListSep "" "" "," @errs)

SEM JExpr
  | Let         loc     .   ppLaTeX     =   @bExpr.ppLaTeX
  | Str         loc     .   ppLaTeX     =   switchLaTeXLhs (mkMBox (text @str))
  | StrAsIs     loc     .   ppLaTeX     =   text @str
  | Paren       loc     .   ppLaTeX     =   (if @lhs.needToParen then ppParens else id) @jExpr.ppLaTeX
  | AppTop      loc     .   ppLaTeX     =   @jExpr.ppLaTeX
  | App         loc     .   ppLaTeX     =   @lExpr.ppLaTeX >#< @rExpr.ppLaTeX
  | SelTop      loc     .   ppLaTeXSel  =   let sw = (" " >|<) . switchLaTeXLhs
                                                over n s = case n of
                                                             "_" -> sw (text "\\overline{")
                                                             _   -> sw ("\\stackrel{" >|< sw s >|< "}{")
                                             in case (@jExpr.ppLaTeX,reverse @jExpr.selL) of
                                                  (x,[Nothing,Nothing,Just (n3,s3)])
                                                    -> over n3 s3
                                                       >|< x
                                                       >|< sw (text "}")
                                                  (x,[Nothing,Just (_,s2),Just (n3,s3)])
                                                    -> over n3 s3
                                                       >|< x
                                                       >|< sw ("^{" >|< sw s2 >|< "}}")
                                                  (x,[Just (_,s1),Nothing,Just (n3,s3)])
                                                    -> over n3 s3
                                                       >|< x
                                                       >|< sw ("_{" >|< sw s1 >|< "}}")
                                                  (x,[Just (_,s1),Just (_,s2),Just (n3,s3)])
                                                    -> over n3 s3
                                                       >|< x
                                                       >|< sw ("_{" >|< sw s1 >|< "}^{" >|< sw s2 >|< "}}")
                                                  (x,(Just (_,s1):Just (_,s2):_))
                                                    -> x >|< sw ("_{" >|< sw s1 >|< "}^{" >|< sw s2 >|< "}")
                                                  (x,(Nothing:Just (_,s2):_))
                                                    -> x >|< sw ("^{" >|< sw s2 >|< "}")
                                                  (x,(Just (_,s1):_))
                                                    -> x >|< sw ("_{" >|< sw s1 >|< "}")
                                                  (x,_)
                                                    -> x
                loc     .   ppLaTeX     =   if @jExpr.isEmpty then empty else @ppLaTeXSel
  | Op          loc     .   ppLaTeX     =   @lExpr.ppLaTeX >#< mkLhs2TeXSafe @nm >#< @rExpr.ppLaTeX
  | Empty       loc     .   ppLaTeX     =   empty

SEM JExpr
  | Var         lhs     .   txt         =   @nm
  | Str StrAsIs lhs     .   txt         =   @str
  | App SelTop AppTop Op
                lhs     .   txt         =   ""

SEM MbJExpr
  | Nothing     lhs     .   mbPPLaTeX   =   Nothing
  | Just        lhs     .   mbPPLaTeX   =   Just (@jExpr.txt,@jExpr.ppLaTeX)

SEM RExpr
  | Cond        loc     .   ppLaTeX     =   mkInLhs2Tex @jExpr.ppLaTeX

SEM RExprs
  | Nil         lhs     .   ppLaTeXL    =   []
  | Cons        lhs     .   ppLaTeXL    =   @hd.ppLaTeX : @tl.ppLaTeXL

SEM Rule
  | Rule        lhs     .   ppLaTeX     =   "\\infrule" >|< ppArg (mkLaTeXNm @nm ++ @lhs.view)
                                            >-< ppListSepVV "{%" "}" "\\\\" @pre.ppLaTeXL
                                            >-< ppListSepVV "{%" "}" "\\\\"  @post.ppLaTeXL
  | RuleUse     lhs     .   ppLaTeX     =   mkCmdNmUse (ppDots (rulesCmdPre : map mkLaTeXNm @nmAlias))

-------------------------------------------------------------------------
-- Rules to be shown
-------------------------------------------------------------------------

ATTR AllRule [ | | rules USE {++} {[]}: {[(PP_Doc,Bool,Rule)]} ]

SEM Rule
  | Rule        lhs     .   rules       =   [(pp (mkLaTeXNm @nm),@horizontal,@self)]

-------------------------------------------------------------------------
-- Environment for let bound redefs
-------------------------------------------------------------------------

{
data JVarGamInfo = JVarGamInfo {jviPP :: PP_Doc, jviIsEmpty :: Bool}
type JVarGam = FiniteMap String JVarGamInfo
}

ATTR AllNT AGRuleItf [ jVarGam: JVarGam | | ]
ATTR JExpr [ | | jVarGam: JVarGam ]

SEM AGItf
  | AGItf       decls   .   jVarGam     =   emptyFM

SEM JExpr
  | Let         bExpr   .   jVarGam     =   addToFM @lhs.jVarGam @nm (JVarGamInfo @vExpr.ppLaTeX @vExpr.isEmpty)
  | Var         loc     .   (ppLaTeX,isEmpty)
                                        =   case lookupFM @lhs.jVarGam @nm of
                                              Nothing -> (text (mkLhs2TeXSafe @nm),False)
                                              Just v -> (jviPP v,jviIsEmpty v)

-------------------------------------------------------------------------
-- Empty expr?
-------------------------------------------------------------------------

ATTR JExpr [ | | isEmpty: Bool ]

SEM JExpr
  | Empty       lhs     .   isEmpty     =   True
  | Sel         lhs     .   isEmpty     =   @jExpr.isEmpty
  | Let         lhs     .   isEmpty     =   @bExpr.isEmpty
  | * - Empty Var Sel Let
                lhs     .   isEmpty     =   False

-------------------------------------------------------------------------
-- Self
-------------------------------------------------------------------------

ATTR Rule AllRExpr AllJudge MbJExpr [ | | self: SELF ]

-------------------------------------------------------------------------
-- Which view
-------------------------------------------------------------------------

ATTR AGRuleItf AllRule AllRExpr AllJudge MbJExpr [ view: String | | ]

SEM Decl
  | *     		loc		.	view		=	""

SEM View
  | *     		loc		.	view		=	""

-------------------------------------------------------------------------
-- Wrapper for Rule
-------------------------------------------------------------------------

WRAPPER AGRuleItf

{
ruleEval :: Rule -> String -> JScmGam -> JFmtGam -> JVarGam -> PP_Doc
ruleEval r vw sg fg vg
  = let r1 = sem_AGRuleItf (AGRuleItf_AGItf r)
        r2 = wrap_AGRuleItf r1 (Inh_AGRuleItf {view_Inh_AGRuleItf = vw,jFmtGam_Inh_AGRuleItf = fg,jScmGam_Inh_AGRuleItf = sg,jVarGam_Inh_AGRuleItf = vg})
    in  ppLaTeX_Syn_AGRuleItf r2
}
