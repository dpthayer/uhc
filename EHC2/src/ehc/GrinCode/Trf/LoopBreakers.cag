%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Inlining mutual recursive functions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin)
{

showLoopBreakers = False

-- Find the loopbreaker for inlining recursive functions, but don't loop.
-- TODO topological sorting. Fix the right scc instead of arbitrary.
-- TODO heuristic for choosing loopbreaker.
type GraphData = [(HsName, [HsName])]      
 
calcLoopBreakers :: GraphData -> [HsName]
calcLoopBreakers graph = 
    let sccs :: [[HsName]]
        sccs = scc graph
        isDirectRecursive name = let (a,edges) = fromJust (find ((name ==) . fst) graph)
                                 in  elem name edges
        nonTrivialSccs = filter (\l -> length l > 1 || isDirectRecursive (head l) ) sccs
        loopBreaker = head (head nonTrivialSccs)                   
    in  if    (null nonTrivialSccs)
        then  []
        else  let newGraph = map (\(a,b) -> (a,filter (/= loopBreaker) b)) graph
                  validEdge = (/= loopBreaker) . snd
              in  (loopBreaker : calcLoopBreakers newGraph)
}

ATTR AllBind [ | | dependencies USE {++} {[]}: {GraphData} ]
ATTR AllBind [ loopBreakers: {[HsName]} | |  ]
ATTR AllBind [ inhBindingNames : {[HsName]} |  |  ]
ATTR AllBind [  |  | synBindingNames USE {++} {[]} : {[HsName]} ]

SEM GrModule 
  | Mod   bindL.loopBreakers    = (showLoopBreakers,\b -> 
                                    "\nrecursive bind found,names are:\n" ++ show @bindL.synBindingNames ++
                                    "\n loopbreakers are:" ++ show b) >?>
                                  calcLoopBreakers @bindL.dependencies
          bindL.inhBindingNames = []
                 
{
}                 

SEM GrBindL
  | Cons    hd.inhBindingNames      = @hd.synBindingNames

SEM GrBind
  | Bind    lhs.dependencies        = (showLoopBreakers,\d -> 
                                        "bindingNames = " ++ show @lhs.inhBindingNames 
                                        ++ "\ngathMp = " ++ show @loc.gathFviMp 
                                        ++ "\ndependencies = " ++ show d) >?>                                      
                                      [(@nm,filter (\name -> Map.member name @loc.gathFviMp) @lhs.inhBindingNames)]
                                      
            lhs.synBindingNames     = [@nm]
%%]