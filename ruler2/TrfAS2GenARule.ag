-------------------------------------------------------------------------
-- Generate ARule's from attr bindings
-------------------------------------------------------------------------

{
module TrfAS2GenARule
  where

import Data.Maybe
import Data.Char
import Data.List
import qualified Data.Set as Set
import qualified Data.Map as Map
import Utils
import Opts
import Common
import KeywParser( propsSynInhMp )
import ExprUtils
import ARuleUtils
import FmGam
import RwExprGam
import ECnstrGam
import RulerAbsSyn2
import RulerAdmin

-- for ppDbg
import UU.Pretty
import PPUtils
}

-------------------------------------------------------------------------
-- Inclusion of split off parts
-------------------------------------------------------------------------

INCLUDE "RulerAbsSyn2AG.ag"
INCLUDE "RulerAbsSynCommonAG.ag"
INCLUDE "RulerAS2Opts.ag"

INCLUDE "ExprAbsSynAG.ag"
INCLUDE "ExprSelfAG.ag"

INCLUDE "ARuleAbsSynAG.ag"
INCLUDE "ARuleSelfAG.ag"

-------------------------------------------------------------------------
-- Interfacing to AST
-------------------------------------------------------------------------

WRAPPER AGItf 

{
as2ARule :: Opts -> ScGam Expr -> FmGam Expr -> RwExprGam -> Decls -> (Decls,PP_Doc)
as2ARule o scg fmg rwg r
  = (self_Syn_AGItf r2,ppDbg_Syn_AGItf r2)
  where r1 = sem_AGItf (AGItf_AGItf r)
        r2 = wrap_AGItf r1
                (Inh_AGItf {opts_Inh_AGItf = o, fmGam_Inh_AGItf = fmg, rwGam_Inh_AGItf = rwg, scGam_Inh_AGItf = scg})
}

-------------------------------------------------------------------------
-- Context: is in premise?
-------------------------------------------------------------------------

ATTR AllJd AllAt [ isPre: Bool | | ]

SEM RlDecl
  | Rl              preJds  .   isPre       =   True
                    postJds .   isPre       =   False

-------------------------------------------------------------------------
-- Context: options, position, etc
-------------------------------------------------------------------------

ATTR AllJd AllAt [ pos: SPos | | ]

SEM RlDecl
  | Rl              loc     .   pos         =   @pos

ATTR AllAS2 [ fm: FmKind | | ]

SEM AGItf
  | AGItf           loc     .   fm          =   fmAS2Fm (optGenFM @lhs.opts)
                            .   opts        =   @lhs.opts {optGenFM = @fm}

-------------------------------------------------------------------------
-- Context: scGam, fmGam, rwGam
-------------------------------------------------------------------------

ATTR AllAS2 AGItf [ scGam: {ScGam Expr}  fmGam: {FmGam Expr}  rwGam: RwExprGam | | ]

-------------------------------------------------------------------------
-- Context: substitution
-------------------------------------------------------------------------

SEM JdAt
  | At              loc     .   sbse        =   exprSubst (@lhs.opts {optSubstFullNm=False}) @lhs.fmGam
                            .   sbsn        =   nmSubst (@lhs.opts {optSubstFullNm=False}) @lhs.fmGam

SEM Jd
  | Ats             loc     .   sbse        =   exprSubst (@lhs.opts {optSubstFullNm=False}) @lhs.fmGam
                            .   sbsn        =   nmSubst (@lhs.opts {optSubstFullNm=False}) @lhs.fmGam

-------------------------------------------------------------------------
-- Context: ruleset/view/rule name, agStr
-------------------------------------------------------------------------

ATTR AllVw AllRl [ rsScNm: Nm | | ]

SEM RsVwDecl
  | Rs              loc     .   rsScNm      =   @scNm

ATTR AllRl AllJd [ vwNm: Nm | | ]

SEM VwDecl
  | Vw              loc     .   vwNm        =   @nm

ATTR AllJd [ rlNm: Nm | | ]

SEM RlDecl
  | Rl              loc     .   rlNm        =   @nm

ATTR AllJd [ agStr: Nm | | ]

SEM RlDecl
  | Rl              loc     .   agStr       =   maybe @rlNm Nm @mbAGStr

-------------------------------------------------------------------------
-- Context: scInfo
-------------------------------------------------------------------------

SEM RlDecl
  | Rl              loc     .   rsScInfo    =   maybe (panic "RlDecl_Rl: rsScInfo") id $ Map.lookup @lhs.rsScNm @lhs.scGam

SEM Jd
  | Ats             loc     .   (scInfo,vwScInfo)
                                            =   maybe (panic "Jd_Ats: scInfo") id
                                                $ scVwGamLookup @scNm @lhs.vwNm @lhs.scGam

-------------------------------------------------------------------------
-- Context: scAtGam
-------------------------------------------------------------------------

ATTR AllAt [ scAtGam: AtGam | | ]

SEM Jd
  | Ats             ats     .   scAtGam     =   vwscFullAtGam @vwScInfo

SEM JdAt
  | At              loc     .   atInfo      =   maybe emptyAtInfo id $ Map.lookup @nm @lhs.scAtGam
                            .   propRetain  =   atProps @atInfo `intersect` [AtRetain]

-------------------------------------------------------------------------
-- Local properties for attr
-------------------------------------------------------------------------

{
data Dir = Def | Use | Node | NoDir deriving (Show,Eq,Ord)
}

SEM JdAt
  | At              loc     .   dir         =   let isSyn = AtSyn `elem` atDirs @atInfo
                                                    isInh = AtInh `elem` atDirs @atInfo
                                                in  if AtNode `elem` atProps @atInfo
                                                    then Node
                                                    else if isSyn
                                                    then if @lhs.isPre then Use else Def
                                                    else if isInh
                                                    then if @lhs.isPre then Def else Use
                                                    else NoDir
                            .   isBi        =   not $ null $ Map.elems propsSynInhMp `intersect` atProps @atInfo

SEM JdAt
  | At              loc     .   atCnstr     =   ECnstr_Ty [atTy @atInfo]

-------------------------------------------------------------------------
-- Context: node name
-------------------------------------------------------------------------

ATTR JdAts [ | | gathNmNd: Nm ]
ATTR AllAt [ | | gathExNd: Expr ]
ATTR JdAt [ | | mbNmNd: {Maybe Nm} ]

SEM JdAt
  | At              lhs     .   mbNmNd      =   if @dir == Node then Just @nm else Nothing
                            .   gathExNd    =   @expr.self

SEM JdAts
  | Nil             lhs     .   gathNmNd    =   nmUnk
                            .   gathExNd    =   exprUnk
  | Cons            lhs     .   (gathNmNd,gathExNd)
                                            =   maybe (@tl.gathNmNd,@tl.gathExNd) (\n -> (n,@hd.gathExNd)) @hd.mbNmNd

ATTR AllAt [ nmNd: Nm | | ]

SEM Jd
  | Ats             ats     .   nmNd        =   exprAsNm @ats.gathExNd

-------------------------------------------------------------------------
-- Node order gam
-------------------------------------------------------------------------

ATTR AllJd [ | | coGam USE {`Map.union`} {Map.empty}: ChOrdGam ]

SEM Jd
  | Ats             loc     .   exNdNmS     =   exprNmS @ats.gathExNd
                            .   exNdFmGam   =   fmGamFromList' @lhs.fm [ (n,mkAFld . @sbsn $ n) | n <- Set.toList @exNdNmS ]
                    lhs     .   coGam       =   exprCoGam . exprSubst (@lhs.opts {optSubstFullNm=False}) @exNdFmGam $ @ats.gathExNd 

SEM RlDecl
  | Rl              loc     .   coNmL       =   coGamNmL @postJds.coGam

-------------------------------------------------------------------------
-- Attr bindings as FmGam
-------------------------------------------------------------------------

ATTR AllAt [ | | atFmGam USE {`fmGamUnion`} {emptyGam}: {FmGam (Expr,ECnstr)} ]

SEM JdAt
  | At              lhs     .   atFmGam     =   fmSingleton @nm @lhs.fm (@expr.self,@atCnstr)

-------------------------------------------------------------------------
-- Building blocks for transforming
-------------------------------------------------------------------------

SEM JdAt
  | At              loc     .   nmAdapt     =   if @isBi then nmInit else id
                            .   nmSbs       =   Nm . nmShowAG . @sbsn . @nmAdapt $ @nm
                            .   defLhs      =   if @lhs.isPre then mkANd @lhs.nmNd @nmSbs else mkALhs' @propRetain @nmSbs
                            .   defRhs      =   @expr.self
                            .   useLhs      =   @expr.self
                            .   useRhs      =   if @lhs.isPre then mkANd @lhs.nmNd @nmSbs else mkALhs @nmSbs

-------------------------------------------------------------------------
-- Introduced names, mapped to AG equivalent
-------------------------------------------------------------------------

ATTR AllJd AllAt [ | | introFmGam USE {`fmGamUnion`} {emptyGam}: {FmGam Expr} ]

SEM JdAt
  | At              lhs     .   introFmGam  =   case @dir of
                                                  Use -> fmGamFromList' @lhs.fm [ (n,mkALoc' n') | (n,n') <- nmRefAscL ]
                                                      where nmRefAscL = [ (n,Nm . nmShowAG . @sbsn {- . nmAdapt -} $ n) | n <- Set.toList (exprNmS @useLhs), n /= nmWild ]
                                                  _   -> emptyGam

SEM Jd
  | Ats             lhs     .   introFmGam  =   case scKind @scInfo of
                                                  ScJudge | not @lhs.isPre -> @exNdFmGam `fmGamUnion` @ats.introFmGam
                                                  _                        -> @ats.introFmGam

SEM RlDecl
  | Rl              loc     .   introFmGam  =   @preJds.introFmGam `fmGamUnion` @postJds.introFmGam

-------------------------------------------------------------------------
-- Full fmGam
-------------------------------------------------------------------------

SEM RlDecl
  | Rl              loc     .   fullFmGam   =   @introFmGam `fmGamUnion` @lhs.fmGam

-------------------------------------------------------------------------
-- Constraint gam
-------------------------------------------------------------------------

ATTR AllJd AllAt [ | | introECGam USE {`Map.union`} {Map.empty}: ECnstrGam ]

SEM JdAt
  | At              lhs     .   introECGam  =   @introECGam

SEM Jd
  | Ats             lhs     .   introECGam  =   @introECGam
{-
  | Ats             lhs     .   introECGam  =   case scKind @scInfo of
                                                  ScRelation -> Map.fromList [ ec | (_,ec) <- fmGamToList' @lhs.fm @ats.atFmGam ]
                                                  _          -> @ats.introECGam
-}

SEM RlDecl
  | Rl              loc     .   introECGam  =   Map.mapKeys
                                                    (exprSubst (@lhs.opts {optSubstFullNm=False}) @fullFmGam)
                                                    (@preJds.introECGam `Map.union` @postJds.introECGam)

-------------------------------------------------------------------------
-- 'Attr defined' gam
-------------------------------------------------------------------------

ATTR AllJd AllAt [ | | introADGam USE {`Map.union`} {Map.empty}: AtDefdGam ]

SEM JdAt
  | At              lhs     .   introADGam  =   case @dir of
                                                  Def -> Map.fromList [(@nmSbs,@isBi)]
                                                  _   -> emptyGam

SEM RlDecl
  | Rl              loc     .   adGam       =   @preJds.introADGam `Map.union` @postJds.introADGam

-------------------------------------------------------------------------
-- Replica
-------------------------------------------------------------------------

ATTR AGItf [ | | self: {Decls} ]
ATTR AllAS2 [ | | self: SELF ]
ATTR AllAt AllJd [ | | exprEqnL USE {++} {[]}: {[Expr]} ]

SEM JdAt
  | At              loc     .   (exprEqnL,introECGam)
                                            =   let mk l r = ([eqn2],ecGam `Map.union` ecGamFromList [ (l,@atCnstr), (r,@atCnstr) ])
                                                           where eqn1         = mkExprEqn l r
                                                                 (eqn2,ecGam) = exprElimCnstr eqn1
                                                in  case @dir of
                                                      Use -> mk @useLhs @useRhs
                                                      Def -> mk @defLhs @defRhs
                                                      _   -> ([],Map.empty)

SEM Jd
  | Ats             loc     .   (exprEqnL,introECGam,eqnErrs)
                                            =   case scKind @scInfo of
                                                  ScJudge    -> (@ats.exprEqnL,@ats.introECGam,[])
                                                  ScRelation -> (exprLines jd2,introECGam2,concat jd1ErrLL)
                                                             where jd1      = fkGamLookup exprUnk jdExpr [@lhs.fm] . vwscJdGam $ @vwScInfo
                                                                   (jd1EqlL,jd1ErrLL)
                                                                            = unzip
                                                                                [ maybe (Map.empty,[Err_NotAEqnForm @lhs.pos (pp l)]) (\e -> (e,[])) (exprCheckAEqnForm l)
                                                                                | l <- exprLines jd1
                                                                                ]
                                                                   jd2      = exprSubst (@lhs.opts {optSubstFullNm=False}) (fmGamMap (const fst) @ats.atFmGam) jd1
                                                                   mkG eqm gn
                                                                            = if null n1 then [] else n1 ++ mkG (foldr (\(e,_) m -> Map.delete e m) eqm n1) n1
                                                                            where n1 = [ (exprEnsureAppTop e',c) | (e,c) <- gn, e' <- maybeToList (Map.lookup e eqm) ]
                                                                   introECL1   = [ (e,c) | (n,(e,c)) <- fmGamToList' @lhs.fm @ats.atFmGam ]
                                                                   introECGam2 = ecGamFromList $ introECL1 ++ mkG (Map.unions jd1EqlL) introECL1

SEM RlDecl
  | Rl              (lhs.self,loc.selfNonOptim)
                                            =   let (eqnLL,eqnGamL)
                                                      = unzip
                                                          [ (es,g)
                                                          | e <- @preJds.exprEqnL ++ @postJds.exprEqnL
                                                          , let (_,es,g) = exprRewrite' (@lhs.opts {optSubstFullNm=False}) @fullFmGam @lhs.rwGam @introECGam e
                                                          ]
                                                    aRule1
                                                      = ARule_Rule
                                                          [maybe (scNm @rsScInfo) Nm (scMbAGStr @rsScInfo)]
                                                          @agStr
                                                          ["rule " ++ show @rlNm,"view " ++ show @lhs.vwNm]
                                                          (concat eqnLL)
                                                    aRule2
                                                      = arlUniq @lhs.fmGam @coNmL
                                                        $ arlSubst (fmGamUnions eqnGamL)
                                                        $ aRule1
                                                    aRule3
                                                      = arlElimWild
                                                        $ (if optAGCopyElim @lhs.opts then arlElimCopyRule @coNmL @adGam else id)
                                                        $ arlElimAlphaRename
                                                        $ aRule2
                                                in  (RlDecl_AG @nm @pos aRule3,aRule2)

-------------------------------------------------------------------------
-- Debug pretty printing of ruler AST2
-------------------------------------------------------------------------

ATTR AllAS2 AGItf [ | | ppDbg USE {>-<} {empty} : PP_Doc ]

SEM RlDecl
  | Rl              lhs     .   ppDbg       =   "-- debug info"
                                                >-< @nm >#< ppCommaList [pp @pos,pp @mbAGStr]
                                                >-< "introFmGam" >#< ppGam @introFmGam
                                                >-< "introECGam" >#< ppECGam @introECGam
                                                >-< "lhs.rwGam" >#< ppGam @lhs.rwGam
                                                >-< "adGam" >#< ppGam @adGam
                                                >-< "lhs.opts" >#< text (show @lhs.opts)
                                                >-< "coNmL" >#< ppListSep "[" "]" "," @coNmL
                                                >-< "non optim" >#< pp @selfNonOptim
{-
-}

