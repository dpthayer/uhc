-------------------------------------------------------------------------
-- Optimisation: ARule copy rule elimination
-------------------------------------------------------------------------

{
module ARuleCopyRuleElim
  ( module Gam

  , AtDefdGam
  , CrOrdGam
  
  , arlElimCopyRule
  )
  where

-- import Data.List
-- import qualified Data.Set as Set
import qualified Data.Map as Map
-- import Utils
import Common
import Expr
-- import ExprIsRw
-- import ExprToAEqn
import ARule
-- import ARulePrettyPrint
import Gam
-- import FmGam
-- import ECnstrGam
-- import RwExprGam
}

INCLUDE "ExprAbsSynAG.ag"
INCLUDE "ARuleAbsSynAG.ag"

INCLUDE "ExprSelfAG.ag"

INCLUDE "ARuleCopyRuleNmAG.ag"

INCLUDE "ARuleEqnDest1NmAG.ag"
INCLUDE "ARuleInCompDestAG.ag"

WRAPPER  AGARuleItf

{
arlElimCopyRule :: [Nm] -> AtDefdGam -> ARule -> ARule
arlElimCopyRule co ag rl
  = replCr_Syn_AGARuleItf r2
  where r1 = sem_AGARuleItf (AGARuleItf_AGItf rl)
        r2 = wrap_AGARuleItf r1
                (Inh_AGARuleItf {croNmL_Inh_AGARuleItf = co
                                ,adGam_Inh_AGARuleItf = ag
                                })
}

-------------------------------------------------------------------------
-- Copy rule order, ref to previous node
-------------------------------------------------------------------------

{
type CrOrdGam = Gam Nm Nm
}

-------------------------------------------------------------------------
-- Non local attr's defined, threaded?
-------------------------------------------------------------------------

{
type AtDefdGam = Gam Nm Bool
}

-------------------------------------------------------------------------
-- Context
-------------------------------------------------------------------------

ATTR ARule AEqn AEqns AGARuleItf [ adGam: AtDefdGam | | ]
ATTR ARule AEqn AEqns [ croGam: CrOrdGam | | ]

SEM AGARuleItf
  | AGItf           rule    .   croGam      =   fst . foldl (\(g,pn) n -> (Map.insert n pn g,n)) (emptyGam,head @lhs.croNmL) $ tail @lhs.croNmL

-------------------------------------------------------------------------
-- Replica
-------------------------------------------------------------------------

ATTR AllARule AllExpr [ | | replCr: SELF ]
ATTR AGARuleItf [ | | replCr: ARule ]
ATTR AEqns AEqn [ | | replCrEqns USE {++} {[]}: {[AEqn]} ]

SEM AEqn
  | Eqn             lhs     .   replCrEqns  =   let isThr n = Map.findWithDefault False n @lhs.adGam
                                                    isPrev n1 n2 = maybe False (==n1) $ Map.lookup n2 @lhs.croGam
                                                in  case (@dest.mbSingleANm,@val.mbSingleANm) of
                                                      (Just (ANm_Node nn dn),Just (ANm_Lhs sn _)) | dn == sn && not (isThr sn)
                                                        -> []
                                                      (Just (ANm_Node nn dn),Just (ANm_Lhs sn _)) | dn == sn && (isThr sn) && nmLhs `isPrev` nn
                                                        -> []
                                                      (Just (ANm_Node nn1 dn),Just (ANm_Node nn2 sn)) | dn == sn && (isThr sn) && nn2 `isPrev` nn1
                                                        -> []
                                                      (Just (ANm_Lhs dn _),Just (ANm_Node nn sn)) | dn == sn {- && (isThr sn) -} && nn `isPrev` nmLhs
                                                        -> []
                                                      (Just (ANm_Lhs dn _),Just (ANm_Lhs sn _)) | dn == sn && (isThr sn) && nmLhs `isPrev` nmLhs
                                                        -> []
                                                      _ -> [@replCr]
  | * - Eqn         lhs     .   replCrEqns  =   [@replCr]

SEM ARule
  | Rule            lhs     .   replCr      =   ARule_Rule @ndNmL @rlNm @info @eqns.replCrEqns


