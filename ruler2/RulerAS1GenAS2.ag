-------------------------------------------------------------------------
-- Utils
-------------------------------------------------------------------------

{
rsSelect :: RlSelIsSel -> RsGam Expr -> [(Nm,RsInfo Expr)]
rsSelect rlSelIsSel rsGam
  = rs
  where rs = [ (rsNm,rsInfo {rsRlGam = Map.fromList rls})
             | (rsNm,rsInfo) <- Map.toList rsGam
             , rsInfoIsPlain rsInfo
             , rlSelIsSel nmAny rsNm nmAny
             , let rls
                     = [ (rlNm,rlInfo {rlVwGam = Map.fromList vws})
                       | (rlNm,rlInfo) <- Map.toList (rsRlGam rsInfo)
                       , rlSelIsSel nmAny nmAny rlNm
                       , let vws
                               = [ v
                                 | v@(vwNm,_) <- Map.toList (rlVwGam rlInfo)
                                 , rlSelIsSel vwNm nmAny nmAny
                                 ]
                       ]
             ]

jdChangeInfo :: Opts -> (Nm -> Maybe Bool) -> FmGam Expr -> (FmGam Expr,Expr->Expr)
jdChangeInfo opts isChgd jaFmGam
  = if null chs    then (jaFmGam,id)
    else if or chs then (fmGamMap mkChng jaFmGam,id)
                   else (jaFmGam,Expr_Wrap WrIsSame)
  where chs = catMaybes . map isChgd . Map.keys $ jaFmGam
        mkChng
          = case optMbMarkChange opts of
              Just _  -> \nAt -> case isChgd nAt of
                                   Just isCh -> Expr_Wrap (if isCh then WrIsChanged else WrIsSame)
                                   Nothing   -> id
              Nothing -> \_   -> id

atIsChanged :: VwRlInfo Expr -> Nm -> Nm -> Maybe Bool
atIsChanged vwRlInfo
  = case vwrlMbChGam vwRlInfo of
      Just g  -> \j a -> maybe (Just False) (const (Just True)) $ dblGamLookup id j a g
      Nothing -> \_ _ -> Nothing
}

-------------------------------------------------------------------------
-- Generate AS2
-------------------------------------------------------------------------

ATTR AGItf [ | | as2: {AS2.Decls} ]

SEM AGItf
  | AGItf           loc     .   fmAS2       =   fmAS2Fm (optGenFM @lhs.opts)
                    lhs     .   as2         =   @as2ScmMeta ++ @as2RuleSets

-------------------------------------------------------------------------
-- Generate AS2 for scheme related (meta) info
-------------------------------------------------------------------------

SEM AGItf
  | AGItf           loc     .   as2ScmMeta  =   if optGenAGAttr @lhs.opts
                                                then let nVwS = vgVertices @vwDpdGr
                                                         sv = Map.fromListWith Set.union
                                                                [ (rsScNm i,vs) | i <- Map.elems @rsGam
                                                                                , let vs = Set.filter (\v -> @rlSelIsSel v (rsNm i) nmAny) nVwS, not (Set.null vs)
                                                                ]
                                                         mkChunk s v
                                                           = AS2.wrapInChunk AS2.Decl_Chunk @lhs.opts (rsSelMapVwNm (optMbRlSel @lhs.opts) v `nmApd` s `nmApd` Nm "ATTR")
                                                         mk s v
                                                           = case scVwGamLookup s v @scGam of
                                                               Just (si,vi)
                                                                 -> [AS2.Decl_AttrAG (AS2.AttrAGDecl_Attr (maybe (scNm si) Nm (scMbAGStr si)) (mkg agi) (mkg agsi) (mkg ags))]
                                                                 where ag1 = Map.filter (\ai -> AtNode `notElem` atProps ai) (vwscFullAtGam vi)
                                                                       (agsi,ag2) = Map.partition (\ai -> isJust (atMbSynInh ai)) ag1
                                                                       (ags,agi) = Map.partition (\ai -> AtSyn `elem` atDirs ai) ag2
                                                                       mkg g = [ (n,atTy ai) | ai <- Map.elems g, let n = nmSubst @lhs.opts @fmGam $ maybe (atNm ai) id $ atMbSynInh ai ]
                                                               _ -> []
                                                     in  [ mkChunk s v d | (s,vs) <- Map.toList sv, v <- Set.toList vs, d <- mk s v ] 
                                                else []

-------------------------------------------------------------------------
-- Generate AS2 for rulesets
-------------------------------------------------------------------------

SEM AGItf
  | AGItf           loc     .   as2RuleSets =   let vwOrder = vgTopSort @vwDpdGr
                                                    rsGen
                                                      = [ AS2.Decl_RsVw (mkRs rsInfo) | (nRs,rsInfo) <- rsSelect @rlSelIsSel @rsGam ]
                                                      where mkRs rsInfo
                                                              = case rsInfo of
                                                                  RsInfo nRs nSc vwSel d rlGam
                                                                    -> AS2.RsVwDecl_Rs nRs nSc vwSel d
                                                                         [ AS2.VwDecl_Vw v rls'
                                                                         | (v,rls) <- Map.toList rlGamT
                                                                         , let rls' = catMaybes [ Map.lookup n rls | n <- rlOrder ]
                                                                         ]
                                                                    where rlGamT    = gamTranspose (rlVwGam,mkRl) rlGam
                                                                          rlOrder   = rsRlOrder rsInfo
                                                                          jdsOf o g = [ maybe (panic "as2") id (Map.lookup jNm g) | jNm <- o ]
                                                                          mkRl rNm vNm rlInfo vwRlInfo
                                                                            = mkChunk vNm rlInfo
                                                                              $ AS2.RlDecl_Rl rNm fullNm (rlPos rlInfo) (rlMbAGStr rlInfo) (rlInclVwS rlInfo) pre post
                                                                            where preg  = vwrlFullPreGam vwRlInfo
                                                                                  postg = vwrlFullPostGam vwRlInfo
                                                                                  preOrder  = concat (vwrlPreScc vwRlInfo)
                                                                                  postOrder = Map.keys postg
                                                                                  (pre,post)
                                                                                    = case @fmAS2 of
                                                                                        FmTeX -> (mkExprJds vwRlInfo preOrder preg,mkExprJds vwRlInfo postOrder postg)
                                                                                        FmAG  -> (mkAtsJds preOrder preg,mkAtsJds postOrder postg)
                                                                                        _     -> ([],[])
                                                                                  fullNm = nmApd (Nm (optBaseNm @lhs.opts)) $ (if vNm == nmNone then id else nmApd vNm) $ nmApd nRs $ rNm
                                                                          mkChunk vNm rlInfo
                                                                            = AS2.wrapInChunk AS2.RlDecl_Chunk @lhs.opts (nVwRnm `nmApd` nSc `nmApd` rlNm rlInfo)
                                                                            where nVwRnm = rsSelMapVwNm (optMbRlSel @lhs.opts) vNm
                                                                          mkAtsJds order reGam
                                                                            = [ AS2.Jd_Ats (reNm jInfo) (reScNm jInfo) (mkAts jInfo) | jInfo <- jdsOf order reGam ]
                                                                            where mkAts jInfo = [ AS2.JdAt_At aNm (jaExpr a) | (aNm,a) <- Map.toList (reJAGam jInfo) ]
                                                                          mkExprJds vwRlInfo order reGam
                                                                            = [ AS2.Jd_Expr (reNm jInfo) (reScNm jInfo) (mkExpr vwRlInfo jInfo) | jInfo <- jdsOf order reGam ]
                                                                            where mkExpr vwRlInfo jInfo
                                                                                    = e'
                                                                                    where (scInfo,vwScInfo) = fromJust (scVwGamLookup (reScNm jInfo) vNm @scGam)
                                                                                          jg = jaGamToFmGam id . reJAGam $ jInfo
                                                                                          (jg',w) = jdChangeInfo @lhs.opts (atIsChanged vwRlInfo vNm) jg
                                                                                          e  = jdGamFmExpr @fmAS2 . vwscJdGam $ vwScInfo
                                                                                          e' = exprSubst @lhs.opts @fmGam . w . exprSubst (@lhs.opts {optSubstOnce=True}) jg' $ e
                                                                                          vNm = vwrlNm vwRlInfo
                                                in  rsGen

