-- $Id: Ruler.ag 231 2005-06-07 14:39:41Z atze $

-------------------------------------------------------------------------
-- Pretty printing of ruler AST
-------------------------------------------------------------------------

{-
ppExprMbEmpty :: Expr -> (PP_Doc -> PP_Doc) -> PP_Doc -> PP_Doc
ppExprMbEmpty (Expr_Empty) _ p = p
ppExprMbEmpty _            f p = f p
-}

-------------------------------------------------------------------------
-- Need for parenthesis
-------------------------------------------------------------------------

{-
data NeedParCtxt
  = ParCtxtAppL | ParCtxtAppR | ParCtxtOpL | ParCtxtOpR | ParCtxtOther
  deriving Eq

exprNeedPar :: NeedParCtxt -> Nm -> Expr -> (PP_Doc -> PP_Doc)
exprNeedPar ctxt opNm e
  = case e of
      Expr_Paren e
        -> case (t e,ctxt) of
             (Expr_Op    _ _ _ _,ParCtxtAppL) -> pp_parens
             (Expr_Op    _ _ _ _,ParCtxtAppR) -> pp_parens
             (Expr_Op    _ _ _ _,ParCtxtOpL ) -> pp_parens
             (Expr_Op    _ _ _ _,ParCtxtOpR ) -> pp_parens
             (Expr_App   _ _    ,ParCtxtAppR) -> pp_parens
             (Expr_Paren _      ,_          ) -> pp_parens
             _ | opNm == nmSp1 -> pp_parens
               | otherwise     -> id
      _ -> id
  where t (Expr_AppTop  e) = t e
        t (Expr_Named _ e) = t e
        t e                = e
-}

{-
exprNeedPar :: NeedParCtxt -> Expr -> (PP_Doc -> PP_Doc)
exprNeedPar ctxt e
  = case (t e,ctxt) of
      (Expr_Op _ _ _ _,ParCtxtAppL) -> pp_parens
      (Expr_Op _ _ _ _,ParCtxtAppR) -> pp_parens
      (Expr_Op _ _ _ _,ParCtxtOpL) -> pp_parens
      (Expr_App _ _,ParCtxtAppR) -> pp_parens
      _ -> id
  where t (Expr_AppTop  e) = t e
        t (Expr_Named _ e) = t e
        t e                = e
-}

-------------------------------------------------------------------------
-- Plain, for all
-------------------------------------------------------------------------

ATTR AllNT AGItf {- AGExprItf AGARuleItf -} [ | | pp USE {>-<} {empty} : PP_Doc ]

SEM AGItf
  | AGItf           lhs     .   pp          =   @decls.pp
                                                >-< "---------- rw gam" >-< ppRwGam @rwGam
                                                >-< "---------- fm gam" >-< ppGam @fmGam
                                                >-< "---------- scheme gam" >-< ppGam @scGam
                                                >-< "---------- rule set gam" >-< ppGam @rsGam
                                                >-< "---------- topsorted vw dpd graph" >-< ppCommas (vgTopSort @vwDpdGr)

SEM Decl
  | Scheme          lhs     .   pp          =   "scheme"        >#< @scKind >#< @nm >-< "=" >#< @decls.pp
  | SchemeDeriv     lhs     .   pp          =   "scheme"        >#< @scKind >#< @nm >#< ":" >#< @scDeriv >-< "=" >#< @decls.pp
  | Fmt             lhs     .   pp          =   "format"        >#< @fmKind >#< @matchExpr.pp >#< "=" >#< @expr.pp
  | ScmView         lhs     .   pp          =   "view"          >#< @nm >-< "=" >#< @decls.pp
  | RulView         lhs     .   pp          =   "view"          >#< @nm >-< "=" >#< (@pre.pp >-< "-" >-< @post.pp)
  | Rules           lhs     .   pp          =   "rules"         >#< @nm >#< "scheme" >#< @schemeNm >-< "=" >#< @decls.pp
  | RulesGroup      lhs     .   pp          =   "rulesgroup"    >#< @nm >#< "scheme" >#< @schemeNm >-< "=" >#< (vlist . map (\(rs,r) -> "rule" >#< rs >#< r) $ @rlNms)
  | Rule            lhs     .   pp          =   "rule"          >#< @nm >#< "viewsel" >#< pp @viewSel >-< "=" >#< @decls.pp
  | ViewHierarchy   lhs     .   pp          =   "viewhierarchy" >#< text (show @nmOrder)
  | ShpJudge        lhs     .   pp          =   "judgeshape"    >#< @expr.pp
  | ShpDel          lhs     .   pp          =   "judgeshape"    >#< "-" >#< ppCommas @fmKinds
  | Attr            lhs     .   pp          =   "hole"          >#< ("inh" >#< @inhs.pp >-< "i+s" >#< @inhsyns.pp >-< "syn" >#< @syns.pp)
  | Explain         lhs     .   pp          =   "explain"       >#< @mbNm >#< "=" >#< pp_parens @expr.pp

{-
SEM ViewSel
  | All             lhs     .   pp          =   pp "*"
  | View            lhs     .   pp          =   pp @nm
  | Range           lhs     .   pp          =   @vwFr.pp >#< ".." >#< @vwTo.pp

SEM ViewSels
  | Cons            lhs     .   pp          =   @hd.pp >|< "," >#< @tl.pp
-}

SEM RExpr
  | Judge           lhs     .   pp          =   "judge" >#< maybe empty (\n -> pp n >#< "=") @mbRNm >#< pp @schemeNm >#< @eqns.pp
  | Del             lhs     .   pp          =   "judge" >#< "-" >#< ppCommas @nms

SEM AttrIntro
  | Intro           lhs     .   pp          =   pp @props >#< pp @nm >#< ":" >#< pp @ty

SEM AttrEqn
  | Eqn             lhs     .   pp          =   "|" >#< pp @nm >#< "=" >#< @expr.pp

{-
-------------------------------------------------------------------------
-- ARule max column width info, for tabular like PP
-------------------------------------------------------------------------

ATTR AllARuleButARule [ mbDstWd: {Maybe (Int,Int)} | | mxDstNdWd, mxDstAtWd USE {`max`} {0}: Int ]

SEM ANm
  | Loc Lhs         lhs     .   mxDstNdWd   =   3
  | Wild            lhs     .   mxDstNdWd   =   0
  | Node            lhs     .   mxDstNdWd   =   length @ndStr
  | *               lhs     .   mxDstAtWd   =   length . show $ @nm

SEM ARule
  | Rule            loc     .   mbDstWd     =   Just (@eqns.mxDstNdWd,@eqns.mxDstAtWd)

SEM Expr
  | AVar            loc     .   mbDstWd     =   Nothing

SEM AEqnDest
  | Many            dests   .   mbDstWd     =   Nothing

-------------------------------------------------------------------------
-- ARule dest width info, for lining up multidestination AEqn
-------------------------------------------------------------------------

ATTR AEqnDest [ | | dstWd: Int ]
ATTR AEqnDests [ | | dstWdL: {[Int]} ]

SEM AEqnDest
  | Many            lhs     .   dstWd       =   sum @dests.dstWdL + length @dests.dstWdL + 1
  | One             lhs     .   dstWd       =   @anm.mxDstNdWd + @anm.mxDstAtWd + (if @anm.mxDstNdWd > 0 then 1 else 0)

SEM AEqnDests
  | Cons            lhs     .   dstWdL      =   @hd.dstWd : @tl.dstWdL
  | Nil             lhs     .   dstWdL      =   []

-------------------------------------------------------------------------
-- Kind of lhs of eqn, composite?
-------------------------------------------------------------------------

ATTR AEqnDest [ | | isComposite: Bool ]

SEM AEqnDest
  | Many            lhs     .   isComposite =   True
  | One             lhs     .   isComposite =   False

-------------------------------------------------------------------------
-- Node name of AEqnDest in an AEqn, for emitting only first of a series of same node names
-------------------------------------------------------------------------

ATTR ANm AEqnDest AEqn [ | | ndStr: String ]
ATTR ANm AEqnDest AEqn AEqns [ mbPrevNdStr: {Maybe String} | | ]

SEM ANm
  | Loc             loc     .   ndStr       =   strLoc
  | Lhs             loc     .   ndStr       =   if AtRetain `elem` @props then strLoc else strLhs
  | Node            loc     .   ndStr       =   show @ndNm
  | Fld Wild        loc     .   ndStr       =   ""

SEM AEqnDest
  | Many            lhs     .   ndStr       =   "??"

SEM AEqn
  | Err             lhs     .   ndStr       =   "??"

SEM AEqns
  | Cons            tl      .   mbPrevNdStr =   fmap (const @hd.ndStr) @lhs.mbDstWd

SEM ARule
  | Rule            loc     .   mbPrevNdStr =   Nothing

SEM AEqnDests
  | Cons            loc     .   mbPrevNdStr =   Nothing

SEM AEqnDest
  | Many            loc     .   mbPrevNdStr =   Nothing

SEM Expr
  | AVar            loc     .   mbPrevNdStr =   Nothing

-}

{-
-------------------------------------------------------------------------
-- Pretty printing, LaTeX, Expr
-------------------------------------------------------------------------

ATTR AGExprItf Expr [ | | ppLaTeX USE {>-<} {empty} : PP_Doc ]

SEM Expr
  | Int             loc     .   ppLaTeX     =   pp @int
  | StrText         loc     .   ppLaTeX     =   switchLaTeXLhs (mkMBox (text @str))
  | StrAsIs         loc     .   ppLaTeX     =   pp @str
  | App             loc     .   ppLaTeX     =   @lExpr.ppLaTeX >#< @rExpr.ppLaTeX
  | Op              loc     .   ppLaTeX     =   @lExpr.ppLaTeX >#< @nmExpr.ppLaTeX >#< @rExpr.ppLaTeX
  | LF              loc     .   ppLaTeX     =   @lExpr.ppLaTeX >#< switchLaTeXLhs (mkTexCmdUse "quad" empty) >#< @rExpr.ppLaTeX
  | SP              loc     .   ppLaTeX     =   let c = case @rExpr.exprKind of
                                                          EKNm n -> case show n of
                                                                      (c:_) | isAlpha c -> (>#<)
                                                                            | otherwise -> (>|<)
                                                                      _                 -> (>#<)
                                                          _      -> (>#<)
                                                in  @lExpr.ppLaTeX `c` @rExpr.ppLaTeX
  | Paren           loc     .   ppLaTeX     =   (if @lhs.needToParen then ppParens else id) @expr.ppLaTeX
  | Cnstr           loc     .   ppLaTeX     =   @expr.ppLaTeX
  | SelTop          loc     .   ppLaTeXSel  =   ppSelLaTeX (== nmVec) @expr.ppLaTeX (reverse @expr.selL)
                    loc     .   ppLaTeX     =   if @expr.exprKind == EKEmp then empty else @ppLaTeXSel
  | Sel             lhs     .   ppLaTeX     =   @expr.ppLaTeX
  | Var             loc     .   ppLaTeX     =   ppNmLaTeX . nmLhs2TeXSafe $ @nm
  | Wrap            loc     .   ppLaTeX     =   let wr o c e = switchLaTeXLhs (mkTexCmdUse (show o) empty) >#< e >#< switchLaTeXLhs (mkTexCmdUse (show c) empty)
                                                in  case Map.lookup @wrKind wrKindGam of
                                                      Just i -> wr (wkBegCmd i) (wkEndCmd i) @expr.ppLaTeX
                                                      _      -> @expr.ppLaTeX
  | ChildOrder      loc     .   ppLaTeX     =   @expr.ppLaTeX
  | Expr            lhs     .   ppLaTeX     =   ensureTeXMath . switchLaTeXLhs' $ @expr.ppLaTeX
  | Empty           loc     .   ppLaTeX     =   empty

-------------------------------------------------------------------------
-- Maybe Pretty printing, LaTeX
-------------------------------------------------------------------------

ATTR MbExpr [ | | mbPPLaTeX: {Maybe (Nm,PP_Doc)} ]

SEM MbExpr
  | Nothing         lhs     .   mbPPLaTeX   =   Nothing
  | Just            lhs     .   mbPPLaTeX   =   Just (@just.txt,@just.ppLaTeX)
-}

-------------------------------------------------------------------------
-- Just the text of a name
-------------------------------------------------------------------------

{-
ATTR Expr [ | | txt USE {`const`} {nmNone}: Nm ]

SEM Expr
  | Var             lhs     .   txt         =   @nm
  | StrText StrAsIs lhs     .   txt         =   Nm @str
  | App SelTop Op   lhs     .   txt         =   nmNone
-}

-------------------------------------------------------------------------
-- Selections info
-------------------------------------------------------------------------

{-
ATTR Expr [ | | selL: {[Maybe (Nm,PP_Doc)]}]

SEM Expr
  | Sel             lhs     .   selL        =   @selMbExpr.mbPPLaTeX : @expr.selL
  | * - Sel         lhs     .   selL        =   []
-}

-------------------------------------------------------------------------
-- Empty expr?
-------------------------------------------------------------------------

{-
{
data ExprKind = EKEmp | EKNm Nm | EKOther deriving Eq
}

ATTR Expr [ | | exprKind: ExprKind ]

SEM Expr
  | Empty           lhs     .   exprKind    =   EKEmp
  | Var             lhs     .   exprKind    =   EKNm @nm
  | Sel             lhs     .   exprKind    =   @expr.exprKind
  | * - Var Empty Sel AppTop Paren
                    lhs     .   exprKind    =   EKOther
-}

-------------------------------------------------------------------------
-- Need parenthesis
-------------------------------------------------------------------------

{-
ATTR MbExpr Expr [ needToParen: Bool | | ]

SEM Expr
  | Sel             selMbExpr   .   needToParen =   False
                    expr        .   needToParen =   case @selMbExpr.mbPPLaTeX of
                                                        Just (n,_) | n == nmVec
                                                          -> False
                                                        _ -> case @expr.exprKind of
                                                               EKNm _ -> False
                                                               _      -> @lhs.needToParen
  | Paren App Op SelTop SP
                    loc         .   needToParen =   True

SEM AGExprItf
  | AGItf           loc         .   needToParen =   True
  
SEM Decl
  | Fmt ShpJudge Explain
                    loc         .   needToParen =   True
  
SEM RExprEqn
  | Expr            loc         .   needToParen =   True

SEM AttrEqn
  | Eqn             loc         .   needToParen =   True
  
SEM AExpr
  | Expr            loc         .   needToParen =   True
    
SEM AEqn
  | Err             loc         .   needToParen =   True
-}  
