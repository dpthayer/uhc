% $Id$

%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell importable interface to eliminate 'Both' types
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4_1 hs import(EHCommon,EHTy,EHCnstr,EHSubstitutable) export(tyElimBoth)
%%]

%%[4_1.WRAPPER import(EHTyAbsSyn)
WRAPPER TyAGItf
%%]

%%[4_1 hs
tyElimBoth :: TyVarIdL -> Ty -> (Ty,Cnstr)
tyElimBoth elimTvL ty
  =  let  t =  wrap_TyAGItf
                 (sem_TyAGItf (TyAGItf_AGItf ty))
                 (Inh_TyAGItf {elimTvL_Inh_TyAGItf = elimTvL})
     in   (repl_Syn_TyAGItf t,cnstr_Syn_TyAGItf t)
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Tvars to eliminate
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4_1
ATTR AllAllTy TyAGItf [ elimTvL: TyVarIdL | | ]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Replacement
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4_1
ATTR AllAllTy [ | | repl: SELF  ]
ATTR TyAGItf  [ | | repl: Ty    ]

SEM Ty
  | Both            loc     .   replTv      =   mkTyVar @tv
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Unification of all binds
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4_1
ATTR AllAllTy [ | | replExpose: SELF  ]
ATTR AllAllTy [ | cnstr: Cnstr | ]
ATTR TyAGItf  [ | | cnstr: Cnstr ]

SEM Ty
  | Both            lhs     .   (replExpose,cnstr)
                                            =   if @tv `elem` @lhs.elimTvL
                                                then  case @tyL.replExpose of
                                                        []      ->  (@replTv,@lhs.cnstr)
                                                        (r:_)   ->  (r,(@tv `cnstrTyUnit` r) |=> @tyL.cnstr)
                                                else  let  r = Ty_Both @tv @tyL.replExpose
                                                      in   (r,@tyL.cnstr)
                    lhs     .   repl        =   if @tv `elem` @lhs.elimTvL then @replTv else @repl

SEM TyAGItf
  | AGItf           ty      .   cnstr       =   emptyCnstr
%%]
SEM Ty
  | Both            lhs     .   (replExpose,cnstr)
                                            =   if @tv `elem` @lhs.elimTvL
                                                then  case @tyL.replExpose of
                                                        []      ->  (@replTv,@lhs.cnstr)
                                                        (r:_)   ->  (r,(@tv `cnstrTyUnit` r) |=> @tyL.cnstr)
                                                else  let  r = Ty_Both @tv @tyL.replExpose
                                                      in   (r,@tyL.cnstr)
SEM Ty
  | Both            lhs     .   (replExpose,cnstr)
                                            =   case @tyL.replExpose of
                                                    []      ->  (@replTv,@lhs.cnstr)
                                                    (r:_)   ->  (r,(@tv `cnstrTyUnit` r) |=> @tyL.cnstr)

