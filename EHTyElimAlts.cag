% $Id$

%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell importable interface to check/elimination for/of inconsistent/ binds
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4_2 hs import(qualified Data.Set as Set,Data.List,EHCommon,EHOpts,EHTy,EHError,EHCnstr,EHSubstitutable,EHGam,EHTyFitsInCommon) export(tyElimAlts)
%%]

%%[4_2 hs import(EHDebug,UU.Pretty,EHErrorPretty)
%%]

%%[4_2 hs export(tyElimForgetAlts,cnstrElimForgetAlts)
%%]
 
%%[4_2.WRAPPER import(EHTyAbsSyn)
WRAPPER TyAGItf
%%]

%%[4_2.tyElimAlts hs
type FitsIn = FIOpts -> UID -> Ty -> Ty -> (Ty,Cnstr,ErrL)

tyElimAlts :: FitsIn -> FIOpts -> TyVarIdL -> UID -> Ty -> (Ty,Cnstr,ErrL)
tyElimAlts fitsIn fio globTvL uniq ty
  =  let  t =  wrap_TyAGItf
                 (sem_TyAGItf (TyAGItf_AGItf ty))
                 (Inh_TyAGItf {fitsIn_Inh_TyAGItf = fitsIn, fio_Inh_TyAGItf = fio, gUniq_Inh_TyAGItf = uniq, globTvL_Inh_TyAGItf = globTvL})
     in   (repl_Syn_TyAGItf t,tyCnstr_Syn_TyAGItf t,errL_Syn_TyAGItf t)

tyElimForgetAlts :: Ty -> (Ty,Set.Set TyVarId)
tyElimForgetAlts ty
  =  let  t =  wrap_TyAGItf
                 (sem_TyAGItf (TyAGItf_AGItf ty))
                 (Inh_TyAGItf {fitsIn_Inh_TyAGItf = undefined, fio_Inh_TyAGItf = undefined, gUniq_Inh_TyAGItf = undefined, globTvL_Inh_TyAGItf = []})
     in   (replNoAlt_Syn_TyAGItf t,ambTvS_Syn_TyAGItf t)

cnstrElimForgetAlts :: Cnstr -> (Cnstr,Set.Set TyVarId)
cnstrElimForgetAlts c
  = (c'',s)
  where  (c',s) = cnstrMapThrTy  (\_ t s -> let (t',s') = tyElimForgetAlts t in (t',s `Set.union` s')) Set.empty c
         c'' = cnstrDelAlphaRename c'
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% fitsIn, parameterized with env+opts, passed as param to avoid mutual module recursion
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4_2
ATTR TyAGItf AllAllTy [ fitsIn: FitsIn | | ]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Global tvars (no elim allowed)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4_2
ATTR TyAGItf AllAllTy [ globTvL: TyVarIdL | | ]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Other flags: is it a meet?
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4_2
ATTR TyAGItf AllAllTy [ fio: FIOpts | | ]

SEM Ty
  | Quant           ty      .   fio         =   @lhs.fio {fioDontBind = @tv : fioDontBind @lhs.fio}
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Uniq
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4_2
ATTR TyAGItf [ gUniq: UID | | ]
ATTR AllAllTy [ | gUniq: UID | ]

SEM TyPlusL
  | Cons            (hd.gUniq,loc.lUniq)    =   mkNewLevUID @lhs.gUniq

SEM Ty
  | Alts            (tyL.gUniq,loc.lUniq,loc.lUniq2,loc.lUniq3,loc.lUniq4)
                                            =   mkNewLevUID4 @lhs.gUniq
  | Var             (lhs.gUniq,loc.lUniq)   =   mkNewUID @lhs.gUniq
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Has quantifier inside
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4_2
ATTR AllTy [ | | hasHardTy USE {||} {False}: Bool ]

SEM Ty
  | Quant           lhs     .   hasHardTy   =   True

SEM TyPlus
  | Ty              lhs     .   hasHardTy   =   @hardness == TyHard || @ty.hasHardTy
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Check/elim
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4_2
ATTR AllAllTy [ | | repl: SELF  ]
ATTR TyAGItf  [ | | repl: Ty    ]
%%]

%%[4_2 hs
fitAlts :: FitsIn -> FIOpts -> UID -> Ty -> TyL -> (Ty,Cnstr,ErrL)
fitAlts elimFits fio u startTy tL
  =  let  (t,c,e,_)
            =  foldr  (\t1 (t2,c2,e2,u2) 
                          ->  let  (u',u1) = mkNewLevUID u2
                                   (t,c,e) = elimFits fio u1 t2 t1
                              in   if null e && null e2 then (t,c |=> c2,[],u') else (Ty_Any,emptyCnstr,if null e then e2 else e,u)
                      )
                      (startTy,emptyCnstr,[],u) tL
     in   (t,c,e)
%%]
                              in   tr "XX" (pp t2 >#< fioMode fio >#< pp t1 >-< "res=" >#< pp t >-< "cnstr=" >#< ppCnstrV c >-< ppErrL e)
                                     (if null e && null e2 then (t,c |=> c2,[],u') else (Ty_Any,emptyCnstr,if null e then e2 else e,u)
                                     )
                              in   if null e && null e2 then (t,c |=> c2,[],u') else (Ty_Any,emptyCnstr,if null e then e2 else e,u)

%%[4_2
SEM Ty
  | Alts            loc     .   (repl,quTyCnstr,errL)
                                            =   case cnstrTyLookup @tv @lhs.tyCnstr of
                                                    Nothing | @tv `notElem` @lhs.globTvL
                                                        ->  if null @tyL.yesQuTyL
                                                            then  (mkTyVar @tv,@tv `cnstrTyUnit` mkTyVar @tv,[])
                                                            else  let  (ht,hc,he) = fitAlts @lhs.fitsIn (@lhs.fio {fioBindToTyAlts = True}) @lUniq Ty_Any (@tyL.yesQuTyL)
                                                                  in   if null he
                                                                       then  let  (st,sc,se) = fitAlts @lhs.fitsIn (@lhs.fio {fioBindToTyAlts = True}) @lUniq2 ht (hc |=> @tyL.noQuTyL)
                                                                                  mkTvCnstr t = @tv `cnstrTyUnit` t
                                                                                  (eat,eac) = if null se then (st,emptyCnstr) else (ht,emptyCnstr)
                                                                                  (t,c,e) = tyElimAlts @lhs.fitsIn @lhs.fio @lhs.globTvL @lUniq3 eat
                                                                             in   (t,mkTvCnstr t |=> c |=> eac |=> hc,e)
                                                                       else  (mkTyVar @tv
                                                                             ,@tv `cnstrTyUnit` Ty_Any
                                                                             ,[Err_InconsistentAlts @lhs.selfRepl @tv @tyL.yesQuTyL (fioMode @lhs.fio)]
                                                                             )
                                                    Just t
                                                        ->  (t,emptyCnstr,[])
                                                    _   ->  (@self,emptyCnstr,[])
  | Quant           lhs     .   repl        =   mkTyQu @qu.self ([@tv] `intersect` ftv @ty.repl) @ty.repl
%%]
                                                                                  (eat,eac) = if null se then (st,tr "ZZ" (ppCnstrV sc) emptyCnstr) else (ht,emptyCnstr)
SEM Ty
  | Alts            loc     .   (repl,quTyCnstr,errL)
                                            =   case cnstrTyLookup @tv @lhs.tyCnstr of
                                                    Nothing | @tv `notElem` @lhs.globTvL
                                                        ->  if null @tyL.yesQuTyL
                                                            then  (mkTyVar @tv,@tv `cnstrTyUnit` mkTyVar @tv,[])
                                                            else  let  (ht,hc,he) = fitAlts @lhs.fitsIn (@lhs.fio {fioBindToTyAlts = True}) @lUniq Ty_Any (@tyL.yesQuTyL)
                                                                  in   if null he
                                                                       then  let  (st,_,se) = fitAlts @lhs.fitsIn (@lhs.fio {fioBindToTyAlts = True}) @lUniq2 ht (hc |=> @tyL.noQuTyL)
                                                                                  mkTvCnstr t = @tv `cnstrTyUnit` t
                                                                                  (t,c,e) = tyElimAlts @lhs.fitsIn @lhs.fio @lhs.globTvL @lUniq3 (if null se then st else ht)
                                                                             in   (t,mkTvCnstr t |=> c |=> hc,e)
                                                                       else  (mkTyVar @tv
                                                                             ,@tv `cnstrTyUnit` Ty_Any
                                                                             ,[Err_InconsistentAlts @lhs.selfRepl @tv @tyL.yesQuTyL (fioMode @lhs.fio)]
                                                                             )
                                                    Just t
                                                        ->  (t,emptyCnstr,[])
                                                    _   ->  (@self,emptyCnstr,[])
  | Quant           lhs     .   repl        =   mkTyQu @qu.self ([@tv] `intersect` ftv @ty.repl) @ty.repl
SEM Ty
  | Alts            loc     .   (repl,quTyCnstr,errL,internErrL)
                                            =   case cnstrTyLookup @tv @lhs.tyCnstr of
                                                    Nothing | @tv `notElem` @lhs.globTvL
                                                        ->  if null @tyL.yesQuTyL
                                                            then  (mkTyVar @tv,@tv `cnstrTyUnit` mkTyVar @tv,[],[])
                                                            else  let  (ht,hc,he) = fitAlts @lhs.fitsIn (@lhs.fio {fioBindToTyAlts = True}) @lUniq Ty_Any (@tyL.yesQuTyL)
                                                                  in   if null he
                                                                       then  let  (st,sc,se) = fitAlts @lhs.fitsIn (@lhs.fio {fioBindToTyAlts = True}) @lUniq2 ht (hc |=> @tyL.noQuTyL)
                                                                                  mkTvCnstr t = @tv `cnstrTyUnit` t
                                                                             in   if null se
                                                                                  then  let (t,c,e,ie) = tyElimAlts @lhs.fitsIn @lhs.fio @lhs.globTvL @lUniq3 st
                                                                                        in  if null e && null ie
                                                                                            then (t,mkTvCnstr t |=> c |=> sc |=> hc,[],[])
                                                                                            else (ht,mkTvCnstr ht |=> hc,[],e++ie)
                                                                                  else  (ht,mkTvCnstr ht |=> hc,se,[])
                                                                       else  (mkTyVar @tv
                                                                             ,@tv `cnstrTyUnit` Ty_Any
                                                                             ,[Err_InconsistentAlts @lhs.selfRepl @tv @tyL.yesQuTyL (fioMode @lhs.fio)]
                                                                             ,[]
                                                                             )
                                                    Just t
                                                        ->  (t,emptyCnstr,[],[])
                                                    _   ->  (@self,emptyCnstr,[],[])
  | Quant           lhs     .   repl        =   mkTyQu @qu.self ([@tv] `intersect` ftv @ty.repl) @ty.repl
SEM Ty
  | Alts            loc     .   (repl,errL,quTyCnstr)
                                            =   case cnstrTyLookup @tv @lhs.tyCnstr of
                                                    Nothing | @tv `notElem` @lhs.globTvL
                                                        ->  if null @tyL.yesQuTyL
                                                            then  (mkTyVar @tv,[],@tv `cnstrTyUnit` mkTyVar @tv)
                                                            else  let  (ht,hc,he) = fitAlts @lhs.fitsIn (@lhs.fio {fioBindToTyAlts = True}) @lUniq Ty_Any (@tyL.yesQuTyL)
                                                                  in   if null he
                                                                       then  let  (st,_,se) = fitAlts @lhs.fitsIn (@lhs.fio {fioBindToTyAlts = True}) @lUniq2 ht (hc |=> @tyL.noQuTyL)
                                                                                  (t,c,e) = tyElimAlts @lhs.fitsIn @lhs.fio @lhs.globTvL @lUniq3 (if null se then st else ht)
                                                                             in   (t,e,(@tv `cnstrTyUnit` t) |=> c |=> hc)
                                                                       else  (mkTyVar @tv
                                                                             ,[Err_InconsistentAlts @lhs.selfRepl @tv @tyL.yesQuTyL (fioMode @lhs.fio)]
                                                                             ,@tv `cnstrTyUnit` Ty_Any
                                                                             )
                                                    Just t
                                                        ->  (t,[],emptyCnstr)
                                                    _   ->  (@self,[],emptyCnstr)
  | Quant           lhs     .   repl        =   mkTyQu @qu.self ([@tv] `intersect` ftv @ty.repl) @ty.repl

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Errors
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4_2
ATTR TyAGItf AllAllTy [ | | errL USE {++} {[]}: ErrL ]

SEM Ty
  | Alts            lhs     .   errL        =   @errL
%%]
ATTR TyAGItf AllAllTy [ | | errL, internErrL USE {++} {[]}: ErrL ]

SEM Ty
  | Alts            lhs     .   errL        =   @errL
                            .   internErrL  =   @internErrL

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Gathering of yes/not quant types
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4_2
ATTR TyPlusL [ | | yesQuTyL: TyL ^^^ noQuTyL: TyL ]

SEM TyPlusL
  | Cons            lhs     .   (yesQuTyL,noQuTyL)
                                            =   if @hd.hasHardTy
                                                then (tyPlusTy @hd.self : @tl.yesQuTyL, @tl.noQuTyL)
                                                else (@tl.yesQuTyL, tyPlusTy @hd.self : @tl.noQuTyL)
  | Nil             lhs     .   yesQuTyL    =   []
                            .   noQuTyL     =   []
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Unification of all binds
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4_2
ATTR AllAllTy [ | tyCnstr: Cnstr | ]
ATTR TyAGItf  [ | | tyCnstr: Cnstr ]

SEM TyAGItf
  | AGItf           ty      .   tyCnstr     =   emptyCnstr

SEM Ty
  | Alts            loc     .   tyCnstr     =   @quTyCnstr `cnstrPlus` @lhs.tyCnstr
                    lhs     .   tyCnstr     =   @tyCnstr
%%]
                    lhs     .   tyCnstr     =   @tyCnstr
                    lhs     .   tyCnstr     =   tr "YY" ("ty=" >#< pp @self >-< "l.cnstr=" >#< ppCnstrV @lhs.tyCnstr >-< "cnstr=" >#< ppCnstrV @quTyCnstr >-< "err=" >#< ppErrL @errL) @tyCnstr
                    lhs     .   tyCnstr     =   tr "YY" ("ty=" >#< pp @self >-< "cnstr=" >#< ppCnstrV @tyCnstr >-< "err=" >#< ppErrL @errL) @tyCnstr
                    lhs     .   tyCnstr     =   tr "YY" ("ty=" >#< pp @self >-< "cnstr=" >#< ppCnstrV @tyCnstr >-< "err=" >#< ppErrL @errL >-< "ierr=" >#< ppErrL @internErrL) @tyCnstr

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Replacement of free tvars with fresh ones (alpha rename)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4_2
%%]
ATTR AllTy [ boundTvS: {Set.Set TyVarId} | | ]

SEM TyAGItf
  | AGItf           ty      .   boundTvS    =   Set.empty

SEM Ty
  | Quant           ty      .   boundTvS    =   @tv `Set.insert` @lhs.boundTvS
  | Var             loc     .   tvNew       =   @lUniq

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Tvars which arise from alts with >1 (i.e. ambiguous) bindings
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4_2
ATTR AllTy TyAGItf [ | | ambTvS USE {`Set.union`} {Set.empty}: {Set.Set TyVarId} ]

SEM Ty
  | Alts            lhs     .   ambTvS      =   if length @tyL.yesQuTyL + length @tyL.noQuTyL > 1
                                                then Set.singleton @tv
                                                else @tyL.ambTvS
%%]
SEM Ty
  | Alts            lhs     .   ambTvS      =   @tyL.ambTvS `Set.union`
                                                    (if length @tyL.yesQuTyL + length @tyL.noQuTyL > 1
                                                     then Set.singleton @tv
                                                     else Set.empty
                                                    )

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Full alts removal
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4_2
ATTR TyAGItf [ | | replNoAlt: Ty ]
ATTR AllAllTy [ | | replNoAlt: SELF ]

SEM Ty
  | Alts            lhs     .   replNoAlt   =   mkTyVar @tv
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Orig type
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4_2
ATTR AllAllTy [ | | self: SELF ]
%%]
ATTR AllAllTy [ | | selfTvRen: SELF ]

SEM Ty
  | Var             lhs     .   selfTvRen   =   if @tv `Set.member` @lhs.boundTvS then @selfTvRen else Ty_Var @tvNew @categ.selfTvRen

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Replacement type passed back inside
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4_2
ATTR AllTy [ selfRepl: Ty | | ]

SEM TyAGItf
  | AGItf           ty      .   selfRepl    =   @ty.repl
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% App spine info, coco variance
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4_2
ATTR Ty [ | | appSpineInfoL: {[AppSpineInfo]} ]

SEM Ty
  | Con             lhs     .   appSpineInfoL       =   asGamLookup appSpineGam @nm
  | App             (loc.asi,lhs.appSpineInfoL)     =   hdAndTl @func.appSpineInfoL
  | * - Con App     lhs     .   appSpineInfoL       =   unknownAppSpineInfoL

SEM Ty
  | App             arg     .   fio                 =   fioSwapCoCo (asCoCo @asi) @lhs.fio
%%]

