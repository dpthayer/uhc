% $Id$

%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell importable interface to check/elimination for/of inconsistent/ binds
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4_1 hs import(EHCommon,EHOpts,EHTy,EHError,EHCnstr,EHSubstitutable,EHGam,EHTyFitsInCommon) export(tyElimAlts)
%%]

%%[4_1 hs import(EHDebug,UU.Pretty,EHErrorPretty)
%%]

%%[4_2 hs import(Set)
%%]

%%[4_1.WRAPPER import(EHTyAbsSyn)
WRAPPER TyAGItf
%%]

%%[4_2.tyElimAlts hs
type FitsIn = FIOpts -> UID -> Ty -> Ty -> (Ty,Cnstr,ErrL)

tyElimAlts :: FitsIn -> FIOpts -> TyVarIdL -> UID -> Ty -> (Ty,Cnstr,ErrL)
tyElimAlts fitsIn fio globTvL uniq ty
  =  let  t =  wrap_TyAGItf
                 (sem_TyAGItf (TyAGItf_AGItf ty))
                 (Inh_TyAGItf {fitsIn_Inh_TyAGItf = fitsIn, fio_Inh_TyAGItf = fio, gUniq_Inh_TyAGItf = uniq, globTvL_Inh_TyAGItf = globTvL})
     in   (repl_Syn_TyAGItf t,tyCnstr_Syn_TyAGItf t,errL_Syn_TyAGItf t)
%%]

%%[4_3.tyElimAlts hs
type FitsIn = FIOpts -> UID -> Ty -> Ty -> (Ty,Cnstr,ErrL)

tyElimAlts :: FitsIn -> FIOpts -> UID -> Ty -> (Ty,Cnstr,ErrL)
tyElimAlts fitsIn fio uniq ty
  =  let  t =  wrap_TyAGItf
                 (sem_TyAGItf (TyAGItf_AGItf ty))
                 (Inh_TyAGItf {fitsIn_Inh_TyAGItf = fitsIn, fio_Inh_TyAGItf = fio, gUniq_Inh_TyAGItf = uniq})
     in   (repl_Syn_TyAGItf t,tyCnstr_Syn_TyAGItf t,errL_Syn_TyAGItf t)
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% fitsIn, parameterized with env+opts, passed as param to avoid mutual module recursion
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4_1
ATTR TyAGItf AllAllTy [ fitsIn: FitsIn | | ]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Global tvars (no elim allowed)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4_2
ATTR TyAGItf AllAllTy [ globTvL: TyVarIdL | | ]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Other flags: is it a meet?
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4_1
ATTR TyAGItf AllAllTy [ fio: FIOpts | | ]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Uniq
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4_1
ATTR TyAGItf [ gUniq: UID | | ]
ATTR AllAllTy [ | gUniq: UID | ]

SEM TyPlusL
  | Cons            (hd.gUniq,loc.lUniq)    =   mkNewLevUID @lhs.gUniq

SEM Ty
  | Alts            (tyL.gUniq,loc.lUniq)   =   mkNewLevUID @lhs.gUniq
%%]

%%[4_2
SEM Ty
  | Var             (lhs.gUniq,loc.lUniq)   =   mkNewUID @lhs.gUniq
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Has quantifier inside
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4_2
ATTR AllTy [ | | hasQu USE {||} {False}: Bool ]

SEM Ty
  | Quant           lhs     .   hasQu       =   True
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Check/elim
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4_1
ATTR AllAllTy [ | | repl: SELF  ]
ATTR TyAGItf  [ | | repl: Ty    ]
%%]

%%[4_2
SEM Ty
  | Alts            loc     .   (repl,quTyCnstr)
                                            =   case cnstrTyLookup @tv @lhs.tyCnstr of
                                                    Nothing | @tv `notElem` @lhs.globTvL
                                                        ->  if null @tyL.errL && @tyL.hasQu
                                                            then  let  (t,c,_) = tyElimAlts @lhs.fitsIn @lhs.fio @lhs.globTvL @lUniq @tyL.quTy
                                                                  in   (t,(@tv `cnstrTyUnit` t) `cnstrPlus` c)
                                                            else (mkTyVar @tv,emptyCnstr)
                                                    Just t
                                                        ->  (t,emptyCnstr)
                                                    _   ->  (@self,emptyCnstr)
                            .   errL        =   []
                    lhs     .   tyCnstr     =   @quTyCnstr `cnstrPlus` @lhs.tyCnstr
%%]

%%[4_3
SEM Ty
  | Alts            (loc.repl,loc.errL,loc.iCnstr)
                                            =   case cnstrTyLookup @tv @lhs.tyCnstr of
                                                    Just t
                                                        ->  (t,[],emptyCnstr)
                                                    _   ->  let  (t,ci,e) = tyElimAlts @lhs.fitsIn @lhs.fio @lUniq @tyL.resTy
                                                            in   if @tyL.canMeet && null e
                                                                 then  (t,[],ci)
                                                                 else  (mkTyVar @tv
                                                                       ,if null e then [Err_InconsistentAlts @lhs.selfRepl @tv (map tyPlusTy @tyL.replL) (fioMode @lhs.fio)] else e
                                                                       ,@tv `cnstrTyUnit` mkTyVar @tv)
                    lhs     .   tyCnstr     =   @iCnstr |=> @tyL.tyCnstr
%%]

%%[4_3
ATTR TyPlusL [ | | replL: TyPlusL ]

SEM TyPlusL
  | Cons            lhs     .   replL       =   @hd.repl : @tl.replL
  | Nil             lhs     .   replL       =   []
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Errors
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4_1
ATTR TyAGItf AllAllTy [ | | errL USE {++} {[]}: ErrL ]
%%]

%%[4_3
SEM Ty
  | Alts            lhs     .   errL        =   @errL ++ @tyL.errL

SEM TyAGItf
  | AGItf           lhs     .   errL        =   @ty.errL
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Unification of all binds
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4_1
ATTR AllAllTy [ | tyCnstr: Cnstr | ]
ATTR TyAGItf  [ | | tyCnstr: Cnstr ]

SEM TyAGItf
  | AGItf           ty      .   tyCnstr     =   emptyCnstr
%%]

%%[4_2
ATTR TyPlusL [ | | quTy: Ty ]

SEM TyPlusL
  | Cons            loc     .   (quTy,_,errL)
                                            =   if null @tl.errL && @hd.hasQu
                                                then @lhs.fitsIn @lhs.fio @lUniq @tl.quTy (tyPlusTy @hd.selfTvRen)
                                                else (@tl.quTy,emptyCnstr,@tl.errL)
  | Nil             lhs     .   quTy        =   Ty_Any
%%]

%%[4_3
ATTR TyPlusL [ ty: Ty | | resTy: Ty ]
ATTR TyPlusL [ | | canMeet: Bool ]

SEM TyPlusL
  | Cons            loc     .   (ty,cnstr,errL)
                                            =   @lhs.fitsIn @lhs.fio @lUniq @lhs.ty (@lhs.tyCnstr |=> tyPlusTy @hd.self)
                    tl      .   ty          =   @ty
                            .   tyCnstr     =   @cnstr |=> @lhs.tyCnstr
                    lhs     .   (resTy,tyCnstr,canMeet)
                                            =   if null @errL
                                                then (@tl.resTy,@tl.tyCnstr,@tl.canMeet)
                                                else (@lhs.ty,@lhs.tyCnstr,False)
  | Nil             lhs     .   resTy       =   @lhs.ty
                            .   canMeet     =   True

SEM Ty
  | Alts            tyL     .   ty          =   Ty_Any
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Replacement of free tvars with fresh ones (alpha rename)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4_2
ATTR AllTy [ boundTvS: {Set TyVarId} | | ]

SEM TyAGItf
  | AGItf           ty      .   boundTvS    =   emptySet

SEM Ty
  | Quant           ty      .   boundTvS    =   @lhs.boundTvS `addToSet` @tv
  | Var             loc     .   tvNew       =   @lUniq
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Orig type
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4_2
ATTR AllAllTy [ | | selfTvRen: SELF ]
ATTR AllAllTy [ | | self: SELF ]

SEM Ty
  | Var             lhs     .   selfTvRen   =   if @tv `elementOf` @lhs.boundTvS then @selfTvRen else Ty_Var @tvNew @categ.selfTvRen
%%]

%%[4_3
ATTR AllAllTy [ | | self: SELF ]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Replacement type passed back inside
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4_3
ATTR AllTy [ selfRepl: Ty | | ]

SEM TyAGItf
  | AGItf           ty      .   selfRepl    =   @ty.repl
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% App spine info, coco variance
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4_1
ATTR Ty [ | | appSpineInfoL: {[AppSpineInfo]} ]

SEM Ty
  | Con             lhs     .   appSpineInfoL       =   asGamLookup @nm appSpineGam
  | App             (loc.asi,lhs.appSpineInfoL)     =   hdAndTl @func.appSpineInfoL
  | * - Con App     lhs     .   appSpineInfoL       =   unknownAppSpineInfoL

SEM Ty
  | App             arg     .   fio                 =   fioSwapCoCo (asCoCo @asi) @lhs.fio
%%]

