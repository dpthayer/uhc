-------------------------------------------------------------------------
-- Shared
-------------------------------------------------------------------------

include EhcRulesShared2

-------------------------------------------------------------------------
-- Ty alternative elimination
-------------------------------------------------------------------------

ruleset tyAltTyElim scheme tyAltTyElim viewsel I2 - * "Type alternative elimination" =
  rule ty.ae.alts =
    view I2 =
      judge C : bind1TyVarToTy = tyCnstr === [tvarv :-> ty]
      judge NE : notIsEmpty = `|` (ty.thardH.._, ty.Qu.._) `|` > 0
      judge EQ : eqRLTy = (tvarv [ talt..._ ]) =<= ity
      judge tysH : tyAltSelect = ty.thardH.._ === talt..._ , ty, thardH, tneed
      judge tysS : tyAltSelect = ty.thardS.._ === talt..._ , ty.nQu, thardS, tneed
      judge tysQ : tyAltSelect = ty.Qu.._ === talt..._ , ty.Qu, thardS, tneed
      judge H : match = fiopt :- ((ty.thardH.._, ty.Qu.._)) <=>.(<=>) ANY : ity.thardH ~> ityCnstr.h
      judge S : match = fiopt :- (ityCnstr.h ty.thardS.._) <=>.(<=>) ity.thardH : ity.thardS ~> _
      judge AE : tyAltTyElim = fiopt ; ityCnstr.in; tvarv.g.._ :- ity.thardS : ty ~> tyCnstr.e
      judge need : fioptMkNeed = tneed === fiopt
      judge glob : notElemTyVarIdS = tvarv `notElem` tvarv.g.._
      ---
      judge R : tyAltTyElim = fiopt ; ityCnstr.in; tvarv.g.._ :- ity : ty ~> (tyCnstr tyCnstr.e)

  rule ty.ae.var =
    view I2 =
      judge P : tyAltPartition = (tvarv [ _ ]) === ity
      judge glob : notElemTyVarIdS = tvarv `notElem` tvarv.g.._
      ---
      judge R : tyAltTyElim = fiopt ; ityCnstr.in; tvarv.g.._ :- ity : tvarv ~> emptyCnstr

  rule ty.ae.ty =
    view I2 =
      ---
      judge R : tyAltTyElim = fiopt ; ityCnstr.in; tvarv.g.._ :- ty : ty ~> emptyCnstr

  rule ty.ae.arrow =
    view I2 =
      judge Res : tyAltTyElim = fiopt ; ityCnstr.in; tvarv.g.._ :- ity.r : ty.r ~> tyCnstr.r
      judge Arg : tyAltTyElim = fiopt.a ; ityCnstr.in; tvarv.g.._ :- ity.a : ty.a ~> tyCnstr.a
      judge S : fioptSwapMeetJoin = fiopt.a === fiopt
      ---
      judge R : tyAltTyElim = fiopt ; ityCnstr.in; tvarv.g.._ :- (ity.a -> ity.r) : (ty.a -> ty.r) ~> (tyCnstr.a tyCnstr.r)

-------------------------------------------------------------------------
-- Gam Ty alternative elimination
-------------------------------------------------------------------------

ruleset valElimExprAlts scheme valElimExprAlts viewsel I2 - * "Type alternative elimination (for a |Gamma|)" =
  rule g.ae.cons =
    view I2 =
      judge G : valElimExprAlts = fiopt ; ityCnstr.in; tvarv.g.._ :- (ityCnstr.a valGam) : ityCnstr.g
      judge A : tyAltTyElim = fiopt ; ityCnstr.in; tvarv.g.._ :- ityCnstr.in ity : _ ~> ityCnstr.a
      ---
      judge R : valElimExprAlts = fiopt ; ityCnstr.in; tvarv.g.._ :- ((_ :-> ity, valGam)) : (ityCnstr.g ityCnstr.a)

-------------------------------------------------------------------------
-- 'Both' alternative elimination
-------------------------------------------------------------------------

ruleset tyBtTyElim scheme tyBtTyElim viewsel I2 - * "Type `both' elimination" =
  rule ty.eb.any =
    view I2 =
      judge E : tvarsHasTvar = tvarv `elem` bv
      ---
      judge R : tyBtTyElim = bv :- (tvarv /=/ ANY) : tvarv ~> tvarv; ([])

  rule ty.eb.var =
    view I2 =
      judge T : tyBtTyElim = bv :- ty.b : ty ~> tvarv.e ; tyCnstr
      judge E : tvarsHasTvar = tvarv `elem` bv
      ---
      judge R : tyBtTyElim = bv :- (tvarv /=/ ty.b) : tvarv ~> tvarv; ([tvarv.e :-> tvarv] tyCnstr)

  rule ty.eb.ty =
    view I2 =
      judge T : tyBtTyElim = bv :- ty.b : ty ~> ty.e ; tyCnstr
      judge E : tvarsHasTvar = tvarv `elem` bv
      ---
      judge R : tyBtTyElim = bv :- (tvarv /=/ ty.b) : tvarv ~> ty.e ; ([tvarv :-> ty.e] tyCnstr)

