imports
{
import System
import GetOpt
import Maybe
import Char
import IO
import List
import FiniteMap
import FPath
import Utils
import PPUtils
import UU.Pretty
import UU.Parsing
import UU.Parsing.Offside
import UU.Scanner
import UU.Scanner.Position( initPos, Pos )
import UU.Scanner.GenToken
}

{
-------------------------------------------------------------------------
-- Main
-------------------------------------------------------------------------

main :: IO ()
main
  = do { args <- getArgs
       ; let oo@(o,n,errs)  = getOpt Permute cmdLineOpts args
             opts           = foldr ($) defaultOpts o
       ; if optHelp opts
         then putStrLn (usageInfo "Usage: brew [options] [file]\n\noptions:" cmdLineOpts)
         else if null errs
              then  doCompile (if null n then emptyFPath else mkFPath (head n)) opts
              else  putStr (head errs)
       }

doCompile :: FPath -> Opts -> IO ()
doCompile fp opts
  = do { (fn,fb,fh)
             <- if fpathIsEmpty fp
                then return ("<stdin>","<stdin>",stdin)
                else do { let fn = fpathToStr fp
                        ; h <- openFile fn ReadMode
                        ; return (fn,fpathToStr (fpathRemoveSuff fp),h)
                        }
       ;  tokens <- offsideScanHandle fn fh
       ;  let steps = parseOffside (pAGItf) tokens
       ;  (pres,_) <- evalStepsIO show steps
       ;  let res = wrap_AGItf pres (Inh_AGItf {opts_Inh_AGItf = opts})
       ;  putStrLn (disp (pp_Syn_AGItf res)  200 "")
       }

offsideScanHandle fn fh
  = do  {  tokens <- scanHandle keywordsText keywordsOps specialChars opChars fn fh
        ;  return (scanOffside moduleT oBrace cBrace triggers tokens)
        }
  where   moduleT   = reserved "let" noPos
          oBrace    = reserved "{" noPos
          cBrace    = reserved "}" noPos
          triggers  = [ reserved x noPos | x <- offsideTrigs ]

instance Position (Maybe Token) where
  line    =  maybe (-1)  (line.position) 
  column  =  maybe (-1)  (column.position)
  file    =  maybe ""    (file.position)

-------------------------------------------------------------------------
-- Options
-------------------------------------------------------------------------

data Opts 
  = Opts
      { optLaTeX        :: Bool
      , optHelp         :: Bool
      , optWrapLhs2tex  :: Bool
      }

defaultOpts
  = Opts
      { optLaTeX        =  False
      , optHelp         =  False
      , optWrapLhs2tex  =  True
      }

cmdLineOpts  
  =  [  Option "l"  ["latex"]     (NoArg oLaTeX)
          "generate code for latex, default=no"
     ,  Option ""   ["help"]      (NoArg oHelp)
          "output this help"
     ,  Option ""   ["lhs2tex"]   (OptArg oLhs2tex "yes|no")
          "wrap chunks in lhs2tex's code environment, default=yes (not implemented)"
     ]
  where  oLaTeX          o =  o {optLaTeX = True}
         oLhs2tex    ms  o =  yesno (\f o -> o {optWrapLhs2tex = f}) ms o
         oHelp           o =  o {optHelp = True}
         yesno updO  ms  o =  case ms of
                                Just "yes"  -> updO True o
                                Just "no"   -> updO False o
                                _           -> o


-------------------------------------------------------------------------
-- Scanning
-------------------------------------------------------------------------

offsideTrigs  =  [ "let", "of" ]

specialChars  =  "().{}[],$"
opChars       =  "+->="

keywordsText  =  [ "in", "case", "if", "then", "else" ] ++ offsideTrigs
keywordsOps   =  [ "=", "->", "\\\\", "++" ]

scanHandle :: [String] -> [String] -> String -> String -> FilePath -> Handle -> IO [Token]
scanHandle keywordstxt keywordsops specchars opchars fn fh
  = do  {  txt <- hGetContents fh
        ;  return (scan keywordstxt keywordsops specchars opchars (initPos fn) txt) 
        }

-------------------------------------------------------------------------
-- Basic structures
-------------------------------------------------------------------------

data Name = Nm String deriving (Show,Eq,Ord)

instance PP Name where
  pp (Nm s) = pp s

-------------------------------------------------------------------------
-- Value
-------------------------------------------------------------------------

data Value
  = ValNm       Name
  | ValList     [Value]
  | ValRec      (FiniteMap Name Value)
  | ValApp      Name [Name] Value
  deriving Eq

emptyValue :: Value
emptyValue = ValList []

instance Show Value where
  show _ = "Value"

instance PP Value where
  pp (ValNm n)          = pp n
  pp (ValList l)        = ppListSep "[" "]" " " l
  pp (ValRec m)         = ppListSep "{" "}" ", " . map (\(k,v) -> pp k >|< "=" >|< pp v) . fmToList $ m
  pp (ValApp f m a)     = pp f >#< pp a >#< "-" >#< ppListSep "{" "}" "," m

-------------------------------------------------------------------------
-- Value Graph
-------------------------------------------------------------------------

type VGKey = Name

data VGNode
  = NodeNm      Name
  | NodeFile    Name
  | NodeDeriv   {ndLam :: Name, ndArgs :: Value, ndRes :: Value, ndDependsOn :: [VGKey] }

instance Show VGNode where
  show _ = "VGNode"

instance PP VGNode where
  pp (NodeNm n)             = "N:" >|< pp n
  pp (NodeFile n)           = "F:" >|< pp n
  pp (NodeDeriv f a r ds)   = "D:" >|< pp f >#< pp a >#< "->" >#< pp r >#< "<-" >#< ppListSep "[" "]" " " ds

data ValGraph
  = ValGraph
        { vgKeyToNode :: FiniteMap VGKey VGNode
        }

emptyVG :: ValGraph
emptyVG = ValGraph emptyFM

-------------------------------------------------------------------------
-- Run state
-------------------------------------------------------------------------

data RunState
  = RunState
        { rsValGraph :: ValGraph
        }

emptyRS :: RunState
emptyRS = RunState emptyVG

-------------------------------------------------------------------------
-- Parser
-------------------------------------------------------------------------

type BrParser         ep    =    (IsParser (OffsideParser i o Token p) Token,InputState i Token p, OutputState o, Position p)
                                    => OffsideParser i o Token p ep

pAGItf :: BrParser T_AGItf
pAGItf
  = let mkExprL             =   foldr sem_ExprL_Cons sem_ExprL_Nil
        pAGItf              =   sem_AGItf_AGItf <$> pBindL
        pBindL              =   foldr sem_BindL_Cons sem_BindL_Nil
                                <$> pBlock pOCurly pSemi pCCurly pBind
        pBind               =   sem_Bind_Bind <$> pNm <* pKey "=" <*> pExpr
        pNm                 =   Nm <$> (pVarid <|> pConid)
        pNmKey k            =   Nm <$> pKey k
        pOp                 =   (\o l r -> sem_Expr_App o (mkExprL [l,r])) <$> pNmKey "++"
        pExpr               =   pChainr pOp pExprApp
        pExprApp            =   pNm <**> (flip sem_Expr_App <$> (mkExprL <$> pList1 pExprBase) `opt` sem_Expr_Var)
        pExprBase           =   pParens pExpr
     in pAGItf
}

-------------------------------------------------------------------------
-- Interfacing
-------------------------------------------------------------------------

WRAPPER AGItf

ATTR AGItf [ opts: {Opts} | | ]

-------------------------------------------------------------------------
-- AST
-------------------------------------------------------------------------

DATA AGItf
  | AGItf               bindL       : BindL

DATA Bind
  | Bind                nm          : {Name}
                        expr        : Expr

TYPE BindL = [Bind]

SET AllBind = Bind BindL

DATA Expr
  | App                 func        : {Name}
                        argL        : ExprL
  | Lam                 argL        : LamArgs
  | Let                 bindL       : BindL
                        body        : Expr
  | Var                 nm          : {Name}
  | Str                 str         : {String}
  | List                argL        : ExprL
  | Rec                 bindL       : BindL

TYPE ExprL = [Expr]

SET AllExpr = Expr ExprL

DATA LamArgs
  | Var                 nmL         : {[Name]}
  | Bind                bindL       : ArgBindL

DATA ArgBind
  | Var                 nmLocal     : {Name}
                        nm          : {Name}

TYPE ArgBindL = [ArgBind]

SET AllArgBind = ArgBind ArgBindL

SET AllNT = AllExpr AllArgBind AllBind

-------------------------------------------------------------------------
-- Evaluator
-------------------------------------------------------------------------

{
type Eval = IO (Value,RunState)

emptyEval :: Eval
emptyEval = return (emptyValue,emptyRS)
}

ATTR AGItf AllNT [ | | eval USE {`const`} {emptyEval}: Eval ]

SEM Expr
  | App

-------------------------------------------------------------------------
-- Pretty printing
-------------------------------------------------------------------------

ATTR AGItf AllNT [ | | pp USE {>-<} {empty} : PP_Doc ]
ATTR BindL ExprL [ | | ppL: {[PP_Doc]} ]

SEM AGItf
  | AGItf               loc         .   pp          =   vlist @bindL.ppL

SEM Bind
  | Bind                loc         .   pp          =   @nm >#< "=" >#< @expr.pp

SEM BindL
  | Nil                 lhs         .   ppL         =   []
  | Cons                lhs         .   ppL         =   @hd.pp : @tl.ppL

SEM Expr
  | Var                 loc         .   pp          =   pp @nm
  | App                 loc         .   pp          =   @func >#< ppListSep "" "" " " @argL.ppL

SEM ExprL
  | Nil                 lhs         .   ppL         =   []
  | Cons                lhs         .   ppL         =   @hd.pp : @tl.ppL

