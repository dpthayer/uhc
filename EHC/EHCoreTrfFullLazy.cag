% $Id: EHC.lag 199 2004-05-12 19:11:13Z andres $

%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Fully lazy code
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs import(Maybe,Set,List,FiniteMap,EHCommon,EHCore) export(cmodTrfFullLazy)
%%]

%%[8 hs import(EHDebug)
%%]

%%[9 hs import(EHTy)
%%]

%%[8.WRAPPER import(EHCoreAbsSyn,EHCoreTrfCommonFv,EHCoreTrfCommonLev)
WRAPPER CodeAGItf
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell itf
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs
cmodTrfFullLazy :: UID -> CModule -> CModule
cmodTrfFullLazy uniq cmod
  =  let  t = wrap_CodeAGItf  (sem_CodeAGItf (CodeAGItf_AGItf cmod))
                              (Inh_CodeAGItf {gUniq_Inh_CodeAGItf = uniq})
     in   cTrf_Syn_CodeAGItf t
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Unique
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR AllCodeNT [ | gUniq: UID | ]
ATTR CodeAGItf [ gUniq: UID | | ]

SEM CExpr
  | App         (func.gUniq,loc.lUniq)      =   mkNewUID @lhs.gUniq
  | Lam         (body.gUniq,loc.lUniq)      =   mkNewUID @lhs.gUniq
  | Case TupSel TupDel TupIns TupUpd
                (expr.gUniq,loc.lUniq)      =   mkNewUID @lhs.gUniq
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Is top App?
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR CExpr [ isTopApp: Bool | | ]

SEM CModule
  | Mod         expr        .   isTopApp    =   True

SEM CBind
  | Bind        expr        .   isTopApp    =   True

SEM CPatBind
  | Bind        offset      .   isTopApp    =   True

SEM CExpr
  | App         func        .   isTopApp    =   False
                arg         .   isTopApp    =   True
  | * - App     loc         .   isTopApp    =   True

SEM CAlt
  | Alt         expr        .   isTopApp    =   True
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Gathering let's
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs
type LevBindL = AssocL Int (CBindCateg,CBindL)

levBindSplit :: Int -> LevBindL -> (LevBindL,LevBindL)
levBindSplit lev b = partition (\(l,_) -> l >= lev) b
%%]

%%[8
ATTR AllCodeNT [ | | levBindL USE {++} {[]}: LevBindL ]
ATTR AllBind [ | | bindL USE {++} {[]}: {AssocL Int CBind} ]

SEM CExpr
  | App         lhs         .   levBindL    =   @arg.levBindL ++ @func.levBindL ++ @levBindL
  | Case        lhs         .   levBindL    =   @expr.levBindL ++ @alts.levBindL ++ @dflt.levBindL ++ @levBindL
  | TupSel TupDel
                lhs         .   levBindL    =   @expr.levBindL ++ @offset.levBindL ++ @levBindL
  | TupIns TupUpd
                lhs         .   levBindL    =   @expr.levBindL ++ @offset.levBindL ++ @fldExpr.levBindL ++ @levBindL
  | Let         (loc.hereBindL,lhs.levBindL)=   let ((hl,_):_) = @binds.bindL
                                                    b1 = @binds.levBindL
                                                    b2 = [(@strLev hl,(@categ,assocLElts @binds.bindL))]
                                                    b12 = [(@maxBindLev,(CBindRec,concat . map (\(_,(_,b)) -> b) $ (b1 ++ b2)))]
                                                    b3 = @body.levBindL
                                                    b  = case @categ of 
                                                           CBindRec -> b12 ++ b3
                                                           _ -> b1 ++ b2 ++ b3
                                                in  if @lhs.lev == cLevOuter
                                                    then (b,[])
                                                    else ([],b)
  | Lam         loc         .   (hereBindL,remBindL)
                                            =   levBindSplit @lev @body.levBindL
                lhs         .   levBindL    =   @remBindL ++ @levBindL

SEM CBind
  | Bind        lhs         .   bindL       =   [(@expr.levOf,@cTrf)]

SEM CAlt
  | Alt         (loc.hereBindL,lhs.levBindL)=   levBindSplit @lev @expr.levBindL
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Allow trf?
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs
data AppTop = AppYesLet | AppNoLet deriving (Eq,Ord)
data LamTop = LamYesLet | LamNoLet deriving (Eq,Ord)
%%]

%%[8
ATTR CExpr [ appTrfIsOk: AppTop | | ]

SEM CModule
  | Mod         expr        .   appTrfIsOk  =   AppYesLet

SEM CBind
  | Bind        expr        .   appTrfIsOk  =   AppNoLet

SEM CPatBind
  | Bind        offset      .   appTrfIsOk  =   AppYesLet

SEM CExpr
  | App         func        .   appTrfIsOk  =   AppNoLet
                arg         .   appTrfIsOk  =   AppYesLet
  | Lam Let     body        .   appTrfIsOk  =   AppNoLet
  | * - App Lam Let
                loc         .   appTrfIsOk  =   AppYesLet

SEM CAlt
  | Alt         expr        .   appTrfIsOk  =   AppYesLet
%%]

%%[8
ATTR CExpr [ lamTrfIsOk: LamTop | | ]

SEM CModule
  | Mod         expr        .   lamTrfIsOk  =   LamYesLet

SEM CBind
  | Bind        expr        .   lamTrfIsOk  =   LamNoLet

SEM CPatBind
  | Bind        offset      .   lamTrfIsOk  =   LamYesLet

SEM CExpr
  | Lam         body        .   lamTrfIsOk  =   LamNoLet
  | * - Lam     loc         .   lamTrfIsOk  =   LamYesLet

SEM CAlt
  | Alt         expr        .   lamTrfIsOk  =   LamYesLet
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Transformation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs
mkTrf :: Bool -> Int -> Int -> HsName -> CExpr -> (CExpr,LevBindL)
mkTrf cond outerLev hereLev n e
  =  if cond
     then (CExpr_Var n,[(hereLev,(CBindPlain,[CBind_Bind n e]))])
     else (e,[])

mkLetTrf :: LevBindL -> CExpr -> CExpr
mkLetTrf bs ce = foldr (\(_,(c,b)) e -> mkCExprLet c b e) ce bs
%%]

  =  if cond && (outerLev /= hereLev || hereLev <= cLevOuter)
     then (CExpr_Var n,[(hereLev,(CBindPlain,[CBind_Bind n e]))])
     else (e,[])

%%[8
ATTR AllCodeNT [ | | cTrf: SELF ]
ATTR CodeAGItf [ | | cTrf: CModule ]

SEM CExpr
  | App Lam Case TupSel TupDel TupIns TupUpd
                loc         .   nm          =   uidHNm @lUniq
  | App Case TupSel TupDel TupIns TupUpd
                loc         .   trfIsOk     =   @lhs.appTrfIsOk == AppYesLet && @lhs.isTopApp
  | Lam         loc         .   trfIsOk     =   @lhs.lamTrfIsOk == LamYesLet
  | App Case TupSel TupDel TupIns TupUpd Lam
                (lhs.cTrf,loc.levBindL)     =   mkTrf @trfIsOk @lhs.lev @levOf @nm @cTrf
  | Lam         loc         .   cTrf        =   CExpr_Lam @arg (mkLetTrf @hereBindL @body.cTrf)
  | Let         lhs         .   cTrf        =   mkLetTrf @hereBindL @body.cTrf

SEM CAlt
  | Alt         lhs         .   cTrf        =   CAlt_Alt @pats.cTrf (mkLetTrf @hereBindL @expr.cTrf)

%%]

SEM CBind
  | Bind        loc         .   cTrf        =   CBind_Bind @nm (mkLetTrf @expr.levBindL @expr.cTrf)
                            .   levBindL    =   []
SEM CAlt
  | Alt         loc         .   cTrf        =   CAlt_Alt @pats.cTrf (mkLetTrf @expr.levBindL @expr.cTrf)
                            .   levBindL    =   []
SEM CAlt
  | Alt         lhs         .   cTrf        =   CAlt_Alt @pats.cTrf (mkLetTrf @hereBindL @expr.cTrf)

