% $Id: EHC.lag 199 2004-05-12 19:11:13Z andres $

%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Fully lazy code
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs import(Maybe,Set,List,FiniteMap,EHCommon,EHCore) export(cmodTrfFullLazy)
%%]

%%[9 hs import(EHTy)
%%]

%%[8.WRAPPER import(EHCoreAbsSyn)
WRAPPER CodeAGItf
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell itf
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs
cmodTrfFullLazy :: UID -> CModule -> CModule
cmodTrfFullLazy uniq cmod
  =  let  t = wrap_CodeAGItf  (sem_CodeAGItf (CodeAGItf_AGItf cmod))
                              (Inh_CodeAGItf {gUniq_Inh_CodeAGItf = uniq})
     in   cTrf_Syn_CodeAGItf t
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Unique
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR AllCodeNT [ | gUniq: UID | ]
ATTR CodeAGItf [ gUniq: UID | | ]

SEM CExpr
  | App         (func.gUniq,loc.lUniq)      =   mkNewUID @lhs.gUniq
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Generation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs
mkTrf :: Int -> Int -> HsName -> CExpr -> (CExpr,LevBindL)
mkTrf outerLev hereLev n e
  =  if outerLev == hereLev
     then (e,[])
     else (CExpr_Var n,[(hereLev,(CBindPlain,[CBind_Bind n e]))])

mkLetTrf :: LevBindL -> CExpr -> CExpr
mkLetTrf bs ce = foldr (\(_,(c,b)) e -> mkCExprLet c b e) ce bs
%%]

%%[8
ATTR AllCodeNT [ | | cTrf: SELF ]
ATTR CodeAGItf [ | | cTrf: CModule ]

SEM CExpr
  | App         loc         .   nm          =   uidHNm @lUniq
                (lhs.cTrf,loc.levBindL)     =   if @lhs.isTopApp
                                                then mkTrf @lhs.lev @levOf @nm @cTrf
                                                else (@cTrf,[])
  | Lam         lhs         .   cTrf        =   CExpr_Lam @arg (mkLetTrf @hereBindL @body.cTrf)
  | Let         lhs         .   cTrf        =   mkLetTrf @hereBindL @body.cTrf

SEM CAlt
  | Alt         lhs         .   cTrf        =   CAlt_Alt @pats.cTrf (mkLetTrf @hereBindL @expr.cTrf)
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Is App a top App?
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR CExpr [ isTopApp: Bool | | ]

SEM CModule
  | Mod         expr        .   isTopApp    =   True

SEM CBind
  | Bind        expr        .   isTopApp    =   True

SEM CPatBind
  | Bind        offset      .   isTopApp    =   True

SEM CExpr
  | App         func        .   isTopApp    =   False
                arg         .   isTopApp    =   True
  | * - App     loc         .   isTopApp    =   True

SEM CAlt
  | Alt         expr        .   isTopApp    =   True
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Level
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs
levOuter = 0
%%]

%%[8
ATTR AllCodeNT [ lev: Int | | ]

SEM CodeAGItf
  | AGItf       module      .   lev         =   levOuter

SEM CExpr
  | Lam         loc         .   lev         =   @lhs.lev + 1

SEM CAlt
  | Alt         loc         .   lev         =   @lhs.lev + 1
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Free vars
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs
type FvS = Set HsName
type FvSMp = FiniteMap HsName FvS
%%]

%%[8
ATTR AllCodeNT [ | | fvS USE {`Set.union`} {emptySet}: FvS ]
ATTR AllBind [ | | fvSMp USE {`plusFM`} {emptyFM}: FvSMp ]

SEM CExpr
  | Lam         loc         .   fvS         =   @body.fvS `delFromSet` @arg
  | Let         lhs         .   fvS         =   (@body.fvS `Set.union` @binds.fvS) `minusSet` mkSet (keysFM @binds.levOfMp)
  | Var         lhs         .   fvS         =   unitSet @nm
  | App         loc         .   fvS         =   @func.fvS `Set.union` @arg.fvS

SEM CBind
  | Bind        lhs         .   fvSMp       =   unitFM @nm @expr.fvS

SEM CAlt
  | Alt         loc         .   fvS         =   @expr.fvS `minusSet` mkSet @pats.nmL
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Binding to id's
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs
type LevMp = FiniteMap HsName Int

fvLev :: LevMp -> FvS -> Int
fvLev lm fvs = foldr (\n l -> lookupWithDefaultFM lm levOuter n `max` l) levOuter . setToList $ fvs

addLevMp :: LevMp -> FvSMp -> LevMp
addLevMp lm fvm = lm `plusFM` mapFM  (\_ fv -> fvLev lm fv) fvm
%%]

%%[8
ATTR AllCodeNT [ levMp: LevMp | | ]

SEM CodeAGItf
  | AGItf       module      .   levMp       =   emptyFM

SEM CExpr
  | Lam         body        .   levMp       =   addToFM @lhs.levMp @arg @lev
  | Let         body        .   levMp       =   @lhs.levMp `plusFM` @binds.levOfMp

SEM CAlt
  | Alt         expr        .   levMp       =   addListToFM @lhs.levMp (zip @pats.nmL (repeat @lev))
%%]

%%[8
ATTR AllBind AllPat [ | | nmL USE {++} {[]}: {[HsName]} ]

SEM CPatBind
  | Bind        lhs         .   nmL         =   [@nm] ++ @pat.nmL

SEM CPat
  | Var Con     loc         .   nm          =   cpatNmEither id id @pnm
  | Var         lhs         .   nmL         =   [@nm]
  | Con         lhs         .   nmL         =   [@nm] ++ @binds.nmL
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Level of expr
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR AllCodeNT [ | | levOf USE {`max`} {0}: Int ]

SEM CExpr
  | Var         lhs         .   levOf       =   lookupWithDefaultFM @lhs.levMp levOuter @nm
  | App         loc         .   levOf       =   @func.levOf `max` @arg.levOf
  | Lam         lhs         .   levOf       =   fvLev @lhs.levMp @body.fvS

SEM CAlt
  | Alt         lhs         .   levOf       =   fvLev @lhs.levMp @expr.fvS

ATTR AllBind [ | | levOfMp USE {`plusFM`} {emptyFM}: LevMp ]

SEM CBind
  | Bind        lhs         .   levOfMp     =   unitFM @nm @expr.levOf
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Gathering let's
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs
type LevBindL = AssocL Int (CBindCateg,CBindL)

levBindSplit :: Int -> LevBindL -> (LevBindL,LevBindL)
levBindSplit lev b = partition (\(l,_) -> l >= lev) b
%%]

%%[8
ATTR AllCodeNT [ | | levBindL USE {++} {[]}: LevBindL ]
ATTR AllBind [ | | bindL USE {++} {[]}: {AssocL Int CBind} ]

SEM CExpr
  | App         lhs         .   levBindL    =   @arg.levBindL ++ @func.levBindL ++ @levBindL
  | Let         loc         .   levBindL    =   @binds.levBindL ++ [(@lhs.lev,(@categ,@binds.cTrf))] ++ @body.levBindL
  | Let         (loc.hereBindL,lhs.levBindL)=   let ((hl,_):_) = @binds.bindL
                                                    b = @binds.levBindL ++ [(hl,(@categ,assocLElts @binds.bindL))] ++ @body.levBindL
                                                in  if @lhs.lev == levOuter then (b,[]) else ([],b)
  | Lam         (loc.hereBindL,lhs.levBindL)=   levBindSplit @lev @body.levBindL

SEM CBind
  | Bind        lhs         .   bindL       =   [(@expr.levOf,@cTrf)]

SEM CAlt
  | Alt         (loc.hereBindL,lhs.levBindL)=   levBindSplit @lev @expr.levBindL
%%]

