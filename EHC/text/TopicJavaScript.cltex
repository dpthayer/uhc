%%[prelude
%include IdentColors.fmt
%include Javascript.fmt

%format a_1
%format a_i
%format a_j
%format a_n
%format MANY   = "\!^{*}"
%format ::= = "::="
%format \ = "{\lambda}"

% defs etc
\newcommand{\todo}[1]{{\color{red}#1}}
%\newcommand{\Coloneqq}[1]{{::=}}
%%]

%%[abstract
We describe a small web application intended to make secondary school students familiar with functional and logic programming.
The application demonstrates the use of Haskell on various levels.
First, the accompanying teaching material for the web application explains both Prolog and its implementation in Haskell.
Second, the web application has been written in Haskell, both server and client side.
As an experiment, the browser side has been implemented using the JavaScript backend of the Utrecht Haskell Compiler.
We discuss the consequences that the actual use of a Haskell frontend for an Object-Oriented language bring.
%%]

%%[introduction
Haskell afficionados occasionally are confronted with the question ``Haskell is all well and good, but does it also run on XYZ?'',
where XYZ can be substituted with your favorite and usually widespread platform.
This is a valid question as many developers are tied to such platforms for a variety of reasons,
yet also wish for niceties Haskell offers, such as type safety.
In this paper we substitute ``JavaScript in a web browser'' for XYZ,
and indeed frustration with JavaScript turned out to be a strong motivation for the work described by this paper.

The context for this paper is provided by a small client-server application to teach secondary school math students
about logic and functional programming, called the Junior College University (JCU) application.
Figure~\ref{jcuapp} shows the web browser user interface which allows the user to define Prolog like facts,
which then can be queried and unified with.
Prolog rules can be added (on the right) and are used to decompose a term (on the left), showing the resulting proof tree.
Rules are chosen by dragging and dropping them on the query.
Under the hood the browser interface delegates all work to the server, both Prolog queries and the storage
of Prolog rules.

An accompanying document \cite{swierstra11jcu} walks the students through the application,
its use, its implementation in terms of Prolog, and its Haskell implementation of Prolog,
thus exposing students to a variety of programming language concepts.

\begin{figure}[t]
\hrule\vspace{2mm}
\FigCenterPDF{.23}{JCU1}
\caption{Browser interface of JCU application}
\label{jcuapp}
\end{figure}

The server side of the JCU application is written using Snap Framework \cite{www11snap-framework} whereas the
(original) client side is written using various JavaScript frameworks
(Brunch.IO \cite{www11brunch}, which contains CoffeeScript \cite{www11CoffeeScript} and jQuery \cite{www11jquery}).
The task we set ourselves was to rewrite as much as possible of the JavaScript part to Haskell,
using the JavaScript backend of the Utrecht Haskell Compiler (UHC) \cite{www09uhc,dijkstra09uhc-arch}.
We also moved the Prolog machinery from server to client,
leaving only database access (for Prolog rules) at the server side.
In principle these rules also could move to the client side (and be stored on a particular client machine)
with the loss of location transparency.

Moving functionality outside the usual Haskell habitat --Unix(like) environments and C-- to
a diffent runtime environment and target langauge poses some challenges,
of which most have been looked into before. In particular mappings to Java have been explored
(see Section~\ref{discussionIssuesRelatedWork}).
Our contribution is to actually build an application using such a mapping to an OO environment,
observe what the consequences are for Haskell as a language and for its libraries and runtime environment,
and --quite pragmatically-- try to make it all work.
To make our contribution more precise, in the following sections we discuss the following topics.

\begin{itemize}
%\item The structure of the JCU application (Section~\ref{JuniorCollegeApp})
\item A FFI based mapping between Haskell and JavaScript, in principle applicable to other OO languages as well
 (Sections~\ref{HaskellToJavaScript})
 and its use in accessing existing JavaScript libraries (Section~\ref{UseOfExistingJavaScriptStuff}).
\item Experience with the consequences of stretching the use of Haskell
 beyond its comfort zone found in and around the defacto default production compiler GHC
 (Section~\ref{discussionIssuesRelatedWork}).
\end{itemize}

Finally we wrap up in Section~\ref{conclusion}.


%%]

%%[JuniorCollegeApp
\label{JuniorCollegeApp}



%\todo{Structure: server (snap?), GUI, NanoProlog.}

%%]

%%[HaskellToJavaScript
\label{HaskellToJavaScript}
There is an obvious mismatch between Haskell and Object-Oriented (OO) languages,
which has been addressed in various ways over time (Section~\ref{discussionIssuesRelatedWork}):
\begin{itemize}
\item
 Mapping the runtime machinery required for Haskell to an imperative language has to deal with the lazy evaluation strategy
 imposed by Haskell;
 we deal with this in the remaining part of this section.
\item
 Use of OO language mechanisms available in JavaScript, in particular prototype based objects; we avoid dealing with this problem.
\item
 Use of available libraries built with JavaScript;
 we deal with this in the following section by exploiting the freedom offered by Haskells Foreign Function Interface (FFI)
\end{itemize}

The design of any backend for a lazy functional languages needs to deal with functions, their (lazy) application to arguments,
and forcing evaluation of such applications to Weak Head Normal Form (WHNF).
The design should also cater for under- and oversaturated function applications as well as tail recursion.

In UHC's JavaScript backend functions and their applications are both represented straightforwardly by objects,
being the principle OO datastructure available:

\begin{code}
Fun.prototype = {
    applyN : function ( args ) ...
    needsNrArgs : function() ...
}

function Fun( fun ) { ... }
\end{code}

For now we omit implementation details and only expose the programmatic interface used by the runtime system.
A |Fun| object wraps a JavaScript function so that it can be used as a Haskell function.
The |applyN| field is only used when evaluation of a function application takes place,
in which case it is necessary to know the |needsNrArgs| number of arguments which must be passed.
Until then it stays unevaluated as a |Fun| object wrapped inside a closure object |App| or |AppLT|.

Similarly, partially applied (and thus undersaturated) functions
need to remember already applied arguments and how many arguments are still missing.
An |AppLT| object encodes this, again we provide its programmatic interface first:

\begin{code}
AppLT.prototype = {
    applyN : function ( args ) ...
    needsNrArgs : function() ...
}

function AppLT( fun, args ) { ... }
\end{code}

An |AppLT| only wraps other |AppLT| objects or |Fun| objects.

Finally, for all remaining saturation cases an |App| object is used, knowledge about saturedness is delegated to the encapsulated
function object, which may be another |App|, |AppLT|, or |Fun|.

\begin{code}
App.prototype = {
    applyN : function ( args ) ...
}

function App( fun, args ) { ... }
\end{code}

With this interface we now can translate Haskell functions, for example a function |\x -> id ^ (id x)| would be translated to the
following, assuming |id| is available:

\begin{code}
new Fun( function(x) {
    return new App(id, [new App(id,[x])]);
} )
\end{code}

Evaluation is done by a separate function |eval| which assumes the presence
of an |eOrV| (evaluator Or Value) field for all Haskell runtime values,
so it can decide whether an JavaScript object represents a Haskell non-WHNF value which needs further evaluation.
If it is an evaluator, a JavaScript function, then it is a non WHNF.
A Haskell function or application object does not evaluate itself because this would lead tail recursion to overflow the stack of the underlying
Javascript engine.
The separate external function |eval| doing the evaluation allows non WHNF values to be returned,
thus implementing a trampoline mechanism:

\begin{code}
function eval( x ) {
    while ( x && x.eOrV ) {
        if ( typeof x.eOrV == 'function' ) {
            x = x.eOrV() ;
        } else {
            x = x.eOrV ;
    }   }
    return x ;
}
\end{code}

The |eOrV| is either a function representing a next evaluation step, or a WHNF value.
Even JavaScript values can be thrown at |eval|, which distinguishes those values by the absence of the |eOrV| field.
In the actual runtime system all the above names are chosen to be more unclear as to reduce chances of accidentily
bumping into a JavaScript object having this hidden field.
The actual |eval| function is somewhat more involved as it provides more protection against null values.
It is also necessary to update
the |eOrV| field for all intermediate non WHNF objects computed in the evaluation loop.

The evaluation function is invoked when a Haskell value needs to be inspected,
for example by a case expression or by a primitive requiring underlying JavaScript values such as
the following translation of a primitive multiplication function:

\begin{code}
new Fun( function(a,b) {
    return eval(a) * eval(b) ;
} )
\end{code}

\begin{figure}[t]
\hrule
\begin{code}
_F_.prototype = {
  __aN__ : function ( args ) {
    if ( args.length < this. __evN__.length ) {
      return new _A_undersat_( this, args ) ;
    } else if ( args.length == this. __evN__.length ) {
      return this. __evN__.apply( null, args ) ;
    } else {
      var fun = _e_( this. __evN__.apply
                       ( null, args.slice( 0, this. __evN__.length ) ) ) ;
      var remargs = args.slice( this. __evN__.length ) ;
      return {
        __eOrV__ : function() {
          return fun. __aN__( remargs ) ;
        } } ;
  } }
, needsNrArgs : function() {
    return this. __evN__.length ;
} }
function _F_( evalN ) {
  this. __evN__ = evalN ;
}

_A_.prototype = {
  __aN__ : function ( args ) {
    var fun = _e_(this) ;
    return {
      __eOrV__ : function() {
        return fun. __aN__( args ) ;
      } } ;
} }
function _A_( fun, args ) {
  this. __eOrV__ = function() {
    return fun. __aN__( args ) ;
} }

_A_undersat_.prototype = {
  __aN__ : function ( args ) { ... }
, needsNrArgs : function() {
    return this.fun.needsNrArgs() - this.args.length ;
} }
function _A_undersat_( fun, args ) {
  this.fun = fun ;
  this.args = args ;
}

function _e_( x ) { ... }
\end{code}
\caption{JavaScript runtime system}
\label{rts}
\end{figure}

Figure~\ref{rts} shows how the actual evaluation is delegated to |applyN| of |Fun| (or |App|, |AppLT|).
Depending on the number of arguments provided either an undersatured closure is build, or the function is directly invoked using
JavaScripts |apply|.
In case too many arguments are provided a JavaScript closure is constructed, which subsequently is evaluated in the evaluation 
loop of |eval|.
The implementation of |AppLT| is similar to that of |Fun|, therefore omitted from Figure~\ref{rts}.
|App|s implementation of |applyN| simply delegates to |applyN| of the function it applies to.
Also omitted are the encodings of nullary applications, used for unevaluated constants (CAF, Constant Applicative Form) and indirection nodes required for
mutual recursive definitions.
Datatypes and tuples are straightforwardly mapped onto JavaScript objects
with fields for the constructor tag and its fields.
If available, record field names of the corresponding Haskell datatype are used.
%%]

%%[UseOfExistingJavaScriptStuff
\label{UseOfExistingJavaScriptStuff}
Translating to JavaScript is attractive because we then can access its available libraries via
the Foreign Function Interface (FFI);
we thus can avoid programming in JavaScript.
For example, the globally (in a web browser environment) available function |alert|,
which pops up an alert window,
can be interfaced to by the following FFI declaration:

\begin{code}
foreign import js "alert(%*)"
  _alert :: JSString -> IO ()
\end{code}

The type |JSString| represents JavaScript string values,
conversion to and from |String| is provided by the runtime system and |Prelude|.

\paragraph{JS calling convention.}
The standard C calling convention requires only a rather simple syntax for import entities;
all access is basically done via functions.
However, JavaScript libraries often expose functionality via OO mechanisms or specific JavaScript idiom.
The |js| calling convention introduced by UHC
therefore provides a richer notation for specifying import entities,
summarized in Figure~\ref{jsimpent}.
\begin{figure}[t]
\hrule
\begin{code}
exp    ::=  '{}'                                ^ -- Haskell constructor to JS object
         |  (arg | ident) post MANY             ^ -- JS expression

post   ::=  '.' ident                           ^ -- object field
         |  '[' exp ']'                         ^ -- array indexing
         |  '(' args ')'                        ^ -- function call

args   ::=  epsilon | arg (, arg) MANY          ^ -- possible arguments

arg    ::=  '%' ('*' | int)                     ^ -- all arguments, or a specific one
         |  '"' str '"'                         ^ -- literal text

ident  ::= a valid JavaScript identifier
int    ::= any integer
str    ::= any string
\end{code}
\caption{Import entity notation for the JS calling convention}
\label{jsimpent}
\end{figure}

The notation allows the use of a subset of JavaScript expressions,
in which (possibly converted) Haskell function arguments can be spliced.
The above alert function uses |%*| to let the compiler expand all arguments.
Similarly individual arguments can be referred to by number;
a further occurrence of |%*| then does not include that individual argument anymore.
This allows translation to OO style of function invocation, as in the following example:

\begin{code}
foreign import js "%1.charCodeAt(%2)"
  charCodeAt :: JSString -> Int -> Int
\end{code}

JavaScript functions taking a variable number of arguments need a Haskell declaration for
each number of arguments.
For example string concatenation requires the following declarations.

\begin{code}
foreign import js "%1.concat(%*)"
  concat :: JSString -> JSString -> JSString

foreign import js "%1.concat(%*)"
  concat2 :: JSString -> JSString -> JSString -> JSString
-- etc.
\end{code}

Although functions taking a variable number of arguments can be expressed in Haskell
using the class system \cite{asai08haskell-printf,kiselyov10functional-format-io},
it is unclear how to combine this with the FFI.
We thus require an explicit definition for each number of arguments to |concat|.
The import entity can still be the same because of the compiler generated expansion to the
proper number of arguments.

\paragraph{Records.}
Values of basic non aggregrate types like |Int| are shared between Haskell and JavaScript,
no marshalling is required. Absence of the hidden field |eOrV| makes the evaluation |eval| ignore these values.
Between |String| and |JSString| conversion must be done as their internal representation is different;
this still can be done straightforwardly with a pair of conversion functions, or hidden behind a class interface for conversion.
However, the problem is more serious with records, as runtime representations of aggregrates vary between Haskell and JavaScript libraries.
One cannot expect that these representations exactly coincide.
We did consider various solutions:
\begin{itemize}
\item
Design a FFI for datatypes, allowing one to specify how fields are mapped between a JavaScript implementation and Haskell datatypes.
This soon becomes cumbersome when record fields hold callback functions, or other aggregrates, as the conversion need to traverse
the record as well as its fields, steered by their types.
\item
Use some generic technique, for example generic deriving. This is heavyweight, would require marshalling for each FFI call, and fixes on a particular JavaScript representation.
\item
Leave it up to the programmer with some help from the runtime system to create objects and manipulate fields.
\end{itemize}
For now, we chose the last and simplest solution.
Lower level access to construction and manipulation of JavaScript objects is offered by Lens like \cite{oconnor11lens} primitives,
of which we show the interfaces of their wrappers only:
\begin{code}
data JSPtr a
newObj :: String -> IO (JSPtr p)

getAttr :: String -> JSPtr p -> IO a
setAttr :: String -> a -> JSPtr p -> IO (JSPtr p)
modAttr :: String -> (a -> b) -> JSPtr p -> IO (JSPtr p)
\end{code}

Lack of types in JavaScript is visible in the interfaces, and the only guarantee is that a |JSPtr| can only be created via
the runtime system:
|newObj| constructs an instance of the JavaScript type (i.e. constructor object) with the name of its |String| argument.
It is the responsibility of the user of these functions to enforce a type discipline, e.g. by using phantom types.

For example, the following |Book| datatype is constructed and manipulated by the following:
\begin{code}
data BookPtr
type Book = JSPtr BookPtr

main = do
  o  <- newObj "Book"
  setAttr "pages" 123 o
  modAttr "pages" (+1) o
  p  <- getAttr "pages" o   ^^
  print p                   ^^ -- Prints 124
\end{code}

The runtime system can actually do somewhat better than the above manual JavaScript object construction by
exploiting knowledge about the Haskell representation of datatypes:
\begin{code}
foreign import js "{}"
  mkObj :: a -> IO (JSPtr b)
\end{code}
Primitive |mkObj| takes a Haskell datatype constructor, enforces WHNF of all components, and constructs
a corresponding JavaScript object.
All components must have a runtime representation known to JavaScript,
so no recursive invocation of the conversion is required for fields.
The FFI allows to access this runtime conversion via the @{}@ notation.

For example, now assume the following |Book| definition:
\begin{code}
data Book = Book
  { author  ::  JSString   , title  ::  JSString      , pages  ::  Int  }
book = Book
  { author  =   toJS "me"  , title  =   toJS "story"  , pages  =   123  }
\end{code}

The above is then manipulated by
\begin{code}
main = do
  let b' = book { pages = pages book + 1 }
  b  <- mkObj b'
  p  <- getAttr "pages" b   ^^
  print p                   ^^ -- Prints 124
\end{code}

Note however, that there is no conversion back from JavaScript records to Haskell records.

%\todo{Predictably at many places there is tension between Haskell and JavaScript. There are many more places where there is tension between the typed and the untyped...}

%\todo{jQuery, Google, or other libraries for accessing DOM.}

%\todo{DOM.}

%\todo{User interface: HTML5, Canvas Drawing.}

\paragraph{JCU application.}

The JCU application uses a UHC JavaScript backend specific library to access browser functionality
and available libraries.
Much of the library consists of wrappers around library functionality.
Most of this code is done by straightforward use of the discussed FFI import mechanisms.
The code shown in Figure~\ref{jqueryevent} shows the exporting direction of the FFI:
the part required to register Haskell code via the `wrapper' FFI entity for
dealing with GUI events generated by the jQuery library.
The ``wrapper'' FFI entity specification is used to wrap Haskell event handlers for use by JavaScript,
bound to browser user interface elements, and called when a particular event happens.
Specifically in the JCU application, this mechanism is also used as a way to encode access to global state:
all event handlers are partial applications holding references to this global state.
After each change in the global change all event handlers are then replaced with a new partial application to new state.

\begin{figure}[t]
\hrule
\begin{code}
data JQueryPtr
type JQuery         = JSPtr JQueryPtr
type EventHandler   = JQuery -> IO Bool
type JEventHandler  = JSFunPtr EventHandler
data JEventType     = Click | DoubleClick | Focus | ...

instance Show JEventType where
  show Click = "click"
  show ...

foreign import js "wrapper"
  mkJEventHandler :: EventHandler -> IO JEventHandler

foreign import js "%1.bind(%*)"
  _bind :: JQuery -> JSString -> JEventHandler -> IO ()

bind :: JQuery -> JEventType -> EventHandler -> IO ()
bind jq evt eh = do  hdlr <- mkJEventHandler eh
                     _bind jq ((toJS . show) evt) hdlr
\end{code}
\caption{Interface with jQuery event handling}
\label{jqueryevent}
\end{figure}

A small but nasty OO related detail is that the jQuery UI library ensures that @this@ in the event callbacks points to the
object an event is occurring on, instead of passing it as an argument.
This complicates matters for the runtime system as @this@ is bound by functions generated by
the compiler.
Additional wrapping code adds @this@ to arguments before passing the arguments to a handler.
The code for @this@ wrapping is not included.

%In the reworked JCU application the Prolog machinery has moved to the browser.

%\todo{JCU specific and interesting stuff}

%%]

%%[discussionIssuesRelatedWork
\label{discussionIssuesRelatedWork}

\paragraph{Alternate approaches.}
The idea of running Haskell in a browser is not new.
To our knowledge
first attempts to do so using JavaScript were done in the context of
the York Haskell Compiler (YHC) \cite{www07yhc-javascript}.
The Document Object Model (DOM) inside a browser was accessed via wrapper code generated
from HTML standard definitions \cite{www07haskell-in-browser}.
However, YHC is no longer maintained and direct interfacing to DOM
nowadays is replaced by libraries built on top of the multiple DOM variations.

The idea of running functional programs in a browser even goes further back
to the availability of Java applets.
The workflow framework iTasks, built on top of the Clean system \cite{www11clean-system},
uses a minimal platform independent functional language, SAPL, to
encode code intended to run in a browser.
SAPL code is then interpreted in a browser, by a Java-written interpreter.
The latest interpreter incarnations are written in JavaScript
\cite{jansen10phd-itasks-sapl-funcweb,bruel10sapl-javascript,plasmeijer08clientside-itasks-ajax}.
Although currently a Haskell frontend exists for Clean, the use of it in a browser seems to be tied up to the iTasks system.
The intermediate language SAPL also does not to provide the equivalent of the Haskell FFI.
This limits used code to that which is generated by the iTasks system.

Of the GHC a version exists which generates JavaScript \cite{www11ghcjs-git},
based on the GHC API, supporting the use of primitives but not the FFI.
Further down we elaborate on some consequences of multiple platforms and backends
relevant for this GHC backend variant as well.

Both ``Functional javascript'' \cite{www07functional-javascript} and
``Haskell in Javascript'' \cite{www10haskellinjavascript} do not use a separate Haskell compiler.
Instead, JavaScript is used directly in a functional style,
respectively a small compiler for a subset of Haskell has been written in JavaScript.

\paragraph{Object orientation.}

Object Oriented behavior itself can be realized inside Haskell by exploiting the class system
\cite{shields01haskell-oo-overloading,kiselyov05haskell-oo}.
However, we aim to access libraries written in JavaScript, not mimic JavaScript or OO mechanism in general inside Haskell.

However, when functionality of the libraries would have to be (re)written in Haskell some form of OO mechanism
should be available.
This issue arises when one would code in Haskell a platform independent part of an otherwise OO GUI library,
say |wxHaskell|.
For now we limit ourselves to accessing JavaScript libraries via the FFI, hiding OO idiom inside FFI import entities. 

%\paragraph{This is a moving target.}

%\todo{Explain about @this@}

%\todo{Mapping to OO: FFI or other mechanism.}

%\todo{Records in JS vs HS.}

\paragraph{Type system absence.}

JavaScript has no type system, the absence of which can be dealt with
by using phantom types in wrapper functions around untyped FFI calls.
More problematic are for example DOM functions returning objects with a different interface,
like a DOM element or attribute.
A sum type defining all possible result types could be used, but datatypes are not extensible,
which might be too limiting in practice.
Dynamics might be used as result values, but require assistence from the runtime system as well
as knowledge about types (e.g. in the form of |TypeRep|).
Existentially quantified datatypes and classes might be used (similar to extensible exceptions \cite{marlow06extensible-exception}),
but then knowledge about the class system also seeps into the runtime system.
Currently this has not yet been further addressed.

%\todo{Typing the untyped.}

\paragraph{Side effects.}

All access to JavaScript values is done in the IO monad, so side effect can be properly modelled.
For now it is assumed that no threads exist.
JavaScript's worker thread mechanism can be used safely,
hence no semaphore, STM, or other shared data access machinery needs
to be implemented.
Some values like the globally available @window@ in a browser could be accessed without the use of the IO monad because its value does not change.
However, if and when this assumption would not hold in a near future it would break our wrapping code as well.

%\todo{All in IO, what can be done without IO, threads? STM?.}

\paragraph{Deployment.}

JavaScript code is usually downloaded, hence compact representation as well as avoiding or delaying loading of code is
important.
UHC allows pruning of unused code as to achieve a relative compact representation,
but provides no mechanism for dynamic loading.
It is left up to the user of the compiled code to incorporate it into a webpage.

%\todo{Code compactification, module loading, whole prog, ...}

\paragraph{Mapping to OO runtime environments.}

In general, it is attractive to map onto available virtual machines for popular OO languages,
in particular because of the availability of a wealth of libraries.
Targeting the Java virtual machine (JVM) has been experimented with
\cite{wakeling98haskell-to-java,func:lazy:java:parser-combinator,stewart02mthesis-multiparadigm-jit,tullsen96haskell-to-java},
as well as with the @.NET@ platform \cite{monteiro05functional-to-dotnet,www04haskell-dotnet,meijer07mondrian,meijer01dotnet-scripting-mondrian};
UHC also provides a backend to the JVM \cite{func:lazy:java:parser-combinator}
using the same technique as described here.
However, interfacing to libraries is still lacking in UHC, and in general library access and other
runtime oriented features (threads, exceptions)
is where the real work lies \cite{www12ghc-faq}.
Wrapping and interfacing to libraries has to be done manually or by tools interpreting library code,
either time consuming or suffering from misinterpretation.
In the case of JavaScript lack of typing annotations even excludes automatic FFI wrapper generation,
unless type annotations in comments could be trustworthy and formal enough to be used instead.

Efficient code generation is also an issue.
Usually non standard OO language constructs are used to implement
standard idiom of (lazy) functions.
For now, with UHC we have taken the approach to first make it work and not bother about efficiency,
generating code from an early stage in the compiler pipeline.

\paragraph{Libraries, Haskell platform.}

Targeting Haskell to a different platform means that some assumptions assumed valid
when using one platform only are no longer valid.
First, a different platform means a different runtime environment.
Almost all of the UNIX functionality available for the usual Haskell UNIX runtime
naturally is not available inside a web browser
and, vice verse, specific JavaScript libraries like jQuery are not available on a UNIX platform.
Some library modules of a package (partially) cannot be build on some platforms, while others (partially) can.
To cater for this, UHC rather ad-hoc marks modules to be unavailable for a backend by a pragma
\verb|{-# EXCLUDE_IF_TARGET js #-}|.
Of course |cpp| can still be used to select functionality inside a module.
However, in general, awareness of platform permeates all aspects of a language system, from the compiler itself
to the library build system like |Cabal|.
In particular, |Cabal| needs a specification mechanism for such variation in target and platform
to allow for selective or different compilation.
Currently this means that UHC compilation for the JavaScript backend cannot be done via |Cabal|.

A second aspect has more to do with the evolution of Haskell as an ecosystem.
Many libraries no longer take a Haskell standard as standard,
but GHC.
Currently, such libraries evolve to use (say) type families, a feature not (yet) available in UHC.
For (non GHC) Haskell compiler writers to keep with this pace of evolution poses a considerable challenge,
yet in our opinion there is value in the availability of compiler alternatives as well as variation in what those
compilers are good at.

%\todo{Mismatch: Cabal does not deal with multiple backend of one compiler.}

%\todo{Mismatch: Libraries take GHC as standard, not Haskell2010 (or H98).}

%\todo{Unix based library is useless, basically other OS to run on, what about shared code, ...}

\paragraph{More info, download.}

For the variant of the JCU application as implemented for this paper more info (download, how to install, etc)
is available, via the UHC www site \cite{www09uhc} or directly \cite{www12uhc-js-backend}.
%%]

%%[conclusion
\label{conclusion}
We have taken an existing client-server application, which already was partially implemented in Haskell,
and adapted it to replace the JavaScript part by Haskell using the JavaScript backend of UHC.
This has been the driving force to construct supporting libraries,
to design and experiment with a FFI specifically for OO like backend languages,
and to see whether it could be done.
The good news is that indeed it can be done,
the bad news is ``that having it all'' --type system, multiplatform Haskell, efficient featurerich runtime--
is quite an undertaking to achieve,
which from past experiences seems to be a reason that longterm support for such backend alternatives is abandoned.
However, as Haskell aficionados we believe there is real benefit in using Haskell at as many places
as possible.
We therefore hope that UHCs JavaScript implementation and libraries will contribute and become a viable option for
type safe web programming.
%%]

%%[XX
%%]

