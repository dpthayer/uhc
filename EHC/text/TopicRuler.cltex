%%[abstract
Some type systems are first described formally,
to be sometimes followed by an implementation.
Other type systems are first implemented as a language extension,
to be sometimes retrofitted with a formal description.
In neither case it is an easy task to keep both artefacts consistent.
In \thischapt\ we introduce |Ruler|, a domain specific language for describing type rules.
Type rules can be incrementally described, thus providing a means for building complex type systems on top of simpler ones.
Besides checking well-formedness of |Ruler| programs we use them to generate
(1) a visual \LaTeX\ rendering, suitable for use in the presentation of formal aspects,
and (2) an attribute grammar based implementation.
Combining these two aspects
in |Ruler| contributes to bridging the gap between theory and practice:
mutually consistent representations can be generated for use in both theoretical and practical settings.
%%]

%%[body
\subsection{Introduction}

Theory and practice of type systems often seem to be miles apart.
For example, for the programming language Haskell the following artefacts exist:
\begin{Itemize}
\item
A language definition for the Haskell98 standard \cite{peytonjones03has98-rev-rep},
which defines Haskell's syntax and
its meaning in informal terms.
Part of this is specified in the form of a translation to a subset of Haskell.
\item
A formal description of the static semantics of most of Haskell98 \cite{faxen02semantics-haskell}.
\item
Several implementations, of which we mention GHC \cite{www04ghc} and Hugs \cite{www03hugs}.
\item
Experimental language features, of which some have
been formally described in isolation,
and some of them
found their way into Haskell,
or are available as non-standard features.
As an example we mention Haskell's class system
\cite{jones94phd-qual-types},
%if False
which started as experimental and now is standard
in Haskell98,
%endif
and multi-parameter type classes 
\cite{peytonjones97typecl-explore,duggan02check-multipclass}
present in extensions
\cite{www04ghc,www03hugs}
to Haskell98.
\item
A Haskell description of type inferencing for Haskell98
\cite{jones00thih},
serving at the same time as a description and an implementation.
\end{Itemize}

We thus can ask ourselves the following questions:

\begin{Itemize}
\item
What is the relationship between all the descriptions (i.e language definition and static semantics)
of Haskell and available implementations?
\item
What is the effect of a change or extension which is first implemented and subsequently described?
\item
What is the effect of a change or extension which is first described and subsequently implemented?
\end{Itemize}

For example,
if we were to extend Haskell with a new feature, we may start by exploring the feature
in isolation from its context by creating a minimal type system for the feature,
an algorithmic variant of such a type system,
a proof of the usual properties (soundness, completeness), or perhaps a prototype.
Upto this point the extension process is fairly standard;
however when we start to integrate the feature into a working implementation this process and the preservation of proven
properties becomes less clear.
Whatever route we take, that is, first extend the implementation,
and give a formal description afterwards or the other way around,
there is no guarantee that the formal description and the implementation are mutually consistent.
Even worse, we cannot be sure that an extension preserves the possibility to prove desirable properties.
As a example, it has already been shown that Haskell does not have principal types,
due to a combination of language features and seemingly innocent extensions
\cite{faxen03hask-princ-types}.

Based on these observations we can identify the following problems:

\begin{description}
\item[Problem 1.]
It is difficult, if not impossible, to keep separate (formal) descriptions and implementations
of a complex modern programming language consistent.
\end{description}

Our approach to this problem is to
maintain a single description of the static semantics of a programming language.
From this description we generate both the material which can be used as a starting point for a formal treatment as well as the implementation.

\begin{description}
\item[Problem 2.]
The extension of a language with a new feature means that the interaction between new and old features
needs to be examined with respect to the preservation of desirable properties,
where a property may be formal (e.g. soundness) or practical (e.g. sound implementation). 
\end{description}

The |Ruler| language that we introduce in this paper aims
to make it easy to describe language features in relative isolation.
The separate descriptions for these features however can be combined into a description of the complete language.
Note that traditional programming language solutions, like the use of modules and abstract data types to factor code, are not sufficient:
a language extension often requires the extension of the data types representing the abstract syntax and the required implementation may require changes across
multiple modules.
Usually an additional language feature requires textual changes to numerous parts of the language description and implementation.

The feature interactions seem to be unescapable,
no matter how much we try to keep language definitions orthogonal.
We cannot solve this. We only can relief this by building incremental, modular and statified language descriptions.

Our approach is similar to, but also different from literate programming.
We emphasize that |Ruler| provides a solution for the abovementioned problems;
in the conclusion (\secRef{ruler-conclude}) we will further discuss additional desirable features of the |Ruler| system.

%if False
\Paragraph{Consequences of the problems}
These problems
contribute to a gap between type systems theory and practice:

\begin{Itemize}
\item
n
\item
The disproportional interaction between language features may reduce the usefulness of formal
mechanisms because a desirable property may not survive a feature combination or it may become too difficult
to proof such a property.
\end{Itemize}
%endif

\rulerCmdUse{rulerDemo.E.expr.base}

\rulerCmdUse{rulerDemo.A.expr.base}

\begin{CodeFigure}{Part of the generated implementation}{ruler-demo-impl}
%%[[wrap=code
%%@RulerDemoMain.3.AST.Expr.App

%%@rulerDemoAG.3.expr.ATTR

%%@rulerDemoAG.3.expr.e.app
%%]
\end{CodeFigure}

%if not limitSize
\Paragraph{How our approach contributes to solving the problems}
%endif

We explore these problems and our solution
by looking at the final products that are generated by the |Ruler| system as described in
\thischapt, and which are
presented in figures~\ref{rulerDemo.E.expr.base} through~\ref{ruler-demo-impl}.
We emphasize at this point that a full understanding of these figures is not required nor intended.
The focus of \thischapt\ is on the construction of the figures, not on their meaning:
|Ruler| only tackles the problem of \emph{consistency} between such figures and the corresponding implementation.
Our aim is to look at these figures from a metalevel
and to see how type rules can be specified and how their content can be generated using our |Ruler| system.
Nevertheless, we have chosen a small, well known, and realistic
%if not limitSize
running
%endif
example: the Hindley-Milner (HM) type system.
\figRef{rulerDemo.E.expr.base} gives the equational rules, \figRef{rulerDemo.A.expr.base} the algorithmic variant and \figRef{ruler-demo-impl} part of
the generated implementation.
In later sections we will come back to the technical part of
%if limitSize
\figRef{rulerDemo.E.expr.base}.
\figRef{rulerDemo.A.expr.base} and \figRef{ruler-demo-impl}
are included to demonstrate the artefacts which are generated by |Ruler|;
we will not discuss these any further and refer to an extended version of \thischapt\ \cite{dijkstra05phd} for the omitted material.
%else
these figures.
%endif
For now we only use the content of
\figRef{rulerDemo.A.expr.base} and \figRef{ruler-demo-impl}
to discuss
the general idea of our approach.

The need for a system producing these artefacts arose in the context of the
Essential Haskell (EH) project
\cite{dijkstra04ehc-web%
%if not storyPHD
,dijkstra05phd
%endif
}.
The design goal of EH is to construct a compiler for an extended version of Haskell,
and to (simultaneously) build an explanation of its implementation,
while keeping both versions consistent 
by generating corresponding parts from a single source.
This approach resembles the one taken by Pierce \cite{typing:types-prog-lang:pierce} who
explains both non-algorithmic and algorithmic variants of type systems.
The EH project starts with the description of a very simple language, and extends it in a sequence of steps,
leading to full Haskell with extensions
(including higher ranked polymorphism,
mechanisms for explicitly passing implicit parameters \cite{dijkstra05explimpl},
higher order kinds).
Each step introduces new features and describes the corresponding compiler.

Both type rules and fragments of corresponding source code are used in the explanation of the compiler.
For example, \ruleRef{e.app} from \figRef{rulerDemo.A.expr.base} and the corresponding attribute grammar (AG) implementation from
\figRef{ruler-demo-impl} are jointly explained, each strengthening the understanding of the other.
However, later versions of EH introduce more features, resulting in the following problems:

\begin{Itemize}
\item
Type rules and AG source code both become quite complex and increasingly difficult to understand.
\item
A proper understanding may require explanation of a feature both in isolation as well as in its context.
These are contradictory requirements.
\item
With increasing complexity comes increasing likeliness of inconsistencies between type rules and AG source code.
\end{Itemize}

Part of our solution to these problems is the use of the concept of \IxAsDef{views} on both the type
rules and AG source code.
Views are ordered in the sense that later views are built on top of earlier views.
Each view is defined in terms of its differences and extensions with its ancestor view;
the resulting view on the artefact is the accumulation of all these incremental definitions.

This, of course, is not a new idea: version managment systems use similar mechanisms,
and object-oriented systems use the notion of inheritance.
However, the difference lies in our focus on a whole sequence of versions as well as the changes between versions:
in the context of version management only the latest version is of interest, whereas for a class hierarchy we aim
for encapsulation of changes.
We need simultaneous
access to all versions,
which we call views,
in order to build both the explanation and the sequence
of compilers.
A version management systems uses versions as a mechanism for evolution,
whereas we use views as a mechanism for explaining and maintaining EH's sequence of compilers.
We may e.g. change the first view, and have these changes included in all subsequent views.

For example, \figRef{rulerDemo.E.expr.base} displays view |E| (equational),
and \figRef{rulerDemo.A.expr.base} displays view |A| (algorithmic)
on the set of type rules, where each rule consists of judgements (premises and a single conclusion).
%if False
For the purpose of \thischapt, there is no need to understand the content these figures;
their purpose is to demonstrate what can be described with |Ruler|.
%endif
View |A| is built on top of view |E| by specifying the differences with respect to view |E|.
%if targetForPaper
In the electronic version of \thispaper, the
%else
The
%endif
incremental definition of these views is exploited by using a color scheme to visualise the differences.
The part which has been changed with respect to a previous view is displayed in blue,
the unchanged part is displayed in grey (however, in the printed version all is black).
In this way we address ``Problem 2''.

Independently from the view concept we exploit the similarity between type rules and AG based implementations.
To our knowledge this similarity has never been exploited.
We use this similarity by specifying type rules using a single notation,
which contains enough information to
generate both the sets of type rules
(in \figRef{rulerDemo.E.expr.base} and \figRef{rulerDemo.A.expr.base})
as well as part of the AG implementation
(in \figRef{ruler-demo-impl}).
\figRef{ruler-demo-impl} shows the generated implementation for \ruleRef{e.app}.
In this way we address ``Problem 1''.

Our |Ruler| system allows the definition of type rules, views on those rules,
and the specification of information directing the generation of a partial implementation.
In addition, |Ruler| allows the specification of the structure of judgements in type rules:
the type of a judgement.
This ``type of a judgement'' is used by |Ruler| to check whether concrete judgements follow the correct pattern.

In the course of the EH project the Ruler system  has become indispensable for us:

\begin{Itemize}
\item
|Ruler| is a useful
tool for describing type rules and keeping type rules consistent with their implementation.
In subsequent sections we will see how this is accomplished.
\item
It is relatively easy to incorporate the generation of output to be used as input for other targets (besides \LaTeX\ and AG).
This makes |Ruler| suitable for other goals while at the same time maintaining a single source for type rules.
\item
We also feel that it may be a starting point for a discussion about how to deal with the complexities of
modern programming languages: both their formal and practical aspects.
In this light, \thischapt\ also is an invitation to the readers to improve on these aspects.
In our conclusion (\secRef{ruler-conclude}) we will discuss some developments we foresee
and directions of further research.
\end{Itemize}

We summarize |Ruler|'s strong points,
such that we can refer to these points from the technical part of \thischapt:

\begin{description}
\item[Single source.]
Type rules are described by a single notation;
all required type rule related artefacts are generated from this.
\item[Consistency.]
Consistency between the various type rule related artefacts is guaranteed automatically
as a consequence of being generated from a single source.
\item[Incrementality.]
It is easy to incrementally describe type rules.
\item[Well-formedness checks.]
Judgements are checked against the `type' of a judgement.
\end{description}

The remainder of \thischapt\ is organised as follows:
in \secRef{ruler-overview} we present an overview of the |Ruler| system.
This overview gives the reader an intuition of what |Ruler| can do
and how it interacts with
other tools.
Preliminaries for the example language and type systems are given
in \secRef{ruler-prelim}.
In \secRef{ruler-basics} we specify the contents of
%if limitSize
\figRef{rulerDemo.E.expr.base}.
%else
\figRef{rulerDemo.E.expr.base},
in \secRef{ruler-hm-infer} we extend this specification for
the contents of
\figRef{rulerDemo.A.expr.base}.
%if not storyPHD
In \secRef{ruler-ag-basics} we explain the AG (attribute grammar) system.
%endif
In \secRef{ruler-ag-infer} we extend the example |Ruler| specification so that
|Ruler| can generate AG code.
%endif %% limitSize
Finally we discuss and conclude in \secRef{ruler-conclude}.

%{
%include ruler.fmt

%format <	= "\langle "
%format >	= "\rangle "

\begin{CodeFigure}{High level structure of Ruler source}{ruler-src-template}
%%@TopicRuler.rulerSrcTemplate wrap=code
\end{CodeFigure}

\subsection{|Ruler| overview}
\label{ruler-overview}

%if not limitSize
\begin{XFigFigure}{}{ruler-overview}{Ruler overview}{ruler-fig-overview}
\end{XFigFigure}
%endif

%if limitSize
%else
\Paragraph{Infrastructure around Ruler}
Although the |Ruler| system allows us to generate part of an implementation, it is by no means the only
tool we use in the construction of our compilers.
\figRef{ruler-fig-overview} gives an overview of the tools used to construct the example compiler for the
type rules presented in \thischapt.
In the left branch we generate an executable compiler using the following sources:

\begin{Itemize}
\item
|Ruler| code (in box `Ruler') for type rules, out of which attribute grammar AG code is generated by |Ruler|.
\item
AG code (in box `AG main') for the specification of a pretty printed representation of the input and error handling.
The AG compiler generates Haskell.
\item
Haskell code (in box `HS main') for the specification of a parser, interaction with the outside world and remaining functionality.
\end{Itemize}

In the right branch we generate \LaTeX\ commands for |Ruler| type rules which can be used in a \LaTeX\ document (in box `latex main').
The major part of generating \LaTeX\ is delegated to |lhs2TeX|
\cite{loh04lhs2tex-www}.

The use of tools for the EH compilers is slightly more complicated because we need to specify different views on AG and Haskell code as well.
A separate fragment management tool, called |shuffle| (part of the EH project \cite{dijkstra04ehc-web}),
is used to generate AG and Haskell code from code fragments describing the view inheritance chains for
AG and Haskell code.
Because we do not discuss this any further, this part has been omitted (from \figRef{ruler-fig-overview}).
%endif %% limitSize

%if limitSize
%else
\Paragraph{The design of |Ruler|}
In the remainder of this section we discuss the concepts used in |Ruler| by inspecting elements of
figures~\ref{rulerDemo.E.expr.base}, \ref{rulerDemo.A.expr.base} and \ref{ruler-demo-impl}.
%endif %% limitSize

The design of |Ruler| is driven by the need to check the following \emph{properties} of type rules:
\begin{Itemize}
\item
All judgements match an explicitly specified structure for the judgement.
For example, in \figRef{rulerDemo.E.expr.base} all judgements for an expression should match the structure of the expression judgement in the box at the top of the same figure.
\item
If an identifier is used for the generation of an implementation, it must be defined before it can be used.
%if limitSize
In \thischapt, we will not discuss this aspect further.
%else
The meaning of this will be explained later.
%endif
\end{Itemize}
Other properties can be added to this list,
but we limit ourselves to this list and the requirement of output generation for different targets.

In the remainder of this section we give a high-level overview of the concepts manipulated by |Ruler|.
\figRef{ruler-src-template} gives a schematic |Ruler| specification, showing how these concepts relate syntactically.
\figRef{ruler-legenda-syntax} provides an overview of the full concrete syntax of |Ruler|.

%{
%%@AppxNotation.rulerSyntaxSetup

%if llncs

{\footnotesize
\begin{CodeFigure}{Syntax of ruler notation}{ruler-legenda-syntax}
%%[[wrap=code
%%@AppxNotation.rulerSyntaxBasic
%%@AppxNotation.rulerSyntaxLexical
%%@AppxNotation.rulerSyntaxRest
%%]
\end{CodeFigure}
}

%else

\begin{CodeFigure}{Syntax of ruler notation (part I, basics)}{ruler-legenda-syntax}
%%[[wrap=code
%%@AppxNotation.rulerSyntaxBasic
%%]
\end{CodeFigure}

\begin{CodeFigure}{Syntax of ruler notation (part II, lexical and other)}{ruler-legenda-syntax2}
%%[[wrap=code
%%@AppxNotation.rulerSyntaxLexical
%%@AppxNotation.rulerSyntaxRest
%%]
\end{CodeFigure}

%endif

%}

The structure of a judgement is described by a (judgement) \IxAsDef{scheme}.
For each scheme we specify multiple \IxAsDef{views}.
A view on a scheme consists of named \IxAsDef{holes} and \IxAsDef{judgeshape}s, which come in the following varieties:

\begin{Itemize}
\item One \IxAsDef{judgespec}, used to specify the template for judgements.
\item For each output target a \IxAsDef{judgeuse}, used to specify how to map a judgement to an output format.
\end{Itemize}

A \IxAsDef{rule} consists of a set of judgement instances (syntactically denoted by keyword |judge|)
for the premises, and a judgement for the conclusion.
Just as we specify views for schemes, we specify views for rules.
For each view, each of the judgements of a rule should comply with the corresponding view of the scheme of the judgement.
%if False
Each of these judgements is of a specified scheme,
and its definition must comply with the structure defined by the corresponding view on the scheme.
%endif
A judgement is defined by binding hole names to |Ruler| expressions.

Rules are grouped into \IxAsDef{rulesets}.
A ruleset corresponds to a figure like \figRef{rulerDemo.E.expr.base},
so it consists of a set of rules,
the scheme for which the rules specify a conclusion,
and additional information like the text for the caption of the figure.

Views are ordered by a \IxAsDef{view hierarchy}.
A view hierarchy specifies which view inherits from which other (ancestor) view.
A view on a scheme inherits the holes and judgeshapes.
A view on a rule inherits the hole bindings.

%if False
\figRef{ruler-src-template} presents a schematic, high-level |Ruler| specification.
The syntactic structure of a |Ruler| specification reflects the relationships between the aforementioned concepts.
%endif
The incremental definition of views on a rule is supported by two different variants of specifying a judgement (using the above mechanisms):

\begin{Itemize}
\item
A judgement in a (view on a) rule can be specified by using a judgespec as a macro where the values of the holes are defined by filling
in the corresponding positions in the judgespec.
This variant is useful for the first view in a view hierarchy, because all holes need to be bound to a |Ruler| expression.
\item
A judgement in a (view on a) rule can be specified by individually specifying values for each hole.
This variant is useful for views which are built on top of other views,
because only holes for which the value differs relative to the ancestor view need to be given a new value.
\end{Itemize}

The incremental definition of views on a scheme is supported in a similar way:
only the holes not present in an ancestor view require a definition.


%if False

A specification of a type rule starts with describing the structure (\IxAsDef{scheme}) of the judgements used in a type rule.
This corresponds to the box at the top of \figRef{rulerDemo.E.expr.base} and \figRef{rulerDemo.A.expr.base}.
This structure consists of a fixed template (\IxAsDef{judgeshape}, introduced as a \IxAsDef{judgespec}), and parts (\IxAsDef{holes}) which vary with each judgement.
For example, for the rules in \figRef{rulerDemo.E.expr.base} the
judgeshape ``@gam :- e : ty@'' is defined, which pretty prints as ``|Gamma :- e : tau|''.
The ``| ... :- ... : ... |'' part is fixed, |gam|, |e| and |ty| identify the holes.
A different judgeshape may be defined for each view.
We require that each judgement (in a type rule)
for a view must match its corresponding judgeshape for the view.
A judgeshape is to a judgement what a type is to an expression.
For example, the conclusion of \ruleRef{e.int} is specified by ``@Gamma :- int : Int@''
which pretty prints as ``|Gamma :- int : Int|''.

Type rules (\IxAsDef{rule}) are defined within a group of rules (\IxAsDef{ruleset}) for
a scheme,
which together are displayed in a figure (such as \figRef{rulerDemo.E.expr.base}).
For each rule multiple views (\IxAsDef{view}) are defined together.
Each view specifies judgements (\IxAsDef{judge}) for both premises and conclusion.
The |Ruler| system regroups views to generate different figures for the different views.

Different views may be built on top of each other
by defining additional holes and redefining judgeshapes.
For example,
view |A| (\figRef{rulerDemo.A.expr.base}) extends view |E| (\figRef{rulerDemo.E.expr.base})
by introducing two additional holes in its structure, for |Cnstrk| and |Cnstr|.
For all rules we thus need to specify values for these additional holes.
Of course this can be done by completely redefining the judgements for a rule using the corresponding judgeshapes,
but an attractive aspect of our approach is that we can extend a judgement by specifying the differences, that is,
values for newly introduced holes or redefining values for already filled holes.

%endif

The |Ruler| system is open-ended in the sense that some judgements can be expressed in a less structured form,
for which its implementation is defined externally.
For example, the premises of \ruleRef{e.var} consist of arbitrary conditions.
These arbitrary (i.e. as far as |Ruler| is concerned unstructured)
conditions are treated like regular judgements, but their
implementation has to be specified explicitly.
We call the scheme of such a judgement variant a \IxAsDef{relation}.

%if False
|Ruler| (currently) checks the following properties:
\begin{Itemize}
\item
Each judgement has to follow its judgeshape (see \secRef{ruler-basics}).
\item
Identifiers used as part of hole values must be introduced (see \secRef{ruler-hm-infer}).
\item
The conclusions of rules in a ruleset must be of the scheme of the ruleset.
\end{Itemize}
%endif



\subsection{Preliminaries}
\label{ruler-prelim}

In this section we introduce notation used by our 
%if not limitSize
running
%endif
example,
that is, the set of type rules to be specified by |Ruler|.
There should be no surprises here as we use
a standard term language based on the |lambda|-calculus (see \figRef{ruler-demo-lang-terms}).
%if not limitSize
An overview of the type related notation is included in
\figRef{ruler-legenda-ty-symbols}.
%endif
Our example language contains e.g. the following program:

%% ruler2/demo/tst5
%%[[wrap=code
let  id = \x -> x
in   let  v1 = id 3
     in   let  v2 = id id
          in   v2 v1
%%]

The type language for our example term language is given in
%if limitSize
\figRef{ruler-demo-lang-terms}.
%else
\figRef{ruler-demo-hm-lang-types}.
%endif
Types are either monomorphic types |tau|,
called \IxAsDef{monotypes},
or universally quantified types |sigma|, called \IxAsDef{polymorphic types} or \IxAsDef{polytypes}.
A monotype either is a type constant |Int|, a function type |tau -> tau|,
or an unknown type represented as a type variable |tvarv|.
We discuss the use of these types when we introduce the typing rules for our term language
in the following sections.

%if limitSize
\begin{TabularCenterFigure}{}{Terms and types}{ruler-demo-lang-terms}{c||c}
\begin{tabular}
%%@AppxNotation.termTableFormat
%%@AppxNotation.exprHeader
%%@AppxNotation.rulerExpr
\end{tabular}
&
\begin{tabular}
%%@AppxNotation.termTableFormat
%%@AppxNotation.typeHeader
%%@AppxNotation.rulerTy
\end{tabular}
\end{TabularCenterFigure}
%else
\begin{TabularCenterFigure}{th}{Terms}{ruler-demo-lang-terms}%
%%@AppxNotation.termTableFormat
%%@AppxNotation.exprHeader
%%@AppxNotation.rulerExpr
\end{TabularCenterFigure}

\begin{TabularCenterFigure}{th}{Types}{ruler-demo-hm-lang-types}%
%%@AppxNotation.termTableFormat
%%@AppxNotation.typeHeader
%%@AppxNotation.rulerTy
\end{TabularCenterFigure}
%endif

The typing rules use an environment |Gamma|,
holding bindings for program identifiers with their typings:

%%[[wrap=code
Gamma   ::=  Vec(i :-> sigma)
%%]

%if not limitSize
During HM type inferencing, type variables
will be bound to monotypes:

%%[[wrap=code
Cnstr   ::=  Vec(tvarv :-> tau)
%%]

A |Cnstr| represents constraints on type variables, usually called a \IxAsDef{substitution}.
Its application to a type, denoted by juxtapositioning, has the usual meaning;
it replaces type variables with types.

\begin{TabularCenterFigure}{th}{Legenda of type related notation}{ruler-legenda-ty-symbols}{ll}
%%@AppxNotation.notationTableHeader
%%@AppxNotation.notationRulerDemoBasic
%if not limitSize
%%@AppxNotation.notationRulerDemoCnstr
%endif
\end{TabularCenterFigure}
%endif %% not limitSize

\subsection{Describing typing rules using |Ruler| notation}
\label{ruler-basics}

In this section we make the use of |Ruler| more precise.
%if limitSize
We describe
|Ruler| notation, by explaining
%else
We start by describing 
%endif
how to specify the content of \figRef{rulerDemo.E.expr.base}.
The type rules in \figRef{rulerDemo.E.expr.base} specify the non-algorithmic version of
the typing rules for our term language.
The transition (instantiation) from polytypes to monotypes is performed by |inst|,
whereas the transition (generalisation) from monotypes to polytypes is described in \ruleRef{e.let}.

Because the rules implicitly state that certain equalities between types (of terms) should hold,
we call this the equational view;
the subscript |E| is used throughout \thischapt\ to identify equational views.

The use of an equational version of typing rules usually serves to explain a type system and to prove properties about the type system.
An algorithmic version subsequently is introduced to specify an implementation for such a type system.
In \thischapt\ we follow the same pattern,
but use it to show how |Ruler| can be used to describe
%if limitSize
the equational version
%else
both type systems
%endif
in such a way
that its type rule representation can be included in the documentation
(read here: \thischapt).
%if limitSize
In the extended version of \thischapt\ we also describe how to extend the equational version to an algorithmic one,
and a version from which a partial implementation can be generated.
%else
 and its partial implementation can be integrated into a full implementation.
%endif

\Paragraph{The basics: judgement schemes}
A typing rule consists of judgements describing the conclusion and premises of the rule.
A judgement has a structure of its own, described by a \IxAsDef{scheme}.
A scheme plays the same role in rules as a type does for an expression in our example term language.
In our example, we want to specify a judgement for terms (expressions).
We introduce such a judgement by a |scheme| declaration,
which is immediately followed by the views on this scheme%
\footnote{%
The text for |Ruler| program fragments already appears in pretty printed form throughout \thischapt, but in the original source code
the |judgespec| appears as: ``@judgespec gam :- e : ty@''
}:

%%[[wrap=code
%%@rulerDemoRL.1.expr.scm
%%@rulerDemoRL.1.expr.scm.E

%%@rulerDemoRL.1.expr.base.rls
%%@rulerDemoRL.1.rl.e.int
%%@rulerDemoRL.1.rl.e.int.E
%%]

We first examine the |scheme| definition in detail, and then the |ruleset| definition for the type rules themselves.

Each view defines empty slots (|holes|),
the judgement shape (\IxAsDef{judgeshape}) by which concrete judgements will be specified (|judgespec|)
and judgement shapes that will be used for output generation (|judgeuse|).
Holes act like parameters to a judgement shape.

In the scheme definition for expressions we specify for view |E|, that is the equational view,
three empty slots (|e, gam, ty|),
or \IxAsDef{holes}, denoted by names (alphanumerical identifiers),
which are to be filled in by judgements following this scheme.
Each hole has an associated hole type, so |ty| has type |Ty|;
%if limitSize
we will not discuss this further.
%else
we postpone the discussion of hole types until \secRef{ruler-ag-infer}.
%endif
Holes can be filled in two different ways:

\begin{Itemize}
\item
A judgespec can be used as a macro by passing arguments at the hole positions.
\item
Holes are individually assigned a value by referring to their name.
\end{Itemize}

Judgeshapes are introduced by the keyword |judgespec| or |judgeuse|.
A |judgespec| introduces a template, used as a distfix operator (here: |... :- ... : ...|)
for specifying instances of this judgement in a |rule|.
A |judgeuse| judgement shape introduces the template which is used for the generation for a \IxAsDef{target}.
The target is also specified by a |judgeuse|.
The target |tex| indicates that the shape is to be used to generate \LaTeX;
%if limitSize
the target is meant for attribute grammar (AG) generation, to be found in the extended version of \thischapt.
%else
later we will use the target |ag| to indicate that the shape is to be used for attribute grammar (AG) generation.
%endif
We will refer to these three shapes as the |spec|, |tex| and |ag| judgement shapes.
The |spec| shape is used as an input template, the |tex| and |ag| shapes are used as output templates.

The shape of a judgespec is defined by a |Ruler| expression,
which effectively introduces a distfix operator,
which is denoted by combinations of operator like characters such as `:' and `-'.
A simple expression may be the (possibly empty) juxtapositioning of a mixture of identifiers,
parenthesized expressions or one of the other |<rexpr_base>| alternatives in
%if llncs
\figRef{ruler-legenda-syntax}.
%else
\figRef{ruler-legenda-syntax2}.
%endif

The identifiers of the |Ruler| expression should refer to the introduced hole names.
Each |Ruler| expression for a judgement instance (defined by |judgeuse|) is matched against its corresponding
|spec| shape,
thus binding the hole identifiers occurring in the judgespec.

The dot character `.' has a special role in |Ruler| expressions and names for the |tex| target output generation.
It is used to specify subscripts, superscripts and stacking.
%if limitSize
We refer to the extended version of \thischapt\ \cite{dijkstra05phd} for further explanation.
%else
So, |x.1.2.3| pretty prints as:
\[\stackrel{3}{x_1^2}\]
The part after the first dot is used as a subscript, the part after the second dot is used as a superscript, and the part
after the third dot is stacked on top.
In this context the underscore character `|_|' denotes a horizontal line for use in vector like notations,
so @v..._@ pretty prints as |Vec(v)|.
Additional dots are ignored.

Names, |Ruler| expressions and operators all may be immediately followed by this dot notation.
For names however, the dots and their related information form part of the name.
%endif

Since the judgespec and an associated |judgeuse tex| are usually quite similar,
we have decided to make the latter default to the first.
For this reason we allow the dot notatation to be used in the judgespec too,
although it only will play a role in its defaulted uses.


\Paragraph{The basics: rulesets}
Rules are grouped in rulesets to be displayed together in a figure.
So the description of \figRef{rulerDemo.E.expr.base} starts with the |ruleset| keyword of our example.
A |ruleset| specifies the name |expr.base| of the ruleset,
the scheme |expr| for the conclusion of the rules,
and text to be displayed as part of the caption of the figure.
The judgespec of (a view on) the scheme is used to provide the boxed scheme representation in
\figRef{rulerDemo.E.expr.base}.
The ruleset name |expr.base| is used to uniquely identify this figure,
so it can be included in text such as \thischapt.
We do not discuss this further;
we only note that part of the \LaTeX\ formatting
is delegated to external \LaTeX\ commands.

The ruleset heading is immediately followed by a list of rules, of
which only one is shown here (|e.int| is pretty printed in small caps as \textsc{e.int})%
%if (storyPHD && targetForPaper) || limitSize
.
%else
;
for a complete description see \appRef{ruler-app-demo-src}.
%endif

Before discussing its components,
we repeat the \LaTeX\ rendering of \ruleRef{e.int} from \figRef{rulerDemo.E.expr.base} together with its |Ruler| definitions
to emphasize the similarities
between the rule specification and its visual appearance:

\begin{center}
\begin{tabular}{cc}
\begin{minipage}{.55\linewidth}
%%[[wrap=code
%%@rulerDemoRL.1.rl.e.int
%%@rulerDemoRL.1.rl.e.int.E
%%]
\end{minipage}
&
\begin{minipage}{.35\linewidth}
\[
\rulerCmdUse{rulerDemo.E.expr.base.e.int}
\]
\end{minipage}
\end{tabular}
\end{center}

All views of a rule are jointly defined,
although we present the various views separately throughout \thischapt.
We will come back to this in our discussion.

Each view for a rule specifies premises and a conclusion, separated by
a `-'.
The \ruleRef{e.int} for integer constants only has a single judgement for the conclusion.
The judgement has name |R|, follows scheme |expr|,
and is specified using the |spec| judgement shape for view |E|.
The name of the judgement is used to refer to the judgement from later views, either to
overwrite it completely or to adapt the values of the holes individually.
In the latter case the hole values of the previous view which are not adapted are kept.
%if not limitSize
Later, when we introduce subsequent views we will see examples of this.
%endif

The rule for integer constants refers to |Ty_Int|.
This is an identifier which is not introduced as part of the rule,
and its occurrence generates an
error message unless we specify it to be external%
%if limitSize
 (we do not discuss this nor its proper \LaTeX\ formatting further).
%else
:

%%@rulerDemoRL.1.ext wrap=code

Additionally we also have to specify the way |Ty_Int| will be typeset as |Ruler| does not make
any assumptions here.
|Ruler| outputs identifiers as they are and delegates formatting to |lhs2TeX| \cite{loh04lhs2tex-www}.
A simple renaming facility however is available as some renaming may be necessary, depending on the kind of
output generated.
Formatting declarations introduce such renamings:

%%@rulerDemoRL.1.fmt.Ty_Int wrap=code

Here the keyword |tex| specifies that this renaming is only used when \LaTeX\ (i.e. the |tex| target)
is generated.
The formatting for the names |gam| and |ty| are treated similarly.
%endif

The \ruleRef{e.app} for the application of a function to an argument is defined similarly to \ruleRef{e.int}.
Premises now relate the type of the function and its argument:

\begin{center}
\begin{tabular}{cc}
\begin{minipage}{.55\linewidth}
%%[[wrap=code
%%@rulerDemoRL.1.rl.e.app
%%@rulerDemoRL.1.rl.e.app.E
%%]
\end{minipage}
&
\begin{minipage}{.35\linewidth}
\[
\rulerCmdUse{rulerDemo.E.expr.base.e.app}
\]
\end{minipage}
\end{tabular}
\end{center}

%if not limitSize
The dot notation allows us to treat @ty.a@ as a single identifier, which is at the same time rendered as
the subscripted representation |taua|.
Also note that we parenthesize |(ty.a -> ty)| such that |Ruler| treats it
as a single expression.
The outermost layer of parentheses are stripped when an expression is matched against a judgement shape.
%endif

%if limitSize
\Paragraph{The rest}
The above demonstrates the basic features of |Ruler|.
We omit the full specification leading to a working implementation of our example.
However, to demonstrate the use of subsequent views, which build upon equational view |E|,
we have included, without further explanation,
part of the algorithmic view |A|.
The following extends the scheme definition:

%%[[wrap=code
%%@rulerDemoRL.2.expr.scm.A
%%]

The following extends the definition for \ruleRef{e.int}:

\begin{center}
\begin{tabular}{cc}
\begin{minipage}{.55\linewidth}
%%[[wrap=code
%%@rulerDemoRL.2.rl.e.int.A
%%]
\end{minipage}
&
\begin{minipage}{.35\linewidth}
\[
\rulerCmdUse{rulerDemo.A.expr.base.e.int}
\]
\end{minipage}
\end{tabular}
\end{center}

The following extends the definition for \ruleRef{e.app}:

\begin{center}
\begin{tabular}{cc}
\begin{minipage}{.55\linewidth}
%%[[wrap=code
%%@rulerDemoRL.2.rl.e.app.A
%%]
\end{minipage}
&
\begin{minipage}{.35\linewidth}
\[
\rulerCmdUse{rulerDemo.A.expr.base.e.app}
\]
\end{minipage}
\end{tabular}
\end{center}


The expanded version of \thispaper\
\cite{dijkstra05phd}
describes view |A| and the following additional aspects:

\begin{Itemize}
\item
Judgements representing arbitrary conditions (called \IxAsDef{relation}, e.g. |tvFresh|).
\item
The definition of additional views building upon view |E| (algorithmic view |A| and attribute grammar view |AG| (omitted)).
\item
Specifying the direction of computation for holes (e.g. adapted scheme for view |A| for |expr|).
\item
Additional datastructures (e.g. substitutions/constraints |Cnstr|) required for an algorithmic version of the type rules.
\end{Itemize}

%else
\Paragraph{Relations: external schemes}
The \ruleRef{e.var} for variables is less straightforward as it requires premises which do not follow an introduced scheme:
\[
\rulerCmdUse{rulerDemo.E.expr.base.e.var}
\]

This rule requires a binding of the variable |i| with type |sigma| to be present in |Gamma|;
the instantiation |tau| of |sigma| then is the type of the occurrence of |i|.
These premises are specified by judgements |G| and |I| respectively:

%%[[wrap=code
%%@rulerDemoRL.1.rl.e.var 
%%@rulerDemoRL.1.rl.e.var.E
%%]

Judgements |G| and |I| use a variation of a scheme, called a \IxAsDef{relation}.
For example, the judgement |G| must match the template for relation |gamLookupIdTy|
representing the truth of the existence of an identifier |i| with type |ty| in a |gam|:

%%@rulerDemoRL.1.gamLookupIdTy wrap=code

A relation differs only from a scheme in that we will not define rules for it.
It acts as the boundary of our type rule specification.
As such it has the same role as the foreign function interface in Haskell (or any other programming language interfacing with an outside world).
As a consequence we have
to specify an implementation for it elsewhere.
The relation |tyInst| is defined similarly:

%%@rulerDemoRL.1.tyInst wrap=code

%endif %% limitSize

%if not limitSize
\subsection{Extending to an algorithm}
\label{ruler-hm-infer}

In this section we demonstrate the usefulness of views and incremental extension
by adapting the equational rules from \figRef{rulerDemo.E.expr.base} to
the algorithmic variant in \figRef{rulerDemo.A.expr.base}.
We call this the |A| view.
We only need to specify the differences between two views.
This minimises our specification work;
|Ruler| emphasises the differences using color.
The resulting type rules are shown in
\figRef{rulerDemo.A.expr.base}.

\FigRef{rulerDemo.A.expr.base} not only shows the adapted rules but also shows the differences with
the previous view by using colors.
%if targetForPaper
In the electronic version of \thispaper\ the
%else
The
%endif
unchanged parts of the previous view (E) are shown in grey,
whereas the changed parts are shown in black (blue, if seen in color).
%if targetForPaper
The paper version typesets the rules in black for better readability.
%else
%endif
In our opinion,
clearly indicating differences while still maintaining an overview of the complete picture, contributes
to the understandability of the type rules when the complexity of the rules increases.

For this to work, we specify which view is built on top of which other view:

%%@rulerDemoRL.1.viewhierarchy wrap=code

The view hierarchy declaration defines the |A| view to be built on top of view |E|, and |AG| again on top of |A|.
We can also specify branches, for example |E < X| specifies |X| to be built on top of |E|, independently of other views;
because we do not use this feature, will will not discuss it further.
A view inherits the hole structure and the judgement shapes from its predecessor.
Similarly, for each rule the bindings of hole names to their values are preserved as well.
As a consequence we only have to define the differences.

In order to turn the equational specification into an algorithmic one based on HM type inference,
we need to:
\begin{Itemize}
\item
Specify the direction in which values in the holes flow through a rule.
This specifies the computation order.
\item
Represent yet unknown types by type variables and knowledge about those type variables by constraints.
\end{Itemize}

Both modifications deserve some attention, because they are both instances of a more general phenomenon
which occurs when we shift from the equational to the algorithmic realm:
we need to specify a computation order.

\Paragraph{From relationships to functions}
In an equational view we simply relate two values.
In an algorithmic view this relation is replaced by a function
mapping input values to output values.
For example, \ruleRef{e.app} from \figRef{rulerDemo.E.expr.base} specifies that
the type of |a| and the argument part of the type of |f| must be equal.
The use of the same identifier |taua| expresses this equality.
To compute |taua| however we either need to:
\begin{Itemize}
\item
compute information about |a|'s type first and use it to construct |f|'s type,
\item
compute information about |f|'s type first and use it to deconstruct and extract |a|'s type,
\item
compute information about both and then try to find out whether they are equal
(or remember they should be equal).
\end{Itemize}
The last approach is taken for hole |ty|,
because it allows us to compute types compositionally in terms
of the types of the children of an |Expr|.

\Paragraph{Using yet unknown information}
In an equational view we simply use values without bothering about how they are to be computed.
However, computation order and reference to a value may conflict if we to refer to a value before its value is computed.
For example, \ruleRef{e.let} allows reference to the type of |i| (in |e|) before its type has been computed.
In \ruleRef{e.let} the type of |i| is available only after HM's generalisation of the type of a let-bound variable.
The standard solution to this problem is to introduce an extra indirection by letting the type of |i| be a placeholder, called a type variable.
Later, if and when we find more information about this type variable, we gather this information in the form of constraints, which is the information then
used to replace the content of the placeholder.

\Paragraph{Adding direction to holes}
In |Ruler| notation, we specify the direction of computation order as follows for view |A| on scheme |expr|:

%%@rulerDemoRL.2.expr.scm.A wrap=code

The holes for |expr| are split into three groups, separated by vertical bars `| || |'.
Holes in the first group are called \IxAsDef{inherited},
holes in the third group are called \IxAsDef{synthesized}
and the holes in the middle group are both.
The type rules now translate to a syntax directed computation over an abstract syntax tree (AST).
Values for inherited holes are computed in the direction from the root to the leaves of the AST
providing contextual information;
values for synthesized holes are computed in the reverse order providing a result.
We will come back to this in following sections.

In our |A| view on scheme |expr| both |e| and |gam| are inherited,
whereas |ty| is the result.
This, by convention, corresponds to the standard visualisation of a judgement in which contextual information
is positioned at the left of the turnstyle `|:-|' and results are placed after a colon `:'.
As we will see, the hole |e| plays a special role because it corresponds to the AST.

Besides being declared as both an inherited and a synthesized hole, |cnstr| is also declared to be \IxAsDef{threaded}, indicated by the keyword |thread|.
For a threaded hole its computation proceeds in a specific order over the AST, thus simulating a global variable.
For now it suffices to know that for a threaded hole |h| two other holes are introduced instead:
|h.inh| for the inherited value, |h.syn| for the synthesized value.
Because |cnstr| is declared threaded, |cnstr.inh| refers to the already gathered information about type variables,
whereas this and newly gathered information is returned in |cnstr.syn|.
For example, view |A| on \ruleRef{e.int} fills |cnstr.syn| with |cnstr.inh|.

%%@rulerDemoRL.2.rl.e.int.A wrap=code

Although a definition for |cnstr.inh| is included,
we may omit the hole binding for |cnstr.inh|, that is |cnstr.inh = cnstr.inh|
(we will do this in the remainder of \thischapt).
If a binding for a new hole is omitted, the hole name itself is used as its value.

Instead of using a shape to specify the rule, we may bind individual hole names to their values.
In this way we only need to define the holes which are new or need a different value.
The |Ruler| system also uses this to highlight the new or changed parts and grey out the unchanged parts.
This can be seen from the corresponding rule from \figRef{rulerDemo.A.expr.base}
(value |cnstr.inh| shows as |Cnstrk| by means of additional formatting information):
\[
\rulerCmdUse{rulerDemo.A.expr.base.e.int}
\]

For \ruleRef{e.app} both the handling of the type (hole |ty|) and the constraints need to be
adapted.
The type |ty.a| of the argument is used to construct |ty.a->tv| which is matched against
the type |ty.f| of the function.
Constraints are threaded through the rules.
For example constraints |cnstr.f| constructed by the judgement for the function |f|
are given to the judgement |a| in the following fragment (which follows view |E| of \ruleRef{e.app} in the |Ruler| source text):

%%@rulerDemoRL.2.rl.e.app.A wrap=code

The \ruleRef{e.app} also requires two additional judgements: a |tvFresh| relation stating that |tv| should be a fresh type variable
and a |match| relation performing unification of two types, resulting in additional constraints under which the two types are equal.
The resulting rule (from \figRef{rulerDemo.A.expr.base}) thus becomes:
\[
\rulerCmdUse{rulerDemo.A.expr.base.e.app}
\]

The way this rule is displayed also demonstrates the use of the inherited or synthesized direction associated with a hole
for ordering judgements.
The value of a hole in a judgement is either in a position where the identifiers of the value are introduced
for use elsewhere or in a position where the identifiers of a value are used:

\begin{Itemize}
\item
A synthesized hole corresponds to a result of a judgement.
Its value specifies how this value can be used;
it specifies the pattern it must match.
This may be a single identifier or a more complex expression describing
the decomposition into the identifiers of the hole value.
For example, |cnstr.f| in the premise judgement |F| for function |f| is in a so called \IxAsDef{defining}
position because it serves as the
value of a hole which is defined as synthesized.
\item
For an inherited hole the reverse holds:
the hole corresponds to the context of, or parameters for, a judgement.
Its value describes the composition in terms of other identifiers introduced by values at defining positions.
For example, |cnstr.f| in the judgement |A| for argument |a| is in a so called \IxAsDef{use} position because its hole is inherited.
\item
For the concluding judgement the reverse of the previous two bullets hold.
For example,
|cnstr.inh| of the conclusion judgement |R|, implicitly defined as |cnstr.inh = cnstr.inh|, is on
a defining position although its hole is inherited.
This is because it is given by the context of the type rule itself, for use in premise judgements.
\end{Itemize}

|Ruler| uses this information to order the premise judgements from top to bottom
such that values in holes are defined before used.
Because judgements may be mutually dependent this is done in the same way as the binding group mechanism of Haskell:
the order in a group of mutually dependent judgements cannot be determined and therefore is arbitrary.

Relation |match| represents the unification of two types; it is standard.
Relation |tvFresh| simply states the existence of a fresh type variable;
we discuss its implementation in \secRef{ruler-ag-infer}. 


%if not storyPHD
\subsection{Target language: attribute grammar}
\label{ruler-ag-basics}

In this section we give a brief overview of the AG system used as the target language
for |Ruler| to generate code for.
|Ruler| generates a partial implementation expressed as an attribute grammar (AG);
we discuss this in the next section.
We present as much as is required for an understanding of the next section;
more can be found elsewhere \cite{swierstra99comb-lang,dijkstra04thag}.
This section can safely be skipped by those who are familiar with our AG system.

%if False
We use fragments from the implementation of our type rules.
In this section we view those AG fragments without its relationship to |Ruler| as
discussed in the next section.
%endif

An attribute grammar describes computations over an AST by means of attributes.
An AST is a data structure similar to data types in Haskell.
For example, part of the AST required for our type rule implemention is defined as follows:

%%[[wrap=code
%%@RulerDemoMain.3.AST.Expr.App

%%@RulerDemoMain.3.AST.Expr.IntVar
%%]

This AST for an |Expr| node defines \IxAsDef{alternatives} (or \IxAsDef{variants}, \IxAsDef{productions})
for application, integer constants and use of variables respectively.
The application alternative |App| has two |Expr| \IxAsDef{children}, whereas |Int| and |Var| have a \IxAsDef{field} holding the integer
and identifier respectively.
In the context of an alternative the node itself is called the \IxAsDef{parent}.

An \IxAsDef{attribute} holds the value of a computation; it has a name, a type and is defined as inherited (before the first vertical `| || |'),
synthesized (after the second vertical `| || |') or both (in between both `| || |').
In AG code we define attributes for a node, for example for |Expr|:

%%@rulerDemoAG.3.expr.ATTR wrap=code

Our AG system and |Ruler| use similar notation for attribute and hole definitions.
For example, attribute |ty| is synthesized and has type |Ty|.

We define the value of an attribute for each alternative of a node
by specifying an \IxAsDef{attribute equation} for the synthesized attributes of the parent
and the inherited attributes of all children.
For example, for the |Int| alternative of |Expr| we define the value of the |ty| attribute of the parent (referred to by |lhs|)
to be |Ty_Int|:

%%@rulerDemoAG.3.expr.e.int wrap=code

Each attribute equation is of the form

%{
%format node = "node"
%include lag2TeX.fmt

%%[[wrap=code
| <alternative> ^^^ <node> . <attr> = <Haskell expr>
%%]

A |<node>| may be:
\begin{Itemize}
\item |lhs|: reference to parent.
\item |<child>|: reference to child.
\item |loc|: reference to a local attribute.
The scope of a local attribute is the alternative it is declared in.
\end{Itemize}

Our implementation (based on \cite{bird84circ-traverse,johnsson87attr-as-fun})
uses Haskell expressions to define values for an attribute.
From within these Haskell expressions we refer to attributes by means of the notation |@ <node> . <attr>|:

\begin{Itemize}
\item |@ lhs. <attr>|: reference to (inherited) |<attr>| of parent.
\item |@ <child> . <attr>|: reference (synthesized) |<attr>| of |<child>|.
\item |@ <attr>|: reference to a local attribute |<attr>|.
\end{Itemize}

For example, the following combines this notation (where | ||=> | is a Haskell operator for applying constraints as a substitution):

%%[[wrap=code
SEM Expr
  | App  (f.uniq,loc.uniq1)
                         =  rulerMk1Uniq @lhs.uniq
         loc  .  tv_     =  Ty_Var @uniq1
         f    .  c       =  @lhs.c          -- may be omitted
         f    .  g       =  @lhs.g          -- may be omitted
         a    .  c       =  @f.c            -- may be omitted
              .  g       =  @lhs.g          -- may be omitted
         (loc.c_,loc.mtErrs)
                         =  ((@a.ty) `Ty_Arr` (@tv_)) <=> (@a.c |=> (@f.ty))
         lhs  .  c       =  @c_ |=> (@a.c)
              .  ty      =  @c_ |=> @a.c |=> (@tv_)
%%]

In this fragment
\begin{Itemize}
\item
|@lhs.c| refers to the |c| attribute of the parent which is passed on to the |c| attribute
of child |f|.
\item
|tv_| is defined locally and is referred to by |@tv_| in an expression for |@lhs.ty|.
\end{Itemize}

Additionally, the AG notation allows the following notational variations:
\begin{Itemize}
\item
For a sequence of attribute equations defining a value for the same |<node>|,
only the first one needs to mention |<node>|.
In the example this has been done for |a| but not for |f|.
\item
The rules for |f| and |a| may be omitted anyway as the AG system
uses built-in copy rules for attributes for which no equation has been given.
We omit the details;
the intuition is that values of attributes with the same name are
copied top-to-bottom (if inherited), bottom-to-top (if synthesized) and left-to-right
(if inherited + synthesized).
\item
AG allows pattern matching for tuples.
For example, |loc.c_| and |loc.mtErrs| are defined via AG's pattern matching notation.
\item
AG fragments may be specified at textually different locations.
The AG system gathers all fragments.
\end{Itemize}

%}

%endif

\subsection{Extensions for AG code generation}
\label{ruler-ag-infer}

In this section we discuss the modifications to our type rule specification required for the generation of a partial implementation,
and the additional infrastructure required for a working compiler.
The end result of this section is a translation of type rules to AG code.
%if storyPHD
%%[[hide "app-ruler-demo-ag"="Ruler demo: Generated AG"
\VerbatimInput[fontsize=\footnotesize]{demo.ag}
%%]
%endif
For example, the following is generated for \ruleRef{e.app};
the required additional |Ruler| specification and supporting code is discussed in this section:

%%[[wrap=code
%%@rulerDemoAG.3.expr.ATTR

%%@rulerDemoAG.3.expr.e.app
%%]

We need to deal with the following issues:

\begin{Itemize}
\item
Type rules need to be translated to AG code that describes the computation of hole values.
We exploit the similarity between type rules and attribute grammars to do this.
\item
Fresh type variables require a mechanism for generating unique values.
\item
Type rules are positive specifications,
but do not specify what needs to be done in case of errors.
\item
Of course we also need to specify parsing to an AST as well as output generation,
but we won't treat this here.
\end{Itemize}

\Paragraph{Type rule structure and AST structure}
The structure of type rules and an abstract syntax tree are often very similar.
This should come as no surprise, because type rules are usually syntax directed in their algorithmic
form so the choice which type rule to apply can be made deterministically.
We need to tell |Ruler|:

\begin{Itemize}
\item
Which hole of a scheme acts as a node from the AST, the \IxAsDef{primary hole}.
\item
Which values in this primary hole in the conclusion of a rule are children in the AST.
\item
To which AG |DATA| a scheme maps, and for each rule to which alternative.
\end{Itemize}

The AST is defined externally relative to |Ruler| (this may change in future versions of |Ruler|).
For example, the part of the AST for expression application is defined as:

%%@RulerDemoMain.3.AST.Expr.App wrap=code

The keyword |node| is used to mark the primary hole that corresponds to the AST node for scheme |expr| in the AST:

%%@rulerDemoRL.3.expr.scm.AG wrap=code

For each rule with children we mark the children and simultaneously specify the order of the children as they
appear in the AST.
For example, for \ruleRef{e.app} we mark |f| to be the first and |a| to be the second child
(the ordering is required for AG code generation taking into account AG's copy rules):

%%@rulerDemoRL.3.rl.e.app.AG wrap=code

The scheme |expr| is mapped to the AST node type |Expr| by adapting the scheme definition to:

%%@rulerDemoRL.3.expr.scm wrap=code

Similarly we adapt the header for \ruleRef{e.app} to include the name |App| as the name
of the alternative in the AST:

%%@rulerDemoRL.3.rl.e.app wrap=code

\Paragraph{|Ruler| expressions and AG expressions}
Expressions in judgements are defined using a notation to which |Ruler| attaches no meaning.
In principle, the |Ruler| expression defined for a hole is straightforwardly copied to the generated AG code.
For example, for \ruleRef{e.app} the expression |ty.a -> tv| would be copied, including the arrow |->|.
Because AG attribute definitions are expressed in Haskell, the resulting program would be incorrect
without any further measures taken.

|Ruler| uses rewrite rules to rewrite ruler expressions to Haskell expressions.
For example, |ty.a -> tv| must be rewritten to a Haskell expression representing the meaning of the
|Ruler| expression.
We define additional Haskell datatypes and functions to support the intended meaning;
unique identifiers |UID| are explained later:
%if storyPHD
%%[[hide "app-ruler-supp-hs"="Ruler demo: Supporting Haskell"
\VerbatimInput[fontsize=\footnotesize]{DemoUtils.hs}
%%]
%endif

%%@RulerDemoUtils.3.Ty wrap=code

A |Ty_All| represents universal quantification |forall|,
|Ty_Arr| represents the function type |->|,
|Ty_Var| represents a type variable
and |Ty_Any| is used internally after an error has been found
(we come back to this later).
We define a rewrite rule to rewrite |ty.a -> tv| to |ty.a `Ty_Arr` tv|:

%%[[wrap=code
rewrite ag def  a -> r = (a) `Ty_Arr` (r)
%%]

A rewrite declaration specifies a pattern (here: |a -> r|) for an expression containing variables which are bound to the actual values
of the matching expression.
These bindings are used to construct the replacement expression (here: |(a) `Ty_Arr` (r)|).
The target |ag| limits the use of the rewrite rule to code generation for AG.
The flag |def| limits the use of the rule to defining positions,
where a \IxAsDef{defining position} is defined as a position in a value for an inherited hole in a premise judgement or
a synthesized hole in a conclusion judgement.
This is a position where we construct a value opposed to a position where we deconstruct a value into its constituents.
Although no example of deconstructing a value is included in \thischapt,
we mention that in such a situation
a different rewrite rule expressing the required pattern matching (using AG language constructs) is required.
The flag |use| is used to mark those rewrite rules.

The rewrite rule used for rewriting |ty.a -> tv| actually is limited further by specifying the required type of the
value for both pattern and the type of the replacement pattern:

%%@rulerDemoRL.3.rw.TyArr wrap=code

The notion of a type for values in |Ruler| is simple: a type is just a name.
The type of an expression is deduced from the types specified for a hole or the result expression of
a rewrite rule.
This admittedly crude mechanism for checking consistency appears to work quite well in practice.

Limiting rewrite rules based on |Ruler| type information is useful in situations where
we encounter overloading of a notation;
this allows the use of juxtapositioning of expressions to
keep the resulting expression compact.
We can then specify different rewrite rules based on the types of the arguments.
The meaning of such an expression usually is evident from its context
or the choice of identifiers.
For example, |cnstr cnstr.a tv|
(\ruleRef{e.app}, \figRef{rulerDemo.A.expr.base})
means the application of constraints |cnstr| and |cnstr.a| as a substitution to type |tv|.
Constraints can be applied to constraints as well,
similar to Haskell's overloading.
To allow for this flexibility a pattern of a rewrite rule may use (|Ruler|) type variables to propagate an actual type.
For example, the rewrite rule required to rewrite |cnstr cnstr.a tv| is defined as:

%%@rulerDemoRL.3.rw.Cnstr wrap=code

Rewrite rules are only applied to saturated juxtapositionings or applications of operators.
Rewrite rules are non-recursively applied in a bottom-up strategy.

The rule assumes the definition of additional Haskell types and class instances defined elsewhere:

%%@RulerDemoUtils.3.Cnstr wrap=code

\Paragraph{Unique values}
Our implementation of ``freshness'', required for fresh type variables,
is to simulate a global seed for unique values.
The global seed is implemented by a threaded attribute |uniq|;
we have omitted its declaration and initialisation.
|Ruler| assumes that such an implementation is provided externally.
From within |Ruler| we use the keyword |unique| to obtain a unique value.
For example, the relation |tvFresh| has a |ag| judgement shape for the generation of AG
which contains a reference to |unique|:

%%@rulerDemoRL.2.tvFresh wrap=code

AG code generation inlines the judgement using the |ag| judgement shape:

%%@rulerDemoAG.3.expr.e.app wrap=code

The presence of |unique| in a judgement for a rule triggers the insertion of additional AG code to create
an unique value and to update the unique seed value.
|Ruler| automatically translates the reference to |unique| to |uniq1| and
inserts a call to |rulerMk1Uniq|.
The function |rulerMk1Uniq| is assumed to be defined externally.
It must have the following type:

%%[[wrap=code
rulerMk1Uniq  ::  <X> -> (<X>,<Y>)
rulerMk1Uniq  =   ...
%%]

For |<X>| and |<Y>| any suitable type may be chosen,
where |<X>| is restricted to match the type of the seed for unique values,
and |<Y>| matches the type of the unique value.
Our default implementation is a nested counter which allows a unique value itself
to also act as a seed for an unlimited series of unique values.
This is required for the instantiation of a quantified type where the number of fresh type variables depends on the type
(we do not discuss this further):

%%@RulerDemoUtils.3.UID wrap=code

When a rule contains multiple occurrences of |unique|, |Ruler| assumes the presence of |rulerMk<n>Uniq| which returns |<n>| unique values;
|<n>| is the number of |unique| occurrences.

%if False
Finally, we need to add some AG for the attribute declaration and initialisation of attribute @uniq@:

%%@RulerDemoMain.3.uniq wrap=code
%endif

The |Ruler| code for relation |tvFresh| also demonstrates how the |ag| judgement shape for |tvFresh| is inlined as an attribute definition.
The |ag| shape for a relation must have the form |<attrs> `=` <expr>|.

\Paragraph{Handling errors}
The generated code for \ruleRef{e.app} also shows how the implementation deals with errors.
This aspect of an implementation usually is omitted from type rules,
but it cannot be avoided when building an implementation for those type rules.
Our approach is to ignore the details related to error handling in the \LaTeX\ rendering of the type rules,
but to let the generated AG code return two values at locations where an error may occur:
\begin{Itemize}
\item
The value as defined by the type rules.
If an error occurs, this is a ``does not harm'' value.
For example, for types this is |Ty_Any|,
for lists this is an empty list.
\item
A list of errors.
If no error occurs, this list is empty.
\end{Itemize}

For example, the AG code for relation |match| as it is inlined in the translation for \ruleRef{e.app} is defined as:

%%@rulerDemoRL.2.match wrap=code

The operator |<=>| implementing the matching returns constraints as well as errors.
The errors are bound to a local attribute which is used by additional AG code for error reporting.
%if storyPHD
%%[[hide "app-ruler-supp-ag"="Ruler demo: Supporting AG"
\VerbatimInput[fontsize=\footnotesize]{DemoMain.ag}
%%]
%endif

%endif %% not limitSize


%}


\subsection{Discussion, related work, conclusion}
\label{ruler-conclude}

\Paragraph{Experiences with |Ruler|}
|Ruler| solves the problem of maintaining consistency and managing type rules;
it is a relief to avoid writing \LaTeX\ for type rules by hand,
to know that the formatted rules correspond directly
to their implementation,
and to know checks have been performed.

|Ruler| enforces all views on a type rule to be specified together.
This is a consequence of our design paradigm in which we both isolate parts
of the type rules specification (by using views),
and need to know the context of these isolated parts (by rendering parts together with their context).
As a developer of a specification all views can best be developed together,
to allow for a understandable partitioning into different views, while at the same time keeping an overview.

%if False
Type rules are just a small part of a whole compiler.
The gory details of a compiler often are swept under the carpet as uninteresting.
However, counting lines
%endif

\Paragraph{Literate programming}
Literate programming \cite{www05litprog}
is a style of programming where the program source text and its documentation are combined
into a single document.
So called \IxAsDef{tangling} and \IxAsDef{weaving} tools extract the program source and documentation.
Our |Ruler| system is different:
\begin{Itemize}
\item
Within a literate programming document program source and documentation are recognizable and identifiable artefacts.
In |Ruler| there is no such distinction.
\item
|Ruler| does not generate documentation; instead it generates fragments for use in documentation.
\end{Itemize}

We think |Ruler| is mature enough to be used by others,
and we are sure such use will be a source of new requirements.
Since |Ruler| itself has been produced using the AG system \cite{swierstra99comb-lang}
new extensions can relatively easily be incorporated.

\Paragraph{Emphasizing differences}
We use colors to emphasize differences in type rules.
For black-and-white print this is hardly a good way to convey information to the reader.
We believe however that in order understand more complex material,
more technical means (like colors, hypertext, collapsable/expandable text)
must be used to express and explain the complexity.

\Paragraph{Future research}
We foresee the following directions of further research and development of |Ruler|%
%if storyPHD
(see \chapterRef{ehcConcl} for a further elaboration)%
%else
%endif
:

\begin{Itemize}
\item
The additional specification required to shift from equational to algorithmic type rules is currently done by hand.
However, our algorithmic version of the type rules uses a heuristic for dealing with yet unknown information
and finding this unknown information.
We expect that this (and other) heuristics
can be applied to similar problems as an automated strategy.
\item
|Ruler| currently generates output for two targets: \LaTeX\ and AG.
We expect the |Ruler| to be useful in many different situations,
requiring different kinds of output,
such as material for use in theorem provers.
%if False
We already have started to develop a plugin architecture for this kind of extensibility.
%endif
\end{Itemize}

\Paragraph{Related work}
TinkerType \cite{levin99tinkertype},
used for Pierce's book \cite{typing:types-prog-lang:pierce},
comes closest to |Ruler|.
Type system features can be combined into type systems.
The system provides checks for valid combinations, and allows the specification of (implementing) code fragments.
However, no automatic code generation is supported, nor checks on the structure of judgements.

The theorem proving environment Twelf \cite{www05twelf}
is used to describe and proof properties for
programming languages \cite{harper05lect-mechlangdef},
thus answering the POPLmark challenge \cite{www05poplmark-chall}.
Although we intend to generate descriptions for use in such theorem proving tools,
we emphasize that |Ruler| is meant as a lightweight tool for the construction of well-documented compilers.

Various
%if limitSize
abstract syntax tree (AST)
%else
AST
%endif
based compiler construction tools exist
\cite{www99croap,www05asf-sdf,visser05stratego-www,www05synth-gen},
among which our AG system.
Such tools have in common that they only allow programming on the level of AST's,
whereas |Ruler| allows a higher form of programming.
Furthermore, in our experience, stepwise AG descriptions \cite{dijkstra04thag}
became too complex (which inspired us to design |Ruler| in the first place),
and we expect this to be the case for similar formalisms as well.

Finally, we also mention 
the Programmatica project, which
provides mechanisms and tools for proving properties of Haskell programs.

%if False
As mentioned in our future research,
in both cases we envision many useful extensions to |Ruler| for the generation of material for theorem provers.
We want to stress however that, already in its current state,
we have found it an indispensable tool in keeping the formal description of a whole series of compilers and the associated implementations consistent.
Ruler can be downloaded as part of EHC \cite{dijkstra05ruler-www}.
%endif

%if False
\Paragraph{(Random) observations}
Observation: type rule implementation is just a small part, the bulk is in the environment

\Paragraph{Grouping of views for a rule}
For a single rule all views are grouped together. Is this necessary?
Currently |Ruler| enforces this grouping.
Experience with [...] has shown that the grouping of views in the source code for the rules is benificial to the maintenance
of the source code.
However, the explanation of the source code seems to be better of with a gradual introduction.
In other words, the initial understanding benefits from ... ???

\Paragraph{Future research}
Translation from equational to algorithmic is done by hand, but systematically done.
It is likely that this can be automated as well.

Other patterns: interaction between known/inferred info

Generation of HOL strategies/facts (?)
%endif

%%]

%%[appendix
\subsection{Source code using |Ruler| notation}
\label{ruler-app-demo-src}

The preambles are specific to the generation for \thischapt\ because of the need for additional preprocessing
to include pretty printed fragments of the |Ruler| source code in \thischapt.

\VerbatimInput[fontsize=\small]{demo.rl2}

\subsection{Supporting AG}
\label{app-ruler-supp-ag}

\VerbatimInput[fontsize=\footnotesize]{DemoMain.ag}

\subsection{Supporting Haskell}
\label{app-ruler-supp-hs}

Type, unification

\VerbatimInput[fontsize=\footnotesize]{DemoUtils.hs}

\onecolumn
\subsection{Generated AG}
\label{app-ruler-demo-ag}

\VerbatimInput[fontsize=\footnotesize]{demo.ag}
%%]

%%[[rulerSrcTemplate
scheme X =
  view A =
    holes ...
    judgespec ...
  view B =
    holes ...
    judgespec ...

ruleset x scheme X =
  rule r =
    view A =
      judge ...        -- premises
      ...
      -
      judge ...        -- conclusion
    view B = ...
  rule s =
    view A = ...
    view B = ...
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

