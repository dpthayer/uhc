%%[main
%%@ThePlan.init

\section{Goals \& vision}
\subsection{Assumptions and directions already taken}
%%@ThePlan.goalsAndVision.assumptions

\subsection{Vision}
%%@ThePlan.goalsAndVision.vision

\subsection{SWOT: Opportunities}
%%@ThePlan.goalsAndVision.swotOpportunities

\section{UHC directions}

\section{Research directions}

\section{Work packages}
\subsection{Toplevel goals}
%%@ThePlan.workPackages.goals

\subsection{Subgoals}
%%@ThePlan.workPackages.subgoals

\subsection{Research}
%%@ThePlan.workPackages.research

\subsection{Haskell 98 compatibility}
%%@ThePlan.workPackages.haskell98compatibility

\subsection{Haskell 2010 compatibility}
%%@ThePlan.workPackages.haskell2010compatibility

\subsection{GHC compatibility \& arbitrary extensions}
%%@ThePlan.workPackages.extensions

\subsection{Maintenance \& internal changes}
%%@ThePlan.workPackages.maintenance

\subsection{RTS}
%%@ThePlan.workPackages.rtssupport

\subsection{Backends}
%%@ThePlan.workPackages.backends

\subsection{Library, tool environment, UHC as a tool}
%%@ThePlan.workPackages.library

\FigurePDF{t}{0.4}{\jobname-dpd}{Work packages, |X -> Y ===| |X| needs |Y| }{fig-workpackages}

%%@ThePlan.exit
%%]

%%[init
\begingroup  \catcode`\[=1 \catcode`\{=12
\toks0=[\endgroup
  \def\curlyopenchar[{}}
\the\toks0 \relax

\begingroup  \catcode`\]=2 \catcode`\}=12
\toks0={\endgroup
  \def\curlyclosechar{}]]
\the\toks0 \relax

\newwrite\DpdFile
\openout\DpdFile=\jobname.dot\relax

\def\writeDpd#1{\write\DpdFile{#1}}
\writeDpd{digraph}
\writeDpd\curlyopenchar
\writeDpd{rankdir=LR; node [shape=box];}
% rotate=90 ; 

\makeatletter
\def\writeDpdNode#1{%
 \edef\l{\csname r@@#1\endcsname}
 \immediate\writeDpd{"#1" [label="#1\string\n\expandafter\@@firstoftwo\l(\expandafter\@@secondoftwo\l)"] ;}}
%\global\def\@@tmpNode{}
\def\writeDpdEdges#1#2{%
 \@@for\@@tmpNode:=#2\do{%
  \immediate\writeDpd{"#1" -> "\@@tmpNode" ;}
 }
}
\makeatother

% Work package
% #1: unique identifier/label/name
% #2: short description
% #3: required predecessors: comma separated list of identifiers
% #4: required time: <X> year/month
% #5: worktype: phd, master, expproj, maint
% #6: areas of interest
% #7: assigned startdate (optional)
% #8: assigned worker(s) (optional)
\newenvironment{WorkPackage}[8]{%
 \subsubsection{#2 (#1)}
 \label{#1}
 \writeDpdNode{#1}
 \writeDpdEdges{#1}{#3}
 \def\WPmeta{%
  \begin{tabular}{||p{.25\linewidth}||p{.5\linewidth}||}
   \hline
   \textbf{#1}
   & \textit{needs}: \textbf{#3}
   \\ \hline
   \textbf{#6}
   & \textit{takes}: \textbf{#4, #5}
   \\ 
   & \textit{start}: at \textbf{#7} by \textbf{#8}
   \\ \hline
  \end{tabular}
 }
}{%
 \par
 \hspace{.07\linewidth}
 \WPmeta
 \par
}
%%]

%%[exit
% \writeDpd\curlyopenchar
% \writeDpd{rank=same ; "SelfComp" ; "UHC.usable" ; }
% \writeDpd\curlyclosechar
\writeDpd\curlyclosechar
\closeout\DpdFile
%%]

%%[goalsAndVision.assumptions
\begin{itemize}
\item
 Assumption:
 we programmers need programming languages + corresponding tools
 which do as much programming work for us whilst preventing errors as much as possible.
\item
 Assumption:
 Haskell + GHC are a language + compiler which already fulfills this need to a certain degree.
\item
 Observation:
 GHC is sophisticated but also complicated, built without newer tools.
 UHC intends to remedy this by building from scratch, using compiler specific tools (e.g. AG system).
 This has been the rationale for UHC's existence until now.
\end{itemize}
%%]

%%[goalsAndVision.vision
\begin{itemize}
\item
 If Haskell is to survive and to be used it needs not just one compiler but at least two,
 based on the notion that users invest effort to learn and use only when second source is available.
\end{itemize}
%%]

%%[goalsAndVision.swotOpportunities
\begin{itemize}
\item
 \textbf{Parallelism}:
 Exploitation of parallelism available in todays multicore processors,
 because the per processor speed will not increase because of limitations (heat dissipation + energy consumption) imposed by physics.
\item
 \textbf{Lightweight}:
 Low resource usage (energy, runtime memory \& processor cycles consumption, program size).
 Many processing environments have limited resources available: mobile phones, distributed computing environments (relative low bandwidth).
\item
 \textbf{Rapid development} (see assumptions):
 Rapid development requires tools to take over the job of the programmer.
\end{itemize}
%%]

%%[workPackages.goals
\begin{WorkPackage}%
 {Perf.Exec}% ident
 {UHC generated executable performance}% descr
 {LW.ExecSz,LW.ExecSpd,LW.ExecMem}% prerequisites (, separated)
 {}% required time
 {perf}% kind of work
 {Goal}% categorization, area to which this applies
 {}% startdate
 {}% worker
Placeholder for goal general performance of programs generated by UHC.
\end{WorkPackage}

\begin{WorkPackage}%
 {Feature}% ident
 {General desirable features}% descr
 {GADT,FunDep,GHC.lib,GC.Extra,Conc}% prerequisites (, separated)
 {}% required time
 {Compat}% kind of work
 {Goal,CompatGHC}% categorization, area to which this applies
 {}% startdate
 {}% worker
Placeholder for goal GHC compatibility and/or other desirable features.
\end{WorkPackage}

\begin{WorkPackage}%
 {Platform}% ident
 {Haskell platform compatibility}% descr
 {Pkg,Cabal.lib}% prerequisites (, separated)
 {}% required time
 {Compat}% kind of work
 {Goal,CompatPlatform}% categorization, area to which this applies
 {}% startdate
 {}% worker
Placeholder for goal Haskell platform compatibility.
\end{WorkPackage}

\begin{WorkPackage}%
 {Backend}% ident
 {Various backends}% descr
 {Backend.C,Backend.BC,Backend.Jazy,Backend.LLVM}% prerequisites (, separated)
 {}% required time
 {Backend}% kind of work
 {Goal,Backend}% categorization, area to which this applies
 {}% startdate
 {}% worker
Placeholder for goal Backends.
\end{WorkPackage}

\begin{WorkPackage}%
 {SelfComp}% ident
 {UHC self compilation}% descr
 {SelfComp.lib,UHC.usable,Cabal.lib}% prerequisites (, separated)
 {}% required time
 {Compat}% kind of work
 {Goal}% categorization, area to which this applies
 {}% startdate
 {}% worker
UHC can compile itself.
\end{WorkPackage}

\begin{WorkPackage}%
 {Maint}% ident
 {UHC longterm maintainability}% descr
 {UHC.Driver}% prerequisites (, separated)
 {}% required time
 {maint}% kind of work
 {Maintenance}% categorization, area to which this applies
 {}% startdate
 {}% worker
Internal structure required to keep internals manageable and maintainable.
\end{WorkPackage}

%%]

%%[workPackages.subgoals
\begin{WorkPackage}%
 {LW.ExecSz}% ident
 {Minimal UHC generated executable size}% descr
 {}% prerequisites (, separated)
 {}% required time
 {perf}% kind of work
 {Goal}% categorization, area to which this applies
 {}% startdate
 {}% worker
Placeholder for goal ``minimal size'' of generated executables.
\end{WorkPackage}

\begin{WorkPackage}%
 {LW.ExecSpd}% ident
 {Minimal UHC generated executable cycle use}% descr
 {StrictAna}% prerequisites (, separated)
 {}% required time
 {perf}% kind of work
 {Goal}% categorization, area to which this applies
 {}% startdate
 {}% worker
Placeholder for goal ``minimal processor cycle use'' by generated executables.
\end{WorkPackage}

\begin{WorkPackage}%
 {LW.ExecMem}% ident
 {Minimal UHC generated executable memory use}% descr
 {GC.Static}% prerequisites (, separated)
 {}% required time
 {perf}% kind of work
 {Goal}% categorization, area to which this applies
 {}% startdate
 {}% worker
Placeholder for goal ``minimal memory use'' by generated executables.
\end{WorkPackage}

\begin{WorkPackage}%
 {GC.Extra}% ident
 {Full-fledged GC}% descr
 {GC.Par,GC.Gen,GC.Precise}% prerequisites (, separated)
 {}% required time
 {design}% kind of work
 {Goal,GC,RTD}% categorization, area to which this applies
 {}% startdate
 {}% worker
Everything a GC should do, apart from the stuff required for language features.
\end{WorkPackage}

\begin{WorkPackage}%
 {UHC.usable}% ident
 {UHC usable as a real Haskell compiler}% descr
 {H98,UHC.BinFile,Backend.BC,UHC.Test,ErrMsg}% prerequisites (, separated)
 {}% required time
 {Compat}% kind of work
 {Goal}% categorization, area to which this applies
 {}% startdate
 {}% worker
UHC can be used as a tool (not as a subject of investigation).
\end{WorkPackage}
%%]

%%[workPackages.research
\begin{WorkPackage}%
 {GC.Static}% ident
 {Static GC}% descr
 {UniqAna}% prerequisites (, separated)
 {}% required time
 {master,phd}% kind of work
 {Analyses}% categorization, area to which this applies
 {}% startdate
 {}% worker
Static GC: determine statically when memory can be reused.
\end{WorkPackage}

\begin{WorkPackage}%
 {Incr.UHC}% ident
 {Incrementalization of UHC analyses}% descr
 {}% prerequisites (, separated)
 {}% required time
 {nwo,phd}% kind of work
 {Analyses,Performance}% categorization, area to which this applies
 {}% startdate
 {}% worker
Incrementalization of UHC analyses based on their AG description.
AG generated incrementalized code.
\end{WorkPackage}

\begin{WorkPackage}%
 {StrictAna}% ident
 {Strictness analysis}% descr
 {TyCore,AnaFrame}% prerequisites (, separated)
 {}% required time
 {master}% kind of work
 {Analyses}% categorization, area to which this applies
 {2009}% startdate
 {TL}% worker
Static analyses: strictness.
\end{WorkPackage}

\begin{WorkPackage}%
 {UniqAna}% ident
 {Uniqueness analysis}% descr
 {TyCore,AnaFrame}% prerequisites (, separated)
 {}% required time
 {master}% kind of work
 {Analyses}% categorization, area to which this applies
 {}% startdate
 {}% worker
Static analyses: uniqueness.
\end{WorkPackage}

\begin{WorkPackage}%
 {AnaFrame}% ident
 {Analysis framework}% descr
 {StrictAna,UniqAna}% prerequisites (, separated)
 {}% required time
 {master,phd}% kind of work
 {Analyses}% categorization, area to which this applies
 {2009}% startdate
 {TL}% worker
Static analyses framework, of which various other analyses are instances of build upon the framework.
\end{WorkPackage}

\begin{WorkPackage}%
 {ErrTop}% ident
 {Error reporting a la Bastiaan's TOP}% descr
 {ErrMsg}% prerequisites (, separated)
 {}% required time
 {phd}% kind of work
 {Analyses}% categorization, area to which this applies
 {}% startdate
 {}% worker
Integration of Bastiaan's work into UHC, taking into account more complex types.
\end{WorkPackage}
%%]

%%[workPackages.haskell98compatibility
\begin{WorkPackage}%
 {H98}% ident
 {Haskell 98 compatibility}% descr
 {Default,Deriving,MonoRestr,H98.lib}% prerequisites (, separated)
 {}% required time
 {maint}% kind of work
 {Compat98}% categorization, area to which this applies
 {}% startdate
 {}% worker
Placeholder for Haskell 98 compatibility.
n+k patterns will not be done (is removed in Haskell 2010).
\end{WorkPackage}

\begin{WorkPackage}%
 {Default}% ident
 {Haskell 98 defaulting mechanism}% descr
 {}% prerequisites (, separated)
 {}% required time
 {maint}% kind of work
 {Compat98}% categorization, area to which this applies
 {}% startdate
 {}% worker
@default@ language feature.
\end{WorkPackage}

\begin{WorkPackage}%
 {Deriving}% ident
 {Deriving mechanism}% descr
 {}% prerequisites (, separated)
 {}% required time
 {maint}% kind of work
 {Compat98}% categorization, area to which this applies
 {}% startdate
 {}% worker
Derivings for @Ix@, @Bounded@ (partly done), tuples (done explicitly in library).
\end{WorkPackage}

\begin{WorkPackage}%
 {MonoRestr}% ident
 {Monomorphism restriction}% descr
 {}% prerequisites (, separated)
 {}% required time
 {maint}% kind of work
 {Compat98}% categorization, area to which this applies
 {}% startdate
 {}% worker
\end{WorkPackage}
%%]

%%[workPackages.haskell2010compatibility
\begin{WorkPackage}%
 {H2010}% ident
 {Haskell 2010 compatibility}% descr
 {H98,FFI,PatGrd}% prerequisites (, separated)
 {}% required time
 {maint}% kind of work
 {Compat2010}% categorization, area to which this applies
 {}% startdate
 {}% worker
Placeholder for Haskell 2010 compatibility.
\end{WorkPackage}

\begin{WorkPackage}%
 {PatGrd}% ident
 {Pattern Guards}% descr
 {}% prerequisites (, separated)
 {}% required time
 {langfeature}% kind of work
 {Compat2010}% categorization, area to which this applies
 {}% startdate
 {}% worker
Pattern guards.
\end{WorkPackage}

%%]

%%[workPackages.extensions
\begin{WorkPackage}%
 {GADT}% ident
 {Generalized Algebraic Data Types}% descr
 {}% prerequisites (, separated)
 {2 month}% required time
 {langfeature}% kind of work
 {CompatGHC}% categorization, area to which this applies
 {}% startdate
 {}% worker
Finishing GADTs as already partially done by AM.
\end{WorkPackage}

\begin{WorkPackage}%
 {FunDep}% ident
 {Functional dependencies}% descr
 {TyCase,TyFun}% prerequisites (, separated)
 {}% required time
 {langfeature}% kind of work
 {CompatGHC}% categorization, area to which this applies
 {}% startdate
 {}% worker
\end{WorkPackage}

\begin{WorkPackage}%
 {TyCase}% ident
 {Type level extensible case}% descr
 {}% prerequisites (, separated)
 {}% required time
 {langfeature}% kind of work
 {CompatGHC}% categorization, area to which this applies
 {}% startdate
 {}% worker
Case constructs on type level.
\end{WorkPackage}

\begin{WorkPackage}%
 {TyFun}% ident
 {Type level functions}% descr
 {}% prerequisites (, separated)
 {}% required time
 {langfeature}% kind of work
 {CompatGHC}% categorization, area to which this applies
 {}% startdate
 {}% worker
Functions on type level.
\end{WorkPackage}

\begin{WorkPackage}%
 {ExistPred}% ident
 {Existential quantification over predicates}% descr
 {}% prerequisites (, separated)
 {}% required time
 {langfeature}% kind of work
 {CompatGHC}% categorization, area to which this applies
 {}% startdate
 {}% worker
Basically: tupling instances with anything else, to be used for opening elsewhere.
\end{WorkPackage}

\begin{WorkPackage}%
 {Conc}% ident
 {Concurrency}% descr
 {Thread}% prerequisites (, separated)
 {}% required time
 {langfeature}% kind of work
 {CompatGHC}% categorization, area to which this applies
 {}% startdate
 {}% worker
Concurrency: threads, STM, concurrency aware GC, parallel GC.
\end{WorkPackage}
%%]

%%[workPackages.rtssupport
\begin{WorkPackage}%
 {GC.Stableptr}% ident
 {StablePtr}% descr
 {}% prerequisites (, separated)
 {0.5 month}% required time
 {maint}% kind of work
 {Compat2010}% categorization, area to which this applies
 {}% startdate
 {}% worker
StablePtr as required by FFI, supported by the GC.
\end{WorkPackage}

\begin{WorkPackage}%
 {GC.Thread}% ident
 {Thread aware GC}% descr
 {}% prerequisites (, separated)
 {}% required time
 {maint}% kind of work
 {CompatGHC}% categorization, area to which this applies
 {}% startdate
 {}% worker
Thread aware GC.
\end{WorkPackage}

\begin{WorkPackage}%
 {GC.Par}% ident
 {Parallel GC}% descr
 {}% prerequisites (, separated)
 {}% required time
 {maint}% kind of work
 {CompatGHC}% categorization, area to which this applies
 {}% startdate
 {}% worker
GC itself parallelized.
\end{WorkPackage}

\begin{WorkPackage}%
 {GC.Gen}% ident
 {Full generational GC}% descr
 {}% prerequisites (, separated)
 {}% required time
 {maint}% kind of work
 {CompatGHC}% categorization, area to which this applies
 {}% startdate
 {}% worker
GC with: generations, separate areas for large blobs (collected, non-collected + explicit free + finalizer).
\end{WorkPackage}

\begin{WorkPackage}%
 {GC.Precise}% ident
 {Precise GC}% descr
 {}% prerequisites (, separated)
 {}% required time
 {maint}% kind of work
 {CompatGHC}% categorization, area to which this applies
 {}% startdate
 {}% worker
Precise GC where GC exactly knows what yes/no to collect.
\end{WorkPackage}

\begin{WorkPackage}%
 {FFI}% ident
 {Foreign Function interface}% descr
 {GC.Stableptr}% prerequisites (, separated)
 {0.5 month}% required time
 {maint}% kind of work
 {Compat2010}% categorization, area to which this applies
 {}% startdate
 {}% worker
FFI, as specified by the Haskell FFI spec. Partly done; extern call, stubs etc do miss.
\end{WorkPackage}

\begin{WorkPackage}%
 {Thread}% ident
 {Thread support}% descr
 {GC.Thread}% prerequisites (, separated)
 {3 month}% required time
 {maint}% kind of work
 {CompatGHC}% categorization, area to which this applies
 {}% startdate
 {}% worker
Threads. Two levels: OS threads as offered by OS, non-preemptive microthreads within OS threads. Heap based stacks.
\end{WorkPackage}
%%]

%%[workPackages.maintenance
\begin{WorkPackage}%
 {UHC.Test}% ident
 {UHC (regress) tested}% descr
 {Test.nofib}% prerequisites (, separated)
 {}% required time
 {}% kind of work
 {Internal}% categorization, area to which this applies
 {}% startdate
 {}% worker
UHC testing against various test suites.
\end{WorkPackage}

\begin{WorkPackage}%
 {Test.nofib}% ident
 {Nofib test suite}% descr
 {H98}% prerequisites (, separated)
 {}% required time
 {}% kind of work
 {Internal}% categorization, area to which this applies
 {}% startdate
 {}% worker
UHC can deal with nofib test suite.
\end{WorkPackage}

\begin{WorkPackage}%
 {TyCore}% ident
 {Typed core}% descr
 {}% prerequisites (, separated)
 {6 month}% required time
 {design}% kind of work
 {Internal}% categorization, area to which this applies
 {2009}% startdate
 {AD}% worker
Type core, based on GHC's core, Henk (|lambda|-cube), and calling conventions as types.
\end{WorkPackage}

\begin{WorkPackage}%
 {Pkg}% ident
 {Package support}% descr
 {}% prerequisites (, separated)
 {0.5 month}% required time
 {maint}% kind of work
 {Internal}% categorization, area to which this applies
 {2009}% startdate
 {AD}% worker
Use and build of versioned packages. Mostly done.
\end{WorkPackage}

\begin{WorkPackage}%
 {Cabal.lib}% ident
 {UHC use via Cabal for building packages}% descr
 {Pkg}% prerequisites (, separated)
 {0.5 month}% required time
 {maint}% kind of work
 {Internal}% categorization, area to which this applies
 {2009}% startdate
 {AL}% worker
Adapting cabal so it can invoke UHC.
\end{WorkPackage}
%%]

%%[workPackages.backends
\begin{WorkPackage}%
 {Backend.BC}% ident
 {Interpreter backend}% descr
 {}% prerequisites (, separated)
 {}% required time
 {design}% kind of work
 {Internal,Backend}% categorization, area to which this applies
 {2007}% startdate
 {AD}% worker
Interpreter (ByteCode) backend.
Per module compilation until object code, then linked to whole program.
\end{WorkPackage}

\begin{WorkPackage}%
 {Backend.C}% ident
 {Whole program analysis backend}% descr
 {}% prerequisites (, separated)
 {}% required time
 {design}% kind of work
 {Internal,Backend}% categorization, area to which this applies
 {2006}% startdate
 {JF}% worker
Whole program analysis backend.
Per module compilation until GRIN code, then linked to whole program, followed by HPT analyses and optimizations, finally one C module generated.
\end{WorkPackage}

\begin{WorkPackage}%
 {Backend.Jazy}% ident
 {Java backend + jazy interpreter}% descr
 {}% prerequisites (, separated)
 {}% required time
 {design}% kind of work
 {Internal,Backend}% categorization, area to which this applies
 {2009}% startdate
 {AD}% worker
Java backend, where functions and closures are represented by objects, interpreted by jazy library evaluation methods.
Per module compilation until set of Java class files, then linked together with @jar@.
\end{WorkPackage}

\begin{WorkPackage}%
 {Backend.LLVM}% ident
 {LLVM backend}% descr
 {Backend.C}% prerequisites (, separated)
 {}% required time
 {design}% kind of work
 {Internal,Backend}% categorization, area to which this applies
 {}% startdate
 {}% worker
LLVM backend, as variation of whole program analyses backend.
\end{WorkPackage}
%%]

%%[workPackages.library
\begin{WorkPackage}%
 {ErrMsg}% ident
 {Correct and clear error messages}% descr
 {}% prerequisites (, separated)
 {}% required time
 {maint}% kind of work
 {Internal}% categorization, area to which this applies
 {}% startdate
 {}% worker
Error messages pointing correctly to the program location where detection took place.
Currently this is incomplete.
\end{WorkPackage}

\begin{WorkPackage}%
 {H98.lib}% ident
 {Haskell 98 libraries}% descr
 {}% prerequisites (, separated)
 {}% required time
 {lib}% kind of work
 {Internal,Library}% categorization, area to which this applies
 {2009}% startdate
 {AD}% worker
Library modules required for H98. A few are still missing or incomplete: IO (incomplete), Time, Random, ...
\end{WorkPackage}

\begin{WorkPackage}%
 {GHC.exc}% ident
 {GHC extensible exceptions}% descr
 {ExistPred}% prerequisites (, separated)
 {}% required time
 {lib}% kind of work
 {Internal,Library}% categorization, area to which this applies
 {}% startdate
 {}% worker
Extensible exceptions as of 2009 present in GHC.
\end{WorkPackage}

\begin{WorkPackage}%
 {GHC.lib}% ident
 {Full GHC libraries}% descr
 {GHC.exc}% prerequisites (, separated)
 {}% required time
 {lib}% kind of work
 {Internal,Library}% categorization, area to which this applies
 {}% startdate
 {}% worker
Base libraries of GHC, usable/compilable without severe modifications.
\end{WorkPackage}

\begin{WorkPackage}%
 {SelfComp.lib}% ident
 {Libraries required for UHC self compilation}% descr
 {FunDep}% prerequisites (, separated)
 {}% required time
 {lib}% kind of work
 {Internal,Library}% categorization, area to which this applies
 {}% startdate
 {}% worker
Library modules required for self compilation: parser combinators, various other packages.
\end{WorkPackage}

\begin{WorkPackage}%
 {UHC.Driver}% ident
 {UHC compiler driver}% descr
 {}% prerequisites (, separated)
 {}% required time
 {design,master}% kind of work
 {Internal,Driver}% categorization, area to which this applies
 {}% startdate
 {?Jeroen Bouwmans, AL, AD}% worker
Compiler driver based on Nix (\& Camera) ideas. Dependent values are described by function invocations, which are memoized, using a persistent cached mapped onto file system.
\end{WorkPackage}

\begin{WorkPackage}%
 {UHC.BinFile}% ident
 {Binary represented intermediate files}% descr
 {}% prerequisites (, separated)
 {}% required time
 {maint}% kind of work
 {Internal,Driver}% categorization, area to which this applies
 {}% startdate
 {}% worker
Binary representation of .hi files instead of readable and parseable (and time consuming).
\end{WorkPackage}
%%]

%%[workPackages
\begin{WorkPackage}%
 {ident}% ident
 {descr}% descr
 {pre}% prerequisites (, separated)
 {time}% required time
 {worktype}% kind of work
 {areas}% categorization, area to which this applies
 {}% startdate
 {}% worker
The larger description.
\end{WorkPackage}
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

