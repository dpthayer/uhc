\documentclass[preprint,9pt]{sigplanconf}

%include lhs2tex.fmt



%format GrGlobalL = "\mathit{GlobalL}"
%format GrGlobal  = "\mathit{Global}"
%format GrBindL   = "\mathit{BindL}"
%format GrBind    = "\mathit{Bind}"
%format GrExpr    = "\mathit{Expr}"
%format GrAltL    = "\mathit{AltL}"
%format GrAlt     = "\mathit{Alt}"
%format GrValL    = "\mathit{ValL}"
%format GrVal     = "\mathit{Val}"
%format GrPatAlt  = "\mathit{PatAlt}"
%format GrPatLam  = "\mathit{PatLam}"
%format GrVarL    = "\mathit{VarL}"
%format GrVar     = "\mathit{Var}"
%format GrTag     = "\mathit{Tag}"
%format HsName    = "\mathit{Name}"
%format getNr     = "\mathit{nr}"

%format DATA = "\mathbf{syntax}"
%format TYPE = "\mathbf{type}"
%format ATTR = "\mathbf{attr}"
%format SEM  = "\mathbf{sem}"
%format USE  = "\mathbf{use}"
%format SYN  = "\mathbf{syn}"
%format INH  = "\mathbf{inh}"
%format .    = "."
%format ^    = " "


\usepackage{amsmath}

\usepackage{natbib}
\bibpunct();A{},
\let\cite=\citep
\bibliographystyle{plainnat}



\begin{document}

\conferenceinfo{ICFP '07}{September 30, Freiburg.} 
\copyrightyear{2007} 
\copyrightdata{[to be supplied]} 

%\titlebanner{Working copy v.1}        % These are ignored unless
%\preprintfooter{Working copy v.1}   % 'preprint' option specified.

\title{%
Avoiding Indirect Jumps
% Efficient Case Selection
through 
Abstract Interpretation and Global Analysis
}

\subtitle{}

\authorinfo{Jeroen Fokker\and S.~Doaitse Swierstra}
           {Utrecht University}
           {\{jeroen,doaitse\}@@cs.uu.nl}

\maketitle

\begin{abstract}
This is the text of the abstract.
\end{abstract}

%\category{CR-number}{subcategory}{third-level}

%\terms
%term1, term2

%\keywords
%keyword1, keyword2

\section{Introduction}

The text of the paper begins here.


\section{Case selection and Indirect Jumps}

Case distinction is the driving force in lazy languages

Push/enter vs eval/apply

Marlow\&Peyton Jones

Boquist \cite{boquist}

EHC




\section{Tree walk methodology}

Tree walks

Generalized folds

Attributes

AG-system as preprocessor

AG-rules

Implicit AG-rules





\section{The GRIN language}

Grin as an intermediate language between Core and Silly

Interpretation and compilation of Grin

Overview

Program is sequence of bindings

\begin{code}
DATA Program
  = Prog        mod             : GrModule
DATA GrModule
  = Mod         nm              : HsName
                globalL         : GrGlobalL
                bindL           : GrBindL
\end{code}
Binding binds function name with parameters to expression
\begin{code}
DATA GrBind
  = Bind        nm              : HsName
                argNmL          : [HsName]
                expr            : GrExpr
DATA GrGlobal
  = Global      nm              : HsName
                val             : GrVal
TYPE GrGlobalL  =   [GrGlobal]
TYPE GrBindL    =   [GrBind]
SET AllDef = GrGlobal GrGlobalL GrBind GrBindL
\end{code}

Expression manipulates and returns values

Value are nodes, variables, tags or constants

\begin{code}
DATA GrVal
  =  LitInt      int             : Int
  |  Tag         tag             : GrTag
  |  Var         nm              : HsName
  |  Node        tag             : GrTag
                 fldL            : GrValL
  |  VarNode     fldL            : GrValL
TYPE GrValL   =  [GrVal]
SET AllVal    =  GrVal GrValL
\end{code}

Tags tag nodes, either a constructed value or a thunk:
\begin{code}
DATA GrTag
  |  Con           nm              : HsName
  |  Fun           nm              : HsName
  |  PApp          needs           : Int
                   nm              : HsName
  |  App           nm              : HsName
  |  Unboxed       ^
  |  Hole
\end{code}



Patterns come in two sorts: 
Case (Lit, Tag, Node) 
and Lambda (Empty, Var, VarNode)
\begin{code}
DATA GrPatAlt
  =  LitInt      int             : Int
  |  Tag         tag             : GrTag
  |  Node        tag             : GrTag
                 fldL            : [HsName]
DATA GrPatLam
  =  Empty
  |  Var         nm              : HsName
  |  VarNode     fldL            : GrVarL
DATA GrVar
  =  Var         nm              : HsName
  |  KnownTag    tag             : GrTag
TYPE GrVarL     =   [GrVar]
\end{code}

Details of expressions: 

\begin{code}
DATA GrExpr
  =  Seq          expr            : GrExpr
                  pat             : GrPatLam
                  body            : GrExpr
  |  Unit         val             : GrVal
  |  UpdateUnit   nm              : HsName
                  val             : GrVal
  |  Case         val             : GrVal
                  altL            : GrAltL
  |  FetchNode    nm              : HsName
  |  FetchUpdate  src             : HsName
                  dst             : HsName
  |  FetchField   nm              : HsName
                  offset          : Int
                  mbTag           : Maybe GrTag
  |  Store        val             : GrVal
  |  Call         nm              : HsName
                  argL            : GrValL
  |  FFI          nm              : String
                  argL            : [HsName]
                  tagL            : GrTagL
  |  Eval         nm              : HsName
  |  App          nm              : HsName
                  argL            : GrValL
                  
DATA GrAlt
  | Alt         pat             : GrPatAlt
                expr            : GrExpr

TYPE GrAltL     =   [GrAlt]

SET AllExpr = GrExpr GrAlt GrAltL
              GrPAtAlt GrPatLam GrVar GrVarL
\end{code}


\section{Abstract interpretation}


\subsection{An abstract domain}

Abstract domain for stack values: bottom, basic, tags, locations, nodes

\begin{code}
data AbstractValue
  =  AbsBottom
  |  AbsBasic
  |  AbsTags   (Set.Set GrTag)
  |  AbsLocs   (Set.Set Location)
  |  AbsNodes  (Map.Map GrTag [AbstractValue])
  |  AbsError  String
type AbstractEnv s  
  =  STArray s Variable AbstractValue
type AbstractHeap s 
  =  STArray s Location AbstractValue
  
\end{code}


\subsection{A constraint language}

\begin{code}
data Equation
  =  IsKnown          Variable  AbstractValue
  |  IsEqual          Variable  Variable
  |  IsSelection      Variable  Variable Int GrTag
  |  IsConstruction   Variable  GrTag [Maybe Variable]
  |  IsEvaluation     Variable  Variable
  |  IsApplication    (Maybe Variable) [Variable]
data HeapEquation     ^
  = WillStore         Location  GrTag [Maybe Variable]
type Equations     = [Equation]
type HeapEquations = [HeapEquation]
\end{code}


Constraint specification as a treewalk


\subsection{Gather constraints in a treewalk}


Synthesized attributes for equations and heapequations

\begin{code}
ATTR GrModule AllDef AllExpr
  SYN  equations  USE (++) []  : Equations
  SYN  heapEqs    USE (++) []  : HeapEquations
\end{code}
Heappointer is incremented every time it is used.
\begin{code}
ATTR Program GrModule AllDef AllExpr
  INH SYN  location  :  Int
SEM Program | Prog
  mod.location = 0
\end{code}

Nodes sometimes are sometimes refered to by a variable, sometimes they are enumerated in full.
This datatype distinguishes these two cases:
\begin{code}
data NodeInfo a 
  =  InVar   Variable 
  |  InNode  GrTag [a]
 
fromInVar :: NodeInfo a -> Variable
fromInVar (InVar v)  = v
\end{code}
It is used in attributes that gather the nature of a value and a pattern, respectively:
\begin{code}
ATTR  GrVal     SYN valInfo : NodeInfo (Maybe Variable)
ATTR  GrPatAlt 
      GrPatLam  SYN patInfo : NodeInfo Variable
\end{code}
A few auxiliary attributes are necessary to do the actual gathering:
\begin{code}
ATTR  GrVal   SYN  var      : Maybe Variable
ATTR  GrValL  SYN  vars     : [Maybe Variable]
ATTR  GrVar   SYN  tag      : GrTag
              SYN  var      : Variable
ATTR  GrVarL  SYN  hdTag    : GrTag 
              SYN  vars     : [Variable]
\end{code}
The gathering is straightforward:
\begin{code}
SEM GrVal
| Tag        lhs.valInfo  =  InNode  @tag []
| Var        lhs.valInfo  =  InVar   (getNr @nm)
| Node       lhs.valInfo  =  InNode  @tag @fldL.vars
SEM GrPatAlt
| Tag        lhs.patInfo  =  InNode  @tag []
| Node       lhs.patInfo  =  InNode  @tag (map getNr @fldL)
SEM GrPatLam
| Empty      lhs.patInfo  =  InVar   wildcard
| Var        lhs.patInfo  =  InVar   (getNr @nm)
| VarNode    lhs.patInfo  =  InNode  (@fldL.hdTag)
                                     (tail @fldL.vars)
SEM GrVal
| Var        lhs.var      =  Just    (getNr @nm)
| * - Var    lhs.var      =  Nothing
SEM GrValL
| Cons       lhs.vars     =  @hd.var : @tl.vars
| Nil        lhs.vars     =  []
SEM GrVarL  
| Cons       lhs.hdTag    =  @hd.tag
SEM GrVarL
| Cons       lhs.vars     =  @hd.var : @tl.vars  
| Nil        lhs.vars     =  []
SEM GrVar
| KnownTag   lhs.tag      =  @tag
| Var        lhs.var      =  getNr @nm
\end{code}

Every expression has a target, which is either the next pattern in a sequence,
or the result of a binding.
\begin{code}
ATTR AllExpr 
  INH targetInfo: NodeInfo Variable
SEM GrBind | Bind  
  expr.targetInfo  =  InVar (getNr @nm)
SEM GrExpr | Seq    
  expr.targetInfo  =  @pat.patInfo
  body.targetInfo  =  @lhs.targetInfo
\end{code}
Inside a case-expression, we also need information about the scrutinee
\begin{code}
ATTR GrAlt GrAltL 
  INH valInfo: NodeInfo (Maybe Variable)
\end{code}
Two auxiliary functions are used to build a series of equations for matching a complete node:
\begin{code}
buildSelectEquations 
  :: Variable -> GrTag -> [Variable] -> Equations
buildSelectEquations svar ttag tnms
  = [  IsSelection tvar svar i ttag
    |  (tvar,i) <- zip tnms [0..]                      funnr    = getNr nm
                      sfx      = zip  [funnr+2+length oldArgs ..] args

    ,  tvar /= wildcard
    ]
buildUnifyEquations 
  :: [Maybe Variable] -> [Variable] -> Equations
buildUnifyEquations snms tnms
  = [  case mbSvar of
         Nothing    -> IsKnown  tvar AbsBasic
         Just svar  -> IsEqual  tvar svar
    |  (tvar,mbSvar) <- zip tnms snms
    ,  tvar /= wildcard
    ]
\end{code}
The equations that are generated for each expression type are shown in figure~\ref{fig.equations}.

To make a correspondence between formal and actual parameters,
we need to collect all calls. 
Not only the direct calls, but also the postboned ones hidden in |Fun|, |PApp| and |App| nodes.

\begin{code}
ATTR AllVal AllExpr AllDef GrModule 
  SYN allCalls USE (++) [] : AbstractCallList
  SYN fpaNodes USE (++) [] : [NodeInfo (Maybe Variable)]
ATTR GrTag 
  SYN isfpa : Bool
SEM GrVal  |  Node   
  lhs.fpaNodes  =  if    @tag.isfpa 
                   then  [ InNode @tag @fldL.vars ] 
                   else  []
SEM GrExpr | Call    
  lhs.allCalls  =  [ (getNr @nm, @argL.vars) ]
SEM GrTag
  | Fun      lhs . isfpa  = True
  | PApp     lhs . isfpa  = True
  | App      lhs . isfpa  = True
  | * - Fun PApp App
             lhs . isfpa  = False
\end{code}

The final set of equations is the combination of
those that arose from calls, and the ones that were gathered in the treewal:
\begin{code}
SEM Program  |  Prog
  lhs.equations 
   =  [  IsApplication Nothing (map fromJust args)
      |  (InNode (GrTag_App nm) args) <- @mod.fpaNodes
      ]
      ++
      [  IsEqual x y
      |  (funnr, args) <- @mod.allCalls
      ,  (x, Just y) <- zip [funnr + 2 ..] args
      ]
      ++
      [  IsEqual x y
      |  (InNode (GrTag_Fun nm) args) <- @mod.fpaNodes
      ,  (x, Just y) <- zip [getNr nm + 2 ..] args
      ]
      ++
      [  IsEqual x y
      |  (InNode (GrTag_PApp needs nm) args) <- @mod.fpaNodes
      ,  (x, Just y) <- zip [getNr nm + 2 ..] args
      ]
      ++  @mod.equations
\end{code}



\begin{figure*}
\begin{code}
SEM GrExpr | Unit UpdateUnit
  loc.equations1   = case (@lhs.targetInfo, @val.valInfo) of
                       (InVar tvar        ,  InVar svar        )  -> [IsEqual tvar svar]
                       (InVar tvar        ,  InNode stag snms  )  -> [IsConstruction tvar stag snms Nothing]
                       (InNode ttag tnms  ,  InVar svar        )  -> buildSelectEquations svar ttag tnms
                       (InNode ttag tnms  ,  InNode stag snms  )  -> buildUnifyEquations  snms tnms
SEM GrExpr | UpdateUnit
  loc.equations2   =  [ IsEqual (getNr @nm)  (getNr @val.getName) ]
SEM GrExpr | Unit
  lhs.equations    =  @loc.equations1
SEM GrExpr | UpdateUnit
  lhs.equations    =  @loc.equations2 ++ @loc.equations1

SEM GrAlt | Alt  
  lhs.equations    =  case (@pat.patInfo, @lhs.valInfo) of
                        (InNode ttag tnms, InVar svar)  -> buildSelectEquations svar ttag tnms

SEM GrExpr | FetchNode
  lhs.equations    =  case @lhs.targetInfo of
                        InVar tvar  ->  [ IsEqual  tvar         (getNr @nm)   ]
SEM GrExpr | FetchUpdate                ^          ^            ^             ^
  lhs.equations    =                    [ IsEqual  (getNr @dst) (getNr @src)  ]
SEM GrExpr | FetchField
  lhs.equations    =  case @lhs.targetInfo of
                        InVar tvar  ->  [ IsSelection tvar (getNr @nm) @offset (fromJust @mbTag) ]
  
SEM GrExpr | Store  
  lhs.location     =  @lhs.location + 1  
  lhs.heapEqs      =  case @val.valInfo of
                        InNode stag snms  -> [ WillStore @lhs.location stag snms ]
  lhs.equations    =  case (@val.valInfo, @lhs.targetInfo) of
                        (InNode stag snms, InVar tvar)  -> [ IsKnown tvar (AbsLocs (Set.singleton @lhs.location)) ] 
SEM GrGlobal | Global 
  lhs.location     =  @lhs.location + 1
  lhs.heapEqs      =  case @val.valInfo of
                        InNode stag snms  -> [ WillStore @lhs.location stag snms ]
  lhs.equations    =  case @val.valInfo of
                        InNode stag snms  -> [ IsKnown (getNr @nm) (AbsLocs (Set.singleton @lhs.location)) ]
    
SEM GrExpr | Call  
  lhs.equations    =  case @lhs.targetInfo of
                        InVar  tvar       -> [ IsEqual tvar (getNr @nm) ]
                        InNode ttag tnms  -> buildSelectEquations (getNr @nm) ttag tnms

SEM GrExpr | FFI
  loc.nodemap      =  Map.fromList ( [ (con, [ AbsBasic | con==GrTag_Unboxed ] ) | con <- @tagL ] )
  lhs.equations    =  case @lhs.targetInfo of
                        InVar tvar        -> [ IsKnown tvar (AbsNodes @loc.nodemap) ]
                        InNode ttag tnms  -> zipWith IsKnown tnms (fromJust (Map.lookup ttag @loc.nodemap))

SEM GrExpr | Eval
  lhs.equations    =  case @lhs.targetInfo of
                        InVar tvar  -> [ IsEvaluation tvar (getNr @nm) ]

SEM GrExpr | App  
  lhs.equations    =  case @lhs.targetInfo of
                        InVar tvar ->  [ IsApplication (Just tvar) (getNr @nm : map fromInVar @argL.valsInfo) ]
\end{code}
\caption{Constraints for various expression types}
\label{fig.equations}
\end{figure*}



\subsection{Solve the constraint equations}

Create two arrays, initially storing |AbsBottom| for all variables and locations.
Then do a fixpoint iteration on both sets of equations, usign two procedures
that determine which values need to be updated.
\begin{code}
solveEquations ::  Int -> Int -> Equations -> HeapEquations 
                   -> (Int,AbsHeap,AbsEnv)
solveEquations lenEnv lenHeap eqs1 eqs2
=  runST $
   do  { env   <- newArray (0, lenEnv   - 1) AbsBottom
       ; heap  <- newArray (0, lenHeap  - 1) AbsBottom
       ; let procEnv equat
             = do  { cs  <- envChanges equat env heap
                   ; bs  <- mapM (procChange env) cs
                   ; return (or bs)
                   }
             procHeap equat
             = do  { cs  <- heapChange equat env
                   ; b   <- procChange heap cs
                   ; return b
                   }
       ; count <- fixpoint eqs1 eqs2 procEnv procHeap
       ; return (count, heap, env)
       }
\end{code}
The fixpoint functions keeps processing equations while values change
\begin{code}
fixpoint eqs1 eqs2 proc1 proc2 
=  fix 0
   where  fix count 
          =  do
             {  let step1  b i  = proc1  i >>= return . (b||)
             ;  let step2  b i  = proc2  i >>= return . (b||)
             ;  changes1  <- foldM step1  False eqs1
             ;  changes2  <- foldM step2  False eqs2
             ;  if    changes1 || changes2
                then  fix (count+1)
                else  return count
             }
\end{code}
Changing an array value:
\begin{code}
procChange arr (i,e1) =
   do { e0 <- readArray arr i
      ; let e2       =  e0 `mappend` e1
            changed  =  e0 /= e2
      ; when changed (writeArray arr i e2)
      ; return changed
      }
\end{code}
Selecting the change candiates for a heap equation
\begin{code}
heapChange ::  HeapEquation -> AbstractEnv s 
               -> ST s (Location,AbstractValue)
heapChange (WillStore locat tag args) env 
 = do  { let mbres       =   tagFun tag
       ; absArgs         <-  mapM getEnv args
       ; absRes          <-  getEnv mbres
       ; let absNode     =   AbsNodes (Map.singleton tag absArgs)
       ; return (locat, absNode `mappend` absRes)
       }
       where
       getEnv Nothing   =  return AbsBottom
       getEnv (Just v)  =  readArray env v
       tagFun (GrTag_Fun nm)  =  Just (getNr nm)
       tagFun _               =  Nothing
\end{code}
Auxiliary tests needed:
\begin{code}
isPAppTag :: GrTag -> Bool
isPAppTag (GrTag_PApp _ _)    = True
isPAppTag _                   = False

isValueTag :: GrTag -> Bool
isValueTag  GrTag_Any         = True
isValueTag  GrTag_Unboxed     = True
isValueTag (GrTag_PApp _ _)   = True
isValueTag (GrTag_Con _)      = True
isValueTag _                  = False

filterTaggedNodes ::  (GrTag->Bool) 
                      -> AbstractValue -> AbstractValue
filterTaggedNodes p (AbsNodes nodes) 
  = let  newNodes = Map.filterWithKey (const . p) nodes
    in   AbsNodes newNodes
filterTaggedNodes p av
  = av
\end{code}


\begin{figure*}
\begin{code}
envChanges :: Equation -> AbstractEnv s -> AbstractHeap s -> ApplyMap -> ST s [(Variable,AbstractValue)]
envChanges equat env heap applyMap
  = case equat of
      IsKnown         d av         ->  return [(d, av)]

      IsEqual         d v          ->  do  {  av <- readArray env v
                                           ;  return [(d, av)]
                                           }
      IsSelection     d v i t      ->  do  {  av <- readArray env v
                                           ;  let res = absSelect av i t
                                           ;  return [(d,res)]
                                           }
      IsConstruction  d t as       ->  do  {  vars <- mapM (maybe (return AbsBasic) (readArray env)) as
                                           ;  let res = AbsNodes (Map.singleton t vars)
                                           ;  return [(d,res)]
                                           }
      IsEvaluation    d v          ->  do  {  av   <- readArray env v
                                           ;  res  <- absDeref av
                                           ;  return [(d,res)]
                                           }
      IsApplication mbd (f:as)     ->  do  {  av         <-  readArray env f
                                           ;  absFun     <-  case mbd of
                                                               Nothing  -> absDeref av
                                                               Just _   -> return av
                                           ;  absArgs    <-  mapM (readArray env) as
                                           ;  (sfx,res)  <-  absCall absFun absArgs
                                           ;  return $ (maybe id (\d->((d,res):)) mbd) sfx
                                           }
\end{code}
\begin{code}
    where
    absSelect av i t   =  case av of
                            AbsNodes  ns  -> maybe AbsBottom (!!i) (Map.lookup t ns)
                            AbsBottom     -> av
                            AbsError _    -> av
    absDeref av        =  case av of
                            AbsLocs ls    ->  do  { vs <- mapM (readArray heap) (Set.toList ls)
                                                  ; return (mconcat (map (filterTaggedNodes isValueTag) vs))
                                                  }
                            AbsBottom     ->  return av
                            AbsError _    ->  return av
    absCall f args     =  do {  ts <- mapM addArgs (getNodes (filterTaggedNodes isPAppTag f))
                             ;  let (sfxs,avs) = unzip ts
                             ;  return (concat sfxs, mconcat avs)
      	                     }
      where  addArgs (tag@(GrTag_PApp needs nm) , oldArgs) 
               =  do  {  let  n        =  length args
                              newtag   =  GrTag_PApp (needs-n) nm
                              funnr    = getNr nm
                              sfx      = zip  [funnr+2+length oldArgs ..] args
                      ;  res  <-  if    n<needs
                                  then  return $ AbsNodes (Map.singleton newtag (oldArgs++args))
                                  else  readArray env funnr
                      ;  return (sfx, res)
                      }
             getNodes av  =  case av of  
                               AbsNodes n  -> Map.toAscList n
                               AbsBottom   -> []
\end{code}
\caption{Selection of change candidates for variables}
\end{figure*}









\section{Discussion and future work}


How to keep the number of alternatives limited: specialized versions

Smart ordering of alternatives:
binary tree, most frequently first, or combined: Huffmancode-style

Which cases are frequent:
cons more than nil; empirical gathering of data during test run, for use in subsequent compilations

Return is also an indirect jump and can be avoided by a `came-from analysis'







\acks

Acknowledgments, if needed.

\begin{thebibliography}{}

\bibitem[Boquist 1999]{boquist}
Boquist, Urban. 
Code Optimisation Techniques for Lazy Functional Languages, 
PhD Thesis Chalmers University, G\"oteborg March 1999.

\bibitem[Dijkstra 2005]{dijkstra}
Dijkstra, Atze.
Stepping through Haskell,
PhD Thesis Utrecht University, November 2005.

\bibitem[Douma 2006]{douma}
Douma, Christof.
Exceptional GRIN, 
Master's Thesis Utrecht University, April 2006.

\bibitem[Marlow and Peyton Jones 2006]{marlow}
Marlow, Simon and Peyton Jones, Simon.
`Making a fast curry: push/enter vs.\ eval/apply for higher-order languages',
JFP2006/ICFP2004.

\bibitem[Peyton Jones 1992]{peytonjones}
Peyton Jones, Simon.
`Spineless Tagless G-machine',
 JFP 1992.


\end{thebibliography}

\end{document}





\begin{code}
\end{code}

