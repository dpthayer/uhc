\documentclass[preprint,9pt]{sigplanconf}

%include lhs2tex.fmt



%format GrGlobalL = "\mathit{GlobalL}"
%format GrGlobal  = "\mathit{Global}"
%format GrBindL   = "\mathit{BindL}"
%format GrBind    = "\mathit{Bind}"
%format GrExpr    = "\mathit{Expr}"
%format GrAltL    = "\mathit{AltL}"
%format GrAlt     = "\mathit{Alt}"
%format GrValL    = "\mathit{ValL}"
%format GrVal     = "\mathit{Val}"
%format GrPatAlt  = "\mathit{PatAlt}"
%format GrPatLam  = "\mathit{PatLam}"
%format GrVarL    = "\mathit{VarL}"
%format GrVar     = "\mathit{Var}"
%format GrTag     = "\mathit{Tag}"
%format HsName    = "\mathit{Name}"
%format getNr     = "\mathit{nr}"

%format DATA = "\mathbf{data}"
%format ATTR = "\mathbf{attr}"
%format USE  = "\mathit{use}"
%format SEM  = "\mathbf{sem}"
%format SYN  = "\mathbf{syn}"
%format INH  = "\mathbf{inh}"
%format .    = "."
%format ^    = " "


\usepackage{amsmath}

\usepackage{natbib}
\bibpunct();A{},
\let\cite=\citep
\bibliographystyle{plainnat}



\begin{document}

\conferenceinfo{ICFP '07}{September 30, Freiburg.} 
\copyrightyear{2007} 
\copyrightdata{[to be supplied]} 

%\titlebanner{Working copy v.1}        % These are ignored unless
%\preprintfooter{Working copy v.1}   % 'preprint' option specified.

\title{%
Avoiding Indirect Jumps
% Efficient Case Selection
through 
Abstract Interpretation and Global Analysis
}

\subtitle{}

\authorinfo{Jeroen Fokker\and S.~Doaitse Swierstra}
           {Utrecht University}
           {jeroen at cs.uu.nl}

\maketitle

\begin{abstract}
This is the text of the abstract.
\end{abstract}

%\category{CR-number}{subcategory}{third-level}

%\terms
%term1, term2

%\keywords
%keyword1, keyword2

\section{Introduction}

The text of the paper begins here.


\section{Case selection and Indirect Jumps}

Case distinction is the driving force in lazy languages

Push/enter vs eval/apply

Marlow\&Peyton Jones

Boquist \cite{boquist}

EHC




\section{Tree walk methodology}

Tree walks

Generalized folds

Attributes

AG-system as preprocessor

AG-rules

Implicit AG-rules





\section{The GRIN language}

Grin as an intermediate language between Core and Silly

Interpretation and compilation of Grin

Overview

Program is sequence of bindings

Binding binds function name with parameters to expression

Expression manipulates and returns values

Value are nodes, variables, tags or constants

Patterns come in two sorts: 
Case (Lit, Tag, Node) 
and Lambda (Empty, Var, VarNode)

Details of expressions: 

\begin{code}
DATA GrExpr
  | Seq         expr            : GrExpr
                pat             : GrPatLam
                body            : GrExpr
  | Unit        val             : GrVal
  | UpdateUnit  nm              : {HsName}
                val             : GrVal
  | Case        val             : GrVal
                altL            : GrAltL
  | FetchNode   nm              : {HsName}
  | FetchUpdate src             : {HsName}
                dst             : {HsName}
  | FetchField  nm              : {HsName}
                offset          : {Int}
                mbTag           : {Maybe GrTag}
  | Store       val             : GrVal
  | Call        nm              : {HsName}
                argL            : GrValL
  | FFI         nm              : {String}
                argL            : {[HsName]}
                tagL            : GrTagL
  | Eval        nm              : {HsName}
  | App         nm              : {HsName}
                argL            : GrValL
\end{code}

Seq
Unit
Eval
Apply
Case
Call
FFI
Store
UpdateUnit
FetchNode
FetchField
(Throw Catch?)





\section{Abstract interpretation}


\subsection{An abstract domain}

Abstract domain for stack values: bottom, basic, tags, locations, nodes

\begin{code}
data AbstractValue
  =  AbsBottom
  |  AbsBasic
  |  AbsTags   (Set.Set GrTag)
  |  AbsLocs   (Set.Set Location)
  |  AbsNodes  (Map.Map GrTag [AbstractValue])
  |  AbsError  String
\end{code}


\subsection{A constraint language}

\begin{code}
data Equation
  =  IsKnown          Variable  AbstractValue
  |  IsEqual          Variable  [Variable]
  |  IsSelection      Variable  Variable Int GrTag
  |  IsConstruction   Variable  GrTag [Maybe Variable]
  |  IsEvaluation     Variable  Variable
  |  IsApplication    (Maybe Variable) [Variable]
\end{code}


Constraint specification as a treewalk


\subsection{Gather constraints in a treewalk}


Synthesized attributes for equations and heapequations

\begin{code}
ATTR GrModule AllGlobal AllBind AllExpr
  SYN  equations  USE {++} {[]}  : {Equations}
  SYN  heapEqs    USE {++} {[]}  : {HeapEquations}
\end{code}
We need the |evalMap| in some expressions, so we pass it down.
Heappointer is incremented every time it is used.
\begin{code}
ATTR AllGlobal AllBind AllExpr
  INH  evalMap  :  {EvalMap}
ATTR GrModule AllGlobal AllBind AllExpr
  INH SYN  location  :  Int
\end{code}

Nodes sometimes are sometimes refered to by a variable, sometimes they are enumerated in full.
This datatype distinguishes these two cases:
\begin{code}
data NodeInfo a 
  =  InVar   Variable 
  |  InNode  GrTag [a]
  
fromInVar :: NodeInfo a -> Variable
fromInVar (InVar v)  = v
\end{code}
It is used in attributes that gather the nature of a value and a pattern, respectively:
\begin{code}
ATTR  GrVal     SYN valInfo : { NodeInfo (Maybe Variable) }
ATTR  GrPatAlt 
      GrPatLam  SYN patInfo : { NodeInfo Variable  }
\end{code}
A few auxiliary attributes are necessary to do the actual gathering:
\begin{code}
ATTR  GrVal   SYN  var      : { Maybe Variable }
ATTR  GrValL  SYN  vars     : {[Maybe Variable]}
ATTR  GrVar   SYN  tag      : GrTag
              SYN  var      : { Variable }
ATTR  GrVarL  SYN  hdTag    : GrTag 
              SYN  vars     : {[Variable]}
\end{code}
The gathering is straightforward:
\begin{code}
SEM GrVal
| Tag        lhs.valInfo  =  InNode  @tag []
| Var        lhs.valInfo  =  InVar   (getNr @nm)
| Node       lhs.valInfo  =  InNode  @tag @fldL.vars
SEM GrPatAlt
| Tag        lhs.patInfo  =  InNode  @tag []
| Node       lhs.patInfo  =  InNode  @tag (map getNr @fldL)
SEM GrPatLam
| Empty      lhs.patInfo  =  InVar   wildcard
| Var        lhs.patInfo  =  InVar   (getNr @nm)
| VarNode    lhs.patInfo  =  InNode  (@fldL.hdTag)
                                     (tail @fldL.vars)
SEM GrVal
| Var        lhs.var      =  Just    (getNr @nm)
| * - Var    lhs.var      =  Nothing
SEM GrValL
| Cons       lhs.vars     =  @hd.var : @tl.vars
| Nil        lhs.vars     =  []
SEM GrVarL  
| Cons       lhs.hdTag    =  @hd.tag
SEM GrVarL
| Cons       lhs.vars     =  @hd.var : @tl.vars  
| Nil        lhs.vars     =  []
SEM GrVar
| KnownTag   lhs.tag      =  @tag
| Var        lhs.var      =  getNr @nm
\end{code}

Every expression has a target, which is either the next pattern in a sequence,
or the result of a binding.
\begin{code}
ATTR AllExpr 
  INH targetInfo: {NodeInfo Variable}
SEM GrBind | Bind  
  expr.targetInfo  =  InVar (getNr @nm)
SEM GrExpr | Seq    
  expr.targetInfo  =  @pat.patInfo
  body.targetInfo  =  @lhs.targetInfo
\end{code}
Inside a case-expression, we also need information about the scrutinee
\begin{code}
ATTR GrAlt GrAltL 
  INH valInfo: {NodeInfo (Maybe Variable)}
\end{code}
Two auxiliary functions are used to build a series of equations for matching a complete node:
\begin{code}
buildSelectEquations 
  :: Variable -> GrTag -> [Variable] -> Equations
buildSelectEquations svar ttag tnms
  = [  IsSelection tvar svar i ttag
    |  (tvar,i) <- zip tnms [0..]
    ,  tvar /= wildcard
    ]
buildUnifyEquations 
  :: [Maybe Variable] -> [Variable] -> Equations
buildUnifyEquations snms tnms
  = [  case mbSvar of
         Nothing    -> IsKnown  tvar AbsBasic
         Just svar  -> IsEqual  tvar [svar]
    |  (tvar,mbSvar) <- zip tnms snms
    ,  tvar /= wildcard
    ]
\end{code}
The equations that are generated for each expression type are shown in figure~\ref{fig.equations}.

If the program contains |App| or |PApp| nodes, evaluation of them might
result in functions that were not statically visible.
Therefore, we need more equations, which are generated in figure~\ref{fig.dynapp}
But first, we gather all |App| and |PApp| nodes.
\begin{code}
ATTR AllVal AllExpr AllBind AllGlobal GrModule 
  SYN  appPappNodes USE {++} {[]} : {[NodeInfo (Maybe Variable)]} 
ATTR GrTag 
  SYN  isAppPApp USE {||} {False} : {Bool}
SEM GrVal |  Node   
  lhs.appPappNodes  =  if    @tag.isAppPApp 
                       then  [ InNode @tag.self @fldL.vars ] 
                       else  []
SEM GrTag |  Lit
  lhs.isAppPApp  =  case @categ of
                      GrTagPApp _ -> True
                      GrTagApp    -> True
                      _           -> False
\end{code}


\begin{figure*}
\begin{code}
genDynApplyEqs applyMap evalMap appPappNodes 
  = [ IsApplication Nothing (map fromJust args) (fromJust (Map.lookup tag evalMap))
    | (InNode tag@(GrTag_Lit GrTagApp x y) args) <- appPappNodes
    ]
    ++
    concat
    [ let  lasttag = GrTag_Lit (GrTagPApp 1        ) 0 nm
           funnr   = either undefined id (fromJust $ Map.lookup lasttag applyMap)
      in   zipWith IsEqual [funnr+1+needs+length args ..] (map ((:[]).fromJust) (reverse args))
    | (InNode (GrTag_Lit (GrTagPApp needs) _ nm) args) <- appPappNodes
    ]
\end{code}
\caption{Dynamic application equations}
\label{fig.dynapp}
\end{figure*}





\begin{code}
\end{code}






\begin{figure*}
\begin{code}
SEM GrExpr | Unit UpdateUnit
  loc.equations1   = case (@lhs.targetInfo, @val.valInfo) of
                       (InVar tvar        ,  InVar svar        )  -> [IsEqual tvar [svar]]
                       (InVar tvar        ,  InNode stag snms  )  -> [IsConstruction tvar stag snms Nothing]
                       (InNode ttag tnms  ,  InVar svar        )  -> buildSelectEquations svar ttag tnms
                       (InNode ttag tnms  ,  InNode stag snms  )  -> buildUnifyEquations  snms tnms
SEM GrExpr | UpdateUnit
  loc.equations2   =  [ IsEqual (getNr @nm)  [getNr @val.getName] ]
SEM GrExpr | Unit
  lhs.equations    =  @loc.equations1
SEM GrExpr | UpdateUnit
  lhs.equations    =  @loc.equations2 ++ @loc.equations1

SEM GrAlt | Alt  
  lhs.equations    =  case (@pat.patInfo, @lhs.valInfo) of
                        (InNode ttag tnms, InVar svar)  -> buildSelectEquations svar ttag tnms

SEM GrExpr | FetchNode
  lhs.equations    =  case @lhs.targetInfo of
                        InVar tvar  ->  [ IsEqual  tvar         [getNr @nm]   ]
SEM GrExpr | FetchUpdate                ^          ^            ^             ^
  lhs.equations    =                    [ IsEqual  (getNr @dst) [getNr @src]  ]
SEM GrExpr | FetchField
  lhs.equations    =  case @lhs.targetInfo of
                        InVar tvar  ->  [ IsSelection tvar (getNr @nm) @offset (fromJust @mbTag) ]
  
SEM GrExpr | Store  
  lhs.location     =  @lhs.location + 1  
  lhs.heapEqs      =  case @val.valInfo of
                        InNode stag snms  -> [ WillStore @lhs.location stag snms (Map.lookup stag @lhs.evalMap) ]
  lhs.equations    =  case (@val.valInfo, @lhs.targetInfo) of
                        (InNode stag snms, InVar tvar)  -> [ IsKnown tvar (AbsLocs (Set.singleton @lhs.location)) ] 
SEM GrGlobal | Global 
  lhs.location     =  @lhs.location + 1
  lhs.heapEqs      =  case @val.valInfo of
                        InNode stag snms  -> [ WillStore @lhs.location stag snms (Map.lookup stag @lhs.evalMap) ]
  lhs.equations    =  case @val.valInfo of
                        InNode stag snms  -> [ IsKnown (getNr @nm) (AbsLocs (Set.singleton @lhs.location)) ]
    
SEM GrExpr | Call  
  lhs.equations    =  case @lhs.targetInfo of
                        InVar  tvar       -> [ IsEqual tvar [getNr @nm] ]
                        InNode ttag tnms  -> buildSelectEquations (getNr @nm) ttag tnms

SEM GrExpr | FFI
  loc.nodemap      =  Map.fromList ( [ (con, [ AbsBasic | con==GrTag_Unboxed ] ) | con <- @tagL ] )
  lhs.equations    =  case @lhs.targetInfo of
                        InVar tvar        -> [ IsKnown tvar (AbsNodes @loc.nodemap) ]
                        InNode ttag tnms  -> zipWith IsKnown tnms (fromJust (Map.lookup ttag @loc.nodemap))

SEM GrExpr | Eval
  lhs.equations    =  case @lhs.targetInfo of
                        InVar tvar  -> [ IsEvaluation tvar (getNr @nm) ]

SEM GrExpr | App  
  lhs.equations    =  case @lhs.targetInfo of
                        InVar tvar -> let  [ IsApplication (Just tvar) (getNr @nm : map fromInVar @argL.valsInfo) ]
\end{code}
\caption{Constraints for various expression types}
\label{fig.equations}
\end{figure*}



\subsection{Solve the constraint equations}

Create two arrays, initially storing |AbsBottom| for all variables and locations.
Then do a fixpoint iteration on both sets of equations, usign two procedures
that determine which values need to be updated.
\begin{code}
solveEquations ::  Int -> Int -> Equations -> HeapEquations 
                   -> ApplyMap -> (Int,AbsHeap,AbsEnv)
solveEquations lenEnv lenHeap eqs1 eqs2 applyMap
=  runST $
   do  { let lenEnv2 = lenEnv + Map.size applyMap
       ; env   <- newArray (0, lenEnv2 - 1) AbsBottom
       ; heap  <- newArray (0, lenHeap - 1) AbsBottom
       ; let procEnv equat
             = do  { cs  <- envChanges equat env heap applyMap
                   ; bs  <- mapM (procChange env) cs
                   ; return (or bs)
                   }
             procHeap equat
             = do  { cs  <- heapChange equat env
                   ; b   <- procChange heap cs
                   ; return b
                   }
       ; count <- fixpoint eqs1 eqs2 procEnv procHeap
       ; return (count, heap, env)
       }
\end{code}
The fixpoint functions keeps processing equations while values change
\begin{code}
fixpoint eqs1 eqs2 proc1 proc2 
=  fix 0
   where  fix count 
          =  do
             {  let step1  b i  = proc1  i >>= return . (b||)
             ;  let step2  b i  = proc2  i >>= return . (b||)
             ;  changes1  <- foldM step1  False eqs1
             ;  changes2  <- foldM step2  False eqs2
             ;  if    changes1 || changes2
                then  fix (count+1)
                else  return count
             }
\end{code}
Changing an array value:
\begin{code}
procChange arr (i,e1) =
   do { e0 <- readArray arr i
      ; let e2       =  e0 `mappend` e1
            changed  =  e0 /= e2
      ; when changed (writeArray arr i e2)
      ; return changed
      }
\end{code}
Selecting the change candiates for a heap equation
\begin{code}
heapChange ::  HeapEquation -> AbstractEnv s 
               -> ST s (Location,AbstractValue)
heapChange (WillStore locat tag args mbres) env 
 = do  { absArgs  <- mapM getEnv args
       ; absRes   <- getEnv mbres
       ; let absNode = AbsNodes (Map.singleton tag absArgs)
       ; return (locat, absNode `mappend` absRes)
       }
       where
       getEnv    =  maybe  (return AbsBottom) 
                           (\v -> readArray env v >>= return )
\end{code}



\begin{figure*}
\begin{code}
envChanges :: Equation -> AbstractEnv s -> AbstractHeap s -> ApplyMap -> ST s [(Variable,AbstractValue)]
envChanges equat env heap applyMap
  = case equat of
      IsKnown         d av         ->  return [(d, av)]

      IsEqual         d vs         ->  do  {  rs <- mapM (readArray env) vs
                                           ;  return [(d, mconcat rs)]
                                           }
      IsSelection     d v i t      ->  do  {  av <- readArray env v
                                           ;  let res =  case av of
                                                          AbsNodes  ns  -> maybe AbsBottom (!!i) (Map.lookup t ns)
                                                          AbsBottom     -> av
                                                          AbsError _    -> av
                                           ;  return [(d,res)]
                                           }
      IsConstruction  d t as       ->  do  {  vars <- mapM (maybe (return AbsBasic) (readArray env)) as
                                           ;  let res = AbsNodes (Map.singleton t vars)
                                           ;  return [(d,res)]
                                           }
      IsEvaluation    d v          ->  do  {  av <- readArray env v
                                           ;  res <- absDeref av
                                           ;  return [(d,res)]
                                           }
      IsApplication mbd (f:as)     ->  do  {  av         <-  readArray env f
                                           ;  absFun     <-  case mbd of
                                                              Nothing  -> absDeref av
                                                              Just _   -> return av
                                           ;  absArgs    <-  mapM (readArray env) as
                                           ;  (sfx,res)  <-  absCall absFun absArgs
                                           ;  return $ (maybe id (\d->((d,res):)) mbd) sfx
                                           }
    where
    absDeref av
      = case av of
          AbsLocs ls  ->  do  { vs <- mapM (readArray heap) (Set.toList ls)
                              ; return (mconcat (map (filterTaggedNodes isValueTag) vs))
                              }
          AbsBottom   ->  return av
          AbsError _  ->  return av
    absCall f args
      = do  {  ts <- mapM addArgs (getNodes (filterTaggedNodes isPAppTag f))
            ;  let (sfxs,avs) = unzip ts
            ;  return (concat sfxs, mconcat avs)
      	    }
      where addArgs (tag@(GrTag_Lit (GrTagPApp needs) _ nm) , oldArgs) 
              =  do 
                 { let  n        =  length args
                        newtag   =  GrTag_Lit (GrTagPApp (needs-n)) 0 nm
                        lasttag  =  GrTag_Lit (GrTagPApp 1        ) 0 nm
                        funnr    =  either undefined id (fromJust $ Map.lookup lasttag applyMap)
                        sfx      =  zip  [funnr+2+needs-length args ..] (reverse args)
                 ; res <-  if    n<needs
                           then  return $ AbsNodes (Map.singleton newtag (oldArgs++args))
                           else  readArray env funnr
                 ; return (sfx, res)
                 }
\end{code}
\caption{Selection of change candidates for variables}
\end{figure*}








\section{Discussion and future work}


How to keep the number of alternatives limited: specialized versions

Smart ordering of alternatives:
binary tree, most frequently first, or combined: Huffmancode-style

Which cases are frequent:
cons more than nil; empirical gathering of data during test run, for use in subsequent compilations

Return is also an indirect jump and can be avoided by a `came-from analysis'







\acks

Acknowledgments, if needed.

\begin{thebibliography}{}

\bibitem[Boquist 1999]{boquist}
Boquist, Urban. 
Code Optimisation Techniques for Lazy Functional Languages, 
PhD Thesis Chalmers University, G\"oteborg March 1999.

\bibitem[Dijkstra 2005]{dijkstra}
Dijkstra, Atze.
Stepping through Haskell,
PhD Thesis Utrecht University, November 2005.

\bibitem[Douma 2006]{douma}
Douma, Christof.
Exceptional GRIN, 
Master's Thesis Utrecht University, April 2006.

\bibitem[Marlow and Peyton Jones 2006]{marlow}
Marlow, Simon and Peyton Jones, Simon.
`Making a fast curry: push/enter vs.\ eval/apply for higher-order languages',
JFP2006/ICFP2004.

\bibitem[Peyton Jones 1992]{peytonjones}
Peyton Jones, Simon.
`Spineless Tagless G-machine',
 JFP 1992.


\end{thebibliography}

\end{document}





\begin{code}
\end{code}

