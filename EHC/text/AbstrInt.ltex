\documentclass[preprint,9pt]{sigplanconf}

%include lhs2tex.fmt



%format GrGlobalL = "\mathit{GlobalL}"
%format GrGlobal  = "\mathit{Global}"
%format GrBindL   = "\mathit{BindL}"
%format GrBind    = "\mathit{Bind}"
%format GrExpr    = "\mathit{Expr}"
%format GrAltL    = "\mathit{AltL}"
%format GrAlt     = "\mathit{Alt}"
%format GrValL    = "\mathit{ValL}"
%format GrVal     = "\mathit{Val}"
%format GrPatAlt  = "\mathit{PatAlt}"
%format GrPatLam  = "\mathit{PatLam}"
%format GrVarL    = "\mathit{VarL}"
%format GrVar     = "\mathit{Var}"
%format GrTag     = "\mathit{Tag}"
%format HsName    = "\mathit{Name}"
%format getNr     = "\mathit{nr}"

%format DATA = "\mathbf{syntax}"
%format TYPE = "\mathbf{type}"
%format SET  = "\mathbf{set}"
%format ATTR = "\mathbf{attr}"
%format SEM  = "\mathbf{sem}"
%format USE  = "\mathbf{use}"
%format SYN  = "\mathbf{syn}"
%format INH  = "\mathbf{inh}"
%format .    = "."
%format ^    = " "


\usepackage{amsmath}

\usepackage{natbib}
\bibpunct();A{},
\let\cite=\citep
\bibliographystyle{plainnat}



\begin{document}

\conferenceinfo{ICFP '07}{September 30, Freiburg.} 
\copyrightyear{2007} 
\copyrightdata{[to be supplied]} 

%\titlebanner{Working copy v.1}        % These are ignored unless
%\preprintfooter{Working copy v.1}   % 'preprint' option specified.

\setlength{\parindent}{0pt}
\setlength{\parskip}{3pt}


\title{%
Avoiding Indirect Jumps
% Efficient Case Selection
through 
Abstract Interpretation and Global Analysis
}

\subtitle{}

\authorinfo{Jeroen Fokker\and S.~Doaitse Swierstra}
           {Utrecht University}
           {\{jeroen,doaitse\}@@cs.uu.nl}

\maketitle

\begin{abstract}
This is the text of the abstract.
\end{abstract}

%\category{CR-number}{subcategory}{third-level}

%\terms
%term1, term2

%\keywords
%keyword1, keyword2

\section{Introduction}

The text of the paper begins here.


\section{Case selection and Indirect Jumps}

Case distinction is the driving force in lazy languages

Push/enter vs eval/apply

Marlow\&Peyton Jones

Boquist \cite{boquist}

EHC




\section{Tree walk methodology}

Tree walks

Generalized folds

Attributes

AG-system as preprocessor

AG-rules

Implicit AG-rules





\section{The GRIN language}

Grin as an intermediate language between Core and Silly

Interpretation and compilation of Grin

Overview

Program is sequence of bindings

\begin{code}
DATA Program
  = Prog        mod             : GrModule
DATA GrModule
  = Mod         nm              : HsName
                globalL         : GrGlobalL
                bindL           : GrBindL
\end{code}
Binding binds function name with parameters to expression
\begin{code}
DATA GrBind
  = Bind        nm              : HsName
                argNmL          : [HsName]
                expr            : GrExpr
DATA GrGlobal
  = Global      nm              : HsName
                val             : GrVal
TYPE GrGlobalL  =   [GrGlobal]
TYPE GrBindL    =   [GrBind]
SET AllDef = GrGlobal GrGlobalL GrBind GrBindL
\end{code}

Expression manipulates and returns values

Value are nodes, variables, tags or constants

\begin{code}
DATA GrVal
  =  LitInt      int             : Int
  |  Tag         tag             : GrTag
  |  Var         nm              : HsName
  |  Node        tag             : GrTag
                 fldL            : GrValL
  |  VarNode     fldL            : GrValL
TYPE GrValL   =  [GrVal]
SET AllVal    =  GrVal GrValL
\end{code}

Tags tag nodes, either a constructed value or a thunk:
\begin{code}
DATA GrTag
  |  Con           nm              : HsName
  |  Fun           nm              : HsName
  |  PApp          needs           : Int
                   nm              : HsName
  |  App           nm              : HsName
  |  Unboxed       ^
  |  Hole
\end{code}



Patterns come in two sorts: 
Case (Lit, Tag, Node) 
and Lambda (Empty, Var, VarNode)
\begin{code}
DATA GrPatAlt
  =  LitInt      int             : Int
  |  Tag         tag             : GrTag
  |  Node        tag             : GrTag
                 fldL            : [HsName]
DATA GrPatLam
  =  Empty
  |  Var         nm              : HsName
  |  VarNode     fldL            : GrVarL
DATA GrVar
  =  Var         nm              : HsName
  |  KnownTag    tag             : GrTag
TYPE GrVarL     =   [GrVar]
\end{code}

Details of expressions: 

\begin{code}
DATA GrExpr
  =  Seq          expr            : GrExpr
                  pat             : GrPatLam
                  body            : GrExpr
  |  Unit         val             : GrVal
  |  UpdateUnit   nm              : HsName
                  val             : GrVal
  |  Case         val             : GrVal
                  altL            : GrAltL
  |  FetchNode    nm              : HsName
  |  FetchUpdate  src             : HsName
                  dst             : HsName
  |  FetchField   nm              : HsName
                  offset          : Int
                  mbTag           : Maybe GrTag
  |  Store        val             : GrVal
  |  Call         nm              : HsName
                  argL            : GrValL
  |  FFI          nm              : String
                  argL            : [HsName]
                  tagL            : GrTagL
  |  Eval         nm              : HsName
  |  App          nm              : HsName
                  argL            : GrValL
                  
DATA GrAlt
  | Alt         pat             : GrPatAlt
                expr            : GrExpr

TYPE GrAltL     =   [GrAlt]

SET AllExpr = GrExpr GrAlt GrAltL
              GrPAtAlt GrPatLam GrVar GrVarL
\end{code}


\section{Abstract interpretation}

In this section we describe an abstract interpretation
algorithm for Grin programs.
The algorithm does a fixpoint iteration for solving
a set of constraints.
The constraints are first collected by doing a tree walk
over the Grin program.
We start with a description of an abstract domain,
and a language for specifying the constraints.

\subsection{An abstract domain}

Grin programs consist of expressions, 
which contain values, which can be variables.
Although Grin is an untyped language,
in code generated from a correct Haskell program
variables always refer to values of the same type.
We will use abstract interpretation to not only 
infer these types, but also collect more detailed 
information. 

Running Grin programs maintain a heap of
dynamically allocated nodes.
More specific, execution of a |Store| expression
allocates a new heap cell, as do bindings in
a global |GrBind|.
Our abstract interpretation algorithm will
also determine, for each |Store| expression and
each global |GrBind|, what type of node it can create.
The abstraction of all heap cells that a particular
|Store| of |GrBind| creates is known as a |Location|.
Thus, each |Location| corresponds uniquely to
a |Store| or |GrBind|. In our implementation we
identify locations simply by consecutive numbers.
\begin{code}
type Location = Int
\end{code}
Grin variables are used to refer to four different
types of values.
They can store values of basic type (Char, Int etc.),
or hold a single tag,
or be a pointer to a heap location,
of refer to a complete node.

We introduce a data type |AbstractValue| which will
be used as an abstract domain for our abstract interpretation.
It distinguishes these four cases, with an added
bottom and error case to form a complete lattice
suitable for fixpoint iteration.
\begin{code}
data AbstractValue
  =  AbsBottom
  |  AbsBasic
  |  AbsTags   (Set GrTag)
  |  AbsLocs   (Set Location)
  |  AbsNodes  (Map GrTag [AbstractValue])
  |  AbsError  String
\end{code}
In the |AbsTags| case, abstract interpretation will reveal
to what subset of all possible tags a variable can refer.
Similary, for |AbsLocs| we determine to which locations
a pointer can point.
In the |AbsNodes| case, we not only determine the possible
tags of the nodes, but for each of these also the abstract values
of their parameters.
In the Grin code of a correct program, abstract values
of the parameters of a node in an |AbsNodes| mapping
will never be |AbsNodes| themselves.
  
The fact that |AbstractValue| indeed forms a lattice
is expressed by the following definition,
which specifies how two abstract values can be merged into one.
We state that |AbsBottom| is the identity of a |Monoid|
\begin{code}  
instance Monoid AbstractValue where
    mempty                                  =  AbsBottom
\end{code}
That is, any abstract value remains unchanged when merging it with |AbsBottom|
\begin{code}
 ^  mappend  a          AbsBottom   =  a
 ^  mappend  AbsBottom  b           =  b
\end{code}
Abstract values of each of the four types can be merged with others of the same type:
\begin{code}
 ^  mappend AbsBasic AbsBasic     
 ^     =  AbsBasic
 ^   mappend (AbsTags  at) (AbsTags  bt) 
 ^     =  AbsTags (Set.union at bt)
 ^   mappend (AbsLocs  al) (AbsLocs  bl) 
 ^     =  AbsLocs (Set.union al bl)
 ^   mappend (AbsNodes an) (AbsNodes bn) 
 ^     =  AbsNodes (Map.unionWith (zipWith mappend) an bn)
\end{code}
Errors remain an error even when merged with other values:
\begin{code}
 ^   mappend a@(AbsError _ ) _  =  a
 ^   mappend _ b@(AbsError _ )  =  b
\end{code}
And new errors originate from merging abstract values from incompatible types:
\begin{code}
 ^   mappend a b  
 ^     =  AbsError (show a ++ " incompatible with " ++ show b)
\end{code}  
  
  
  
  
  
The goal of the abstract interpretation algorithm is
to determine the abstract value of each variable
in the program, and likewise for eacht abstract heap |Location|.
For efficiency reasons we represent these mappings with arrays:
\begin{code}
type AbstractEnv s  
  =  STArray s Variable AbstractValue
type AbstractHeap s 
  =  STArray s Location AbstractValue
\end{code}
Like a |Location|, each |Variable| is also represented by a number:
\begin{code}
type Variable = Int
\end{code}
A preprocessing stage uniquely numbers all variable names in a program
(taking care of scoping when necessary),
and makes the sequence number available through a function
\begin{code}
getNr :: HsName -> Variable
\end{code}


\subsection{A constraint language}

By observing a Grin program, we can specify constraints
which hold for variables and locations.
Before doing so, we need a language to specify these constraints.
We introduce the type |Equation| for describing six different
types of constraints for the abstract value of variables.
Likewise, we have |HeapEquation| for specifying constraints
on the abstract values of abstract heap locations.
\begin{code}
data Equation
  =  IsKnown          Variable  AbstractValue
  |  IsEqual          Variable  Variable
  |  IsSelection      Variable  Variable Int GrTag
  |  IsConstruction   Variable  GrTag [Maybe Variable]
  |  IsEvaluation     Variable  Variable
  |  IsApplication    (Maybe Variable) [Variable]
\end{code}
Five out of six constraint types specify a variable which
is to fulfill certain properties.
Only in the case of an |IsApplication| constraint, mentioning
such a variable is optional.

It is allowed to have more than one constraint for a particular variable.
They complement each other. 
If for example a constraint specifies that a variable is known
to possibly have a particular abstract value, 
and another constraint specifies that it is known to have
another value, the abstract interpretation algorithm will
conclude that this variable can have either of these two values.

This example illustrates the semantics of the |IsKnown| constraint:
|IsKnown v a| means that variable |v| can have abstract value |a|.
The meaning of |IsEqual v w| is that variable |v| can have all 
values that variable |w| has. Note that the constraint is
not symmetrical: the solution for |w| will be a subset of 
the solution for |v|, but not necessarily be the same.

The meaning of |IsSelection v n i t| is that |v| can be the 
selection of the |i|th component of any node tagged by |t|
which can be the value of variable |n|.
Dually, the meaning of |IsConstruction v t as| is that |v| can be
a node with tag |t| and arguments |as|. Not all arguments need to be known.

Next, the meaning if |IsEvaluation v w| is that |v| can be the
evaluation result of any value of |w|.
Finally, the meaning of |IsApplication v (f:as)| is that 
|f| is a variable that refers to a function which is applied to
values refered to by variables |as|,
and that the result is a possible value of |v|.
For this type of constraint, mentioning a variable |v| is optional.
If it is lacking, the constraint still bears information
on the possible values of parameters of |f|.

For heap equations, there is only one constraint type:
\begin{code}
data HeapEquation
  =  WillStore Location GrTag [Maybe Variable]
\end{code}
The meaing of |WillStore p t as| is that location |p|
will hold a node with tag |t| and arguments |as|.
Note that a heap cell always stores a complete node,
not an isolated value of other type 
(basic value, tag or pointer to another heap cell).

The sets of constraints for variables and locations, respectively,
are simply collected in lists, for which we define the following types:
\begin{code}  
type Equations      = [Equation]
type HeapEquations  = [HeapEquation]
\end{code}



\subsection{Collect constraints in a treewalk}


Synthesized attributes for equations and heapequations

\begin{code}
ATTR GrModule AllDef AllExpr
  SYN  equations  USE (++) []  : Equations
  SYN  heapEqs    USE (++) []  : HeapEquations
\end{code}
Heappointer is incremented every time it is used.
\begin{code}
ATTR Program GrModule AllDef AllExpr
  INH SYN  location  :  Int
SEM Program | Prog
  mod.location = 0
\end{code}

Nodes sometimes are sometimes refered to by a variable, sometimes they are enumerated in full.
This datatype distinguishes these two cases:
\begin{code}
data NodeInfo a 
  =  InVar   Variable 
  |  InNode  GrTag [a]
 
fromInVar :: NodeInfo a -> Variable
fromInVar (InVar v)  = v
\end{code}
It is used in attributes that gather the nature of a value and a pattern, respectively:
\begin{code}
ATTR  GrVal     SYN valInfo : NodeInfo (Maybe Variable)
ATTR  GrPatAlt 
      GrPatLam  SYN patInfo : NodeInfo Variable
\end{code}
A few auxiliary attributes are necessary to do the actual gathering:
\begin{code}
ATTR  GrVal   SYN  var      : Maybe Variable
ATTR  GrValL  SYN  vars     : [Maybe Variable]
ATTR  GrVar   SYN  tag      : GrTag
              SYN  var      : Variable
ATTR  GrVarL  SYN  hdTag    : GrTag 
              SYN  vars     : [Variable]
\end{code}
The gathering is straightforward:
\begin{code}
SEM GrVal
| Tag        lhs.valInfo  =  InNode  @tag []
| Var        lhs.valInfo  =  InVar   (getNr @nm)
| Node       lhs.valInfo  =  InNode  @tag @fldL.vars
SEM GrPatAlt
| Tag        lhs.patInfo  =  InNode  @tag []
| Node       lhs.patInfo  =  InNode  @tag (map getNr @fldL)
SEM GrPatLam
| Empty      lhs.patInfo  =  InVar   wildcard
| Var        lhs.patInfo  =  InVar   (getNr @nm)
| VarNode    lhs.patInfo  =  InNode  (@fldL.hdTag)
                                     (tail @fldL.vars)
SEM GrVal
| Var        lhs.var      =  Just    (getNr @nm)
| * - Var    lhs.var      =  Nothing
SEM GrValL
| Cons       lhs.vars     =  @hd.var : @tl.vars
| Nil        lhs.vars     =  []
SEM GrVarL  
| Cons       lhs.hdTag    =  @hd.tag
SEM GrVarL
| Cons       lhs.vars     =  @hd.var : @tl.vars  
| Nil        lhs.vars     =  []
SEM GrVar
| KnownTag   lhs.tag      =  @tag
| Var        lhs.var      =  getNr @nm
\end{code}

Every expression has a target, which is either the next pattern in a sequence,
or the result of a binding.
\begin{code}
ATTR AllExpr 
  INH targetInfo: NodeInfo Variable
SEM GrBind | Bind  
  expr.targetInfo  =  InVar (getNr @nm)
SEM GrExpr | Seq    
  expr.targetInfo  =  @pat.patInfo
  body.targetInfo  =  @lhs.targetInfo
\end{code}
Inside a case-expression, we also need information about the scrutinee
\begin{code}
ATTR GrAlt GrAltL 
  INH valInfo: NodeInfo (Maybe Variable)
\end{code}
Two auxiliary functions are used to build a series of equations for matching a complete node:
\begin{code}
buildSelectEquations 
  :: Variable -> GrTag -> [Variable] -> Equations
buildSelectEquations svar ttag tnms
  = [  IsSelection tvar svar i ttag
    |  (tvar,i) <- zip tnms [0..]                      funnr    = getNr nm
                      sfx      = zip  [funnr+2+length oldArgs ..] args

    ,  tvar /= wildcard
    ]
buildUnifyEquations 
  :: [Maybe Variable] -> [Variable] -> Equations
buildUnifyEquations snms tnms
  = [  case mbSvar of
         Nothing    -> IsKnown  tvar AbsBasic
         Just svar  -> IsEqual  tvar svar
    |  (tvar,mbSvar) <- zip tnms snms
    ,  tvar /= wildcard
    ]
\end{code}
The equations that are generated for each expression type are shown in figure~\ref{fig.equations}.

To make a correspondence between formal and actual parameters,
we need to collect all calls. 
Not only the direct calls, but also the postboned ones hidden in |Fun|, |PApp| and |App| nodes.

\begin{code}
ATTR AllVal AllExpr AllDef GrModule 
  SYN allCalls USE (++) [] : AbstractCallList
  SYN fpaNodes USE (++) [] : [NodeInfo (Maybe Variable)]
ATTR GrTag 
  SYN isfpa : Bool
SEM GrVal  |  Node   
  lhs.fpaNodes  =  if    @tag.isfpa 
                   then  [ InNode @tag @fldL.vars ] 
                   else  []
SEM GrExpr | Call    
  lhs.allCalls  =  [ (getNr @nm, @argL.vars) ]
SEM GrTag
  | Fun      lhs . isfpa  = True
  | PApp     lhs . isfpa  = True
  | App      lhs . isfpa  = True
  | * - Fun PApp App
             lhs . isfpa  = False
\end{code}

The final set of equations is the combination of
those that arose from calls, and the ones that were gathered in the treewal:
\begin{code}
SEM Program  |  Prog
  lhs.equations 
   =  [  IsApplication Nothing (map fromJust args)
      |  (InNode (GrTag_App nm) args) <- @mod.fpaNodes
      ]
      ++
      [  IsEqual x y
      |  (funnr, args) <- @mod.allCalls
      ,  (x, Just y) <- zip [funnr + 2 ..] args
      ]
      ++
      [  IsEqual x y
      |  (InNode (GrTag_Fun nm) args) <- @mod.fpaNodes
      ,  (x, Just y) <- zip [getNr nm + 2 ..] args
      ]
      ++
      [  IsEqual x y
      |  (InNode (GrTag_PApp needs nm) args) <- @mod.fpaNodes
      ,  (x, Just y) <- zip [getNr nm + 2 ..] args
      ]
      ++  @mod.equations
\end{code}



\begin{figure*}
\begin{code}
SEM GrExpr | Unit UpdateUnit
  loc.equations1   = case (@lhs.targetInfo, @val.valInfo) of
                       (InVar tvar        ,  InVar svar        )  -> [IsEqual tvar svar]
                       (InVar tvar        ,  InNode stag snms  )  -> [IsConstruction tvar stag snms Nothing]
                       (InNode ttag tnms  ,  InVar svar        )  -> buildSelectEquations svar ttag tnms
                       (InNode ttag tnms  ,  InNode stag snms  )  -> buildUnifyEquations  snms tnms
SEM GrExpr | UpdateUnit
  loc.equations2   =  [ IsEqual (getNr @nm)  (getNr @val.getName) ]
SEM GrExpr | Unit
  lhs.equations    =  @loc.equations1
SEM GrExpr | UpdateUnit
  lhs.equations    =  @loc.equations2 ++ @loc.equations1

SEM GrAlt | Alt  
  lhs.equations    =  case (@pat.patInfo, @lhs.valInfo) of
                        (InNode ttag tnms, InVar svar)  -> buildSelectEquations svar ttag tnms

SEM GrExpr | FetchNode
  lhs.equations    =  case @lhs.targetInfo of
                        InVar tvar  ->  [ IsEqual  tvar         (getNr @nm)   ]
SEM GrExpr | FetchUpdate                ^          ^            ^             ^
  lhs.equations    =                    [ IsEqual  (getNr @dst) (getNr @src)  ]
SEM GrExpr | FetchField
  lhs.equations    =  case @lhs.targetInfo of
                        InVar tvar  ->  [ IsSelection tvar (getNr @nm) @offset (fromJust @mbTag) ]
  
SEM GrExpr | Store  
  lhs.location     =  @lhs.location + 1  
  lhs.heapEqs      =  case @val.valInfo of
                        InNode stag snms  -> [ WillStore @lhs.location stag snms ]
  lhs.equations    =  case (@val.valInfo, @lhs.targetInfo) of
                        (InNode stag snms, InVar tvar)  -> [ IsKnown tvar (AbsLocs (Set.singleton @lhs.location)) ] 
SEM GrGlobal | Global 
  lhs.location     =  @lhs.location + 1
  lhs.heapEqs      =  case @val.valInfo of
                        InNode stag snms  -> [ WillStore @lhs.location stag snms ]
  lhs.equations    =  case @val.valInfo of
                        InNode stag snms  -> [ IsKnown (getNr @nm) (AbsLocs (Set.singleton @lhs.location)) ]
    
SEM GrExpr | Call  
  lhs.equations    =  case @lhs.targetInfo of
                        InVar  tvar       -> [ IsEqual tvar (getNr @nm) ]
                        InNode ttag tnms  -> buildSelectEquations (getNr @nm) ttag tnms

SEM GrExpr | FFI
  loc.nodemap      =  Map.fromList ( [ (con, [ AbsBasic | con==GrTag_Unboxed ] ) | con <- @tagL ] )
  lhs.equations    =  case @lhs.targetInfo of
                        InVar tvar        -> [ IsKnown tvar (AbsNodes @loc.nodemap) ]
                        InNode ttag tnms  -> zipWith IsKnown tnms (fromJust (Map.lookup ttag @loc.nodemap))

SEM GrExpr | Eval
  lhs.equations    =  case @lhs.targetInfo of
                        InVar tvar  -> [ IsEvaluation tvar (getNr @nm) ]

SEM GrExpr | App  
  lhs.equations    =  case @lhs.targetInfo of
                        InVar tvar ->  [ IsApplication (Just tvar) (getNr @nm : map fromInVar @argL.valsInfo) ]
\end{code}
\caption{Constraints for various expression types}
\label{fig.equations}
\end{figure*}



\subsection{Solve the constraint equations}

Create two arrays, initially storing |AbsBottom| for all variables and locations.
Then do a fixpoint iteration on both sets of equations, usign two procedures
that determine which values need to be updated.
\begin{code}
solveEquations ::  Int -> Int -> Equations -> HeapEquations 
                   -> (Int,AbsHeap,AbsEnv)
solveEquations lenEnv lenHeap eqs1 eqs2
=  runST $
   do  { env   <- newArray (0, lenEnv   - 1) AbsBottom
       ; heap  <- newArray (0, lenHeap  - 1) AbsBottom
       ; let procEnv equat
             = do  { cs  <- envChanges equat env heap
                   ; bs  <- mapM (procChange env) cs
                   ; return (or bs)
                   }
             procHeap equat
             = do  { cs  <- heapChange equat env
                   ; b   <- procChange heap cs
                   ; return b
                   }
       ; count <- fixpoint eqs1 eqs2 procEnv procHeap
       ; return (count, heap, env)
       }
\end{code}
The fixpoint functions keeps processing equations while values change
\begin{code}
fixpoint eqs1 eqs2 proc1 proc2 
=  fix 0
   where  fix count 
          =  do
             {  let step1  b i  = proc1  i >>= return . (b||)
             ;  let step2  b i  = proc2  i >>= return . (b||)
             ;  changes1  <- foldM step1  False eqs1
             ;  changes2  <- foldM step2  False eqs2
             ;  if    changes1 || changes2
                then  fix (count+1)
                else  return count
             }
\end{code}
Changing an array value:
\begin{code}
procChange arr (i,e1) =
   do { e0 <- readArray arr i
      ; let e2       =  e0 `mappend` e1
            changed  =  e0 /= e2
      ; when changed (writeArray arr i e2)
      ; return changed
      }
\end{code}
Selecting the change candiates for a heap equation
\begin{code}
heapChange ::  HeapEquation -> AbstractEnv s 
               -> ST s (Location,AbstractValue)
heapChange (WillStore locat tag args) env 
 = do  { let mbres       =   tagFun tag
       ; absArgs         <-  mapM getEnv args
       ; absRes          <-  getEnv mbres
       ; let absNode     =   AbsNodes (Map.singleton tag absArgs)
       ; return (locat, absNode `mappend` absRes)
       }
       where
       getEnv Nothing   =  return AbsBottom
       getEnv (Just v)  =  readArray env v
       tagFun (GrTag_Fun nm)  =  Just (getNr nm)
       tagFun _               =  Nothing
\end{code}
Auxiliary tests needed:
\begin{code}
isPAppTag :: GrTag -> Bool
isPAppTag (GrTag_PApp _ _)    = True
isPAppTag _                   = False

isValueTag :: GrTag -> Bool
isValueTag  GrTag_Any         = True
isValueTag  GrTag_Unboxed     = True
isValueTag (GrTag_PApp _ _)   = True
isValueTag (GrTag_Con _)      = True
isValueTag _                  = False

filterTaggedNodes ::  (GrTag->Bool) 
                      -> AbstractValue -> AbstractValue
filterTaggedNodes p (AbsNodes nodes) 
  = let  newNodes = Map.filterWithKey (const . p) nodes
    in   AbsNodes newNodes
filterTaggedNodes p av
  = av
\end{code}


\begin{figure*}
\begin{code}
envChanges :: Equation -> AbstractEnv s -> AbstractHeap s -> ApplyMap -> ST s [(Variable,AbstractValue)]
envChanges equat env heap applyMap
  = case equat of
      IsKnown         d av         ->  return [(d, av)]

      IsEqual         d v          ->  do  {  av <- readArray env v
                                           ;  return [(d, av)]
                                           }
      IsSelection     d v i t      ->  do  {  av <- readArray env v
                                           ;  let res = absSelect av i t
                                           ;  return [(d,res)]
                                           }
      IsConstruction  d t as       ->  do  {  vars <- mapM (maybe (return AbsBasic) (readArray env)) as
                                           ;  let res = AbsNodes (Map.singleton t vars)
                                           ;  return [(d,res)]
                                           }
      IsEvaluation    d v          ->  do  {  av   <- readArray env v
                                           ;  res  <- absDeref av
                                           ;  return [(d,res)]
                                           }
      IsApplication mbd (f:as)     ->  do  {  av         <-  readArray env f
                                           ;  absFun     <-  case mbd of
                                                               Nothing  -> absDeref av
                                                               Just _   -> return av
                                           ;  absArgs    <-  mapM (readArray env) as
                                           ;  (sfx,res)  <-  absCall absFun absArgs
                                           ;  return $ (maybe id (\d->((d,res):)) mbd) sfx
                                           }
\end{code}
\begin{code}
    where
    absSelect av i t   =  case av of
                            AbsNodes  ns  -> maybe AbsBottom (!!i) (Map.lookup t ns)
                            AbsBottom     -> av
                            AbsError _    -> av
    absDeref av        =  case av of
                            AbsLocs ls    ->  do  { vs <- mapM (readArray heap) (Set.toList ls)
                                                  ; return (mconcat (map (filterTaggedNodes isValueTag) vs))
                                                  }
                            AbsBottom     ->  return av
                            AbsError _    ->  return av
    absCall f args     =  do {  ts <- mapM addArgs (getNodes (filterTaggedNodes isPAppTag f))
                             ;  let (sfxs,avs) = unzip ts
                             ;  return (concat sfxs, mconcat avs)
      	                     }
      where  addArgs (tag@(GrTag_PApp needs nm) , oldArgs) 
               =  do  {  let  n        =  length args
                              newtag   =  GrTag_PApp (needs-n) nm
                              funnr    = getNr nm
                              sfx      = zip  [funnr+2+length oldArgs ..] args
                      ;  res  <-  if    n<needs
                                  then  return $ AbsNodes (Map.singleton newtag (oldArgs++args))
                                  else  readArray env funnr
                      ;  return (sfx, res)
                      }
             getNodes av  =  case av of  
                               AbsNodes n  -> Map.toAscList n
                               AbsBottom   -> []
\end{code}
\caption{Selection of change candidates for variables}
\end{figure*}









\section{Discussion and future work}


How to keep the number of alternatives limited: specialized versions

Smart ordering of alternatives:
binary tree, most frequently first, or combined: Huffmancode-style

Which cases are frequent:
cons more than nil; empirical gathering of data during test run, for use in subsequent compilations

Return is also an indirect jump and can be avoided by a `came-from analysis'







\acks

Acknowledgments, if needed.

\begin{thebibliography}{}

\bibitem[Boquist 1999]{boquist}
Boquist, Urban. 
Code Optimisation Techniques for Lazy Functional Languages, 
PhD Thesis Chalmers University, G\"oteborg March 1999.

\bibitem[Dijkstra 2005]{dijkstra}
Dijkstra, Atze.
Stepping through Haskell,
PhD Thesis Utrecht University, November 2005.

\bibitem[Douma 2006]{douma}
Douma, Christof.
Exceptional GRIN, 
Master's Thesis Utrecht University, April 2006.

\bibitem[Marlow and Peyton Jones 2006]{marlow}
Marlow, Simon and Peyton Jones, Simon.
`Making a fast curry: push/enter vs.\ eval/apply for higher-order languages',
JFP2006/ICFP2004.

\bibitem[Peyton Jones 1992]{peytonjones}
Peyton Jones, Simon.
`Spineless Tagless G-machine',
 JFP 1992.


\end{thebibliography}

\end{document}





\begin{code}
\end{code}

