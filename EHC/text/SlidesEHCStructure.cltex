%%[title
\begin{frame}
\titlepage
\end{frame}

%%]

%%[intro

\raggedbottom

\begin{frame}
\frametitle{The structure of the Essential Haskell Compiler\dots}

{\large We are writing a Haskell compiler}

{\large that by design {\em evolves}}

\begin{itemize}
\item from {\em essential} to {\em syntactically sugared}
\item from {\em lambda calculus} to {\em full Haskell}
\item from {\em plain constructs} to {\em extensions}
\end{itemize}

\end{frame}



\begin{frame}
\frametitle{\dots\ or: Coping with Compiler Complexity}


{\large When writing a compiler we face}

\begin{itemize}
\item {\large Implementation complexity}\\
      \uncover<2->{\hspace*{5mm}a compiler is a {\em large program}}

\item {\large Description complexity}\\
      \uncover<2->{\hspace*{5mm}translation involves {\em complicated trees}}

\item {\large Design complexity}\\
      \uncover<2->{\hspace*{5mm}a language has {\em many features}}

\item {\large Maintenance complexity}\\
      \uncover<2->{\hspace*{5mm}evolving projects must {\em remain consistent}}

\end{itemize}

\end{frame}



\begin{frame}
\frametitle{Coping with \emph{Implementation} Complexity}

\begin{center}
{\Large\bf Transform!}
\end{center}

\temporal<3>{%
\hspace*{-10mm}\raisebox{-55mm}[16mm][0mm]{\FigScaledPDF{0.50}{ehc-dataflow2a}}
}{%
\hspace*{-10mm}\raisebox{-55mm}[16mm][0mm]{\FigScaledPDF{0.50}{ehc-dataflow2b}}
}{%
\hspace*{-10mm}\raisebox{-55mm}[16mm][0mm]{\FigScaledPDF{0.50}{ehc-dataflow2}}
}

Many intermediate languages\uncover<3->{, {\em and even more transformations}}
\begin{itemize}
\item \makebox[30mm][l]{Haskell          }
\item \makebox[30mm][l]{Essential Haskell}  \uncover<2-2>{\makebox[9mm][l]{(desugared)}}
\item \makebox[30mm][l]{Core             }  \uncover<2-2>{\makebox[9mm][l]{(untyped)}}     \uncover<3-4>{{\em 12 transformations}}
\item \makebox[30mm][l]{Grin             }  \uncover<2-2>{\makebox[9mm][l]{(sequential)}}  \uncover<3-4>{{\em 17 transformations}}
\item \makebox[30mm][l]{Silly            }  \uncover<2-2>{\makebox[9mm][l]{(imperative)}}  \uncover<3-4>{{\em 3 transformations}}
\item \makebox[30mm][l]{C                }
\end{itemize}
\end{frame}


\begin{frame}
\frametitle{Coping with \emph{Description} Complexity}


\begin{center}
{\Large\bf Use tools!}
\end{center}

\mbox{%
\parbox[b]{40mm}{%
\begin{itemize}
\item<6-> Ruler\\\mbox{ }
\item<5-> Shuffle\\\mbox{ }
\item<4-> {\em Utrecht University}\\
          Attribute Grammar Compiler
\item<2-> {\em Glasgow}\\
          Haskell Compiler
\end{itemize}
}
\hspace*{-10mm}%
\only<1>{\raisebox{-10mm}[52mm][0mm]{\FigScaledPDF{0.3}{toolchain2a}}}%
\only<2>{\raisebox{-10mm}[52mm][0mm]{\FigScaledPDF{0.3}{toolchain2b}}}%
\only<3>{\raisebox{-10mm}[52mm][0mm]{\FigScaledPDF{0.3}{toolchain2c}}}%
\only<4>{\raisebox{-10mm}[52mm][0mm]{\FigScaledPDF{0.3}{toolchain2d}}}%
\only<5>{\raisebox{-10mm}[52mm][0mm]{\FigScaledPDF{0.3}{toolchain2e}}}%
\only<6>{\raisebox{-10mm}[52mm][0mm]{\FigScaledPDF{0.3}{toolchain2}}}
}

\end{frame}

\begin{frame}
\frametitle{Coping with \emph{Design} Complexity}

\begin{center}
{\Large\bf Grow stepwise!}
\end{center}

\begin{enumerate}
\item[~]<2-> \makebox[50mm][l]{{\color{uured}plain Haskell}}                  {\color{uured}extensions}
\item<1-> \makebox[50mm][l]{$\lambda$-calculus, type checking}
\item<1-> \makebox[50mm][l]{type inference}
\item<1-> \makebox[50mm][l]{polymorphism}
\item<1-> \makebox[50mm][l]{}                                  \visible<2->{higher ranked types}
\item<1-> \makebox[50mm][l]{data types}
\item<3-> \makebox[50mm][l]{kind inference}                    kind signatures
\item<3-> \makebox[50mm][l]{records}                           tuples as records
\item<3-> \makebox[50mm][l]{code generation}                   full program analysis
\item<3-> \makebox[50mm][l]{classes, synonyms}                 extensible records
\setcounter{enumi}{19}
\item<4-> \makebox[50mm][l]{modules}
\setcounter{enumi}{94}
\item<4-> \makebox[50mm][l]{`deriving'}                      exceptions
\setcounter{enumi}{98}
\item<4-> \makebox[50mm][l]{prelude, I/O}
\end{enumerate}

\end{frame}

\begin{frame}
\frametitle{Coping with \emph{Maintenance} Complexity}
\begin{center}
{\Large\bf Generate, generate, generate\dots}
\end{center}

\end{frame}




\begin{frame}
\frametitle{{\em Tools:} Attribute Grammar Compiler}

{\large\visible<2->{{\color{uured}\bf Do not }}
write recursive functions}
\vspace*{2mm}

%%[[wrap=safecode
sum      []      = 0
sum      (x:xs)  = x + sum xs
concat   []      = []
concat   (x:xs)  = x ++ concat xs
%%]]
\vspace*{2mm}

\visible<2->{{\large but generalize\dots}
\vspace*{2mm}

%%[[wrap=safecode
foldr op e []      = e
foldr op e (x:xs)  = x `op` foldr op e xs
%%]]
}

\visible<3->{{\large \dots and specialize}
\vspace*{2mm}

%%[[wrap=safecode
sum        =  foldr (+)  0
concat     =  foldr (++) []
sort       =  foldr insert []
%%]]
}

\visible<4->{
\hspace*{5mm}{\em\color{uured}catamorphism} = {\em foldr} {\em\color{uured}algebra}
}

\end{frame}



\begin{frame}
\frametitle{{\em Tools:} Attribute Grammar Compiler}

{\large If {\em programming by writing algebras} is a Good Thing\\
why doesn't anybody do it?}

\begin{itemize}
\item<2-> we need a custom {\em fold}-function for each datatype\\
          \visible<6>{{\color{uured}automatically generated}}

\item<3-> algebras contain {\em many} functions which\dots\\
          \visible<6>{{\color{uured}distributedly definable}}

\item<4-> \dots each return a tuple\\
          \visible<6>{{\color{uured}{\em synthesized} attributes}}

\item<4-> \dots take extra parameters\\
          \visible<6>{{\color{uured}{\em inherited} attributes}}
      
\item<5-> \dots and mostly just copy values up or down\\  
          \visible<6>{{\color{uured}defaulting mechanism}}

\end{itemize}

\visible<6->{{\large{\color{uured}\em Attribute Grammar Compiler} makes this easy}}
\end{frame}


\newcommand{\Node}[2]{node[fill=white,text=black,anchor=south west,shape=rectangle,rounded corners,draw] {#2}}


\begin{frame}
\frametitle{{\em Tools:} Ruler}


\begin{tikzpicture}

% \draw[step=1cm,blue,very thin] (0,0) grid (8,8);

\draw (0,8) node[fill=white,text=black,anchor=north west] {
{\tiny
%%[[wrap=safecode
sem_Expr_App func_ arg_ =
    (\ _lhsIknTy
       _lhsIopts
       _lhsItyGam
       _lhsIvalGam ->
         (case (_lhsIvalGam) of
          { _argOvalGam ->
          (case (_lhsItyGam) of
           { _argOtyGam ->
           (case (_lhsIopts) of
            { _argOopts ->
            (case (_lhsIvalGam) of
             { _funcOvalGam ->
             (case (_lhsItyGam) of
              { _funcOtyGam ->
              (case (_lhsIopts) of
               { _funcOopts ->
               (case ([ Ty_Any ] `mkArrow` _lhsIknTy) of
                { _funcOknTy ->
                (case ((func_ _funcOknTy _funcOopts _funcOtyGam _funcOvalGam)) of
                 { ( _funcIappArgPPL,_funcIappFunNm,_funcIappFunPP,_funcIerrSq,_funcIpp,_funcIppAST,_funcIty) ->
                 (case (tyArrowArgRes _funcIty) of
                  { __tup2 ->
                  (case (__tup2) of
                   { (_ty_a_,_) ->
                   (case (_ty_a_) of
                    { _argOknTy ->
                    (case ((arg_ _argOknTy _argOopts _argOtyGam _argOvalGam)) of
                     { ( _argIappArgPPL,_argIappFunNm,_argIappFunPP,_argIerrSq,_argIpp,_argIppAST,_argIty) ->
                     (case (_funcIappArgPPL ++ [_argIpp]) of
                      { _lhsOappArgPPL ->
                      (case (_funcIappFunNm) of
                       { _lhsOappFunNm ->
                       (case (_funcIappFunPP) of
                        { _lhsOappFunPP -> 
%%]]
}
};

\only<2->{
\draw (1.5,5) node[fill=uuyellow,text=black,anchor=north west,shape=rectangle,rounded corners] {
{\small
%%[[wrap=safecode
DATA Expr
  | App  func : Expr
         arg  : Expr
ATTR AllExpr [ knTy: Ty | | ty: Ty ]
SEM Expr
  | App  func  .  knTy        =  [ Ty_Any ] `mkArrow` @lhs.knTy
         (loc.ty_a_,loc.ty_)  =  tyArrowArgRes @func.ty
         arg   .  knTy        =  @ty_a_
         loc   .  ty          =  @ty_
%%]]
}
};
}

\only<3->{
\draw (4.5,7.5) node[fill=uured,text=black,anchor=north west,shape=rectangle,rounded corners] {
{\large
\(\rulerCmdUse{rules3.K.expr.base.e.app}\)
}
};
}

\end{tikzpicture}



\(\rulerCmdUse{rules3.K.expr.base.e.app}\)


%%@EHRulerRules.1.expr.e.app wrap=boxcode{.12}



\end{frame}



\begin{frame}
\frametitle{{\em Tools:} Shuffle}

\end{frame}




%%]

