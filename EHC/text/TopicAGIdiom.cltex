%%[abstract
Attribute Grammars have since long been considered a convenient tool for programming over treelike datastructures.
Nevertheless 
%%]

%%[introduction
%%]

%%[agtut
%%]

%%[XX
%%]

%%[agPatComposeAll
\PGFPatComposition

\begin{itemize}
\item Similar to |fold|
\item Here: a = pp, combine = pretty print combinators
\item (instances of AG patterns are indicated like |AGPat(Compose All)|)
\item Supported by AG's copy rule and |USE| construct
\item |AGPat(DeCompose)|: reader monad (class |MonadReader|)
\end{itemize}

%%]

%%[agPatDeCompose
\PGFPatDeComposition

\begin{itemize}
\item |knTy| follows pattern, similar to |unfold|
\item where decomposition follows tree structure
%%[[wrap=safecode
decombine1 :: A -> (A,A,A)
decombine2 :: A -> (A,A)
%%]
\item if decomposition fails: pass ``will do'' value
\begin{itemize}
\item here: |Ty_Any|
\end{itemize}
\item |AGPat(Compose)|: writer monad (class |MonadWriter|)
\end{itemize}
%%]

%%[agPatDistribute
\PGFPatDistribute

\begin{itemize}
\item |valGam| is distributed
\item Special case of |AGPat(DeCompose)| pattern.
\item Passing unmodified, done by AG's copy rules
\item Distribution ``as is'', tree structure is not used for steering the decomposition
\end{itemize}
%%]

%%[agPatState
\PGFPatThread

\begin{itemize}
\item Simulation of global variable via threading
\item Generated by AG's copy rules if |a| is
both inherited and synthesized
\item Update by intervening definition
\begin{itemize}
\item here: |AGPat(State Gather)| gathers set of values in |gathTySigGam|, |upd=| addition to |Gamma|
\end{itemize}
\item |AGPat(State)|: state monad (class |MonadState|)
\end{itemize}
%%]

%%[agPatMultipass
\PGFPatMultipass

\begin{itemize}
\item Iteration over structure
\item Fixed number of times
\item Each pass via different attribute, possibly different role
\item Here:
\begin{itemize}
\item |a1 = gathTySigGam| gathers type signatures
\item |a2 = tySigGam| distributes type signatures of identifiers
\end{itemize}
\end{itemize}
%%]

%%[agPatListSpine
\PGFPatListSpine

\begin{itemize}
\item Extracting info from left/right balanced list like structure
\item |2 x ^ AGPat(Compose All)| over |X|, for a value related to the
\begin{itemize}
\item last (|Nil|) element: |n|
\item spine (|Cons|) + elements: |c|
\end{itemize}
\end{itemize}
%%]

%%[agPatComposeGather
\begin{itemize}
\item Gathering errors follows special case of |AGPat(Compose All)| where
\begin{itemize}
\item |combine = union| (of lists/sets)
\item Leafs of tree: empty list/set
\item Supported by AG's |USE| construct
\end{itemize}
\item Difference with |AGPat(State Gather)|
\begin{itemize}
\item |AGPat(State Gather)| corresponds to tree walk, individual children's contribution cannot be differentiated
\item |AGPat(Compose Gather)| corresponds to postfix tree walk, individual children's contribution accessible
\end{itemize}
\end{itemize}
%%]

%%[agPatUniq
\begin{itemize}
\item<+-> Special case of |AGPat(Global Var)|
\item Threaded counter solution
%%[[wrap=safecode
ATTR AllNT [ | gUniq: Int | ]
SEM Expr
  | App  loc    .  lUniq    = @lhs.gUniq
         func   .  gUniq    = @lhs.gUniq + 1
%%]
\begin{itemize}
\item Must be threaded through all functions needing unique value
\item Additional input counter and tupled output counter
\item Clutters code
\item Creates attribute dependencies which can easily cause cycles if used
together with |AGPat(Multipass)|
\item Unless each pass has own counter
\end{itemize}
\end{itemize}
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

