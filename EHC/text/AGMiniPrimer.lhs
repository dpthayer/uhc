%include lhs2TeX.fmt
%include forSubText.fmt

Haskell:

\chunkCmdUse{RepminHS.1.data}
\chunkCmdUse{RepminHS.1.repmin}
\chunkCmdUse{RepminHS.1.main}

------------------------------------------------------

AG:

\chunkCmdUse{RepminAG.1.data1}
\chunkCmdUse{RepminAG.1.min}
\chunkCmdUse{RepminAG.1.data2}
\chunkCmdUse{RepminAG.1.repmin}
\chunkCmdUse{RepminAG.1.tree}
\chunkCmdUse{RepminAG.1.show}
\chunkCmdUse{RepminAG.1.main}

\begin{Figure}{Full AG specification of repmin}{ag-primer-full-repmin}
\savecolumns
\chunkCmdUse{RepminAG.1.data1}
\restorecolumns
\chunkCmdUse{RepminAG.1.min}
\restorecolumns
\chunkCmdUse{RepminAG.1.data2}
\restorecolumns
\chunkCmdUse{RepminAG.1.repmin}
\restorecolumns
\chunkCmdUse{RepminAG.1.tree}
\restorecolumns
\chunkCmdUse{RepminAG.1.show}
\restorecolumns
\chunkCmdUse{RepminAG.1.main}
\end{Figure}

------------------------------------------------------

Parsing

\chunkCmdUse{RepminAG.1.parser}
\chunkCmdUse{RepminAG.1.main2}

------------------------------------------------------

Expr

\chunkCmdUse{Expr.1.data}
\chunkCmdUse{Expr.1.pp}
\chunkCmdUse{Expr.1.letdata}
\chunkCmdUse{Expr.1.letpp}
\chunkCmdUse{Expr.1.env}
\chunkCmdUse{Expr.1.val}
\chunkCmdUse{Expr.1.parser}
\chunkCmdUse{Expr.1.wrapper}
\chunkCmdUse{Expr.1.main}

------------------------------------------------------


\begin{code}
{
-- Parser
pRoot   =  sem_Root_Root <$> pExpr
pDigit  =  (\d -> ord d - ord '0') <$> ('0' <..> '9')
pNat    =  sem_Expr_IConst <$> (foldl (\a b -> a*10 + b) 0 <$> pList1 pDigit)
pFactor =  pNat <|> pSym '(' *> pExpr <* pSym ')'
pExpr   =  pChainl (sem_Expr_Add <$ pSym '+') pFactor
}

-- Abstract syntax
DATA Root   | Root      expr  : Expr

DATA Expr   | IConst    int   : {Int}
            | Add       e1    : Expr
                        e2    : Expr

-- Attribution
ATTR Expr Root
  [ | | pp: PP_Doc ]

-- Semantics
SEM Expr
  | IConst  lhs  .  pp    =  text (show @int)
  | Add     lhs  .  pp    =  pp_parens (@e1.pp >#< "+" >#< @e2.pp)
\end{code}

Figure~\ref{sl-fig-ag-expr-code} shows a small \textsc{AG} example exhibiting the usual stages
of a compiler: parsing, creating an abstract syntax tree (AST) and producing some output depending on
the actual input and the defined semantics (which
in this case is a pretty printed version of the parsed expression).
The description contains AG code for defining the abstract syntax
(keyword |DATA|), attributes (keyword |ATTR|) and the definition
of the computation defining those attributes (keyword |SEM|).

A |DATA| definition corresponds to a similarly formed Haskell |data| type definition
in the Haskell code generated by the \textsc{AG} compiler. For example, |DATA Expr|
is mapped to

\begin{TT}
  data Expr  =  Expr_Add (Expr) (Expr)
             |  Expr_IConst (Int)
\end{TT}

|ATTR| definitions introduce
inherited or synthesized attributes.
In the generated code inherited attributes (those in front of the first
@|@ in the |ATTR| specification) correspond to arguments of the semantics processing functions, whereas
each synthesized attribute (those in after of the last
@|@)
becomes part of the result tuple.
Attributes in between the two @|@ are both inherited and synthesized.
In the example of figure~\ref{sl-fig-ag-expr-code} only one synthesized attribute |pp|
is defined,
containing a pretty printed representation of the input.

\begin{code}
-- Type
{
data Type  = TCon String
intType    = TCon "Int"
instance Show Type where
  show (TCon nm) = nm
}

ATTR Expr
  [ | | exprTp: {Type} ]

SEM Expr
  | IConst  lhs  .  exprTp  =  intType
  | Add     loc  .  tp      =  intType
            lhs  .  exprTp  =  @tp

SEM Root
  | Root    lhs  .  pp      =  @expr.pp >#< "::" >#< show @expr.exprTp

-- Environment/gamma
{
type Assumptions = [(String,Type)]
}

ATTR Expr
  [ tpGam: {Assumptions} | | ]

SEM Root
  | Root    expr  .  tpGam  =  []
\end{code}

The beauty of the \textsc{AG} system lies in the fact that additional |DATA|, |ATTR| and |SEM|
definitions may be provided
at different locations in the \textsc{AG} source code. This independence of location
allows the \textsc{AG} programmer to formulate the definition of different aspects at different locations. For example,
figure~\ref{sl-fig-ag-expr-tp-code} shows the additional code for the computation of a second attribute which is
combined with the pretty printed value to tell something about the type. The example also shows the definition of
an inherited attribute |tpGam| passing the assumptions required for type inferencing down through the AST,
even though it is not used in this example.

Both inherited and synthesized attributes are defined using the notation

\begin{code}
  | <Alternative>  <ChildOrParentName>  .  <AttrName>  =  <Expression>
\end{code}

For an inherited attribute |<ChildOrParentName>| is the name of one of 
the children nodes in the AST, for example |expr| for |Root|'s |Expr| child.
For synthesized attributes |lhs| (left hand side) is used. The |<Expression>| defining
the value of an attribute |<AttrName>| contains Haskell code, copied without any further
processing to the generated output. Only occurrences of |@<ChildOrParentName>.<AttrName>| have a
special meaning as they stand for the value of an attribute of parent of child node, for
example |@expr.pp| stands for the |pp| attribute of
the |expr| child of alternative |Root| of node |Root|. If |@<ChildOrParentName>.| is
omitted it either refers to a value in an AST node with |<AttrName>| as
its name or refers to a locally (for an alternative of a node of the AST) defined attribute.
Attributes |int| in alternative |IConst| of |Expr| and
|tp| in alternative |Add| of |Expr| are examples of this.

Even though the computation described in figure~\ref{sl-fig-ag-expr-tp-code} is less than rudimentary to serve the
purpose of this paper, it shows what the \textsc{AG} system can best be used for: separation of concerns (or aspects,
attributes). This alleviates the burden of a programmer who otherwise has to combine the computation of these
aspects, creating catamorphisms where inherited attributes are passed down as parameters and synthesized attributes
are grouped into a tuple and returned as the result. The assembly of this code now has become the job of
the \textsc{AG} compiler.

\begin{TT}
data Expr = Expr_Add (Expr) (Expr)
          | Expr_IConst (Int)
-- semantic domain
type T_Expr = (Assumptions) ->
              ((Type),(PP_Doc))
-- cata
sem_Expr :: (Expr) ->
            (T_Expr)
sem_Expr ((Expr_Add (_e1) (_e2))) =
    (sem_Expr_Add ((sem_Expr (_e1))) ((sem_Expr (_e2))))
sem_Expr ((Expr_IConst (_int))) =
    (sem_Expr_IConst (_int))
sem_Expr_Add :: (T_Expr) ->
                (T_Expr) ->
                (T_Expr)
sem_Expr_Add (_e1) (_e2) (_lhs_tpGam) =
    let (_tp) =
            intType
        ( _e1_exprTp,_e1_pp) =
            (_e1 (_lhs_tpGam))
        ( _e2_exprTp,_e2_pp) =
            (_e2 (_lhs_tpGam))
    in  (_tp
        ,pp_parens
           (_e1_pp >#< "+" >#< _e2_pp)
        )
sem_Expr_IConst :: (Int) ->
                   (T_Expr)
sem_Expr_IConst (_int) (_lhs_tpGam) =
    let 
    in  (intType,text (show _int))
\end{TT}

The \textsc{AG} compiler combines all definitions, gathers attribute definitions for each
AST |DATA| definition and creates the corresponding 
catamorphisms. For the combination of figures~\ref{sl-fig-ag-expr-code} and~\ref{sl-fig-ag-expr-tp-code} the output
shown in figure~\ref{sl-fig-ag-gen-code} is created.
The resulting semantic functions can either be used on an already
built |data| structure or used in a deforestated setting,
thereby circumventing the construction
and inspection of a |data| structure.

The Haskell source code generated by the \textsc{AG} compiler does not stand on its own. The code is meant to be
used together with other Haskell code. For example, the parser |pNat| in figure~\ref{sl-fig-ag-expr-code}
directly invokes the semantic function @sem_Expr_IConst@ on the result of parsing an |Int| value.
The parser combinator |<$>|, meaning ``apply left operand to the parse result of the right operand'', is used
for that purpose. The semantic function thus takes the parsed |Int| as its first parameter (the only child defined
for that particular AST node alternative) and returns a function which has yet to be passed the inherited attributes.
The type definitions for @T_Expr@ and @sem_Expr@ reflect this.

Even though the \textsc{AG} language is presented as a language in its own right it is necessary to
keep the underlying mapping to Haskell in mind. In particular, the example defines the |data| structure
|Expr| which can also be used as a Haskell |data| type. The names of these |data| types
are formed by concatenating the type name with the name of the alternative. For example, alternative |Add| of |Expr|
is given the name @Expr_Add@. The \textsc{AG} optionally can omit the prefix @Expr_@,
thereby making a name clash more likely. For example |Add| may be defined as an alternative for another data structure.
On the other side, code is more readable, which is convenient for often used data structures. For example, the data structure
defined for types (in the following section)
is assumed to be compiled without this prefix.

Figures~\ref{sl-fig-ag-expr-code} and~\ref{sl-fig-ag-expr-tp-code} also show the incorporation of Haskell code.
Text between braces |{| and |}| is literaly copied by the \textsc{AG} system.
The resulting code, Haskell and \textsc{AG} generated Haskell, forms a complete program. The example however does not
include code for invoking the parser, accepting command line parameters, use of a scanner and other details necessary
to make a complete compiler. Correct usage of the parser combinators is also left out of this paper and from now on
only AST, attribute and semantics definitions will be used. However the compiler,
upon which this paper is based, includes all the
details necessary to do lexical scanning, parsing, AST building and generation of output, error messages and debug
information. For completeness, a table with a list of parser combinators has been included
in figure~\ref{sl_fig_combinators}.

\begin{center}
\begin{tabular}{lll}
Combinator & Meaning & Usage \\ \hline
\texttt{pSucceed} & EBNF $\empty$ & \verb'pSucceed "a"' \\
\texttt{pSym} & EBNF terminal & \verb'pSym "let"' \\
\texttt{<||>} & EBNF \texttt{||}, choice & \verb.pSym "a" <||> pSym 'a'. \\
\texttt{<*>} & EBNF sequence & \verb.pSucceed ord. \\
& & \verb.<*> pSym 'a'. \\
\verb.<$>. & Application & \verb.ord <$> pSym 'a'. \\
\end{tabular}
\end{center}

