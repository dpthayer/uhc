
%%[termTableFormat
{r@@{\;}c@@{\;}ll}
%%]

%%[notationTableFormat
{ll}
%%]

%%[notationTableHeader
Notation & Meaning \\
\hline
%%]

%%[exprHeader
\multicolumn{4}{l}{Values (expressions, terms):} \\
%%]

%%[patexprHeader
\multicolumn{4}{l}{Pattern expressions:} \\
%%]

%%[tyexprHeader
\multicolumn{4}{l}{Type expressions:} \\
%%]

%%[typredHeader
\multicolumn{4}{l}{Predicate expressions:} \\
%%]

%%[declHeader
\multicolumn{4}{l}{Declarations of bindings:} \\
%%]

%%[typeHeader
\multicolumn{4}{l}{Types:} \\
%%]

%%[tyaltHeader
\multicolumn{4}{l}{Type alternative:} \\
%%]

%%[predHeader
\multicolumn{4}{l}{Predicates:} \\
%%]

%%[impredHeader
\multicolumn{4}{l}{Types for impredicativity inferencing:} \\
%%]

%%[termSeparator
\multicolumn{4}{l}{} \\
%%]

%%[exprBasic
|e| & |::=| &
|int || char |
 & literals
 \\
& | || | &
|identv|
 & program variable
 \\
& | || | &
|e e|
 & application
 \\
& | || | &
|let Vec(d) in e|
 & local definitions
 \\
%%]

%%[exprLamIdent
& | || | &
|\i -> e|
 & abstraction
 \\
%%]

%%[exprLamPat
& | || | &
|\p -> e|
 & abstraction
 \\
%%]

%%[exprTup
& | || | &
|(e,...,e)|
 & tuple
 \\
%%]

%%[exprAnn
& | || | &
|e :: t|
 & type annotated expression
 \\
%%]

%%[exprAppImpred
& | || | &
|e ^^ ~ e|
 & impredicative application
 \\
%%]

%%[exprExplImpl
& | || | &
|e (! e <: pi !)|
 & \emph{explicit implicit application}
 \\
& | || | &
|\(! i <: pi !) -> e|
 & \emph{explicit implicit abstraction}
 \\
%%]

%%[exprRecBasic
& | || | &
|(lbl = e,...)|
 & record
 \\
& | || | &
|(e || lbl := e,...)|
 & record update
 \\
& | || | &
|e.lbl|
 & record selection
 \\
%%]

%%[exprRecExt
& | || | &
|(e || lbl = e,...)|
 & record extension
 \\
%%]

%%[declBasic
|d| & |::=| &
|identv :: t|
 & value type signature
 \\
%%]

%%[declBasicTySigma
|d| & |::=| &
|identv :: sigma|
 & value type signature
 \\
%%]

%%[declValIdent
& | || | &
|identv = e|
 & value binding
 \\
%%]

%%[declValPat
& | || | &
|p = e|
 & value binding
 \\
%%]

%%[declDataType
& | || | &
|data ^^ Vec(t) = Vec(identc ^^ Vec(t))|
 & data type
 \\
%%]

%%[declExplImpl
& | || | &
|class Vec(pr) => pr where Vec(d)|
 & class
 \\
& | || | &
|instance Vec(pr) => pr where Vec(d)|
 & introduced instance
 \\
& | || | &
|instance identv <: Vec(pr) => pr where Vec(d)|
 & \emph{named introduced instance}
 \\
& | || | &
|instance identv :: Vec(pr) => pr where Vec(d)|
 & \emph{named instance}
 \\
& | || | &
|instance e <: pr|
 & \emph{value introduced instance}
 \\
%%]

%%[patexprBasic
|p| & |::=| &
|int || char |
 & literals
 \\
& | || | &
|identv|
 & pattern variable
 \\
& | || | &
|identv@p|
 & pattern variable, with subpattern
 \\
& | || | &
|(p,...,p)|
 & tuple pattern
 \\
%%]

%%[patexprAnn
& | || | &
|p :: t|
 & type annotated pattern
 \\
%%]

%%[patexprRec
& | || | &
|(r||l=p)|
 & record pattern
 \\
%%]

%%[tyexprBasic
|t| & |::=| &
|Int || Char |
 & type constants
 \\
& | || | &
|t -> t|
 & function type
 \\
& | || | &
|(t,...,t)|
 & tuple type
 \\
%%]

%%[tyexprTyVar
& | || | &
|identv|
 & type variable
 \\
%%]

%%[tyexprForall
& | || | &
|forall ^ identv . t|
 & universal quantification
 \\
%%]

%%[tyexprExists
& | || | &
|exists ^ identv . t|
 & existential quantification
 \\
%%]

%%[tyexprRec
& | || | &
|(lbl :: sigma,...)|
 & record
 \\
%%]

%%[typredBasic
|pr| & |::=| &
|identc ^^ Vec(t)|
 & class predicate
 \\
& | || | &
|pr => pr|
 & predicate transformer/abstraction
 \\
%%]

%%[typredRecLacks
& | || | &
|t \\ l|
 & record lacks label predicate
 \\
%%]

%%[identHeader
\multicolumn{4}{l}{Identifiers:} \\
%%]

%%[meetJoinHeader
\multicolumn{4}{l}{Types for computing meet/join:} \\
%%]

%%[identBasic
|ident| & |::=| &
|identv|
 & lowercase: (type) variables
 \\
& | || | &
|identc|
 & uppercase: (type) constructors
 \\
%%]

%%[identRecLbl
& | || | &
|lbl|
 & field labels
 \\
%%]

%%[typeBasic
|sigma| & |::=| &
|Int || Char|
 & literals
 \\
& | || | &
|tvarv|
 & variable
 \\
& | || | &
|sigma -> sigma|
 & abstraction
 \\
& | || | &
|sigma ^^ sigma|
 & type application
 \\
& | || | &
|forall ^ tvarv . sigma|
 & universally quantified type
 \\
%%]

%%[typePred
& | || | &
|pi => sigma|
 & implicit abstraction
 \\
%%]

%%[typeTyVarFixed
& | || | &
|tvarf|
 & (fresh) type constant (a.k.a. fixed type variable)
 \\
%%]

%%[typeExists
& | || | &
|exists ^ alpha . sigma|
 & existentially quantified type
 \\
%%]

%%[typeRecBasic
& | || | &
|(lbl :: sigma,...)|
 & record
 \\
%%]

%%[predBasic
|pi| & |::=| &
|identc ^^ Vec(sigma)|
 & class predicate
 \\
& | || | &
|pi => pi|
 & predicate transformer/abstraction
 \\
%%]

%%[predRecLacks
& | || | &
|sigma \\ l|
 & record lacks label predicate
 \\
%%]

%%[impredBasic
|sigma| & |::=| &
|...|
 & 
 \\
& | || | &
|isigma|
 & type alternatives
 \\
|isigma| & |::=| &
|tvarv [Vec(talt)]|
 & type alternatives
 \\
%%]

%%[meetJoinBasic
|sigma| & |::=| &
|...|
 & 
 \\
& | || | &
|tvarv /=/ sigma|
 & both
 \\
& | || | &
|ANY|
 & absence of type information
 \\
%%]

%%[tyaltBasic
|talt| & |::=| &
|isigma :: thard / tneed|
 & type alternative
 \\
|tneed| & |::=| &
|tneedO|
 & `offered' context
 \\
& | || | &
|tneedR|
 & `required' context
 \\
|thard| & |::=| &
|thardH|
 & `hard' constraint
 \\
& | || | &
|thardS|
 & `soft' constraint
 \\
%%]

%%[notationBasic
|sigma|
 & type
 \\
|sigmak|
 & expected/known type
 \\
|ANY|
 & any type
 \\
|tvarv|
 & type variable
 \\
|ident|
 & identifier
 \\
|identv|
 & value identifier
 \\
|identc|
 & (type) constructor identifier, type constant
 \\
|Gamma|
 & assumptions, environment, context
 \\
|Cnstr|
 & constraints, substitution
 \\
|Cnstr|$_{k..l}$
 & constraint composition of |Cnstr|$_k ...$ |Cnstr|$_l$
 \\
|<=|
 & subsumption, ``fits in'' relation
 \\
%%]

%%[notationExplImpl
|pi|
 & predicate
 \\
|pvar|
 & predicate wildcard (collection of predicates)
 \\
%%]

%%[notationImpredA
|sigmaQu|
 & |sigma| with a quantifier
 \\
|sigmaNQu|
 & |sigma| without a quantifier
 \\
|tvarf|
 & fixed type variable (a.k.a. skolem type)
 \\
|fiopt|
 & options to |<=>|
 \\
%%]

%%[notationImpredB
|isigma|
 & |sigma| for impredicativity inferencing
 \\
|sigmaQu|
 & |sigma| with a quantifier
 \\
|sigmaNQu|
 & |sigma| without a quantifier
 \\
|ICnstr|
 & |Cnstr| for impredicativity inferencing
 \\
|<+>|
 & meet of two types
 \\
|<->|
 & join of two types
 \\
|<=>|
 & |<=|, |<+>| or |<->|
 \\
|thard|
 & type alternative hardness (hard or soft)
 \\
|thardH|
 & hard type alternative
 \\
|thardS|
 & soft type alternative
 \\
|tneed|
 & type alternative need/context (offered or required)
 \\
|tneedO|
 & offered type alternative
 \\
|tneedR|
 & required type alternative
 \\
|talt|
 & type alternative
 \\
%%]

%%[notationCoCo
|coco|
 & co-, contravariant context
 \\
|cocoY|
 & covariant context
 \\
|cocoN|
 & contravariant context
 \\
%%]

%%[notationTransl
|Transl|
 & translated code
 \\
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

