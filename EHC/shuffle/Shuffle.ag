imports
{
import System
import System.Console.GetOpt
import Data.Maybe
import Data.Char
import IO
import Monad
import Array
import Data.List
import qualified Data.Map as Map
import FPath
import Nm
import ParseUtils
{-
import PPUtils
import UU.Pretty
-}
import UU.Parsing
import UU.Parsing.CharParser
import UU.Scanner.Position( initPos, Pos )
import qualified UU.DData.Set as Set
import qualified UU.DData.Seq as Seq
}

-------------------------------------------------------------------------
-- Main
-------------------------------------------------------------------------

{
main :: IO ()
main
  = do { args <- getArgs
       ; let oo@(o,n,errs)  = getOpt Permute cmdLineOpts args
             opts           = foldr ($) defaultOpts o
       ; if optHelp opts
         then putStrLn (usageInfo "Usage shuffle [options] [file|-]\n\noptions:" cmdLineOpts)
         else if null errs
              then  let (f,frest) = if null n then (emptyFPath,[]) else if head n == "-" then (emptyFPath,tail n) else (mkFPath (head n),tail n)
                    in  doCompile f (map mkFPath frest) opts
              else  putStr (head errs)
       }

readShFile :: FPath -> Opts -> IO (String,T_AGItf)
readShFile fp opts
  = do { (fn,fb,fh)
             <- if fpathIsEmpty fp
                then return ("<stdin>","<stdin>",stdin)
                else do { let fn = fpathToStr fp
                        ; h <- openFile fn ReadMode
                        ; return (fn,fpathBase fp,h)
                        }
       ; txt <- hGetContents fh
       ; let toks = scan shuffleScanOpts ScSkip txt
       ; let (pres,perrs) = parseToResMsgs pAGItf toks
       ; if null perrs
         then return (fb,pres)
         else do { mapM_ (hPutStrLn stderr . show) perrs
                 ; exitFailure
                 }
       }

doCompile :: FPath -> [FPath] -> Opts -> IO ()
doCompile fp fpRest opts
  = do { xrefExceptFileContent
           <- case optMbXRefExcept opts of
                Just f -> do c <- readFile f
                             return (Set.unions . map (Set.fromList . words) . lines $ c)
                Nothing -> return Set.empty
       ; ((fb,pres):restPRes) <- mapM (\f -> readShFile f opts) (fp:fpRest)
       ; let nmChMp = allNmChMpOf restPRes
             res = wrapSem fb xrefExceptFileContent Map.empty pres
       ; putBld (optAG opts) nmChMp (bldAG_Syn_AGItf res) 
       ; putBld (optHS opts || optPlain opts) nmChMp (bldHS_Syn_AGItf res) 
       ; putBld (optLaTeX opts) nmChMp (bldLaTeX_Syn_AGItf res) 
       }
  where selBld opts res
          = if optAG opts then bldAG_Syn_AGItf res
            else if optHS opts || optPlain opts then bldHS_Syn_AGItf res
            else bldLaTeX_Syn_AGItf res
        putBld f nmChMp b
          = if f && not (null b)
            then mapM_ (cdPut stdout . cdocSubst nmChMp . bldCD) b
            else return ()
        wrapSem fb xr nmChMp pres = wrapAG_T opts fb fp xr nmChMp pres
        allNmChMpOf restPRes
          = Map.unions [ Map.mapKeys (\n -> mkNm b `nmApd` n) (nMp `Map.union` bMp)
                       | (b,pr) <- restPRes
                       , let r = wrapSem b Set.empty Map.empty pr
                             nMp = gathNmChMp_Syn_AGItf r
                             bMp = Map.unions [ bldNmChMp  b | b <- selBld opts r ]
                       ]
}

-------------------------------------------------------------------------------------------
-- Scanning
-------------------------------------------------------------------------------------------

{
data ScanOpts
  =  ScanOpts
        {   scoKeywordsTxt      ::  Set.Set String
        ,   scoSpecChars        ::  Set.Set Char
        ,   scoOpChars          ::  Set.Set Char
        }

type ScanOptsMp = Map.Map ScState ScanOpts

chKindMp = Map.fromList [ ("hs",ChHS), ("ag",ChAG), ("plain",ChPlain) ]
chDestMp = Map.fromList [ ("here",ChHere), ("hide",ChHide) ]

kwTxtAsVarToo
  = [ "module", "import", "export" ]
    ++ Map.keys chKindMp
    ++ Map.keys chDestMp

shuffleScanOpts :: ScanOptsMp
shuffleScanOpts
  = Map.fromList
        [ ( ScLexMeta
          , ScanOpts
              { scoKeywordsTxt      =   Set.fromList (kwTxtAsVarToo ++ [ "_", "-", ".", "<" ])
              , scoSpecChars        =   Set.fromList "(),"
              , scoOpChars          =   Set.fromList "+-=*&^%$#@!\\|><~`;:?/_."
              }
          )
        ]

data ScState
  = ScChunk | ScLexMeta | ScSkip
  deriving (Show,Eq,Ord)

data TokPos
  = TokPos { tkpLine, tkpColumn :: Int }
  deriving (Eq,Ord)

instance Show TokPos where
  show (TokPos l c) = if l < 0 || c < 0 then "" else "(" ++ show l ++ ":" ++ show c ++ ")"

tkpStart :: TokPos
tkpStart = TokPos 1 1

tkpNone :: TokPos
tkpNone = TokPos (-1) (-1)

data TokKind
  = TKBegChunk | TKEndChunk | TKNameRef | TKNl | TkText | TkInt | TkStr | TkEOF | TkReserved
  deriving (Show,Eq,Ord)

data Tok
  = Tok { tokKind :: TokKind, tokWhite :: String, tokBlack :: String, tokPos :: TokPos, tokState :: ScState }

instance Eq Tok where
  (Tok k1 _ b1 _ _) == (Tok k2 _ b2 _ _) = k1 == k2 && (k1 /= TkReserved || b1 == b2)

instance Ord Tok where
  (Tok k1 _ b1 _ _) `compare` (Tok k2 _ b2 _ _)
    = if ck == EQ
      then if k1 == TkReserved then b1 `compare` b2 else ck
      else ck
    where ck = k1 `compare` k2

instance Show Tok where
  show t = show (tokPos t) ++ show (tokBlack t)

instance Symbol Tok

isVarStart :: Char -> Bool
isVarStart c = c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z'

isVarRest :: Char -> Bool
isVarRest c = isVarStart c || isDigit c || c `elem` "'_"

isWhite :: Char -> Bool
isWhite = (`elem` " \t")

isLF :: Char -> Bool
isLF = (`elem` "\n\r")

isBlack :: Char -> Bool
isBlack c = not (isWhite c || isLF c)

isStrQuote :: Char -> Bool
isStrQuote c = c == '"'

isStr :: Char -> Bool
isStr c = not (isStrQuote c || isLF c)

scan :: ScanOptsMp -> ScState -> String -> [Tok]
scan scoMp st s
  = takeWhile ((/=TkEOF) . tokKind) (sc tkpStart st s)
  where sc p st             ""                      = [Tok TkEOF "" "" p st]
        sc p ScChunk        s@(c:_)
          | isWhite c                               = t {tokWhite = w} : ts
                                                    where (w,s') = span isWhite s
                                                          (t:ts) = sc (a w p) ScChunk s'
        sc p ScLexMeta      s@(c:_)
          | isWhite c                               = sc (a w p) ScLexMeta s'
                                                    where (w,s') = span isWhite s
        sc p st             s@(c:s')
          | isLF c                                  = Tok TKNl       ""   [c] p st : sc (al p) st' s'
                                                    where st' = if st == ScLexMeta then ScChunk else st
        sc p st@ScLexMeta   s@(c:s')
          | isSpec st c                             = Tok TkReserved ""   [c] p st : sc (ai 1 p) st s'
        sc p st@ScLexMeta   s@(c:_)
          | isVarStart c                            = scKw isVarRest p st s
        sc p st@ScLexMeta   s@(c:_)
          | isDigit c                               = Tok TkInt      ""   w   p st : sc (a w p) st s'
                                                    where (w,s') = span isDigit s
        sc p st@ScLexMeta   s@(c:s')
          | isStrQuote c                            = Tok TkStr      ""   w   p st : sc (a w . ai 2 $ p) st s3
                                                    where (w,s2) = span isStr s'
                                                          s3 = case s2 of
                                                                 (c:s) | isStrQuote c -> s
                                                                 _                    -> s2
        sc p st@ScLexMeta   s@(c:_)
          | isOpch st c                             = scKw (isOpch st) p st s
        sc p@(TokPos _ 1) ScSkip  s@('%':'%':'[':s')= Tok TKBegChunk "" "%%[" p ScSkip  : sc (ai 3 p) ScLexMeta s'
        sc p@(TokPos _ 1) ScChunk s@('%':'%':']':s')= Tok TKEndChunk "" "%%]" p ScChunk : sc (ai 3 p) ScSkip s'
        sc p@(TokPos _ 1) ScChunk s@('%':'%':'@':s')= Tok TKNameRef  "" "%%@" p ScChunk : sc (ai 3 p) ScChunk s'
        sc p ScChunk        s@(c:_)
          | isBlack c                               = Tok TkText     ""   b   p ScChunk : sc (a b p) ScChunk s'
                                                    where (b,s') = span isBlack s
        sc p st             s@(c:s')                = sc (ai 1 p) st s'
        scKw f p st s                               = Tok tk         ""   w   p st  : sc (a w p) st s'
                                                    where (w,s') = span f s
                                                          tk = if isKeyw st w then TkReserved else TkText
        a s                                         = ai (length s)
        ai i p                                      = p {tkpColumn = i + tkpColumn p}
        al   p                                      = p {tkpLine = 1 + tkpLine p, tkpColumn = 1}
        opt st p                                    = maybe False p $ Map.lookup st scoMp
        isSpec st c                                 = opt st (\o -> c `Set.member` scoSpecChars o)
        isOpch st c                                 = opt st (\o -> c `Set.member` scoOpChars o)
        isKeyw st w                                 = opt st (\o -> w `Set.member` scoKeywordsTxt o)

pBegChunk, pEndChunk, pBegNameRef, pNl :: (IsParser p Tok) => p Tok
pBegChunk   = pSym (Tok TKBegChunk "" "%%[" tkpNone ScSkip)
pEndChunk   = pSym (Tok TKEndChunk "" "%%]" tkpNone ScSkip)
pBegNameRef = pSym (Tok TKNameRef  "" "%%@" tkpNone ScSkip)
pNl         = pSym (Tok TKNl       "" "LF"  tkpNone ScSkip)

pKey :: (IsParser p Tok) => String -> p String
pKey k = tokBlack <$> pSym (Tok TkReserved "" k tkpNone ScSkip)

pVar :: (IsParser p Tok) => p String
pVar = tokBlack <$> pSym (Tok TkText "" "<ident>" tkpNone ScSkip)

pInt :: (IsParser p Tok) => p String
pInt = tokBlack <$> pSym (Tok TkInt "" "0" tkpNone ScSkip)

pInt' :: (IsParser p Tok) => p Int
pInt' = read <$> pInt

pStr :: (IsParser p Tok) => p String
pStr = tokBlack <$> pSym (Tok TkStr "" "<string>" tkpNone ScSkip)

pBlack :: (IsParser p Tok) => p (Maybe String,String)
pBlack = (\(Tok _ w b _ _) -> (if null w then Nothing else Just w,b)) <$> pSym (Tok TkText "" "<text>" tkpNone ScSkip)
}


-------------------------------------------------------------------------
-- Parsing
-------------------------------------------------------------------------

{
parseHandle :: ShPr a -> FilePath -> Handle -> IO a
parseHandle p fn fh
  = do { txt <- hGetContents fh
       ; let toks = scan shuffleScanOpts ScSkip txt
       ; parseIOMessage show p toks
       }
}

-------------------------------------------------------------------------
-- New Parser
-------------------------------------------------------------------------

{
type ShPr  c = (IsParser p Tok) => p c
type ShPr2 c = (IsParser p Tok) => p c -> p c
type ShPr3 c = (IsParser p Tok) => p c -> p c -> p c

pAGItf :: ShPr T_AGItf
pAGItf = sem_AGItf_AGItf <$> (sem_Lines_Nil <$ pList pNl) <*> pChunks

pVersion            ::  ShPr Version
pVersion            =   mkVerFromIntL <$> pList1Sep (pKey "_") pInt'

pVerOrder           ::  ShPr VersionOrder
pVerOrder           =   pListSep (pKey ",") (pList1Sep (pKey "<") pVersion)

pNm                 ::  ShPr Nm
pNm                 =   (\h t -> nmFromL (h : t)) <$> pVar <*> pList (pKey "." *> (pVar <|> pInt))

pId, pIdNest, pIdNest2, pIdNestPart :: ShPr String
pId                 =   (\h t -> concat . intersperse "." $ h : t) <$> pVar <*> pList (pKey "." *> (pVar <|> pInt))
pIdNest             =   (concat . intersperse " ") <$> pList1 pIdNestPart
pIdNest2            =   (concat . intersperse " ") <$> pList1 (pIdNestPart <|> foldl1 (<|>) (map pKey kwTxtAsVarToo))
pIdNestPart         =   pId
                    <|> (\l -> "(" ++ concat (intersperse "," l) ++ ")") <$> pParens pIdNests2
                    <|> pStr

pIdNests, pIdNests2 ::  ShPr [String]
pIdNests            =   pListSep (pKey ",") pIdNest
pIdNests2           =   pListSep (pKey ",") pIdNest2

pChunkId            ::  ShPr ChunkId
pChunkId            =   (,) <$> pVersion <* pKey "." <*> pNm

pParens             ::  ShPr2 p
pParens p           =   pKey "(" *> p <* pKey ")"

pChunks             ::  ShPr T_Chunks
pChunks             =   pFoldr (sem_Chunks_Cons,sem_Chunks_Nil) pChunk

pChunk              ::  ShPr T_Chunk 
pChunk              =   pBegChunk
                         *> ((   sem_Chunk_Ver
                                 <$> pVersion
                                 <*> pMaybe id NmEmp (pKey "." *> pNm)
                                 <*> (pKey "-" *> ((:[]) <$> pChunkId <|> pParens (pList1 pChunkId)) <|> pSucceed [])
                                 <*> pMaybe id ChAG pChKind
                                 <*> pMaybe id ChHere pChDest
                                 <*> (Just <$ pKey "module" <*> pId <|> pSucceed Nothing)
                                 <*> (pKey "import" *> pParens pIdNests2 <|> pSucceed [])
                                 <*> (pKey "export" *> pParens pIdNests2 <|> pSucceed [])
                             <|> sem_Chunk_Named
                                 <$> pNm
                             )
                             <*  pNl
                             <*> pLines
                             <*  pEndChunk
                             <*> pLines
                            )
                    <?> "a chunk"

pChKind             ::  ShPr ChKind
pChKind             =   pAnyFromMap pKey chKindMp

pChDest             ::  ShPr ChDest
pChDest             =   pAnyFromMap pKey chDestMp

pLines              ::  ShPr T_Lines
pLines              =   pFoldr (sem_Lines_Cons,sem_Lines_Nil) pLine

pLine               ::  ShPr T_Line
pLine               =   sem_Line_AsIs  <$> pLineChars  <*  pNl
                    <|> sem_Line_Named <$  pBegNameRef <*> pNm <* pNl
                    <?> "a line"

pLineChars          ::  ShPr T_Words
pLineChars          =   (foldr sem_Words_Cons sem_Words_Nil . concat)
                        <$> pList ((\(mw,b) -> maybe [] (\w -> [sem_Word_White w]) mw ++ [sem_Word_Black b]) <$> pBlack)
}

-------------------------------------------------------------------------
-- Parser
-------------------------------------------------------------------------

{
parseAndGetRes :: ShPr a -> String -> a
parseAndGetRes p s
  = case evalSteps (parse p toks) of {Pair v _ -> v}
  where toks = scan shuffleScanOpts ScLexMeta s
}

-------------------------------------------------------------------------
-- Options
-------------------------------------------------------------------------

{
data Opts 
  = Opts
      { optAG           :: Bool
      , optHS           :: Bool
      , optPlain        :: Bool
      , optLaTeX        :: Bool
      , optPreamble     :: Bool
      , optIndex        :: Bool
      , optHelp         :: Bool
      , optGenVersion   :: Version
      , optBaseName     :: Maybe String
      , optWrapLhs2tex  :: Bool
      , optMbXRefExcept :: Maybe String
      , optVerOrder     :: VersionOrder
      }

defaultOpts
  = Opts
      { optAG           =  False
      , optHS           =  False
      , optLaTeX        =  False
      , optPreamble     =  True
      , optPlain        =  False
      , optIndex        =  False
      , optHelp         =  False
      , optGenVersion   =  VNone
      , optBaseName     =  Nothing
      , optWrapLhs2tex  =  True
      , optMbXRefExcept =  Nothing
      , optVerOrder     =  [[]]
      }

optsHasNoVerOrder :: Opts -> Bool
optsHasNoVerOrder = null . head . optVerOrder

cmdLineOpts  
  =  [  Option "a"  ["ag"]        (NoArg oAG)
          "generate code for ag, default=no"
     ,  Option "h"  ["hs"]        (NoArg oHS)
          "generate code for haskell, default=no"
     ,  Option "l"  ["latex"]     (NoArg oLaTeX)
          "generate code for latex, default=no"
     ,  Option ""   ["preamble"]    (OptArg oPreamble "yes|no")
          "include preamble (marked by version=0), default=yes"
     ,  Option "p"  ["plain"]     (NoArg oPlain)
          "generate plain code, default=no"
     ,  Option ""   ["index"]     (NoArg oIndex)
          "combined with latex, generate index entries, default=no"
     ,  Option "g"  ["gen"]       (ReqArg oGen "all|<nr>")
          "generate for version, default=none"
     ,  Option ""   ["order"]     (ReqArg oVerOrder "<order-spec>")
          "version order"
     ,  Option "b"  ["base"]      (ReqArg oBase "<name>")
          "base name, default=derived from filename"
     ,  Option ""   ["xref-except"]      (ReqArg oXRefExcept "<filename>")
          "file with list of strings not to be cross ref'd"
     ,  Option ""   ["help"]      (NoArg oHelp)
          "output this help"
     ,  Option ""   ["lhs2tex"]   (OptArg oLhs2tex "yes|no")
          "wrap chunks in lhs2tex's code environment, default=yes"
     ]
  where  oAG             o =  o {optAG = True}
         oHS             o =  o {optHS = True}
         oPreamble   ms  o =  yesno (\f o -> o {optPreamble = f}) ms o
         oLaTeX          o =  o {optLaTeX = True}
         oPlain          o =  o {optPlain = True}
         oIndex          o =  o {optIndex = True}
         oLhs2tex    ms  o =  yesno (\f o -> o {optWrapLhs2tex = f}) ms o
         oBase        s  o =  o {optBaseName = Just s}
         oVerOrder    s  o =  o {optVerOrder = parseAndGetRes pVerOrder s}
         oXRefExcept  s  o =  o {optMbXRefExcept = Just s}
         oGen         s  o =  case s of
                                "all"               -> o {optGenVersion = VAll}
                                (c:_) | isDigit c   -> o {optGenVersion = parseAndGetRes pVersion s}
                                _                   -> o {optGenVersion = VAll}
         oHelp           o =  o {optHelp = True}
         yesno updO  ms  o =  case ms of
                                Just "yes"  -> updO True o
                                Just "no"   -> updO False o
                                _           -> o


}

-------------------------------------------------------------------------
-- Inferfacing
-------------------------------------------------------------------------

WRAPPER AGItf

{
wrapAG_T :: Opts -> String -> FPath -> XRefExcept -> NmChMp -> T_AGItf -> Syn_AGItf
wrapAG_T opts fb fp xr nmChMp pres
  = wrap_AGItf pres
      (Inh_AGItf
         { opts_Inh_AGItf = opts {optBaseName = maybe (Just fb) Just (optBaseName opts)}
         , fpath_Inh_AGItf = fp
         , xrefExcept_Inh_AGItf = xr
         , nmChMp_Inh_AGItf = nmChMp
         })
}

WRAPPER AGCDocItf

{
wrapAGCDoc_T :: NmChMp -> T_AGCDocItf -> Syn_AGCDocItf
wrapAGCDoc_T nmChMp d
  = wrap_AGCDocItf d
      (Inh_AGCDocItf
         { nmChMp_Inh_AGCDocItf = nmChMp
         })

wrapCDoc :: NmChMp -> CDoc -> Syn_AGCDocItf
wrapCDoc m d = wrapAGCDoc_T m (sem_AGCDocItf (AGCDocItf_AGItf d))

cdocSubst :: NmChMp -> CDoc -> CDoc
cdocSubst m d
  = sbRepl_Syn_AGCDocItf r
  where r = wrapCDoc m d
}

-------------------------------------------------------------------------
-- AST
-------------------------------------------------------------------------

-- Outside itf
DATA AGItf
  | AGItf               dumLines    : Lines
                        chunks      : Chunks

DATA AGCDocItf
  | AGItf               cdoc        : CDoc

-- Chunk
DATA Chunk
  | Ver                 version     : {Version}
                        subNm       : {Nm}
                        minusL      : {[ChunkId]}
                        chKind      : {ChKind}
                        chDest      : {ChDest}
                        mbModNm     : {Maybe String}
                        imports     : {[String]}
                        exports     : {[String]}
                        lines       : Lines
                        dumLines    : Lines
  | Named               cref        : {CRef}
                        lines       : Lines
                        dumLines    : Lines

TYPE Chunks     = [Chunk]

SET AllChunk    = Chunk Chunks

-- Single line
DATA Line
  | AsIs                words       : Words
  | Named               cref        : {CRef}

TYPE Lines      = [Line]

SET AllLine     = Line Lines

-- Single word
DATA Word
  | White               chars       : {String}
  | Black               chars       : {String}

TYPE Words      = [Word]

SET AllWord     = Word Words

-- Chunk doc
DATA CDoc
  | Emp
  | Ref                 cref        : {CRef}
                        chDest      : {ChDest}
  | Str                 str         : {String}
  | Hor                 ldoc        : CDoc
                        rdoc        : CDoc
  | Ver                 ldoc        : CDoc
                        rdoc        : CDoc

-- Sets
SET AllNT       = AllWord AllLine AllChunk

-------------------------------------------------------------------------
-- Global info
-------------------------------------------------------------------------

ATTR AGItf [ opts: Opts  fpath: FPath | | ]

-------------------------------------------------------------------------
-- Chunk ref
-------------------------------------------------------------------------

{
type CRef = Nm
}

-------------------------------------------------------------------------
-- Common. Version
-------------------------------------------------------------------------

{
data Version    = VAll
                | VPre
                | VNone
                | VRef {verRef :: Int}
                | VNest {verNest :: Version, verRef :: Int}
                deriving (Show,Eq,Ord)

type VersionOrder = [[Version]]

mkVerFromInt :: Int -> Version
mkVerFromInt r = if r == 0 then VPre else VRef r

mkVerFromIntL :: [Int] -> Version
mkVerFromIntL (0:_)  = mkVerFromInt 0
mkVerFromIntL (i:is) = foldl VNest (VRef i) is

instance NM Version where
  mkNm VPre           = mkNm "pre"
  mkNm VAll           = mkNm "*"
  mkNm VNone          = mkNm "-"
  mkNm (VRef r)       = mkNm r
  mkNm (VNest n r)    = mkNm n `nmApd` mkNm r

instance CD Version where
  cd = cd . mkNm

verMatch :: Version -> Version -> Bool
verMatch VAll           _               = True
verMatch _              VAll            = True
verMatch (VRef r1)      (VRef r2)       = r1 == r2
verMatch (VNest n1 r1)  (VNest n2 r2)   = r1 == r2 && n1 == n2
verMatch VPre           VPre            = True
verMatch _              _               = False

cmpByVersionOrder :: VersionOrder -> Version -> Version -> Ordering
cmpByVersionOrder vo v1 v2
  = maybe EQ id . listToMaybe . catMaybes . map c $ vo
  where  c o = do { i1 <- elemIndex v1 o
                  ; i2 <- elemIndex v2 o
                  ; return (compare i1 i2)
                  }

voAllLE :: VersionOrder -> Version -> [Version]
voAllLE vo v
  = sortBy (cmpByVersionOrder vo)
  . nub . sort . concat
  . (case v of
      VAll -> id
      _    -> map (\o -> maybe [] (\i -> take (i+1) o) (elemIndex v o))
    )
  $ vo

voAllLE' :: VersionOrder -> Version -> [Version]
voAllLE' vo v
  = let voPrefixes
          = map (\p@((v,_):_) -> (v,map snd p))
          . groupBy (\(v1,_) (v2,_) -> v1 == v2)
          . sortBy (\(v1,_) (v2,_) -> compare v1 v2)
          . concat . map (\o -> zip o (inits o))
          $ vo
        all
          = case v of
              VAll -> concat vo
              _    -> maybe [] concat (lookup v voPrefixes)
     in sortBy (cmpByVersionOrder vo) . nub . sort $ all

voAllLE'' :: VersionOrder -> Version -> [Version]
voAllLE'' vo v
  = let allN = nub . sort . concat $ vo
        nrN = length allN
        nsN = [(0::Int)..nrN-1]
        ixOf' v = elemIndex v allN
        ixOf v = maybe 0 id (ixOf' v)
        voPrefixes
          = map (\p@((v,_):_) -> (ixOf v,map ixOf . nub . sort . (v:) . concat . map snd $ p))
          . groupBy (\(v1,_) (v2,_) -> v1 == v2)
          . sortBy (\(v1,_) (v2,_) -> compare v1 v2)
          . concat . map (\o -> zip o (inits o))
          $ vo
        m1 = map
                (\(n,ns)
                    -> map snd . sort $ (zip (ns) (repeat True) ++ zip (nsN \\ ns) (repeat False))
                )
                voPrefixes
        m2 = array (0,nrN-1) (zip nsN (map (\r -> array (0,nrN-1) (zip nsN r)) m1))
        m3 = foldr
                (\n m
                    -> foldr
                        (\i m -> m // [(i,m ! i // [ (j,m ! i ! n && m ! n ! j || m ! i ! j) | j <- nsN ])])
                        m nsN
                )
                m2 nsN
        nsV = maybe [] (\i -> assocs (m3 ! i)) (ixOf' v)
        allN' = case v of
                  VAll -> allN
                  _    -> [ allN !! i | (i,b) <- nsV, b ]
     in sortBy (cmpByVersionOrder vo) . nub . sort $ allN'

voDefault :: VersionOrder
voDefault = [take 30 (map VRef [1..])]

}

-------------------------------------------------------------------------
-- Chunk id
-------------------------------------------------------------------------

{
type ChunkId = (Version,Nm)
}

-------------------------------------------------------------------------
-- Chunk kind, purpose/destination
-------------------------------------------------------------------------

{
data ChKind
  = ChAG | ChHS | ChPlain
  deriving (Show,Eq,Ord)

data ChDest
  = ChHere | ChHide
  deriving (Show,Eq,Ord)
}

-------------------------------------------------------------------------
-- Chunk doc utils
-------------------------------------------------------------------------

{
cdHor :: CD a => [a] -> CDoc
cdHor = foldr CDoc_Hor CDoc_Emp . map cd

cdVer :: CD a => [a] -> CDoc
cdVer = foldr CDoc_Ver CDoc_Emp . map cd

cdLines :: CDoc -> [String]
cdLines d
  = lns d
  where ln l CDoc_Emp = (l,CDoc_Emp)
        ln l (CDoc_Str s) = (s:l,CDoc_Emp)
        ln l (CDoc_Hor d1 d2)
          = case ln l d1 of
              (l1,CDoc_Emp) -> ln l1 d2
              r             -> r
        ln l (CDoc_Ver d1 d2)
          = case ln l d1 of
              (l1,CDoc_Emp) -> (l1,d2)
              (l1,dr)       -> (l1,CDoc_Ver dr d2)
        lns CDoc_Emp = []
        lns d = let (l,d') = ln [] d in concat (reverse l) : lns d'

cdPut' :: Handle -> CDoc -> IO ()
cdPut' h = mapM_ (hPutStrLn h) . cdLines

cdPut :: Handle -> CDoc -> IO ()
cdPut h d
  = case d of
      CDoc_Emp       -> return ()
      CDoc_Str s     -> hPutStr h s
      CDoc_Hor d1 d2 -> do cdPut h d1
                           cdPut h d2
      CDoc_Ver d1 d2 -> do cdPut h d1
                           hPutStrLn h ""
                           cdPut h d2

class CD a where
  cd :: a -> CDoc

instance CD String where
  cd = CDoc_Str

instance CD Int where
  cd = CDoc_Str . show

instance CD CDoc where
  cd = id

instance CD Nm where
  cd = cdDots . nmToL

infixr 2 .-.
infixr 3 .|. , .#.

(.|.) :: (CD a, CD b) => a -> b -> CDoc
(.|.) a b = cd a `CDoc_Hor` cd b

(.-.) :: (CD a, CD b) => a -> b -> CDoc
(.-.) a b = cd a `CDoc_Ver` cd b

(.#.) :: (CD a, CD b) => a -> b -> CDoc
(.#.) a b = cd a .|. " " .|. cd b

cdListSep' :: (CD s, CD c, CD o, CD a) => (forall x . CD x => [x] -> CDoc) -> (forall x y . (CD x, CD y) => x -> y -> CDoc) -> o -> c -> s -> [a] -> CDoc
cdListSep' list aside o c s pps
  = l pps
  where l []      = o `aside` c
        l [p]     = o `aside` p `aside` c
        l (p:ps)  = list ([o `aside` p] ++ map (s `aside`) (init ps) ++ [s `aside` last ps `aside` c])

cdListSep :: (CD s, CD c, CD o, CD a) => o -> c -> s -> [a] -> CDoc
cdListSep = cdListSep' cdHor (.|.)

cdListSepV :: (CD s, CD c, CD o, CD a) => o -> c -> s -> [a] -> CDoc
cdListSepV = cdListSep' cdVer (.|.)

cdDots :: CD a => [a] -> CDoc
cdDots = cdListSep "" "" "."

}

-------------------------------------------------------------------------
-- Utils
-------------------------------------------------------------------------

{
mkTexCmdDef :: (CD a, CD b) => String -> a -> b -> CDoc
mkTexCmdDef cmd nm def = "\\" .|. cmd .|. "{" .|. cd nm .|. "}{%" .-. cd def .-. "}"

mkTexCmdUse :: CD a => String -> a -> CDoc
mkTexCmdUse cmd nm = "\\" .|. cmd .|. "{" .|. cd nm .|. "}"

mkTexCmdUse' :: CD a => String -> a -> CDoc
mkTexCmdUse' cmd nm = mkTexCmdUse cmd nm .|. "%"
}

-------------------------------------------------------------------------
-- Sequence nr (for ordering when printing)
-------------------------------------------------------------------------

ATTR AllChunk [ seqNr: Int | | ]

SEM AGItf
  | AGItf       chunks      . seqNr     = 1

SEM Chunks
  | Cons        tl          . seqNr     = @lhs.seqNr + 1

-------------------------------------------------------------------------
-- Line counting, column counting
-------------------------------------------------------------------------

ATTR AllChunk AllLine [ | lineNr: Int | ]
ATTR AllWord [ | colNr: Int | ]

SEM AGItf
  | AGItf       dumLines    . lineNr    = 1

SEM Lines
  | Cons        tl          . lineNr    = @lhs.lineNr + 1

SEM Chunk
  | Ver Named   loc         . chunkLineNr
                                        = @lhs.lineNr + 1
                lines       . lineNr    = @chunkLineNr
                dumLines    . lineNr    = @lines.lineNr + 1

SEM Line
  | AsIs        words       . colNr     = 0

SEM Word
  | White Black loc         . wordColNr = @lhs.colNr
                lhs         . colNr     = @lhs.colNr + length @chars

-------------------------------------------------------------------------
-- Left + right context
-------------------------------------------------------------------------

ATTR Words [ lCtxt: {[String]}  lAllCtxt: {[String]} | | rCtxt: {[String]} ]
ATTR Word [ | lCtxt: {[String]}  lAllCtxt: {[String]}  rCtxt: {[String]} | ]

SEM Line
  | AsIs        words       . lCtxt     = []
                            . lAllCtxt  = []

SEM Words
  | Nil         lhs         . rCtxt     = []
  | Cons        hd          . rCtxt     = @tl.rCtxt
                lhs         . rCtxt     = @hd.rCtxt

SEM Word
  | Black       lhs         . rCtxt     = @chars : @lhs.rCtxt
                            . lCtxt     = @chars : @lhs.lCtxt
                            . lAllCtxt  = @chars : @lhs.lAllCtxt
  | White       lhs         . lAllCtxt  = @chars : @lhs.lAllCtxt

-------------------------------------------------------------------------
-- Cross ref
-------------------------------------------------------------------------

{
data XRefKind = XRHsDef | XRAgAttrDef | XRAgAltDef | XRAgSemDef | XRHsUse | XRAgAttrUse deriving Show
data XRef = XRef { xrKind :: XRefKind, xrKeyL :: [String] } deriving Show

xrMainKey :: XRef -> String
xrMainKey = head . xrKeyL

xrKindIsDefining :: XRefKind -> Bool
xrKindIsDefining XRHsDef = True
xrKindIsDefining XRAgAttrDef = True
xrKindIsDefining XRAgAltDef = True
xrKindIsDefining XRAgSemDef = True
xrKindIsDefining _ = False

xrIsDefining :: XRef -> Bool
xrIsDefining = xrKindIsDefining . xrKind

type XRefL = Seq.Seq XRef
type XRefExcept = Set.Set String

passXR :: XRefExcept -> String -> ([XRef],Int) -> ([XRef],Int)
passXR exc r xr = if Set.member r exc then ([],0) else xr
}

ATTR AGItf AllNT [ xrefExcept: XRefExcept | | ]
ATTR AllWord AllLine [ | | xrefL USE {`Seq.append`} {Seq.empty} : XRefL ]
ATTR Word [ | rCtxtUsed: Int | ]
ATTR Words [ rCtxtUsed: Int | | ]

SEM Word
  | Black       (loc.xrefL,lhs.rCtxtUsed)
                                        = let ctxtHuge = 10000000
                                              loclhs = ["lhs","loc"]
                                              none = ([],@lhs.rCtxtUsed - 1)
                                              def nms k cUsed
                                                   = if any (flip Set.member @lhs.xrefExcept) nms then ([],0) else ([XRef k nms],cUsed)
                                           in if @lhs.rCtxtUsed <= 0 && isAlpha (head @chars)
                                              then case (@lhs.lAllCtxt,@lhs.lCtxt,@chars,@lhs.rCtxt) of
                                                     (_,("@":_),nm1,(".":nm2:_))
                                                       | nm1 `elem` loclhs          -> def [nm2] XRAgAttrUse 2
                                                     (_,("@":_),nm1,(".":nm2:_))    -> def [nm2,nm1] XRAgAttrUse 2
                                                     (_,("@":_),nm1,_)              -> def [nm1] XRAgAttrUse 0
                                                     (_,("|":_),nm1,_)              -> def [nm1] XRAgAltDef 0
                                                     (_,(".":ll:_),nm1,("=":_))
                                                       | ll `elem` loclhs           -> def [nm1] XRAgAttrDef 1
                                                     (_,(".":nm2:_),nm1,("=":_))    -> def [nm1,nm2] XRAgAttrDef 1
                                                     (_,_,nm1,([sep]:nm2:_))
                                                       | sep `elem` "._"            -> def [nm2,nm1] XRHsUse 2
                                                       | otherwise                  -> none
                                                     (_,["SEM"],nm1,_)              -> def [nm1] XRAgSemDef ctxtHuge
                                                     (_,["data"],nm1,_)             -> def [nm1] XRHsDef 0
                                                     (_,["type"],nm1,_)             -> def [nm1] XRHsDef 0
                                                     ([],_,nm1,_)                   -> def [nm1] XRHsDef ctxtHuge
                                                     (_,_,nm1,_)
                                                       | nm1 `notElem` loclhs       -> def [nm1] XRHsUse 0
                                                     _                              -> none
                                              else none
                lhs         . xrefL     = Seq.fromList @xrefL
  | White       lhs         . rCtxtUsed = 0

SEM Line
  | AsIs        words       . rCtxtUsed = 0

-------------------------------------------------------------------------
-- Named chunks
-------------------------------------------------------------------------

{
data NmChInfo
  = NmChInfo
      { nciNm       :: CRef
      , nciChDest   :: ChDest
      , nciMbCD     :: Maybe CDoc
      }

type NmChMp = Map.Map CRef NmChInfo
}

ATTR AllChunk AGItf [ | | gathNmChMp USE {`Map.union`} {Map.empty}: NmChMp ]
ATTR AllChunk AllLine AGCDocItf AGItf CDoc [ nmChMp: NmChMp | | ]

SEM Chunk
  | Named       loc         . chInfo    = NmChInfo @cref ChHere @lines.mbCD
                lhs         . gathNmChMp= Map.singleton @cref @chInfo

SEM AGItf
  | AGItf       chunks      . nmChMp    = @chunks.gathNmChMp `Map.union` @lhs.nmChMp
                dumLines    . nmChMp    = Map.empty

-------------------------------------------------------------------------
-- Content replica, CDoc
-------------------------------------------------------------------------

ATTR AllLine [ | | mbCD : {Maybe CDoc} ]

SEM Line
  | AsIs        lhs         . mbCD      = Just (if null @words.charsL then CDoc_Str "" else cdHor @words.charsL)
  | Named       lhs         . mbCD      = Just (CDoc_Ref @cref ChHere)

SEM Lines
  | Nil         lhs         . mbCD      = Nothing
  | Cons        lhs         . mbCD      = maybe (@hd.mbCD) (Just . (maybe CDoc_Emp id @hd.mbCD `CDoc_Ver`)) @tl.mbCD

-------------------------------------------------------------------------
-- CRef subst in CDoc
-------------------------------------------------------------------------

ATTR CDoc [ | | sbRepl: SELF ]
ATTR AGCDocItf [ | | sbRepl: CDoc ]

SEM CDoc
  | Ref			lhs			.	sbRepl		=	case Map.lookup @cref @lhs.nmChMp of
  												  Just d
  												    -> maybe CDoc_Emp (cdocSubst (Map.delete @cref @lhs.nmChMp)) (nciMbCD d)
  												  _ -> "<<" .|. @cref .|. ">>"

-------------------------------------------------------------------------
-- Content replica, String part
-------------------------------------------------------------------------

ATTR Word [ | | chars: String ]
ATTR Words [ | | charsL: {[String]} ]

SEM Word
  | White       lhs         . chars     = @chars
  | Black       lhs         . chars     = {- show @xrefL ++ -} @chars

SEM Words
  | Nil         lhs         . charsL    = []
  | Cons        lhs         . charsL    = @hd.chars : @tl.charsL

-------------------------------------------------------------------------
-- Chunks
-------------------------------------------------------------------------

{
data VerChunkInfo
  = VerChunkInfo
      { vciLineNr   :: Int
      , vciSeqNr    :: Int
      , vciVer      :: Version
      , vciSubNm    :: Nm
      , vciMinusL   :: [ChunkId]
      , vciChKind   :: ChKind
      , vciChDest   :: ChDest
      , vciMbModNm  :: Maybe String
      , vciImps     :: [String]
      , vciExps     :: [String]
      , vciMbCD     :: Maybe CDoc
      , vciXRefL    :: [XRef]
      }
type VerChunkInfoM = [(Version,[VerChunkInfo])]

vciMToL :: VerChunkInfoM -> [VerChunkInfo]
vciMToL = concat . map snd

instance Eq VerChunkInfo where
  i1 == i2 = vciVer i1 == vciVer i2

instance Ord VerChunkInfo where
  compare i1 i2 = vciVer i1 `compare` vciVer i2

vciSortBySeqNr :: [VerChunkInfo] -> [VerChunkInfo]
vciSortBySeqNr = sortBy (\v1 v2 -> vciSeqNr v1 `compare` vciSeqNr v2)

vciVerFilter :: (Version -> Bool) -> [VerChunkInfo] -> [VerChunkInfo]
vciVerFilter f = filter (f . vciVer)

vciVerGroup :: [VerChunkInfo] -> [[VerChunkInfo]]
vciVerGroup = groupBy (\i1 i2 -> vciVer i1 == vciVer i2)

vciHasImpExp :: VerChunkInfo -> Bool
vciHasImpExp i = not (null (vciImps i) && null (vciExps i))

vciIsPre :: VerChunkInfo -> Bool
vciIsPre = (==VPre) . vciVer

vciIsHS :: VerChunkInfo -> Bool
vciIsHS = (==ChHS) . vciChKind

vciCD :: VerChunkInfo -> CDoc
vciCD = maybe CDoc_Emp id . vciMbCD

vciHasCD :: VerChunkInfo -> Bool
vciHasCD = isJust . vciMbCD

vciSplitPre :: [VerChunkInfo] -> ([VerChunkInfo],[VerChunkInfo])
vciSplitPre = partition vciIsPre

vciTakePre :: VerChunkInfoM -> ([VerChunkInfo],VerChunkInfoM)
vciTakePre is
  = case is of
        ((VPre,p):r) -> (p,r)
        _            -> ([],is)

selectChunks :: Bool -> Opts -> [VerChunkInfo] -> [(Version,[VerChunkInfo])]
selectChunks appMinus opts agl
  = let (pre,nonPre)    = vciSplitPre agl
        availVersions   = nub . sort . map vciVer $ nonPre
        v               = optGenVersion opts
        vo              = optVerOrder opts
        allowedVersions = voAllLE'' (if optsHasNoVerOrder opts then voDefault else vo) v
        vAndVciL        = map (\v -> (v,vciSortBySeqNr . vciVerFilter (==v) $ nonPre)) allowedVersions
        isNotMinused
          = let minuses = if appMinus then [ m | (_,vciL) <- vAndVciL, ml <- map vciMinusL vciL, m <- ml ] else []
             in \i -> (vciVer i,vciSubNm i) `notElem` minuses
     in filter
          ( not.null.snd )
          ( (VPre,pre)
          : map (\(v,vciL) -> (v,filter isNotMinused vciL)) vAndVciL
          )

data Build
  = Build
      { bldBase     :: String
      , bldVer      :: Version
      , bldCD       :: CDoc
      , bldNmChMp   :: NmChMp
      }
}

ATTR AllChunk [ | | verChInfoL USE {++} {[]} : {[VerChunkInfo]} ]

SEM Chunk
  | Ver         loc         . chInfo    = VerChunkInfo
                                            @chunkLineNr @lhs.seqNr
                                            @version @subNm @minusL
                                            @chKind @chDest @mbModNm @imports @exports
                                            @lines.mbCD (Seq.toList @lines.xrefL)
                lhs         . verChInfoL= [@chInfo]

SEM AGItf
  | AGItf       loc         . selChunks = selectChunks True @lhs.opts @chunks.verChInfoL
                            . selLaTeXChunks
                                        = selectChunks False (@lhs.opts {optGenVersion=VAll}) @chunks.verChInfoL
                            . wrapLhs2tex
                                        = if optWrapLhs2tex @lhs.opts
                                          then (\doWr p -> if doWr then "\\begin{code}" .-. p .-. "\\end{code}" else p)
                                          else flip const
                            . build     = \bld chunks
                                               -> let fileBase = fromJust (optBaseName @lhs.opts)
                                                      v = optGenVersion @lhs.opts
                                                      (d,m) = bld @lhs.opts @wrapLhs2tex @lhs.fpath fileBase chunks
                                                   in [Build fileBase v d m]

-------------------------------------------------------------------------
-- Gen AG
-------------------------------------------------------------------------

{
buildAGImps :: VerChunkInfo -> CDoc
buildAGImps = cdVer . map (\imp -> "INCLUDE \"" .|. imp .|. ".ag\"") . vciImps

buildAG :: Opts -> (Bool -> CDoc -> CDoc) -> FPath -> String -> VerChunkInfoM -> (CDoc,NmChMp)
buildAG opts wrap fpath fileBase is
  = let (pre,noPre) = vciTakePre is
        noPre' = vciMToL noPre
        h p  = "{" .-. p .-. "}"
        mk i = if vciIsHS i
               then h (vciCD i)
               else buildAGImps i .-. vciCD i
        ish  = filter vciIsHS noPre'
        pph  = if any vciHasImpExp ish
               then wrap True (h (buildHSModImpExp fileBase ish))
               else CDoc_Emp
        d = (if optPreamble opts then cdVer (map (wrap False . vciCD) pre) else CDoc_Emp)
            .-. pph
            .-. (cdVer . map (\i -> wrap (not (vciIsPre i)) (mk i)) . vciSortBySeqNr $ noPre')
     in (d,Map.empty)
}

ATTR AGItf [ | | bldAG: {[Build]} ]

SEM AGItf
  | AGItf       lhs         . bldAG     = @build buildAG @selChunks

-------------------------------------------------------------------------
-- Gen LaTeX
-------------------------------------------------------------------------

{
mkCmdNmDef :: CDoc -> CDoc -> CDoc
mkCmdNmDef = mkTexCmdDef "chunkCmdDef"

mkCmdNmUse :: CDoc -> CDoc
mkCmdNmUse = mkTexCmdUse' "chunkCmdUse"

mkCmdInx :: CDoc -> CDoc
mkCmdInx = mkTexCmdUse' "chunkIndex"

mkLabel :: CDoc -> CDoc
mkLabel = mkTexCmdUse' "label"

mkMetaInfo :: CDoc -> String -> CDoc
mkMetaInfo lab fileBase = mkLabel lab -- .-. mkTexCmdDef "chunkMetaDef" lab (cd fileBase)

buildLaTeX :: Opts -> (Bool -> CDoc -> CDoc) -> FPath -> String -> VerChunkInfoM -> (CDoc,NmChMp)
buildLaTeX opts wrap fpath fileBase is
  = let (pre,noPre) = vciTakePre is
        noPre' = vciMToL noPre
        versions = nub . map (verRef.vciVer) $ noPre'
        missing = if null versions then []
                                   else [minimum versions .. maximum versions] \\ versions
        mkInx
          = let styleFmt = if optWrapLhs2tex opts then "||" else "|"
             in \ix
                 -> let n = foldr1 (\x y -> y ++ "!" ++ x) . xrKeyL $ ix
                        dfmt = CDoc_Emp -- if xrIsDefining ix then text (styleFmt ++ "emph") else CDoc_Emp
                     in mkCmdInx (n .|. dfmt)
        mkContent = let mk = wrap True . vciCD
                     in if optIndex opts
                        then \i -> cdVer (map mkInx (vciXRefL i)) .-. mk i
                        else mk
        ppNoPre 
          = cdVer
            . map (\is -> let nm = mkNm fileBase `nmApd` mkNm (vciVer (head is))
                              cnm = cd nm
                              (nms,pps)
                                  = unzip
                                    . map (\(nr,i) -> let n = nm `nmApd` mkNm nr
                                                          cn = cd n
                                                       in ( cn
                                                          , mkCmdNmDef cn (mkMetaInfo cn fileBase .-. mkContent i)
                                                            .-. (let cna = cd (nm `nmApd` vciSubNm i)
                                                                 in  mkCmdNmDef cna (mkMetaInfo cna fileBase .-. mkCmdNmUse cn)
                                                                )
                                                          )
                                          )
                                    . zip [(0::Int)..]
                                    $ is
                           in cdVer pps .-. mkCmdNmDef cnm (mkMetaInfo cnm fileBase .-. cdVer (map mkCmdNmUse nms))
                  )
            . vciVerGroup
            $ noPre'
        d = (if optPreamble opts then cdVer (map (wrap False . vciCD) pre) else CDoc_Emp)
            .-. ppNoPre
            .-. cdVer (map (\v -> mkCmdNmDef (cdDots [cd fileBase,cd v]) CDoc_Emp) missing)
     in (d,Map.empty)
}

ATTR AGItf [ | | bldLaTeX: {[Build]} ]

SEM AGItf
  | AGItf       lhs         . bldLaTeX  = @build buildLaTeX @selLaTeXChunks

-------------------------------------------------------------------------
-- Gen Haskell
-------------------------------------------------------------------------

{
mkModNm :: [CDoc] -> CDoc
mkModNm = cdHor

buildHSImps :: [VerChunkInfo] -> CDoc
buildHSImps = cdVer . map (cdVer . map ("import" .#.) . vciImps)

buildHSModuleHead :: String -> [VerChunkInfo] -> CDoc
buildHSModuleHead fileBase is
  = let ise = [ i | i <- is, not (null (vciExps i) && null (vciImps i))]
        e = filter (not.null) . map vciExps $ ise
        m = catMaybes . map vciMbModNm $ ise
        exps = if null e then CDoc_Emp
                         else cdListSepV "( " " )" ", " . map (cdListSep "" "" ", ") $ e
        modNm = if null m then fileBase else head m
     in "module" .#. modNm .-. {- indent 2 -} (exps .-. "where")

buildHSModImpExp :: String -> [VerChunkInfo] -> CDoc
buildHSModImpExp fileBase is = buildHSModuleHead fileBase is .-. buildHSImps is

buildHS :: Opts -> (Bool -> CDoc -> CDoc) -> FPath -> String -> VerChunkInfoM -> (CDoc,NmChMp)
buildHS opts wrap fpath fileBase is
  = let (pre,noPre) = vciTakePre is
        noPre' = vciMToL noPre
        ppMod = buildHSModImpExp fileBase (vciMToL is)
        -- ppLineNr i = "{-# LINE" .#. vciLineNr i .#. "\"" .|. fpathToStr fpath .|. "\" #-}"
        ppNoPre
          = cdVer
            . map   (\is@(i:_)
                        -> let pb = cdVer (map (\i -> wrap (vciHasCD i) ({- ppLineNr i .-. -} vciCD i)) is)
                            in pb
                    )
            . vciVerGroup . vciSortBySeqNr
            $ noPre'
        isEmpty = all (isNothing.vciMbCD) noPre'
        d = if isEmpty
            then CDoc_Emp
            else if optPlain opts
            then ppNoPre
            else (if optPreamble opts then cdVer (map (wrap False . vciCD) pre) else CDoc_Emp)
                 .-. wrap True ppMod
                 .-. ppNoPre
     in (d,Map.empty)
}

ATTR AGItf [ | | bldHS: {[Build]} ]

SEM AGItf
  | AGItf       lhs         . bldHS     = @build buildHS @selChunks

