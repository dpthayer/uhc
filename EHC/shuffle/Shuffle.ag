imports
{
import System
import System.Console.GetOpt
import Data.Maybe
import Data.Char
import IO
import Monad
import Array
import Data.List
import qualified Data.Map as Map
import FPath
import ParseUtils
{-
import PPUtils
import UU.Pretty
-}
import UU.Parsing
import UU.Parsing.CharParser
import UU.Scanner.Position( initPos, Pos )
import qualified UU.DData.Set as Set
import qualified UU.DData.Seq as Seq
}

-------------------------------------------------------------------------
-- Main
-------------------------------------------------------------------------

{
main :: IO ()
main
  = do { args <- getArgs
       ; let oo@(o,n,errs)  = getOpt Permute cmdLineOpts args
             opts           = foldr ($) defaultOpts o
{-
       ; putStrLn (show (voAllLE' (optVerOrder opts) (optGenVersion opts)))
       ; putStrLn (show (voAllLE'' (optVerOrder opts) (optGenVersion opts)))
-}
       ; if optHelp opts
         then putStrLn (usageInfo "Usage shuffle [options] [file|-]\n\noptions:" cmdLineOpts)
         else if null errs
              then  let (f,frest) = if null n then (emptyFPath,[]) else if head n == "-" then (emptyFPath,tail n) else (mkFPath (head n),tail n)
                    in  doCompile f (map mkFPath frest) opts
              else  putStr (head errs)
       }

readShFile :: FPath -> Opts -> IO (String,T_AGItf)
readShFile fp opts
  = do { (fn,fb,fh)
             <- if fpathIsEmpty fp
                then return ("<stdin>","<stdin>",stdin)
                else do { let fn = fpathToStr fp
                        ; h <- openFile fn ReadMode
                        ; return (fn,fpathBase fp,h)
                        }
       ; txt <- hGetContents fh
       ; let toks = scan shuffleScanOpts ScSkip txt
       ; let (pres,perrs) = parseToResMsgs pAGItf toks
       ; if null perrs
         then return (fb,pres)
         else do { mapM_ (hPutStrLn stderr . show) perrs
                 ; exitFailure
                 }
       }

doCompile :: FPath -> [FPath] -> Opts -> IO ()
doCompile fp fpRest opts
  = do { xrefExceptFileContent
           <- case optMbXRefExcept opts of
                Just f -> do c <- readFile f
                             return (Set.unions . map (Set.fromList . words) . lines $ c)
                Nothing -> return Set.empty
       ; ((fb,pres):restPRes) <- mapM (\f -> readShFile f opts) (fp:fpRest)
       ; let res = wrapSem fb xrefExceptFileContent (allNmChMpOf restPRes) pres
       ; putBld (optAG opts) (bldAG_Syn_AGItf res) 
       ; putBld (optHS opts || optPlain opts) (bldHS_Syn_AGItf res) 
       ; putBld (optLaTeX opts) (bldLaTeX_Syn_AGItf res) 
       ; return ()
       }
  where putBld f b
          = if f && not (null b)
            then mapM_ (cdPut stdout . bldCD) b
            else return ()
        wrapSem fb xr nmChMp pres
          = wrap_AGItf pres
              (Inh_AGItf
                 { opts_Inh_AGItf = opts {optBaseName = maybe (Just fb) Just (optBaseName opts)}
                 , fpath_Inh_AGItf = fp
                 , xrefExcept_Inh_AGItf = xr
                 , allNmChInfoMp_Inh_AGItf = nmChMp
                 })
        allNmChMpOf restPRes
          = Map.unions [ Map.mapKeys (\n -> b ++ "." ++ n) . nmChInfoMp_Syn_AGItf $ r | (b,pr) <- restPRes, let r = wrapSem b Set.empty Map.empty pr ]
}

-------------------------------------------------------------------------------------------
-- Scanning
-------------------------------------------------------------------------------------------

{
data ScanOpts
  =  ScanOpts
        {   scoKeywordsTxt      ::  Set.Set String
        ,   scoSpecChars        ::  Set.Set Char
        ,   scoOpChars          ::  Set.Set Char
{-
        ,   scoKeywordsOps      ::  [String]
        ,   scoOpChars          ::  String
        ,   scoSpecPairs        ::  [String]
        ,   scoDollarIdent      ::  Bool
-}
        }

type ScanOptsMp = Map.Map ScState ScanOpts

kwTxtAsVarToo = [ "module", "import", "export", "hs", "ag" ]

shuffleScanOpts :: ScanOptsMp
shuffleScanOpts
  = Map.fromList
        [ ( ScLexMeta
          , ScanOpts
              { scoKeywordsTxt      =   Set.fromList (kwTxtAsVarToo ++ [ "_", "-", ".", "<" ])
              , scoSpecChars        =   Set.fromList "(),"
              , scoOpChars          =   Set.fromList "+-=*&^%$#@!\\|><~`;:?/_."
              }
          )
        ]

data ScState
  = ScChunk | ScLexMeta | ScSkip
  deriving (Show,Eq,Ord)

data TokPos
  = TokPos { tkpLine, tkpColumn :: Int }
  deriving (Eq,Ord)

instance Show TokPos where
  show (TokPos l c) = if l < 0 || c < 0 then "" else "(" ++ show l ++ ":" ++ show c ++ ")"

tkpStart :: TokPos
tkpStart = TokPos 1 1

tkpNone :: TokPos
tkpNone = TokPos (-1) (-1)

data TokKind
  = TKBegChunk | TKEndChunk | TKNameRef | TKNl | TkText | TkInt | TkStr | TkEOF | TkReserved
  deriving (Show,Eq,Ord)

data Tok
  = Tok { tokKind :: TokKind, tokWhite :: String, tokBlack :: String, tokPos :: TokPos, tokState :: ScState }

instance Eq Tok where
  (Tok k1 _ b1 _ _) == (Tok k2 _ b2 _ _) = k1 == k2 && (k1 /= TkReserved || b1 == b2)

instance Ord Tok where
  (Tok k1 _ b1 _ _) `compare` (Tok k2 _ b2 _ _)
    = if ck == EQ
      then if k1 == TkReserved then b1 `compare` b2 else ck
      else ck
    where ck = k1 `compare` k2

instance Show Tok where
  show t = show (tokPos t) ++ show (tokBlack t)
--  show t = show (tokPos t) ++ "/" ++ show (tokKind t) ++ "/" ++ show (tokState t) ++ " " ++ show (tokBlack t)

instance Symbol Tok

isVarStart :: Char -> Bool
isVarStart c = c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z'

isVarRest :: Char -> Bool
isVarRest c = isVarStart c || isDigit c || c `elem` "'_"

isWhite :: Char -> Bool
isWhite = (`elem` " \t")

isLF :: Char -> Bool
isLF = (`elem` "\n\r")

isBlack :: Char -> Bool
isBlack c = not (isWhite c || isLF c)

isStrQuote :: Char -> Bool
isStrQuote c = c == '"'

isStr :: Char -> Bool
isStr c = not (isStrQuote c || isLF c)

scan :: ScanOptsMp -> ScState -> String -> [Tok]
scan scoMp st s
  = takeWhile ((/=TkEOF) . tokKind) (sc tkpStart st s)
  where sc p st             ""                      = [Tok TkEOF "" "" p st]
        sc p ScChunk        s@(c:_)
          | isWhite c                               = t {tokWhite = w} : ts
                                                    where (w,s') = span isWhite s
                                                          (t:ts) = sc (a w p) ScChunk s'
        sc p ScLexMeta      s@(c:_)
          | isWhite c                               = sc (a w p) ScLexMeta s'
                                                    where (w,s') = span isWhite s
        sc p st             s@(c:s')
          | isLF c                                  = Tok TKNl       ""   [c] p st : sc (al p) st' s'
                                                    where st' = if st == ScLexMeta then ScChunk else st
        sc p st@ScLexMeta   s@(c:s')
          | isSpec st c                             = Tok TkReserved ""   [c] p st : sc (ai 1 p) st s'
        sc p st@ScLexMeta   s@(c:_)
          | isVarStart c                            = scKw isVarRest p st s
        sc p st@ScLexMeta   s@(c:_)
          | isDigit c                               = Tok TkInt      ""   w   p st : sc (a w p) st s'
                                                    where (w,s') = span isDigit s
        sc p st@ScLexMeta   s@(c:s')
          | isStrQuote c                            = Tok TkStr      ""   w   p st : sc (a w . ai 2 $ p) st s3
                                                    where (w,s2) = span isStr s'
                                                          s3 = case s2 of
                                                                 (c:s) | isStrQuote c -> s
                                                                 _                    -> s2
        sc p st@ScLexMeta   s@(c:_)
          | isOpch st c                             = scKw (isOpch st) p st s
        sc p@(TokPos _ 1) ScSkip  s@('%':'%':'[':s')= Tok TKBegChunk "" "%%[" p ScSkip  : sc (ai 3 p) ScLexMeta s'
        sc p@(TokPos _ 1) ScChunk s@('%':'%':']':s')= Tok TKEndChunk "" "%%]" p ScChunk : sc (ai 3 p) ScSkip s'
        sc p@(TokPos _ 1) ScChunk s@('%':'%':'@':s')= Tok TKNameRef  "" "%%@" p ScChunk : sc (ai 3 p) ScChunk s'
        sc p ScChunk        s@(c:_)
          | isBlack c                               = Tok TkText     ""   b   p ScChunk : sc (a b p) ScChunk s'
                                                    where (b,s') = span isBlack s
        sc p st             s@(c:s')                = sc (ai 1 p) st s'
        scKw f p st s                               = Tok tk         ""   w   p st  : sc (a w p) st s'
                                                    where (w,s') = span f s
                                                          tk = if isKeyw st w then TkReserved else TkText
        a s                                         = ai (length s)
        ai i p                                      = p {tkpColumn = i + tkpColumn p}
        al   p                                      = p {tkpLine = 1 + tkpLine p, tkpColumn = 1}
        opt st p                                    = maybe False p $ Map.lookup st scoMp
        isSpec st c                                 = opt st (\o -> c `Set.member` scoSpecChars o)
        isOpch st c                                 = opt st (\o -> c `Set.member` scoOpChars o)
        isKeyw st w                                 = opt st (\o -> w `Set.member` scoKeywordsTxt o)

pBegChunk, pEndChunk, pBegNameRef, pNl :: (IsParser p Tok) => p Tok
pBegChunk   = pSym (Tok TKBegChunk "" "%%[" tkpNone ScSkip)
pEndChunk   = pSym (Tok TKEndChunk "" "%%]" tkpNone ScSkip)
pBegNameRef = pSym (Tok TKNameRef  "" "%%@" tkpNone ScSkip)
pNl         = pSym (Tok TKNl       "" "LF"  tkpNone ScSkip)

pKey :: (IsParser p Tok) => String -> p String
pKey k = tokBlack <$> pSym (Tok TkReserved "" k tkpNone ScSkip)

pVar :: (IsParser p Tok) => p String
pVar = tokBlack <$> pSym (Tok TkText "" "<ident>" tkpNone ScSkip)

pInt :: (IsParser p Tok) => p String
pInt = tokBlack <$> pSym (Tok TkInt "" "0" tkpNone ScSkip)

pInt' :: (IsParser p Tok) => p Int
pInt' = read <$> pInt

pStr :: (IsParser p Tok) => p String
pStr = tokBlack <$> pSym (Tok TkStr "" "<string>" tkpNone ScSkip)

pBlack :: (IsParser p Tok) => p (Maybe String,String)
pBlack = (\(Tok _ w b _ _) -> (if null w then Nothing else Just w,b)) <$> pSym (Tok TkText "" "<text>" tkpNone ScSkip)
}


-------------------------------------------------------------------------
-- Parsing
-------------------------------------------------------------------------

{-
parseHandle :: (Message Char Pos -> String) -> CharParser a -> FilePath -> Handle -> IO a
parseHandle showM p fn fh
  = do { txt <- hGetContents fh
       ; parseIOMessage showM p (Input txt (initPos fn))
       }
-}

{
parseHandle :: ShPr a -> FilePath -> Handle -> IO a
parseHandle p fn fh
  = do { txt <- hGetContents fh
       ; let toks = scan shuffleScanOpts ScSkip txt
       -- ; putStrLn (unlines . map show $ toks)
       ; parseIOMessage show p toks
       }
}

-------------------------------------------------------------------------
-- New Parser
-------------------------------------------------------------------------

{
type ShPr  c = (IsParser p Tok) => p c
type ShPr2 c = (IsParser p Tok) => p c -> p c

pAGItf :: ShPr T_AGItf
pAGItf = sem_AGItf_AGItf <$> (sem_Lines_Nil <$ pList pNl) <*> pChunks
-- pAGItf = sem_AGItf_AGItf <$> pLines <*> pChunks

pVersion           :: ShPr Version
pVersion           = mkVerFromIntL <$> pList1Sep (pKey "_") pInt'

pVerOrder          :: ShPr VersionOrder
pVerOrder          =   pListSep (pKey ",") (pList1Sep (pKey "<") pVersion)

pId, pIdNest, pIdNest2, pIdNestPart :: ShPr String
pId                 =   (\h t -> concat . intersperse "." $ h : t) <$> pVar <*> pList (pKey "." *> (pVar <|> pInt))
pIdNest             =   (concat . intersperse " ") <$> pList1 pIdNestPart
pIdNest2            =   (concat . intersperse " ") <$> pList1 (pIdNestPart <|> foldl1 (<|>) (map pKey kwTxtAsVarToo))
pIdNestPart         =   pId
                    <|> (\l -> "(" ++ concat (intersperse "," l) ++ ")") <$> pParens pIdNests2
                    <|> pStr

pIdNests, pIdNests2 :: ShPr [String]
pIdNests            =   pListSep (pKey ",") pIdNest
pIdNests2           =   pListSep (pKey ",") pIdNest2

pChunkId            :: ShPr (Version,String)
pChunkId            =   (,) <$> pVersion <* pKey "." <*> pId

pParens             :: ShPr2 p
pParens p           =   pKey "(" *> p <* pKey ")"

pChunks             :: ShPr T_Chunks
pChunks             =   pFoldr (sem_Chunks_Cons,sem_Chunks_Nil) pChunk

pChunk              :: ShPr T_Chunk 
pChunk              =   pBegChunk
                         *> ((   sem_Chunk_Ver
                                 <$> pVersion
                                 <*> ((:[]) <$ pKey "." <*> pId <|> pSucceed [])
                                 <*> (pKey "-" *> ((:[]) <$> pChunkId <|> pParens (pList1 pChunkId)) <|> pSucceed [])
                                 <*> (True <$ pKey "hs" <|> pSucceed False)
                                 <*> (Just <$ pKey "module" <*> pId <|> pSucceed Nothing)
                                 <*> (pKey "import" *> pParens pIdNests2 <|> pSucceed [])
                                 <*> (pKey "export" *> pParens pIdNests2 <|> pSucceed [])
                             <|> sem_Chunk_Named
                                 <$> pId
                             )
                             <*  pNl
                             <*> pLines
                             <*  pEndChunk
                             <*> pLines
                            )
                    <?> "a chunk"

pLines              :: ShPr T_Lines
pLines              =   pFoldr (sem_Lines_Cons,sem_Lines_Nil) pLine

pLine               :: ShPr T_Line
pLine               =   sem_Line_AsIs  <$> pLineChars  <*  pNl
                    <|> sem_Line_Named <$  pBegNameRef <*> pId <* pNl
                    <?> "a line"

pLineChars          :: ShPr T_Words
pLineChars          =   (foldr sem_Words_Cons sem_Words_Nil . concat)
                        <$> pList ((\(mw,b) -> maybe [] (\w -> [sem_Word_White w]) mw ++ [sem_Word_Black b]) <$> pBlack)
}

-------------------------------------------------------------------------
-- Parser
-------------------------------------------------------------------------

{
parseAndGetRes :: ShPr a -> String -> a
parseAndGetRes p s
  = case evalSteps (parse p toks) of {Pair v _ -> v}
  where toks = scan shuffleScanOpts ScLexMeta s
}

-------------------------------------------------------------------------
-- Options
-------------------------------------------------------------------------

{
data Opts 
  = Opts
      { optAG           :: Bool
      , optHS           :: Bool
      , optPlain        :: Bool
      , optLaTeX        :: Bool
      , optPrefix       :: Bool
      , optIndex        :: Bool
      , optHelp         :: Bool
      , optGenVersion   :: Version
      , optBaseName     :: Maybe String
      , optWrapLhs2tex  :: Bool
      , optMbXRefExcept :: Maybe String
      , optVerOrder     :: VersionOrder
      }

defaultOpts
  = Opts
      { optAG           =  False
      , optHS           =  False
      , optLaTeX        =  False
      , optPrefix       =  True
      , optPlain        =  False
      , optIndex        =  False
      , optHelp         =  False
      , optGenVersion   =  VNone
      , optBaseName     =  Nothing
      , optWrapLhs2tex  =  True
      , optMbXRefExcept =  Nothing
      , optVerOrder     =  [[]]
      }

optsHasNoVerOrder :: Opts -> Bool
optsHasNoVerOrder = null . head . optVerOrder

cmdLineOpts  
  =  [  Option "a"  ["ag"]        (NoArg oAG)
          "generate code for ag, default=no"
     ,  Option "h"  ["hs"]        (NoArg oHS)
          "generate code for haskell, default=no"
     ,  Option "l"  ["latex"]     (NoArg oLaTeX)
          "generate code for latex, default=no"
     ,  Option ""   ["prefix"]    (OptArg oPrefix "yes|no")
          "include prefix (marked by version=0), default=yes"
     ,  Option "p"  ["plain"]     (NoArg oPlain)
          "generate plain code, default=no"
     ,  Option ""   ["index"]     (NoArg oIndex)
          "combined with latex, generate index entries, default=no"
     ,  Option "g"  ["gen"]       (ReqArg oGen "all|<nr>")
          "generate for version, default=none"
     ,  Option ""   ["order"]     (ReqArg oVerOrder "<order-spec>")
          "version order"
     ,  Option "b"  ["base"]      (ReqArg oBase "<name>")
          "base name, default=derived from filename"
     ,  Option ""   ["xref-except"]      (ReqArg oXRefExcept "<filename>")
          "file with list of strings not to be cross ref'd"
     ,  Option ""   ["help"]      (NoArg oHelp)
          "output this help"
     ,  Option ""   ["lhs2tex"]   (OptArg oLhs2tex "yes|no")
          "wrap chunks in lhs2tex's code environment, default=yes"
     ]
  where  oAG             o =  o {optAG = True}
         oHS             o =  o {optHS = True}
         oPrefix     ms  o =  yesno (\f o -> o {optPrefix = f}) ms o
         oLaTeX          o =  o {optLaTeX = True}
         oPlain          o =  o {optPlain = True}
         oIndex          o =  o {optIndex = True}
         oLhs2tex    ms  o =  yesno (\f o -> o {optWrapLhs2tex = f}) ms o
         oBase        s  o =  o {optBaseName = Just s}
         oVerOrder    s  o =  o {optVerOrder = parseAndGetRes pVerOrder s}
         oXRefExcept  s  o =  o {optMbXRefExcept = Just s}
         oGen         s  o =  case s of
                                "all"               -> o {optGenVersion = VAll}
                                (c:_) | isDigit c   -> o {optGenVersion = parseAndGetRes pVersion s}
                                _                   -> o {optGenVersion = VAll}
         oHelp           o =  o {optHelp = True}
         yesno updO  ms  o =  case ms of
                                Just "yes"  -> updO True o
                                Just "no"   -> updO False o
                                _           -> o


}

-------------------------------------------------------------------------
-- Common. Version
-------------------------------------------------------------------------

{
type StringL    = [String]

data Version    = VAll
                | VPre
                | VNone
                | VRef {verRef :: Int}
                | VNest {verNest :: Version, verRef :: Int}
                deriving (Show,Eq,Ord)

type VersionOrder = [[Version]]

mkVerFromInt :: Int -> Version
mkVerFromInt r = if r == 0 then VPre else VRef r

mkVerFromIntL :: [Int] -> Version
mkVerFromIntL (0:_)  = mkVerFromInt 0
mkVerFromIntL (i:is) = foldl VNest (VRef i) is

instance CD Version where
  cd VPre           = cd "pre"
  cd VAll           = cd "*"
  cd VNone          = cd "-"
  cd (VRef r)       = cd r
  cd (VNest n r)    = cd n .|. "." .|. cd r

verMatch :: Version -> Version -> Bool
verMatch VAll           _               = True
verMatch _              VAll            = True
verMatch (VRef r1)      (VRef r2)       = r1 == r2
verMatch (VNest n1 r1)  (VNest n2 r2)   = r1 == r2 && n1 == n2
verMatch VPre           VPre            = True
verMatch _              _               = False

cmpByVersionOrder :: VersionOrder -> Version -> Version -> Ordering
cmpByVersionOrder vo v1 v2
  = maybe EQ id . listToMaybe . catMaybes . map c $ vo
  where  c o = do { i1 <- elemIndex v1 o
                  ; i2 <- elemIndex v2 o
                  ; return (compare i1 i2)
                  }

voAllLE :: VersionOrder -> Version -> [Version]
voAllLE vo v
  = sortBy (cmpByVersionOrder vo)
  . nub . sort . concat
  . (case v of
      VAll -> id
      _    -> map (\o -> maybe [] (\i -> take (i+1) o) (elemIndex v o))
    )
  $ vo

voAllLE' :: VersionOrder -> Version -> [Version]
voAllLE' vo v
  = let voPrefixes
          = map (\p@((v,_):_) -> (v,map snd p))
          . groupBy (\(v1,_) (v2,_) -> v1 == v2)
          . sortBy (\(v1,_) (v2,_) -> compare v1 v2)
          . concat . map (\o -> zip o (inits o))
          $ vo
        all
          = case v of
              VAll -> concat vo
              _    -> maybe [] concat (lookup v voPrefixes)
     in sortBy (cmpByVersionOrder vo) . nub . sort $ all

voAllLE'' :: VersionOrder -> Version -> [Version]
voAllLE'' vo v
  = let allN = nub . sort . concat $ vo
        nrN = length allN
        nsN = [(0::Int)..nrN-1]
        ixOf' v = elemIndex v allN
        ixOf v = maybe 0 id (ixOf' v)
        voPrefixes
          = map (\p@((v,_):_) -> (ixOf v,map ixOf . nub . sort . (v:) . concat . map snd $ p))
          . groupBy (\(v1,_) (v2,_) -> v1 == v2)
          . sortBy (\(v1,_) (v2,_) -> compare v1 v2)
          . concat . map (\o -> zip o (inits o))
          $ vo
        m1 = map
                (\(n,ns)
                    -> map snd . sort $ (zip (ns) (repeat True) ++ zip (nsN \\ ns) (repeat False))
                )
                voPrefixes
        m2 = array (0,nrN-1) (zip nsN (map (\r -> array (0,nrN-1) (zip nsN r)) m1))
        m3 = foldr
                (\n m
                    -> foldr
                        (\i m -> m // [(i,m ! i // [ (j,m ! i ! n && m ! n ! j || m ! i ! j) | j <- nsN ])])
                        m nsN
                )
                m2 nsN
        nsV = maybe [] (\i -> assocs (m3 ! i)) (ixOf' v)
        allN' = case v of
                  VAll -> allN
                  _    -> [ allN !! i | (i,b) <- nsV, b ]
     in sortBy (cmpByVersionOrder vo) . nub . sort $ allN'

voDefault :: VersionOrder
voDefault = [take 30 (map VRef [1..])]

}

-------------------------------------------------------------------------
-- Chunk doc
-------------------------------------------------------------------------

{
data CDoc
  = CDEmp
  | CDStr String
  | CDHor CDoc CDoc
  | CDVer CDoc CDoc

cdHor :: CD a => [a] -> CDoc
cdHor = foldr CDHor CDEmp . map cd

cdVer :: CD a => [a] -> CDoc
cdVer = foldr CDVer CDEmp . map cd

cdLines :: CDoc -> [String]
cdLines d
  = lns d
  where ln l CDEmp = (l,CDEmp)
        ln l (CDStr s) = (s:l,CDEmp)
        ln l (CDHor d1 d2)
          = case ln l d1 of
              (l1,CDEmp) -> ln l1 d2
              r          -> r
        ln l (CDVer d1 d2)
          = case ln l d1 of
              (l1,CDEmp) -> (l1,d2)
              (l1,dr)    -> (l1,CDVer dr d2)
        lns CDEmp = []
        lns d = let (l,d') = ln [] d in concat (reverse l) : lns d'

cdPut' :: Handle -> CDoc -> IO ()
cdPut' h = mapM_ (hPutStrLn h) . cdLines

cdPut :: Handle -> CDoc -> IO ()
cdPut h d
  = case d of
      CDEmp       -> return ()
      CDStr s     -> hPutStr h s
      CDHor d1 d2 -> do cdPut h d1
                        cdPut h d2
      CDVer d1 d2 -> do cdPut h d1
                        hPutStrLn h ""
                        cdPut h d2

class CD a where
  cd :: a -> CDoc

instance CD String where
  cd = CDStr

instance CD Int where
  cd = CDStr . show

instance CD CDoc where
  cd = id

infixr 2 .-.
infixr 3 .|. , .#.

(.|.) :: (CD a, CD b) => a -> b -> CDoc
(.|.) a b = cd a `CDHor` cd b

(.-.) :: (CD a, CD b) => a -> b -> CDoc
(.-.) a b = cd a `CDVer` cd b

(.#.) :: (CD a, CD b) => a -> b -> CDoc
(.#.) a b = cd a .|. " " .|. cd b

cdListSep' :: (CD s, CD c, CD o, CD a) => (forall x . CD x => [x] -> CDoc) -> (forall x y . (CD x, CD y) => x -> y -> CDoc) -> o -> c -> s -> [a] -> CDoc
cdListSep' list aside o c s pps
  = l pps
  where l []      = o `aside` c
        l [p]     = o `aside` p `aside` c
        l (p:ps)  = list ([o `aside` p] ++ map (s `aside`) (init ps) ++ [s `aside` last ps `aside` c])

cdListSep :: (CD s, CD c, CD o, CD a) => o -> c -> s -> [a] -> CDoc
cdListSep = cdListSep' cdHor (.|.)

cdListSepV :: (CD s, CD c, CD o, CD a) => o -> c -> s -> [a] -> CDoc
cdListSepV = cdListSep' cdVer (.|.)

cdDots :: CD a => [a] -> CDoc
cdDots = cdListSep "" "" "."

}

-------------------------------------------------------------------------
-- Utils
-------------------------------------------------------------------------

{
mkTexCmdDef :: (CD a, CD b) => String -> a -> b -> CDoc
mkTexCmdDef cmd nm def = "\\" .|. cmd .|. "{" .|. cd nm .|. "}{%" .-. cd def .-. "}"

mkTexCmdUse :: CD a => String -> a -> CDoc
mkTexCmdUse cmd nm = "\\" .|. cmd .|. "{" .|. cd nm .|. "}"

mkTexCmdUse' :: CD a => String -> a -> CDoc
mkTexCmdUse' cmd nm = mkTexCmdUse cmd nm .|. "%"
}

-------------------------------------------------------------------------
-- Inferfacing
-------------------------------------------------------------------------

WRAPPER AGItf

ATTR AGItf [ opts: {Opts}  fpath: FPath | | ]

-------------------------------------------------------------------------
-- AST
-------------------------------------------------------------------------

{
type ChunkId = (Version,String)
type MbChunkId = Maybe ChunkId
type ChunkIdL = [ChunkId]
}

DATA AGItf
  | AGItf               dumLines    : Lines
                        chunks      : Chunks

DATA Chunk
  | Ver                 version     : {Version}
                        aliasNmL    : {StringL}
                        minusL      : ChunkIdL
                        isHS        : {Bool}
                        mbModNm     : {Maybe String}
                        imports     : {StringL}
                        exports     : {StringL}
                        lines       : Lines
                        dumLines    : Lines
  | Named               nm          : {String}
                        lines       : Lines
                        dumLines    : Lines

TYPE Chunks     = [Chunk]

SET AllChunk    = Chunk Chunks

DATA Line
  | AsIs                words       : Words
  | Named               nm          : {String}

TYPE Lines      = [Line]

SET AllLine     = Line Lines

DATA Word
  | White               chars       : {String}
  | Black               chars       : {String}

TYPE Words      = [Word]

SET AllWord     = Word Words

SET AllNT       = AllWord AllLine AllChunk

-------------------------------------------------------------------------
-- Sequence nr (for ordering when printing)
-------------------------------------------------------------------------

ATTR AllChunk [ seqNr: Int | | ]

SEM AGItf
  | AGItf       chunks      . seqNr     = 1

SEM Chunks
  | Cons        tl          . seqNr     = @lhs.seqNr + 1

-------------------------------------------------------------------------
-- Line counting, column counting
-------------------------------------------------------------------------

ATTR AllChunk AllLine [ | lineNr: Int | ]
ATTR AllWord [ | colNr: Int | ]

SEM AGItf
  | AGItf       dumLines    . lineNr    = 1

SEM Lines
  | Cons        tl          . lineNr    = @lhs.lineNr + 1

SEM Chunk
  | Ver Named   loc         . chunkLineNr
                                        = @lhs.lineNr + 1
                lines       . lineNr    = @chunkLineNr
                dumLines    . lineNr    = @lines.lineNr + 1

SEM Line
  | AsIs        words       . colNr     = 0

SEM Word
  | White Black loc         . wordColNr = @lhs.colNr
                lhs         . colNr     = @lhs.colNr + length @chars

-------------------------------------------------------------------------
-- Left + right context
-------------------------------------------------------------------------

ATTR Words [ lCtxt: StringL  lAllCtxt: StringL | | rCtxt: StringL ]
ATTR Word [ | lCtxt: StringL  lAllCtxt: StringL  rCtxt: StringL | ]

SEM Line
  | AsIs        words       . lCtxt     = []
                            . lAllCtxt  = []

SEM Words
  | Nil         lhs         . rCtxt     = []
  | Cons        hd          . rCtxt     = @tl.rCtxt
                lhs         . rCtxt     = @hd.rCtxt

SEM Word
  | Black       lhs         . rCtxt     = @chars : @lhs.rCtxt
                            . lCtxt     = @chars : @lhs.lCtxt
                            . lAllCtxt  = @chars : @lhs.lAllCtxt
  | White       lhs         . lAllCtxt  = @chars : @lhs.lAllCtxt

-------------------------------------------------------------------------
-- Cross ref
-------------------------------------------------------------------------

{
data XRefKind = XRHsDef | XRAgAttrDef | XRAgAltDef | XRAgSemDef | XRHsUse | XRAgAttrUse deriving Show
data XRef = XRef { xrKind :: XRefKind, xrKeyL :: StringL } deriving Show

xrMainKey :: XRef -> String
xrMainKey = head . xrKeyL

xrKindIsDefining :: XRefKind -> Bool
xrKindIsDefining XRHsDef = True
xrKindIsDefining XRAgAttrDef = True
xrKindIsDefining XRAgAltDef = True
xrKindIsDefining XRAgSemDef = True
xrKindIsDefining _ = False

xrIsDefining :: XRef -> Bool
xrIsDefining = xrKindIsDefining . xrKind

type XRefL = Seq.Seq XRef
type XRefExcept = Set.Set String

passXR :: XRefExcept -> String -> ([XRef],Int) -> ([XRef],Int)
passXR exc r xr = if Set.member r exc then ([],0) else xr
}

ATTR AGItf AllNT [ xrefExcept: XRefExcept | | ]
ATTR AllWord AllLine [ | | xrefL USE {`Seq.append`} {Seq.empty} : XRefL ]
ATTR Word [ | rCtxtUsed: Int | ]
ATTR Words [ rCtxtUsed: Int | | ]

SEM Word
  | Black       (loc.xrefL,lhs.rCtxtUsed)
                                        = let ctxtHuge = 10000000
                                              loclhs = ["lhs","loc"]
                                              none = ([],@lhs.rCtxtUsed - 1)
                                              def nms k cUsed
                                                   = if any (flip Set.member @lhs.xrefExcept) nms then ([],0) else ([XRef k nms],cUsed)
                                           in if @lhs.rCtxtUsed <= 0 && isAlpha (head @chars)
                                              then case (@lhs.lAllCtxt,@lhs.lCtxt,@chars,@lhs.rCtxt) of
                                                     (_,("@":_),nm1,(".":nm2:_))
                                                       | nm1 `elem` loclhs          -> def [nm2] XRAgAttrUse 2
                                                     (_,("@":_),nm1,(".":nm2:_))    -> def [nm2,nm1] XRAgAttrUse 2
                                                     (_,("@":_),nm1,_)              -> def [nm1] XRAgAttrUse 0
                                                     (_,("|":_),nm1,_)              -> def [nm1] XRAgAltDef 0
                                                     (_,(".":ll:_),nm1,("=":_))
                                                       | ll `elem` loclhs           -> def [nm1] XRAgAttrDef 1
                                                     (_,(".":nm2:_),nm1,("=":_))    -> def [nm1,nm2] XRAgAttrDef 1
                                                     (_,_,nm1,([sep]:nm2:_))
                                                       | sep `elem` "._"            -> def [nm2,nm1] XRHsUse 2
                                                       | otherwise                  -> none
                                                     (_,["SEM"],nm1,_)              -> def [nm1] XRAgSemDef ctxtHuge
                                                     (_,["data"],nm1,_)             -> def [nm1] XRHsDef 0
                                                     (_,["type"],nm1,_)             -> def [nm1] XRHsDef 0
                                                     ([],_,nm1,_)                   -> def [nm1] XRHsDef ctxtHuge
                                                     (_,_,nm1,_)
                                                       | nm1 `notElem` loclhs       -> def [nm1] XRHsUse 0
                                                     _                              -> none
                                              else none
                lhs         . xrefL     = Seq.fromList @xrefL
  | White       lhs         . rCtxtUsed = 0

SEM Line
  | AsIs        words       . rCtxtUsed = 0

-------------------------------------------------------------------------
-- Named chunks
-------------------------------------------------------------------------

{
data NamedChunkInfo
  = NamedChunkInfo
      { nciNm       :: String
      -- , nciMbPP     :: Maybe PP_Doc
      , nciMbCD     :: Maybe CDoc
      }

type NamedChunkInfoMp = Map.Map String NamedChunkInfo
}

ATTR AllChunk AGItf [ | | nmChInfoMp USE {`Map.union`} {Map.empty}: NamedChunkInfoMp ]
ATTR AllChunk AllLine AGItf [ allNmChInfoMp: NamedChunkInfoMp | | ]

SEM Chunk
  | Named       loc         . chInfo    = NamedChunkInfo @nm @lines.mbCD
                lhs         . nmChInfoMp= Map.singleton @nm @chInfo

SEM AGItf
  | AGItf       chunks      . allNmChInfoMp
                                        = @chunks.nmChInfoMp `Map.union` @lhs.allNmChInfoMp
                dumLines    . allNmChInfoMp
                                        = Map.empty

-------------------------------------------------------------------------
-- Content replica, CDoc
-------------------------------------------------------------------------

ATTR AllLine [ | | mbCD : {Maybe CDoc} ]

SEM Line
  | AsIs        lhs         . mbCD      = Just (if null @words.charsL then CDStr "" else cdHor @words.charsL)
  | Named       lhs         . mbCD      = maybe (Just ("<<" .|. @nm .|. ">>")) nciMbCD (Map.lookup @nm @lhs.allNmChInfoMp)

SEM Lines
  | Nil         lhs         . mbCD      = Nothing
  | Cons        lhs         . mbCD      = maybe (@hd.mbCD) (Just . (maybe CDEmp id @hd.mbCD `CDVer`)) @tl.mbCD

-------------------------------------------------------------------------
-- Content replica, String part
-------------------------------------------------------------------------

ATTR Word [ | | chars: String ]
ATTR Words [ | | charsL: {[String]} ]

SEM Word
  | White       lhs         . chars     = @chars
  | Black       lhs         . chars     = {- show @xrefL ++ -} @chars

SEM Words
  | Nil         lhs         . charsL    = []
  | Cons        lhs         . charsL    = @hd.chars : @tl.charsL

-------------------------------------------------------------------------
-- Content replica, PP_Doc
-------------------------------------------------------------------------

{-
ATTR AllLine [ | | mbPP : {Maybe PP_Doc} ]

SEM Line
  | AsIs        lhs         . mbPP      = Just (if null @words.charsL then text "" else hlist @words.charsL)
  | Named       lhs         . mbPP      = maybe (Just ("<<" >|< @nm >|< ">>")) nciMbPP (Map.lookup @nm @lhs.allNmChInfoMp)

SEM Lines
  | Nil         lhs         . mbPP      = Nothing
  | Cons        lhs         . mbPP      = maybe (@hd.mbPP) (Just . (maybe empty id @hd.mbPP >-<)) @tl.mbPP
-}

-------------------------------------------------------------------------
-- Chunks
-------------------------------------------------------------------------

{
data VerChunkInfo
  = VerChunkInfo
      { vciLineNr   :: Int
      , vciSeqNr    :: Int
      , vciVer      :: Version
      , vciAliasL   :: StringL
      , vciMinusL   :: ChunkIdL
      , vciIsHS     :: Bool
      , vciMbModNm  :: Maybe String
      , vciImps     :: StringL
      , vciExps     :: StringL
      -- , vciMbPP     :: Maybe PP_Doc
      , vciMbCD     :: Maybe CDoc
      , vciXRefL    :: [XRef]
      }
type VerChunkInfoL = [VerChunkInfo]
type VerChunkInfoM = [(Version,VerChunkInfoL)]

vciMToL :: VerChunkInfoM -> VerChunkInfoL
vciMToL = concat . map snd

instance Eq VerChunkInfo where
  i1 == i2 = vciVer i1 == vciVer i2

instance Ord VerChunkInfo where
  compare i1 i2 = vciVer i1 `compare` vciVer i2

vciSortBySeqNr :: VerChunkInfoL -> VerChunkInfoL
vciSortBySeqNr = sortBy (\v1 v2 -> vciSeqNr v1 `compare` vciSeqNr v2)

vciVerFilter :: (Version -> Bool) -> VerChunkInfoL -> VerChunkInfoL
vciVerFilter f = filter (f . vciVer)

vciVerGroup :: VerChunkInfoL -> [VerChunkInfoL]
vciVerGroup = groupBy (\i1 i2 -> vciVer i1 == vciVer i2)

vciHasImpExp :: VerChunkInfo -> Bool
vciHasImpExp i = not (null (vciImps i) && null (vciExps i))

vciIsPre :: VerChunkInfo -> Bool
vciIsPre = (==VPre) . vciVer

{-
vciPP :: VerChunkInfo -> PP_Doc
vciPP = maybe empty id . vciMbPP
-}

vciCD :: VerChunkInfo -> CDoc
vciCD = maybe CDEmp id . vciMbCD

{-
vciHasPP :: VerChunkInfo -> Bool
vciHasPP = isJust . vciMbPP
-}

vciHasCD :: VerChunkInfo -> Bool
vciHasCD = isJust . vciMbCD

vciSplitPre :: VerChunkInfoL -> (VerChunkInfoL,VerChunkInfoL)
vciSplitPre = partition vciIsPre

vciTakePre :: VerChunkInfoM -> (VerChunkInfoL,VerChunkInfoM)
vciTakePre is
  = case is of
        ((VPre,p):r) -> (p,r)
        _            -> ([],is)


selectChunks' :: Bool -> Version -> VerChunkInfoL -> VerChunkInfoM
selectChunks' appMinus v agl
  = let s v agl
          = case v of
              VRef r -> let agl' = sort . vciVerFilter (<= v) $ agl
                            m = if appMinus then [ m | ml <- map vciMinusL agl', m <- ml ] else []
                         in [(v,sort . filter (\i -> (vciVer i,if null (vciAliasL i) then "" else head (vciAliasL i)) `notElem` m) $ agl')]
              VAll   -> let vs = nubBy verMatch . filter (/= VPre) . sort . map vciVer $ agl
                         in concat . map (\v -> s v agl) $ vs
              _      -> []
     in s v agl

selectChunks :: Bool -> Opts -> VerChunkInfoL -> [(Version,VerChunkInfoL)]
selectChunks appMinus opts agl
  = let (pre,nonPre)    = vciSplitPre agl
        availVersions   = nub . sort . map vciVer $ nonPre
        v               = optGenVersion opts
        vo              = optVerOrder opts
        allowedVersions = voAllLE'' (if optsHasNoVerOrder opts then voDefault else vo) v
        vAndVciL        = map (\v -> (v,vciSortBySeqNr . vciVerFilter (==v) $ nonPre)) allowedVersions
        isNotMinused
          = let minuses = if appMinus then [ m | (_,vciL) <- vAndVciL, ml <- map vciMinusL vciL, m <- ml ] else []
             in \i -> (vciVer i,if null (vciAliasL i) then "" else head (vciAliasL i)) `notElem` minuses
     in filter
          ( not.null.snd )
          ( (VPre,pre)
          : map (\(v,vciL) -> (v,filter isNotMinused vciL)) vAndVciL
          )

data Build = Build { bldBase :: String, bldVer :: Version, bldCD :: CDoc }
type BuildL = [Build]
}

ATTR AllChunk [ | | verChInfoL USE {++} {[]} : VerChunkInfoL ]

SEM Chunk
  | Ver         loc         . chInfo    = VerChunkInfo
                                            @chunkLineNr @lhs.seqNr
                                            @version @aliasNmL @minusL
                                            @isHS @mbModNm @imports @exports
                                            @lines.mbCD (Seq.toList @lines.xrefL)
                lhs         . verChInfoL= [@chInfo]

SEM AGItf
  | AGItf       loc         . selChunks = selectChunks True @lhs.opts @chunks.verChInfoL
                            . selLaTeXChunks
                                        = selectChunks False (@lhs.opts {optGenVersion=VAll}) @chunks.verChInfoL
                            . wrapLhs2tex
                                        = if optWrapLhs2tex @lhs.opts
                                          then (\doWr p -> if doWr then "\\begin{code}" .-. p .-. "\\end{code}" else p)
                                          else flip const
                            . build     = \bld chunks
                                               -> let fileBase = fromJust (optBaseName @lhs.opts)
                                                      v = optGenVersion @lhs.opts
                                                      builds = [Build fileBase v (bld @lhs.opts @wrapLhs2tex @lhs.fpath fileBase chunks)]
                                                   in builds

-------------------------------------------------------------------------
-- Gen AG
-------------------------------------------------------------------------

{
buildAGImps :: VerChunkInfo -> CDoc
buildAGImps = cdVer . map (\imp -> "INCLUDE \"" .|. imp .|. ".ag\"") . vciImps

buildAG :: Opts -> (Bool -> CDoc -> CDoc) -> FPath -> String -> VerChunkInfoM -> CDoc
buildAG opts wrap fpath fileBase is
  = let (pre,noPre) = vciTakePre is
        noPre' = vciMToL noPre
        h p  = "{" .-. p .-. "}"
        mk i = if vciIsHS i
               then h (vciCD i)
               else buildAGImps i .-. vciCD i
        ish  = filter vciIsHS noPre'
        pph  = if any vciHasImpExp ish
               then wrap True (h (buildHSModImpExp fileBase ish))
               else CDEmp
     in (if optPrefix opts then cdVer (map (wrap False . vciCD) pre) else CDEmp)
        .-. pph
        .-. (cdVer . map (\i -> wrap (not (vciIsPre i)) (mk i)) . vciSortBySeqNr $ noPre')
}

ATTR AGItf [ | | bldAG: BuildL ]

SEM AGItf
  | AGItf       lhs         . bldAG     = @build buildAG @selChunks

-------------------------------------------------------------------------
-- Gen LaTeX
-------------------------------------------------------------------------

{
mkCmdNmDef :: CDoc -> CDoc -> CDoc
mkCmdNmDef = mkTexCmdDef "chunkCmdDef"

mkCmdNmUse :: CDoc -> CDoc
mkCmdNmUse = mkTexCmdUse' "chunkCmdUse"

mkCmdInx :: CDoc -> CDoc
mkCmdInx = mkTexCmdUse' "chunkIndex"

mkLabel :: CDoc -> CDoc
mkLabel = mkTexCmdUse' "label"

mkMetaInfo :: CDoc -> String -> CDoc
mkMetaInfo lab fileBase = mkLabel lab -- .-. mkTexCmdDef "chunkMetaDef" lab (cd fileBase)

buildLaTeX :: Opts -> (Bool -> CDoc -> CDoc) -> FPath -> String -> VerChunkInfoM -> CDoc
buildLaTeX opts wrap fpath fileBase is
  = let (pre,noPre) = vciTakePre is
        noPre' = vciMToL noPre
        versions = nub . map (verRef.vciVer) $ noPre'
        missing = if null versions then []
                                   else [minimum versions .. maximum versions] \\ versions
        mkInx
          = let styleFmt = if optWrapLhs2tex opts then "||" else "|"
             in \ix
                 -> let n = foldr1 (\x y -> y ++ "!" ++ x) . xrKeyL $ ix
                        dfmt = CDEmp -- if xrIsDefining ix then text (styleFmt ++ "emph") else CDEmp
                     in mkCmdInx (n .|. dfmt)
        mkContent = let mk = wrap True . vciCD
                     in if optIndex opts
                        then \i -> cdVer (map mkInx (vciXRefL i)) .-. mk i
                        else mk
        ppNoPre 
          = cdVer
            . map (\is -> let nml = [cd fileBase,cd (vciVer (head is))]
                              nm = cdDots nml
                              (nms,pps)
                                  = unzip
                                    . map (\(nr,i) -> let nm = cdDots (nml ++ [cd nr])
                                                       in ( nm
                                                          , mkCmdNmDef nm (mkMetaInfo nm fileBase .-. mkContent i)
                                                            .-. cdVer (map (\n -> let na = cdDots (nml ++ [cd n])
                                                                                   in mkCmdNmDef na (mkMetaInfo na fileBase .-. mkCmdNmUse nm))
                                                                           (vciAliasL i))
                                                          )
                                          )
                                    . zip [(0::Int)..]
                                    $ is
                           in cdVer pps .-. mkCmdNmDef nm (mkMetaInfo nm fileBase .-. cdVer (map mkCmdNmUse nms))
                  )
            . vciVerGroup
            $ noPre'
     in (if optPrefix opts then cdVer (map (wrap False . vciCD) pre) else CDEmp)
        .-. ppNoPre
        .-. cdVer (map (\v -> mkCmdNmDef (cdDots [cd fileBase,cd v]) CDEmp) missing)
}

ATTR AGItf [ | | bldLaTeX: BuildL ]

SEM AGItf
  | AGItf       lhs         . bldLaTeX  = @build buildLaTeX @selLaTeXChunks

-------------------------------------------------------------------------
-- Gen Haskell
-------------------------------------------------------------------------

{
mkModNm :: [CDoc] -> CDoc
mkModNm = cdHor

buildHSImps :: VerChunkInfoL -> CDoc
buildHSImps = cdVer . map (cdVer . map ("import" .#.) . vciImps)

buildHSModuleHead :: String -> VerChunkInfoL -> CDoc
buildHSModuleHead fileBase is
  = let ise = [ i | i <- is, not (null (vciExps i) && null (vciImps i))]
        e = filter (not.null) . map vciExps $ ise
        m = catMaybes . map vciMbModNm $ ise
        exps = if null e then CDEmp
                         else cdListSepV "( " " )" ", " . map (cdListSep "" "" ", ") $ e
        modNm = if null m then fileBase else head m
     in "module" .#. modNm .-. {- indent 2 -} (exps .-. "where")

buildHSModImpExp :: String -> VerChunkInfoL -> CDoc
buildHSModImpExp fileBase is = buildHSModuleHead fileBase is .-. buildHSImps is

buildHS :: Opts -> (Bool -> CDoc -> CDoc) -> FPath -> String -> VerChunkInfoM -> CDoc
buildHS opts wrap fpath fileBase is
  = let (pre,noPre) = vciTakePre is
        noPre' = vciMToL noPre
        ppMod = buildHSModImpExp fileBase (vciMToL is)
        -- ppLineNr i = "{-# LINE" .#. vciLineNr i .#. "\"" .|. fpathToStr fpath .|. "\" #-}"
        ppNoPre
          = cdVer
            . map   (\is@(i:_)
                        -> let pb = cdVer (map (\i -> wrap (vciHasCD i) ({- ppLineNr i .-. -} vciCD i)) is)
                            in pb
                    )
            . vciVerGroup . vciSortBySeqNr
            $ noPre'
        isEmpty = all (isNothing.vciMbCD) noPre'
     in if isEmpty
        then CDEmp
        else if optPlain opts
        then ppNoPre
        else (if optPrefix opts then cdVer (map (wrap False . vciCD) pre) else CDEmp)
             .-. wrap True ppMod
             .-. ppNoPre
}

ATTR AGItf [ | | bldHS: BuildL ]

SEM AGItf
  | AGItf       lhs         . bldHS     = @build buildHS @selChunks

