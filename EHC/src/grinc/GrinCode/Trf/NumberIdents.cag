Rename all identifiers to unique numbers. exceptions are the FFI names (and
primitives) as well as the eval and apply function names (which do not exist anymore).

To rename efficient we can use the fact that the scope of a variable is local
to a binding, but it's easier not to.

Note: after each binding we skip one number (binding needs two number in the HPTA)


%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[8 import({GrinCode/AbsSyn})
%%]

%%[8 hs import({%{GRIN}Config})
%%]

%%[8.wrapper
WRAPPER GrAGItf
%%]

%%[8 hs module {%{GRIN}GrinCode.Trf.NumberIdents} import({%{GRIN}GRINCCommon}, {%{EH}Base.Common}, {%{EH}Base.Builtin}, {%{EH}GrinCode}, Data.Array.IArray, qualified Data.Map as Map, Data.Maybe) export(numberIdents)

numberIdents :: (GrModule,Int,HptMap) -> (GrModule,Int,HptMap)
numberIdents (code,unique,hptMap)
  = let inh = Inh_GrAGItf {unique_Inh_GrAGItf=unique}
        syn = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf code)) inh
    in  (grTrf_Syn_GrAGItf syn, unique_Syn_GrAGItf syn, hptMap)


%%]

%%[8.lookup hs
type LookupList = Map.Map HsName HsName

findNewVar fm e = Map.findWithDefault (error $ "undeclared variable " ++ show e) e fm


addMaybe :: Int -> LookupList -> Maybe HsName -> (LookupList, Int)
addMaybe u fm = maybe (fm, u) addName
    where
    addName e | e == wildcardNm  = (fm                                , u  )
              | otherwise        = (Map.insert e (HNmNr u (Just e)) fm, u+1)

addList :: Int -> LookupList -> [HsName] -> (LookupList, [HsName], Int)
addList u fm = onFst (flip listInsert fm) . foldr addName ([], [], u)
    where
    onFst f (a, b, c)                       = (f a          , b             , c  )
    addName e (l, l2, u) | e == wildcardNm  = (l            , wildcardNr:l2 , u  )
                         | otherwise        = let newname = HNmNr u (Just e)
                                              in ((e,newname):l, (newname:l2), u+1)
%%]

%%[8.grTrf
ATTR GrAGItf [ | | grTrf: GrModule ]
ATTR AllNT [ | | grTrf: SELF     ]
%%]

%%[8.unique
ATTR GrAGItf          [ | unique: Int | ]
ATTR AllNT          [ | unique: Int | ]

SEM GrAGItf
  | AGItf  loc     .  low         = @lhs.unique
                   .  high        = @module.unique
%%]


%%[8.maps
ATTR AllNT          [ bind2id: LookupList  | var2id: LookupList | ]
ATTR GrModule AllBind [ | bind2idFrag: LookupList | ]

SEM GrAGItf
  | AGItf  module  .  bind2idFrag  = Map.empty
                   .  var2id       = Map.empty
           loc     .  bind2id      = @module.bind2idFrag

%%]

retrieving names and their mapping

%%[8.addMbFM hs
addMbToMap fm mbk mbv = maybe fm id mbMap
    where
    mbMap = do
        k <- mbk
        v <- mbv
        return $ Map.insert k v fm
%%]

%%[8.bindings
SEM GrBind
  | Bind  loc  .  (bindName, unique')  =  if @nm == applyNm
                                          then (applyNr              , @lhs.unique  )
                                          else if @nm == evalNm
                                          then (evalNr               , @lhs.unique  )
                                          else if @nm == hsnMain
                                          then (mainNr               , @lhs.unique  )
                                          else (HNmNr @lhs.unique (Just (hsnPrefix "fun_" @nm)), @lhs.unique+2)
               .  bind2idFrag          = if isSpecialBind @nm
                                         then @lhs.bind2idFrag
                                         else Map.insert @nm @bindName @lhs.bind2idFrag
%%]

%%[8.TagName
SEM GrTag [ | | varName: {Maybe HsName} ]
  | Var       lhs  .  varName  =  Just @nm
  | * - Var   lhs  .  varName  =  Nothing
%%]

%%[8.GetDefinedNames

SEM GrGlobal
  | Global    loc   .  newName  = HNmNr @lhs.unique (Just (hsnPrefix rtsGlobalVarPrefix @nm))
              lhs   .  var2id   = Map.insert @nm @newName @lhs.var2id
                    .  unique   = @lhs.unique + 1

SEM GrPat
  | Node       loc  .  (var2id', newNames, unique') = addList @lhs.unique @lhs.var2id @fldL
  | Tag        loc  .  var2id'  = @lhs.var2id
                    .  unique'  = @unique'
  | Var        lhs  .  var2id   = Map.insert @nm @newName @lhs.var2id
                    .  unique   = @lhs.unique + 1
               loc  .  newName  = HNmNr @lhs.unique (Just @nm)
  | Node Tag   loc  .  (var2id , unique )  = addMaybe @unique' @var2id' @tag.varName
               loc  .  newTag              = maybe @tag.grTrf GrTag_Var @tag.varName

SEM GrExpr
  | Catch      handler  .  var2id   = Map.insert @arg @newName @body.var2id
                        .  unique   = @body.unique + 1
               loc      .  newName  = HNmNr @body.unique (Just @arg)

SEM GrBind
  | Bind      loc   .  (var2id', newNames, unique'')  =  addList @unique' @lhs.var2id @argNmL
              expr  .  var2id                         =  @var2id'
                    .  unique                         =  @unique''
              lhs   .  unique                         =  @expr.unique
                    .  var2id                         =  @expr.var2id
%%]

replacing every identifier with a number

%%[8.ReplaceIdents
SEM GrGlobal
  | Global  lhs  .  grTrf  =  GrGlobal_Global @newName @val.grTrf

SEM GrPat
  | Node  lhs  .  grTrf  = GrPat_Node @newTag @newNames
  | Tag   lhs  .  grTrf  = GrPat_Tag  @newTag
  | Var   lhs  .  grTrf  = GrPat_Var  @newName

SEM GrBind
  | Bind  lhs  .  grTrf    = GrBind_Bind @bindName @newNames @newExpr
          loc  .  newExpr  = @expr.grTrf

SEM GrVal
  | Var  lhs  .  grTrf  = GrVal_Var (findNewVar @lhs.var2id @nm)

SEM GrTag
  | Var  lhs  .  grTrf  = GrTag_Var (findNewVar @lhs.var2id @nm)

SEM GrExpr
  | App Eval Fetch Update Throw  loc  .  newName  =  findNewVar @lhs.var2id @nm
  | App                          lhs  .  grTrf    =  GrExpr_App     @newName @argL.grTrf
  | Eval                         lhs  .  grTrf    =  GrExpr_Eval    @newName
  | Call                         loc  .  newName  =  findNewVar     @lhs.bind2id @nm
                                 lhs  .  grTrf    =  GrExpr_Call    @newName @argL.grTrf
  | Fetch                        lhs  .  grTrf    =  GrExpr_Fetch   @newName @mbOffset @mbTag
  | Update                       lhs  .  grTrf    =  GrExpr_Update  @newName @val.grTrf @mbTag
  | FetchUpdate                  lhs  .  grTrf    =  GrExpr_FetchUpdate (findNewVar @lhs.var2id @src) (findNewVar @lhs.var2id @dst)
  | Throw                        lhs  .  grTrf    =  GrExpr_Throw   @newName
  | Catch                        lhs  .  grTrf    =  GrExpr_Catch   @body.grTrf @newName @handler.grTrf
  | FFI                          lhs  .  grTrf    =  GrExpr_FFI @nm (map (findNewVar @lhs.var2id) @argL) @resTagL.grTrf

SEM GrModule
  | Mod  lhs  . grTrf         = GrModule_Mod @moduleNm @globalL.grTrf @bindL.grTrf @ctagsMp @newEvalTagMp @newAppTagMp
         loc  . newEvalTagMp  = map (newMap @lhs.bind2id) @evalTagMp
              . newAppTagMp   = map (newMap @lhs.bind2id) @applyTagMp
%%]

%%[8 hs
newMap mp (k, EvApTagVar nm)  =  let newNm = if applyNm == nm
                                             then applyNr
                                             else if evalNm == nm
                                             then evalNr
                                             else if hsnMain == nm
                                             then mainNr
                                             else findNewVar mp nm
                                 in (k, EvApTagVar newNm)
newMap mp x                   =  x
%%]
