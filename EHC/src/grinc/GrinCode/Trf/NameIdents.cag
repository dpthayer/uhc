Rename numbered identifiers to their names.

%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[8 import({GrinCode/AbsSyn})
%%]

%%[8.wrapper
WRAPPER GrAGItf
%%]

%%[8 hs module {%{GRIN}GrinCode.Trf.NameIdents} import({%{GRIN}GRINCCommon}, {%{EH}Base.Common}, {%{EH}GrinCode}, Data.Array.IArray, qualified Data.Map as Map) export(nameIdents)

nameIdents :: IdentNameMap -> GrModule -> GrModule
nameIdents m grmod = let t        = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf grmod))
                                                        (Inh_GrAGItf { names_Inh_GrAGItf = m })
                     in grTrf_Syn_GrAGItf t
%%]

%%[8.grTrf
ATTR GrAGItf [ | | grTrf: GrModule ]
ATTR AllNT [ | | grTrf: SELF     ]
%%]

%%[8.rename
ATTR GrAGItf AllNT  [ names: IdentNameMap | | ]

SEM GrGlobal
  | Global  lhs  .  grTrf  =  GrGlobal_Global (getName' @lhs.names @nm) @val.grTrf

SEM GrPat
  | Node  lhs  .  grTrf     = GrPat_Node @tag.grTrf (map (getName' @lhs.names) @fldL)
  | Var   lhs  .  grTrf     = GrPat_Var  (getName' @lhs.names @nm)

SEM GrBind
  | Bind  loc  .  bindName  = getName' @lhs.names @nm
               .  newNames  = map (getName' @lhs.names) @argNmL
          lhs  .  grTrf     = GrBind_Bind @bindName @newNames @expr.grTrf

SEM GrVal
  | Var  lhs  .  grTrf  = GrVal_Var (getName' @lhs.names @nm)

SEM GrTag
  | Var  lhs  .  grTrf  = GrTag_Var (getName' @lhs.names @nm)

SEM GrExpr
  | App Eval Call Fetch Update Throw  loc  .  newName  =  getName' @lhs.names @nm
  | App                               lhs  .  grTrf    =  GrExpr_App     @newName @argL.grTrf
  | Eval                              lhs  .  grTrf    =  GrExpr_Eval    @newName
  | Call                              lhs  .  grTrf    =  GrExpr_Call    @newName @argL.grTrf
  | Fetch                             lhs  .  grTrf    =  GrExpr_Fetch   @newName @mbOffset @mbTag
  | Update                            lhs  .  grTrf    =  GrExpr_Update  @newName @val.grTrf @mbTag
  | FetchUpdate                       lhs  .  grTrf    =  GrExpr_FetchUpdate  (getName' @lhs.names @src)(getName' @lhs.names @dst)
  | FFI                               lhs  .  grTrf    =  GrExpr_FFI     @nm (map (getName' @lhs.names) @argL) @resTagL.grTrf
  | Throw                             lhs  .  grTrf    =  GrExpr_Throw   @newName
  | Catch                             lhs  .  grTrf    =  GrExpr_Catch   @body.grTrf (getName' @lhs.names @arg) @handler.grTrf

SEM GrModule
  | Mod  lhs  . grTrf         = GrModule_Mod @moduleNm @globalL.grTrf @bindL.grTrf @ctagsMp @newEvalTagMp @newAppTagMp
         loc  . newEvalTagMp  = map (newMap @lhs.names) @evalTagMp
              . newAppTagMp   = map (newMap @lhs.names) @applyTagMp
%%]

%%[8 hs
newMap map (k, EvApTagVar nm) = (k, EvApTagVar $ getName' map nm)
newMap map x                  = x

--getName :: IdentNameMap -> Int -> String
--getName m i = show $ getName' m (HNmNr i Nothing)

getName' :: IdentNameMap -> HsName -> HsName
getName' (names, m) nm@(HNmNr i Nothing    ) = nm
getName' (names, m) nm@(HNmNr i (Just orig)) = orig
getName' (names, m) nm@(HNPos p) = nm
--getName' (names, m) nm@(HNPos p) = error $ "findNewVar: position: " ++ show p
getName' (names, m) nm@(HNm s) = error $ "findNewVar: name: " ++ s

{-
getName' (names, m) nm@(HNmNr i _)
  = if wildcardNr == nm
    then wildcardNm
    else if applyNr == nm
    then applyNm
    else if evalNr == nm
    then evalNm
    else let newNm = findNewVar' i ""
         in if   isDigit (head (show newNm))
            then HNm ('x':'_':show i)
            else newNm
    where
    inBetween n (l, h) = n >= l && n <= h
    findNewVar' v suffix = if v `inBetween` bounds names
                           then hsnSuffix (names ! v) suffix
                           else maybe (hsnSuffix (HNPos v) suffix) id (Map.lookup v m >>= return . flip findNewVar' ("_" ++ show v ++ suffix))
-}
getName' _  nm = error $ "findNewVar: Not a number: " ++ show nm


type IdentNameMap   = (Array Int HsName, Map.Map Int Int)

mergeRenameMap :: IdentNameMap -> RenameMap -> IdentNameMap
mergeRenameMap (a,m) rm = (a,foldl addToMap m rm)
    where
    addToMap m (orig,vars) = foldl (\m v -> Map.insert v orig m) m vars






%%]
