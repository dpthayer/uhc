The basic idea of "Split fetch" is that
   fetchnode n; \(x y z) ->
is replaced by
   fetchfield n 0; \x ->
   fetchfield n 1; \y ->
   fetchfield n 2; \z ->
   
This is done if the tag is statically known, because either
1. x is a constant tag
2. hpt analysis reveals that the list of possible tags for n is singleton

Otherwise, all but the first fetchfield operations are right hoisted to the branch of a case expression
where the tag *is* known.

If such a case expression does not follows, we return a node containing a black hole, as a panic result.

Thus,
   fetchnode n; \(x y z) ->
   case x of
    C1 -> ...y...z...
    C2 -> ...y...
is replaced by
   fetchfield n 0; \x ->
   case x of
    C1 -> fetchfield n 1; \y1 ->
          fetchfield n 2; \z1 ->
          ...y1...z1...
    C2 -> fetchfield n 1; \y2 ->
          ...y2...
Note that y and z are renamed in the respective branches to ensure global unique names.
Also note that in the C2 branch, less fetchfield expressions are generated because C2
has lower arity than C1.



%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[8 import({GrinCode/AbsSyn})
%%]
%%[8 hs import(Debug.Trace)
%%]

%%[8.wrapper
WRAPPER GrAGItf
%%]

%%[8 hs module {%{GRIN}GrinCode.Trf.SplitFetch} import({%{EH}Base.Common}, {%{GRIN}GRINCCommon}, {%{EH}GrinCode}) export(splitFetch)

splitFetch :: (GrModule,Int,HptMap) -> (GrModule,Int,HptMap)
splitFetch (input,unique,hptMap)
  = let inh = Inh_GrAGItf {hptMap_Inh_GrAGItf=hptMap, uniq_Inh_GrAGItf=unique}
        syn = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf input)) inh
    in  (grTrf_Syn_GrAGItf syn, uniq_Syn_GrAGItf syn, addHptItems (newVars_Syn_GrAGItf syn) hptMap)


addHptItems :: RenList -> HptMap -> HptMap
addHptItems renList hptMap
 = addEnvVars hptMap [ (getNr newvar, getEnvVar hptMap oldnr) | (oldnr,newvar) <- renList ]

%%]

%%[8
ATTR GrAGItf [  hptMap: HptMap | uniq: Int | grTrf: GrModule ]
ATTR AllNT [  hptMap: HptMap | uniq: Int | grTrf: SELF ]

ATTR AllExpr [ renameMap: RenMap  | | ]
ATTR AllGrExpr AllBind GrModule GrAGItf [ | | newVars USE {++} {[]} : {RenList}  ]

SEM GrGlobal
  | Global  val  . renameMap = Map.empty

SEM GrBind  
  | Bind    expr . renameMap = Map.empty  
%%]

%%%%%%%%%%%%%%%%
%% Node sizes %%
%%%%%%%%%%%%%%%%

%%[8.nodeSizes
ATTR AllBind AllGrExpr [ nodeSizes: {Map.Map GrTag Int} | | ]

SEM GrModule
  | Mod  loc  .  nodeSizes = Map.fromList (map fst @evalTagMp)
%%]


%%%%%%%%%%%%%%%%%%
%%% SplitFetch %%%
%%%%%%%%%%%%%%%%%%

Assumption: if the tag is not statically known, the fetchnode expression
is followed by a case expression which scrutinizes the tag

%%[8

ATTR GrPatLam GrVarL GrVar [ | | mbTag : {Maybe GrTag} ]

SEM GrPatLam
 | VarNode   lhs . mbTag = @fldL.mbTag
 | Var Empty lhs . mbTag = Nothing
 
SEM GrVarL
 | Cons   lhs . mbTag = @hd.mbTag
 | Nil    lhs . mbTag = Nothing

SEM GrVar
 | KnownTag   lhs . mbTag = Just @tag.self
 | Ignore Var lhs. mbTag  = Nothing


ATTR AllGrTag GrVarL GrVar [ | | self:SELF ]

SEM GrExpr [ | | fetchPointer: {Maybe HsName} ]
  | FetchNode     lhs  .  fetchPointer  =  Just @nm
  | * - FetchNode lhs  .  fetchPointer  =  Nothing


SEM GrPatAlt [ | | mbTag: {Maybe GrTag} ]
  |     Tag Node         lhs  .  mbTag  =  Just @tag.grTrf
  | * - Tag Node         lhs  .  mbTag  =  Nothing


SEM GrPatLam [ | |  names: {GrVarL} ]
  | VarNode              lhs  .  names  =  @fldL.self
  | Var                  lhs  .  names  =  error "SplitFetch.ag: attempt to get names from GrPat_Var"
  | Empty                lhs  .  names  =  []


ATTR AllGrExpr [ floatingFetches : FetchEnv | | ]

SEM GrBind
  | Bind  expr  .  floatingFetches = Map.empty

SEM GrExpr
  | Seq  loc  .  fetchesInfo   = do { p <- @expr.fetchPointer
                                    ; let buildFetchInfo (GrVar_Var v) r n  =  (v, n) : r (n+1)
                                          buildFetchInfo _             r n  =           r (n+1)
                                          fetches@(fetch0:fetch1n) = foldr buildFetchInfo (const []) @pat.names 0
                                    ; let mbTag     = checkSingleTag @lhs.hptMap p
                                          f (v,o)   = (v, GrExpr_FetchField p o @pat.mbTag)
                                          g (v,0)   = (v, GrExpr_Unit (GrVal_Tag (fromJust mbTag)))
                                          g (v,o)   = (v, GrExpr_FetchField p o mbTag)
                                    ; let res = if      isJust @pat.mbTag then (map f fetches, Nothing                          )
                                                else if isJust mbTag      then (map g fetches, Nothing                          )
                                                else                           ([f fetch0]   , Just (fst fetch0, map f fetch1n) )
                                    ; return res
                                    }
         lhs   .  grTrf             = maybe @grTrf 
                                            (buildSeqs @body.grTrf . fst)        -- build FetchFields for the known fetches
                                            @fetchesInfo
         body  .  floatingFetches   = maybe @lhs.floatingFetches 
                                            (addFetchInfo @lhs.floatingFetches . snd)   -- add (tag,unknowns) to the floating fetches
                                            @fetchesInfo
                                            
  | Case  loc  .  (mbRes, newMap)   = Map.updateLookupWithKey (\k v -> Nothing) 
                                                              (getTagName @val.grTrf) 
                                                              @lhs.floatingFetches
               .  mbFetches         = @mbRes
               .  floatingFetches   = @newMap

ATTR AllAlt [ mbFetches: {Maybe [(HsName, GrExpr)]} | | ]

SEM GrAlt
  | Alt  loc  .  mbExprInfo  =  do { fetches <- @lhs.mbFetches
                                   ; tag     <- @pat.mbTag
                                   ; return (foldr (specializeFetch tag)
                                                   (@lhs.uniq, [], [])
                                                   (take (nodeSizeTag tag @lhs.nodeSizes) fetches)
                                            )
                                   }
         (expr.uniq, loc.renameList, loc.newExprInfo) = maybe (@lhs.uniq, [], []) id @mbExprInfo
         expr  .  renameMap  =  Map.union (Map.fromList @loc.renameList) @lhs.renameMap
         lhs   .  newVars    =  @loc.renameList
         lhs   .  grTrf      =  GrAlt_Alt @pat.grTrf (buildSeqs @expr.grTrf @newExprInfo)
%%]

%%[8.lastFetch import({GrinCode/LastExpr})
SEM GrExpr
  | Catch  loc  . hasNext      =  False
  | FetchNode FetchField
           loc  .  mbKnownTag  =  checkSingleTag @lhs.hptMap @nm
                .  knownTag    =  case @mbKnownTag of
                                   Just t  -> t
                                   Nothing -> GrTag_Hole  -- TODO: is this the right panic result?
                                              -- error ("unknown tag in returning fetch " ++ show @nm ++ " tags can be " ++ show (getNodes (absFetch @lhs.hptMap @nm))) 
                .  size        =  nodeSizeTag @knownTag @lhs.nodeSizes
                .  fetches     =  let buildFetchInfo o  =  Just (GrExpr_FetchField @nm o @mbKnownTag, o+1)
                                  in take @size $ unfoldr buildFetchInfo 1
                .  names       =  map (\n->HNmNr n Nothing) [@lhs.uniq .. @uniq  - 1]
                .  uniq        =  if @isLastExpr then @lhs.uniq + @size else @lhs.uniq
                .  node        =  GrVal_Node @knownTag (map GrVal_Var @names)
           lhs  .  grTrf       =  if @isLastExpr
                                  then buildSeqs (GrExpr_Unit @node) (zip @names @fetches)
                                  else @grTrf
%%]

%%[8.applySubst
SEM GrVal
  | Var        lhs . grTrf       = maybe @grTrf GrVal_Var (Map.lookup (getNr @nm) @lhs.renameMap)

SEM GrExpr
  | FetchNode FetchField Eval Throw UpdateUnit
               loc  . newName    = maybe @nm id (Map.lookup (getNr @nm) @lhs.renameMap)
  | FetchNode  loc  . grTrf      = GrExpr_FetchNode  @newName
  | FetchField loc  . grTrf      = GrExpr_FetchField @newName @offset @mbTag
  | UpdateUnit loc  . grTrf      = GrExpr_UpdateUnit @newName @val.grTrf
  | Eval       loc  . grTrf      = GrExpr_Eval  @newName
  | Throw      loc  . grTrf      = GrExpr_Throw @newName
%%]

%%[8 hs import(qualified Data.Map as Map, Data.Maybe, Data.List)

type FetchEnv = Map.Map HsName [(HsName, GrExpr)]
type RenMap = Map.Map Int HsName
type RenList = [(Int,HsName)]

fromJust' s Nothing = error $ "fromJust':" ++ s
fromJust' _ (Just v) = v

nodeSizeTag t nodeSizes 
  =  Map.findWithDefault 1 t nodeSizes

getTagName (GrVal_Var v) =  v
getTagName v             = error $ "getName: value not a variable: '" ++ show v ++ "'"

addFetchInfo ffm Nothing                    = ffm
addFetchInfo ffm (Just (v, unknownFetches)) = Map.insert v unknownFetches ffm

buildSeqs body = foldr buildSeq body
    where
    buildSeq (v, e) b = GrExpr_Seq e (GrPatLam_Var v) b

checkSingleTag hptMap p = if singleton nodes
                          then Just (fst $ head nodes)
                          else Nothing
    where
    nodes = getNodes (absFetch hptMap p)

singleton [a] = True
singleton _   = False

specializeFetch :: GrTag -> (HsName, GrExpr) -> (Int, RenList, [(HsName, GrExpr)]) -> (Int, RenList, [(HsName, GrExpr)])
specializeFetch tag (var, GrExpr_FetchField nm offset _) (u, renL, fetchesL)
  = let newVar = HNmNr u Nothing 
    in ( u+1
       , (getNr var, newVar) : renL
       , (newVar, GrExpr_FetchField nm offset (Just tag)) : fetchesL
       )

%%]
