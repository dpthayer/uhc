If an expression is bound to a variable which is never used,
it is removed (if the expression has no side effect).
Variable bindings that are never used are replaced by wildcards.
Global variables and functions thar are never used are removed.
Alternatives with tags that involve functions that do no longer exist are removed.


%%[8 import({GrinCode/AbsSyn})
%%]
%%[8 hs import(Debug.Trace)
%%]
%%[8 hs import(Data.Maybe, qualified Data.Set as Set, qualified Data.Map as Map)
%%]
%%[8 hs import({%{EH}Base.Common}, {%{EH}GrinCode})
%%]
%%[8 hs import({%{GRIN}GRINCCommon})
%%]
%%[8
WRAPPER GrAGItf
PRAGMA nocycle novisit
%%]
%%[8 hs module {%{GRIN}GrinCode.Trf.DropUnusedExpr}  export(dropUnusedExpr)

dropUnusedExpr :: GrModule -> (GrModule, Bool)
dropUnusedExpr grmod = let t = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf grmod)) Inh_GrAGItf
                       in (grTrf_Syn_GrAGItf t, changes_Syn_GrAGItf t)

%%]

%%[8

-- Top-level targets: a transformed module, and a changes bit used for fixpoint iteration.

ATTR GrAGItf [  | | grTrf: GrModule ]
ATTR AllNT [  | | grTrf: SELF ]
ATTR GrAGItf GrModule AllBind AllGlobal AllGrExpr [ | | changes USE {||} {False} : Bool ]
%%]


%%[8

-- We have a bottom-up collection of variables that are "used".
-- Variables that are "defined" by patterns are subtracted, thus only free variables are collected.
-- At the module level this is bended downwards, such that all bindings in "getUsed" get the used variables.
-- Also, patterns in "getUsed" get the locally used variables.


ATTR AllGrExpr
     AllGrVal
     AllGrTag
     AllBind
     AllGlobal   [ | | used     USE {`Set.union`} {Set.empty}: {Set.Set HsName} ]

ATTR AllGrPat    [ getUsed : {Set.Set HsName} | | defined  USE {`Set.union`} {Set.empty}: {Set.Set HsName} ]   

ATTR AllBind
     AllGlobal   [ getUsed : {Set.Set HsName} | | ]

SEM GrModule
  |  Mod          loc.getUsed  =  @globalL.used  `Set.union` (Set.insert mainNr (Set.insert hsnMainFullProg @bindL.used))

SEM GrBind
  | Bind          lhs.used     =  foldr Set.delete @expr.used @argNmL

SEM GrExpr
  | Seq           lhs.used     =  @expr.used `Set.union`  Set.fold Set.delete @body.used @pat.defined
                  pat.getUsed  =  @body.used
  | UpdateUnit    lhs.used     =  Set.insert @nm @val.used
  | FetchNode     lhs.used     =  Set.singleton @nm
  | FetchUpdate   lhs.used     =  Set.singleton @src  `Set.union`  Set.singleton @dst
  | FetchField    lhs.used     =  Set.singleton @nm
  | Call          lhs.used     =  Set.insert @nm @argL.used
  | Eval          lhs.used     =  Set.singleton @nm
  | App           lhs.used     =  Set.insert @nm @argL.used
  | Throw         lhs.used     =  Set.singleton @nm  
  | Catch         lhs.used     =  @body.used `Set.union` Set.delete @arg @handler.used

SEM GrAlt
  | Alt           lhs.used     =  Set.fold Set.delete @expr.used @pat.defined
                  pat.getUsed  =  @expr.used

SEM GrVal
  | Var
    BasicNode
    EnumNode
    PtrNode
    OpaqueNode    lhs.used     =  Set.singleton @nm

SEM GrTag
  | Fun
    PApp
    App           lhs.used     =  Set.singleton @nm

SEM GrPatAlt
  | Node          lhs.defined  =  Set.fromList @fldL
  
SEM GrPatLam
  | Var
    BasicNode
    EnumNode
    PtrNode
    OpaqueNode
    BasicAnnot
    EnumAnnot
    PtrAnnot
    OpaqueAnnot   lhs.defined  =  Set.singleton @nm

SEM GrVar
  | Var           lhs.defined  =  Set.singleton @nm

%%]

%%[10
SEM GrSplit
  | Sel           lhs.defined  =  Set.singleton @nm
%%]


%%[8

-- Determine which expressions have a side effect.
-- This is certainly the case for FFI, Throw, and Update.
-- Case and Seq expressions have side effects if their children have.
-- The only difficult expression is the Call: they have a side effect if
-- the body of the function has, but this is circular for recursive functions.
-- Therefore we have a 2-pass approach: 
-- - a "Coarse" approximation that assumes that every Call has a side effect
-- - a "Fine" better approximation, that takes into account the Course approximation of the body.
-- The side effects of all functions are gathered in "genSideEffectMap" and distribnuted in "allSideEffectMap". 
 
ATTR AllGrExpr [ | | sideEffectCoarse USE {||} {False} : Bool ]
ATTR AllGrExpr [ | | sideEffectFine   USE {||} {False} : Bool ]

SEM GrExpr 
  | FFI 
    Throw 
    FetchUpdate 
    UpdateUnit    lhs  .  sideEffectCoarse  =  True
  | Call          lhs  .  sideEffectCoarse  =  True

SEM GrExpr 
  | FFI 
    Throw 
    FetchUpdate 
    UpdateUnit    lhs  .  sideEffectFine  =  True
  | Call          lhs  .  sideEffectFine  =  Map.findWithDefault True @nm @lhs.allSideEffectMap

ATTR AllBind [ | | genSideEffectMap USE {`Map.union`} {Map.empty} : {Map.Map HsName Bool} ]

SEM GrBind
  | Bind           lhs.genSideEffectMap  =  Map.singleton @nm @expr.sideEffectCoarse
  
ATTR AllGrExpr AllBind  [  allSideEffectMap : {Map.Map HsName Bool}  | | ]

SEM GrModule
  | Mod   bindL.allSideEffectMap  =  @bindL.genSideEffectMap


%%]


%%[8

-- The actual removals
-- Expressions without side effects which are bound to variables that are never used are deleted.

-- (before version 1090 we had an additional test which removed code after an expression that always throws an exception.
-- This needed the HPT map to decide whether a Call always throws: if its result is Bottom, but its throw-result is not Bottom).

SEM GrExpr
  | Seq  (lhs.grTrf
         ,lhs.changes)   =  -- if @expr.throws then @expr.grTrf else 
                            if not @expr.sideEffectFine   &&  not (any (`Set.member` @body.used) (Set.toList @pat.defined)) 
                            then (@body.grTrf, True)
                            else (@loc.grTrf, @expr.changes || @body.changes)

-- Bindings, Globals, and Alternatives that are not "life" are deleted.

SEM GrBindL GrGlobalL GrAltL
  | Cons  (lhs.grTrf
          ,lhs.changes)  =  if @hd.life
                            then ( @hd.grTrf : @tl.grTrf, @hd.changes || @tl.changes )
                            else (             @tl.grTrf, True                       )

%%]


%%[8
-- So, we need a "life" attribute that decides whether a Binding/Global/Alternative is deleted.
ATTR GrBind GrGlobal GrAlt [ | | life : Bool ]

-- Bindings and Gloabls are life if they are used
SEM GrBind
  | Bind   lhs . life  =  @nm `Set.member` @lhs.getUsed
  | Rec    lhs . life  =  not (null @bindL.grTrf)

SEM GrGlobal
  | Global lhs . life  =  @nm `Set.member` @lhs.getUsed

-- The liveness of an alterntive depends on its tag.
-- For C and special tags the are always life.
-- An F, A or P tag is life if the corresponding function exists.

SEM GrAlt
  | Alt    lhs . life  =  maybe True
                                (\nm -> Set.member nm @lhs.allFunctionNames)
                                @pat.mbTagName

-- This determines which tags to check:

ATTR GrPatAlt GrTag [ | | mbTagName : {Maybe HsName} ]

SEM GrPatAlt
  | LitInt
    Otherwise  lhs.mbTagName = Nothing

SEM GrTag
  | Fun
    PApp
    App        lhs.mbTagName = Just @nm
  | Con
    Hole
    Rec
    World
    Unboxed
    Any        lhs.mbTagName = Nothing

-- This collects and subsequently passes down all existing fucntions:

ATTR AllBind           [ | | functionNames USE {`Set.union`} {Set.empty}: {Set.Set HsName} ]
ATTR AllBind AllGrExpr [  allFunctionNames : {Set.Set HsName} | | ]

SEM GrBind
  | Bind    lhs.functionNames  =  Set.singleton @nm

SEM GrModule
  |  Mod  bindL.allFunctionNames = @bindL.functionNames

%%]

%%[8

-- Variables bound in patterns which are never used are replaced with wildcards.
-- (This is only important for the result of expressions that are kept because of their side effects)

SEM GrPatLam
  | Var         lhs  .  grTrf  =  GrPatLam_Var                    (mkWildcard @lhs.getUsed  @nm)
  | BasicNode   lhs  .  grTrf  =  GrPatLam_BasicNode  @annot      (mkWildcard @lhs.getUsed  @nm)
  | EnumNode    lhs  .  grTrf  =  GrPatLam_EnumNode               (mkWildcard @lhs.getUsed  @nm)
  | OpaqueNode  lhs  .  grTrf  =  GrPatLam_OpaqueNode             (mkWildcard @lhs.getUsed  @nm)
  | PtrNode     lhs  .  grTrf  =  GrPatLam_PtrNode                (mkWildcard @lhs.getUsed  @nm)
  | BasicAnnot  lhs  .  grTrf  =  GrPatLam_BasicAnnot @annot      (mkWildcard @lhs.getUsed  @nm)
  | EnumAnnot   lhs  .  grTrf  =  GrPatLam_EnumAnnot  @tagL.grTrf (mkWildcard @lhs.getUsed  @nm)
  | OpaqueAnnot lhs  .  grTrf  =  GrPatLam_OpaqueAnnot            (mkWildcard @lhs.getUsed  @nm)
  | PtrAnnot    lhs  .  grTrf  =  GrPatLam_PtrAnnot   @tagL.grTrf (mkWildcard @lhs.getUsed  @nm)

SEM GrPatAlt
  | Node     lhs  .  grTrf  =  GrPatAlt_Node @tag.grTrf (map (mkWildcard @lhs.getUsed) @fldL)

SEM GrVar
  | Var      lhs  .  grTrf  = if @nm `Set.member` @lhs.getUsed then GrVar_Var @nm else GrVar_Ignore
  
{
mkWildcard m x = if x `Set.member` m then x else wildcardNr
}

%%]


-- for debugging purposes: report which parameters are never used
-- (currently disabled)
                             
SEM GrBind
  | Bind lhs  . grTrf       =  -- trace (show @nm ++ " unused:" ++ concat (map (reportUnused @expr.used) @argNmL))
                                     @loc.grTrf

reportUnused :: Set.Set HsName -> HsName -> String
reportUnused m x = if x `Set.member` m then "" else (" " ++ show x)


