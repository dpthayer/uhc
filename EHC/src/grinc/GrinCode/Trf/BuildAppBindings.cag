The input contains nodes with an A/_ tags and a variable number of fields. 
The first field always represents the function to be applied, the other fields are arguments for this function.
This transformation replaces the tag with a tag that also encodes the number of arguments.
Examples:
  (A/_ f a1 a2 a3)  ==>  (A/app3 f a1 a2 a3)
  (A/_ f a1 a2)     ==>  (A/app2 f a1 a2)
  (A/_ f a1)        ==>  (A/app1 f a1)
The transformation also builds new functions app1, app2, app3 ...
for all number of arguments for which A tags exist.

New: these functions are specialized for each occurence of A/
Examples:
  (A/_ f a1 a2)     ==>  (A/app2_1 f a1 a2)
  (A/_ g b1 b2)     ==>  (A/app2_2 g b1 b2)


%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[8 import({GrinCode/AbsSyn})
%%]

%%[8.wrapper
WRAPPER GrAGItf
%%]

%%[8 hs module {%{GRIN}GrinCode.Trf.BuildAppBindings} import(qualified Data.Set as Set)
%%]

%%[8 hs import({%{EH}Base.Common}, {%{EH}Base.Builtin},{%{GRIN}GRINCCommon}, {%{EH}GrinCode}) export(buildAppBindings)

buildAppBindings :: (GrModule,Int) -> (GrModule,Int)
buildAppBindings (code,unique)
  = let inh = Inh_GrAGItf {unique_Inh_GrAGItf=unique}
        syn = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf code)) inh
    in  (grTrf_Syn_GrAGItf syn, unique_Syn_GrAGItf syn)

%%]

%%[8
ATTR GrAGItf [ | | grTrf: GrModule ]
ATTR AllNT [ | | grTrf: SELF ]

ATTR GrAGItf GrModule [ | unique: Int | ]
%%]

%%[8
ATTR AllBind AllGrExpr [ | applyNodeSizes: {[(Int,Int)]} | ]

SEM GrModule
  | Mod           bindL  .  applyNodeSizes  = []

SEM GrExpr
  | Store  lhs . applyNodeSizes = maybe @lhs.applyNodeSizes 
                                        (\e -> (e,@val.atagId) : @lhs.applyNodeSizes) 
                                        @val.applyNodeSize

SEM GrVal [ | | applyNodeSize: {Maybe Int} ]
  | Node          lhs  .  applyNodeSize         =  if @tag.isGenApplyTag
                                                   then Just @fldL.fieldCount
                                                   else Nothing
  | * - Node      lhs  .  applyNodeSize         =  Nothing

SEM GrValL [ | | fieldCount: Int ]
  | Cons  lhs  .  fieldCount  =  1 + @tl.fieldCount
  | Nil   lhs  .  fieldCount  =  0

SEM GrTag [ | | isGenApplyTag : Bool ]
  | App      lhs  .  isGenApplyTag  =  @nm == hsnWild
  | * - App  lhs  .  isGenApplyTag  =  False
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Replace A/_ by A/appN      %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%[8

ATTR AllGrExpr AllGrVal AllBind AllGlobal [ | atagId : Int | ]

%%]



%%[8.replaceApplyTags
SEM GrVal
  | Node      loc  . newTag      = if   @tag.isGenApplyTag 
                                   then applyFunctionTag @fldL.fieldCount (@lhs.atagId+1)
                                   else @tag.grTrf
  | Node      lhs  . grTrf       = GrVal_Node @newTag @fldL.grTrf
  
  
  | Node      lhs  . atagId     =  if   @tag.isGenApplyTag 
                                   then @lhs.atagId + 1
                                   else @lhs.atagId
  
SEM GrModule
  | Mod       globalL . atagId   = 0
  
  
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Building the appN bindings %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8.buildAppBinding hs


applyFunctionName size specnr
  =  HNm $ "app" ++ show size ++ "_" ++ show specnr
  
applyFunctionTag size specnr
  =  GrTag_App (applyFunctionName size specnr)


buildAppBinding unique size specnr
  = let funcNr  = unique
        minArg  = funcNr + 2
        maxArg  = minArg + size - 1
        unique2 = maxArg + 2
        funcName                  = HNmNr funcNr (OrigLocal origFuncName)    -- not OrigFunc, so app functions get a separate namespace
        origFuncName              = applyFunctionName size specnr
        args@(partialApp:appArgs) = map (\n->HNmNr n OrigNone) [minArg .. maxArg]
        evalPartialApp            = HNmNr (maxArg + 1) OrigNone
        code = GrBind_Bind funcName args body
        body = GrExpr_Seq (GrExpr_Eval partialApp)
                          (GrPatLam_Var evalPartialApp)
                          (GrExpr_App evalPartialApp $ map GrVal_Var appArgs)
    in (unique2, origFuncName, funcName, code)

node2app (size,specnr) (unique, origNamesMap, bindings) =
    let key = (applyFunctionTag size specnr, size)
        (unique2, origFuncName, funcName, code) = buildAppBinding unique size specnr
        origNameMap = (funcName, origFuncName)
    in (unique2, origNameMap:origNamesMap, code:bindings)
%%]

%%[8.addAppBindings
SEM GrModule
  | Mod  loc  . (unique2, origNamesMap, binds)  = foldr node2app
                                                        (@lhs.unique, [], @bindL.grTrf)
                                                        @bindL.applyNodeSizes
         lhs  . unique = @unique2
         lhs  . grTrf  = GrModule_Mod @moduleNm 
                                      @globalL.grTrf 
                                      (@loc.mainFullProg ++ @binds)
                                      @ctagsMp 
                                      
%%[[8
         loc . mainFullProg = []
%%][99
         loc . mainFullProg = let worldNode = GrVal_Node GrTag_Hole []   
                                  worldName = HNm "world"
                                  ioName    = HNm "theio"
                              in  [ GrBind_Bind hsnMainFullProg [] (GrExpr_Seq  (GrExpr_Store worldNode)
                                                                                (GrPatLam_Var worldName)
                                                                                (GrExpr_Seq (GrExpr_Eval hsnMain)
                                                                                            (GrPatLam_Var ioName)
                                                                                            (GrExpr_App ioName [GrVal_Var worldName])
                                                                                )
                                                                   ) 
                                  ]
%%]]
                                      
%%]

