This transformation drops all not directly called functions. Because only
direct calls are counted (not the implicit ones through F, P and A thunks), 
this should be used after inlining eval and apply.

This transformation is almost obsolete, since we do remove unused functions
in DropUnreachablebindings now, which *can* be applied before inlining,
because it *does* take F, P and A into account.
Still, the current transformation can find an occasional unused function
which depends on the abstract interpretation.

For example, packedStringHead is not needed when a packed string is tranformed
to a string, but only counted afterwards.

%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[8 import({GrinCode/AbsSyn})
%%]

%%[8.wrapper
WRAPPER GrAGItf
%%]

%%[8 hs module {%{GRIN}GrinCode.Trf.DropUnusedBindings} import(qualified Data.Set as Set,qualified Data.Map as Map,Data.Graph,Data.List,Data.Array)
type EdgeF   = [Edge] -> [Edge]
type VertexF = [Vertex] -> [Vertex]

type CallInfo = Map.Map Vertex CallType
data CallType = Call | TailCall | BothCall deriving (Eq, Show)


type NodeInfo  = (Vertex, CallInfo)
type NodeInfoF = [NodeInfo] -> [NodeInfo]
%%]

%%[8 hs import({%{EH}Base.Common}, {%{GRIN}GRINCCommon}, {%{EH}GrinCode}) export(dropUnusedBindings)
dropUnusedBindings :: GrModule -> GrModule
dropUnusedBindings grmod = let t = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf grmod))
                                                (Inh_GrAGItf {})
                           in grTrf_Syn_GrAGItf t
%%]

%%[8
ATTR GrAGItf [ | | grTrf: GrModule ]
ATTR AllNT [ | | grTrf: SELF ]

%%]

%%[8.graphInfo import({GrinCode/LastExpr})
ATTR AllBind            [ | | biggest USE {`max`} {minBound}: Int
                              smallest USE {`min`} {maxBound}: Int
                              nodes USE {.} {id}: NodeInfoF
                        ]
ATTR AllGrExpr          [ | calls: CallInfo | ]
ATTR AllBind AllGrExpr  [ | | ]

SEM GrBind
  | Bind  loc   .  bindNr    = getNr @nm
          lhs   .  smallest  = @bindNr
                .  biggest   = @bindNr
                .  nodes     = ( (@bindNr, @expr.calls) :)
          expr  .  calls     = Map.empty

SEM GrExpr
  | Call  loc  .  mergeCall  =  (\p n -> if p == n then p else BothCall)
               .  callType   =  if @isLastExpr then TailCall else Call
               .  calls      =  Map.insertWith @mergeCall (getNr @nm) @callType @lhs.calls
%%]

%%[8.graph
SEM GrModule
  | Mod  loc  .  nodes  = @bindL.nodes []
              .  graph  = let buildNode prev outlist = Map.keys outlist
                          in accumArray buildNode undefined (@bindL.smallest, @bindL.biggest) @loc.nodes
%%]

%%[8.dropUnusedBindings
ATTR AllBind [ lifeBindings: {Set.Set Int} | | ]

SEM GrModule
  | Mod  loc   . entry         =  mainNr
               . lifeBindingL  =  reachable @graph (getNr @loc.entry)
               . lifeBindings  =  Set.fromList @loc.lifeBindingL
         
SEM GrBind [ | | dropBinding: Bool ]
  | Bind  lhs  . dropBinding  =  not (@bindNr `Set.member` @lhs.lifeBindings)
  | Rec   lhs  . dropBinding  =  @bindL.count == 0


SEM GrBindL [ | | count: Int ]
  | Cons  lhs  .  grTrf  =  if @hd.dropBinding
                            then @tl.grTrf
                            else @hd.grTrf : @tl.grTrf
               .  count  =  if @hd.dropBinding then @tl.count else 1 + @tl.count
  | Nil   lhs  .  count  =  0
%%]
