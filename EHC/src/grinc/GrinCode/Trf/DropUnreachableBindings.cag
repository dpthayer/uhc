This transformation drops all functions not reachable from main,
either through direct calls, or through deferred (F) or partially applied (P) or apply (A) calls.

%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[8 import({GrinCode/AbsSyn})
%%]

%%[8.wrapper
WRAPPER GrAGItf
%%]

%%[8 hs module {%{GRIN}GrinCode.Trf.DropUnreachableBindings} import(qualified Data.Set as Set,qualified Data.Map as Map,Data.Graph,Data.Array, Maybe(fromJust))

type IdentSet  = Set.Set Vertex
type UsageMap  = Map.Map Vertex IdentSet

%%]

%%[8 hs import({%{EH}Base.Common},{%{EH}Base.Builtin(hsnMain)}, {%{GRIN}GRINCCommon}, {%{EH}GrinCode}) export(dropUnreachableBindings)
dropUnreachableBindings :: GrModule -> GrModule
dropUnreachableBindings grmod = let t = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf grmod))
                                                     (Inh_GrAGItf {})
                                in grTrf_Syn_GrAGItf t
%%]

%%[8
ATTR GrAGItf [ | | grTrf: GrModule ]
ATTR AllNT   [ | | grTrf: SELF     ]
%%]


Do a provisional numbering of all global definitions and global bindings

%%[8
{
type Env = Map.Map HsName Int

usedGlob :: Env -> HsName -> Set.Set Int
usedGlob env nm = maybe Set.empty
                        Set.singleton
                        (Map.lookup nm env)

}

ATTR AllGlobal AllBind  [ | globalNumber : Int | genEnv USE {`Map.union`} {Map.empty} : Env ]

ATTR AllExpr AllBind AllGlobal [ env : Env | | ]



SEM GrModule
  | Mod       globalL . globalNumber   = 0
              globalL . env            = @bindL.genEnv
              bindL   . env            = @bindL.genEnv
  
SEM GrGlobal
  | Global    lhs.globalNumber = @lhs.globalNumber+1
              lhs.genEnv       = Map.singleton @nm @lhs.globalNumber
  
SEM GrBind
  | Bind      lhs.globalNumber = @lhs.globalNumber+1
              lhs.genEnv       = Map.singleton @nm @lhs.globalNumber
  
%%]





For each definition (globals and bindings) we determine which other globals and functions it uses: the "usage".

%%[8
ATTR AllDef             [ | | usage    USE {`Map.union`} {Map.empty}: UsageMap ]

ATTR AllGrExpr
     AllGrVal
     AllGrTag           [ | | used     USE {`Set.union`} {Set.empty}: IdentSet ]


SEM GrExpr
  | Call
    App           lhs.used = usedGlob @lhs.env @nm `Set.union` @argL.used
  | Eval          lhs.used = usedGlob @lhs.env @nm
  
SEM GrVal
    | Var         lhs.used = usedGlob @lhs.env @nm
%%[[10
    | NodeAdapt   lhs.used = usedGlob @lhs.env @nm `Set.union` @fldL.used
%%]]

SEM GrTag
    | Fun
      App
      PApp        lhs.used = usedGlob @lhs.env @nm
      

SEM GrBind
    | Bind        lhs.usage    = Map.singleton @lhs.globalNumber @expr.used

SEM GrGlobal
    | Global      lhs.usage    = Map.singleton @lhs.globalNumber @val.used

%%]

At module level, we create a graph from the collected usage sets.
Life bindings are those reachable from the main function.
Bindings that appear not to be life are removed in the transformed program.

%%[8
SEM GrModule
  | Mod  loc  .  usageL  = Map.toAscList (Map.map Set.toList (Map.union @globalL.usage @bindL.usage))
              .  biggest = fst (last @loc.usageL)
              .  graph   = array (0, @loc.biggest) @loc.usageL
         lhs  .  grTrf   = GrModule_Mod @moduleNm @globalL.grTrf @bindL.grTrf @ctagsMp
%%]

%%[8
ATTR AllDef          [ lifeSet: {Set.Set Int} | |             ]
ATTR GrBind GrGlobal [                        | | life : Bool ]

SEM GrModule
  | Mod  loc   . lifeList =  reachable @graph (maybe (error ("main not found in " ++ show @bindL.genEnv) ) id (Map.lookup hsnMain @bindL.genEnv))
               . lifeSet  =  Set.fromList @loc.lifeList
         
SEM GrBind
  | Bind   lhs . life  =  @lhs.globalNumber `Set.member` @lhs.lifeSet
  | Rec    lhs . life  =  not (null @bindL.grTrf)

SEM GrGlobal
  | Global lhs . life  =  @lhs.globalNumber `Set.member` @lhs.lifeSet


SEM GrBindL GrGlobalL
  | Cons  lhs  .  grTrf  =  if @hd.life
                            then @hd.grTrf : @tl.grTrf
                            else             @tl.grTrf
%%]
