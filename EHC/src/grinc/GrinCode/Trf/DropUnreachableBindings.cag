This transformation drops all functions not reachable from main,
either through direct calls, or through deferred (F) or partially applied (P) or apply (A) calls.

%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[8 import({GrinCode/AbsSyn})
%%]

%%[8.wrapper
WRAPPER GrAGItf
%%]

%%[8 hs module {%{GRIN}GrinCode.Trf.DropUnreachableBindings} import(qualified Data.Set as Set,qualified Data.Map as Map,Data.Graph,Data.Array)

type IdentSet  = Set.Set Vertex
type UsageMap  = Map.Map Vertex IdentSet

%%]

%%[8 hs import({%{EH}Base.Common}, {%{GRIN}GRINCCommon}, {%{EH}GrinCode}) export(dropUnreachableBindings)
dropUnreachableBindings :: GrModule -> GrModule
dropUnreachableBindings grmod = let t = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf grmod))
                                                     (Inh_GrAGItf {})
                                in grTrf_Syn_GrAGItf t
%%]

%%[8
ATTR GrAGItf [ | | grTrf: GrModule ]
ATTR AllNT   [ | | grTrf: SELF     ]
%%]


For each binding (globals and functions) we determine which other globals and functions it uses: the "usage".
We do so by collecting all names used, and subtracting locally declared ones.

%%[8
ATTR AllDef             [ | | usage    USE {`Map.union`} {Map.empty}: UsageMap ]

ATTR AllGrPat           [ | | declared USE {`Set.union`} {Set.empty}: IdentSet ]

ATTR AllGrExpr
     AllGrVal
     AllGrTag           [ | | used     USE {`Set.union`} {Set.empty}: IdentSet ]


SEM GrExpr
    | Seq         lhs.used = @expr.used `Set.union` (@body.used `Set.difference` @pat.declared)
    | UpdateUnit  lhs.used = Set.insert (getNr @nm) @val.used
    | FetchUpdate lhs.used = Set.fromList [getNr @src, getNr @dst]
    | FetchNode
      FetchField
      Eval
      Throw       lhs.used = Set.singleton (getNr @nm)
    | Call
      App         lhs.used = Set.insert (getNr @nm) @argL.used
    | Catch       lhs.used = @body.used `Set.union` (Set.delete (getNr @arg) @handler.used)

SEM GrAlt
    | Alt         lhs.used = @expr.used `Set.difference` @pat.declared

SEM GrVal
    | Var         lhs.used = Set.singleton (getNr @nm)
%%[[10
    | NodeAdapt   lhs.used = Set.insert (getNr @nm) @fldL.used
%%]]

SEM GrTag
    | Fun
      App
      PApp        lhs.used = Set.singleton (getNr @nm)
      
SEM GrPatAlt
    | Node        lhs.declared = Set.fromList (map getNr @fldL)
    
SEM GrPatLam
    | Var         lhs.declared = Set.singleton (getNr @nm)
    
SEM GrVar
    | Var         lhs.declared = Set.singleton (getNr @nm)
    

SEM GrBind
    | Bind        loc.bindNr   = getNr @nm
                  lhs.usage    = Map.singleton (@loc.bindNr) (Set.difference @expr.used (Set.fromList (map getNr @argNmL)))

SEM GrGlobal
    | Global      lhs.usage    = Map.singleton (getNr @nm) @val.used

%%]

At module level, we create a graph from the collected usage sets.
Life bindings are thos reachable from the main function.
Bindings that appear not to be life are removed in the transformed program.

%%[8
SEM GrModule
  | Mod  loc  .  usageL  = Map.toAscList (Map.map Set.toList (Map.union @globalL.usage @bindL.usage))
              .  biggest = fst (last @loc.usageL)
              .  graph   = array (0, @loc.biggest) @loc.usageL
%%]

%%[8
ATTR AllDef          [ lifeSet: {Set.Set Int} | |             ]
ATTR GrBind GrGlobal [                        | | life : Bool ]

SEM GrModule
  | Mod  loc   . entry    =  mainNr
               . lifeList =  reachable @graph (getNr @loc.entry)
               . lifeSet  =  Set.fromList @loc.lifeList
         
SEM GrBind
  | Bind   lhs . life  =  @bindNr `Set.member` @lhs.lifeSet
  | Rec    lhs . life  =  not (null @bindL.grTrf)

SEM GrGlobal
  | Global lhs . life  =  (getNr @nm) `Set.member` @lhs.lifeSet


SEM GrBindL GrGlobalL
  | Cons  lhs  .  grTrf  =  if @hd.life
                            then @hd.grTrf : @tl.grTrf
                            else             @tl.grTrf
%%]
