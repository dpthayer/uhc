%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[8 hs module {%{GRIN}GrinCode.ToSilly} export(grin2silly)
%%]

%%[8 hs import(UU.Pretty, {%{GRIN}GRINCCommon} hiding (Variable(..)), Data.List(nub), Data.Maybe, {%{EH}GrinCode}, {%{GRIN}Config})
%%]
%%[8 hs import({%{GRIN}Silly})
%%]
%%[8 hs import(EH.Util.Utils,{%{EH}Base.Common} hiding "((<+>))")
%%]
%%[8 hs import(qualified Data.Map as Map, qualified Data.Set as Set, Data.Bits)
%%]
%%[8 hs import({%{EH}Base.Opts})
%%]
%%[8 import({GrinCode/AbsSyn})
%%]
%%[8 import({GrinCode/LastExpr})
%%]
%%[8 hs import(Debug.Trace)
%%]

%%[12 hs import(qualified Data.Set as Set, Data.Bits)
%%]

%%[8
WRAPPER GrAGItf
%%]

%%[8 hs
grin2silly :: HptMap -> GrModule -> EHCOpts -> SilModule
grin2silly hptmap gr opts
 = let t = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf gr))
                        (Inh_GrAGItf { opts_Inh_GrAGItf = opts
                                     , hptMap_Inh_GrAGItf = hptmap
                                     }
                        )
   in silModule_Syn_GrAGItf t 
%%]

%%[12 hs import({%{EH}Base.Builtin},{%{GRIN}Config})
-- primitive related names which should be globally available, in unqualified form

primGlobalNames :: Set.Set HsName
primGlobalNames
  = Set.fromList
  $ map (hsnPrefix rtsGlobalVarPrefix . hsnQualified)
  $ [ hsnTrue, hsnFalse
%%[[99
    , hsnDataOrderingAltEQ, hsnDataOrderingAltLT, hsnDataOrderingAltGT
%%]]
    ]

hsnToGlobal :: HsName -> HsName
hsnToGlobal n
  = if n2 `Set.member` primGlobalNames then n2 else n
  where n2 = hsnQualified n
%%]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Code generation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%[8

ATTR GrAGItf GrModule GrGlobalL GrGlobal GrBindL GrBind GrExpr GrAlt GrAltL [ hptMap : {HptMap} | | ]

ATTR GrAGItf GrModule   [ | | silModule                  : {SilModule}    ]
ATTR GrBindL GrBind     [ | | functions    USE {++} {[]} : {Functions}    ]
ATTR GrExpr             [ | | stats        USE {++} {[]} : {Statements}   ]
ATTR GrAltL             [ | | alternatives               : {Alternatives} ]
ATTR GrAlt              [ | | alternative                : {Alternative}  ]
ATTR GrVal GrPat GrTag  [ | | value                      : {Value}        ]
ATTR GrPat GrTag        [ | | constant                   : {Constant}     ]
ATTR GrValL GrVal       [ | | values                     : {Values}       ]
ATTR GrGlobal GrGlobalL [ | | initStats    USE {++} {[]} : {Statements}
                              names        USE {++} {[]} : {[HsName]}     ]

ATTR GrExpr GrAlt GrAltL [ numberParameters : {Int}
                         |
                         | localsSet USE {`Set.union`} {Set.empty}: {Set.Set HsName}
                           tailJumps USE {&&} {True} : {Bool}
                         ]

ATTR GrBindL GrBind GrExpr GrAlt GrAltL GrGlobal GrGlobalL [ maxConstrParameters : {Int} | | ]

ATTR GrTagL [ | | mbOnlyTagValue : {Maybe Value}  isEmpty : {Bool} ]

ATTR GrAlt GrAltL [ | | hasAnies USE {||} {False} : {Bool} ]
ATTR GrPat GrTag  [ | | isAny: {Bool} ]
ATTR GrTag GrVal  [ | | isUnboxed: {Bool} ]


SEM GrTagL
  | Nil            lhs . isEmpty        = True
                   lhs . mbOnlyTagValue = Nothing
  | Cons           lhs . isEmpty        = False
                   lhs . mbOnlyTagValue = if @tl.isEmpty
                                           then Just @hd.value
                                           else Nothing

SEM GrAlt
  | Alt            loc . hasAnies = @pat.isAny
 
SEM GrTag
  | Any            lhs . isAny = True
  | * - Any        lhs . isAny = False
  | Unboxed        lhs . isUnboxed = True
  | * - Unboxed    lhs . isUnboxed = False

SEM GrVal
  | Node           lhs . isUnboxed = @tag.isUnboxed
  | * - Node       lhs . isUnboxed = False

SEM GrPat          
  | Tag            lhs . isAny = @tag.isAny
  | * - Tag        lhs . isAny = False
  

ATTR GrValL [ | | length : {Int} ]
SEM GrValL
  | Nil lhs.length = 0
  | Cons lhs.length = 1 + @tl.length


ATTR GrBind GrBindL GrExpr GrAlt GrAltL
         [  |  retNr : {Int} |  ]



ATTR GrExpr GrAltL GrAlt
  [ realNodes: {[HsName]} | | ]
  
ATTR GrExpr
  [  | | mbExtraRealNode: {Maybe HsName} ]


SEM GrExpr
  | FetchField      lhs.mbExtraRealNode = if  @offset==0
                                           then Just @nm
                                           else Nothing
  | * - FetchField  lhs.mbExtraRealNode = Nothing
  
SEM GrExpr
  | Seq             body.realNodes      = maybe id (:) @expr.mbExtraRealNode $ @lhs.realNodes

SEM GrBind
  | Bind            expr.realNodes      = []




%%]

%%[8
SEM GrModule
  | Mod lhs.silModule    =   SilModule_SilModule
                                (tagConstants @evalTagMp)   -- constants
                                @globalL.names              -- variables
                                ( Function_Function (HNm "initialize") False [] []
                                                    ( @globalL.initStats
                                                    ++ [ Statement_Assignment Variable_SP (Value_Offset Variable_BP (0+2))
                                                       , Statement_Return 1
                                                       ]
                                                    )
                                : @bindL.functions            -- functions
                                )

        loc . maxConstrParameters = foldr max 0 (map (ctagArity.snd) (concat (map snd @ctagsMp)))
        bindL . retNr   = 3



SEM GrBind
  | Bind   lhs.functions =  [ Function_Function
                                -- name
                                @nm
                                @expr.tailJumps
                                -- parameters
                                @argNmL
                                -- locals
                                @loc.locals
                                -- body
                                @expr.stats
                            ]

          expr . numberParameters = length @argNmL
          loc  . locals  = filter (\(HNmNr n _)->n/=0) (Set.toList @expr.localsSet)
          loc  . nParams      = if @lhs.optOwnParameters then length @argNmL else 0
          

SEM GrExpr
 | Seq     lhs.stats  = @expr.stats
                        ++ @body.stats

 | UpdateUnit
           loc.name   = mkVar @nm
           loc.overwr = if @val.isUnboxed
                          then [ Statement_Assignment @loc.name (Value_UnboxCon (head(tail @val.values))) ]
                          else []
                                
           lhs.stats   = if @isLastExpr
                          then internal2 "Update" @loc.name @val.values
                               ++ @loc.overwr
                               ++ yielding "Unit" (@lhs.optOwnParameters || @lhs.optOwnLocals) @val.values @lhs.numberParameters
                          else 
                               []
                               -- ++ internal2 "Update" @loc.name @val.values
                               -- ++ internal1 "Unit" @lhs.targets @val.values 
                               ++ internal3 "UpdateUnit" @loc.name @lhs.targets @val.values
                               ++ @loc.overwr                         

 | Unit    lhs.stats  = if @isLastExpr
                          then yielding  "Unit" (@lhs.optOwnParameters || @lhs.optOwnLocals) @val.values @lhs.numberParameters
                          else internal1 "Unit" @lhs.targets @val.values

 | FFI     lhs.stats  = if @isLastExpr
                         then yielding  "FFI" (@lhs.optOwnParameters || @lhs.optOwnLocals) @loc.callres @lhs.numberParameters
                         else internal1 "FFI" @lhs.targets @loc.callres

           lhs.localsSet = Set.fromList @lhs.targets
           loc.callres = maybe id (:) @resTagL.mbOnlyTagValue $ [Value_Call @nm (map (Value_Var . mkVar) @argL)]


 | Store   lhs.stats  = let ph = head @lhs.targets
                            vs = @val.values
                            n  = length vs
                            --n2 = @lhs.maxConstrParameters
                            n2 = maximum (map (length.snd) (getNodes (absFetch @lhs.hptMap ph)))
                        in Statement_Comment ["Store"]
                           : store (mkVar ph) n n2 vs

           lhs.localsSet = Set.fromList @lhs.targets

 | FetchUpdate 
           lhs.stats  = let -- use hptMap to determine size, because hptMap can now be used even after changing numbered variables back to names
                            n = maximum (map (length.snd) (getNodes (absFetch @lhs.hptMap @src)))
                         in Statement_Comment ["FetchUpdate"]
                            : zipWith Statement_Assignment
                                     (map (arrayVariab (mkVar @dst)) [0..n])
                                     (map (arrayValue  (mkVar @src)) [0..n])



 | FetchNode
           lhs.stats  = error "FetchNode found while generating Silly"
           lhs.localsSet= error "FetchNode found while generating Silly"
           
 | FetchField
           lhs.stats  = [ Statement_Comment ["Fetch"]
                        , Statement_Assignment (mkVar (head @lhs.targets))
                                               (if   @offset==1 && maybe False (==GrTag_Unboxed) @mbTag && not (elem @nm @lhs.realNodes)
                                                then Value_BoxVar (mkVar @nm)
                                                else arrayValue (mkVar @nm) @offset
                                               )
                        ]
           lhs.localsSet = Set.fromList @lhs.targets

 | Case    lhs.stats  = [ Statement_Comment ["Case"]
                        , if @altL.hasAnies
                           then Statement_If     @val.value
                                                 @altL.alternatives
                           else Statement_Switch @val.value
                                                 @altL.alternatives
                        ]
                        
           lhs.localsSet = Set.union (Set.fromList @lhs.targets) @altL.localsSet

 | Call    lhs.stats  = if @isLastExpr && @lhs.optJumpTailCalls
                         then [ Statement_Comment ["Call (Tail) "]
                              , Statement_Smart (reverse @argL.values ++ map (Value_Var . Variable_Subs Variable_BP) [1, 0] )
                              , Statement_Assignment  Variable_SP (Value_Offset Variable_BP (@lhs.numberParameters+2- @loc.nMyParams-2))
                              , Statement_Jump @nm
                              ]
                         else (   Statement_Comment ["Call (Normal)"]
                              :   (if @lhs.optOwnParameters
                                   then (  zipWith Statement_Assignment
                                                   (map (arrayVariab Variable_SP) [-1,-2..])
                                                   (  reverse @argL.values
                                                   ++ [ Value_Label ("retlab"++show @lhs.retNr)
                                                      , Value_Cast (Value_Offset Variable_BP 0) True
                                                      ]
                                                   )
                                        ++ [ Statement_Assignment  Variable_SP (Value_Offset Variable_SP (- @loc.nMyParams-2))
                                           , Statement_Call @nm [] 
                                           , Statement_Label ("retlab"++show @lhs.retNr)
                                           ]
                                        )
                                   else [Statement_Call @nm @argL.values ]
                                  )
                              ++ [ Statement_Assignment v e
                                 | (v,e) <-zip  [mkVar x  | x <- @lhs.targets]
                                                ( if @lhs.optOwnParameters || @lhs.optOwnLocals
                                                   then map (arrayValue Variable_SP) [-1,-2..]
                                                   else map (arrayValue Variable_RP) [0..]
                                                )
                                 , isRealVar v
                                 ]
                              )

           loc.nMyParams = @argL.length
           lhs.localsSet = Set.fromList @lhs.targets
           lhs.retNr   = @lhs.retNr + 1

 | App     lhs.stats  = [Statement_Comment ["App: SHOULDNT"]]
 | Eval    lhs.stats  = [Statement_Comment ["Eval: SHOULDNT"]]
 | Throw   lhs.stats  = [Statement_Comment ["Throw: TODO"]]
 | Catch   lhs.stats  = [Statement_Comment ["Catch: TODO"]]


SEM GrAltL
  | Nil    lhs.alternatives = []
  | Cons   lhs.alternatives = @hd.alternative : @tl.alternatives

SEM GrAlt
 | Alt     lhs.alternative = Alternative_Alternative @pat.constant
                                                     @expr.stats


SEM GrGlobal
%%[[8
 | Global  loc.globNm      = @nm
%%][12
 | Global  loc.globNm      = hsnToGlobal @nm
%%]]
 		   lhs.names       = [@globNm]
           lhs.initStats   = let vs = @val.values
                                 n  = length vs
                                 n2 = maximum (map (length.snd) (getNodes (absFetch @lhs.hptMap @globNm)))
                             in  store (Variable_Global @globNm) n n2 vs



SEM GrVal
 | LitInt  lhs.value  = Value_Con (Constant_LiteralInt @int)
 | LitStr  lhs.value  = Value_Con (Constant_LiteralStr @str)
%%[[8
 | Var     loc.value  = Value_Var (mkVar @nm)
%%][12
 | Var     loc.value  = Value_Var (mkVar (hsnToGlobal @nm))
%%]]
           lhs.value  = @loc.value
           lhs.values = [@loc.value]
 | Tag     lhs.value  = @tag.value
 | Node    lhs.values = @tag.value : @fldL.values
 | * - LitInt LitStr Var Tag
           lhs.value  = error "GrVal:other value"
 | * - Node Var
           lhs.values = error "GrVal:other values"

SEM GrValL
 | Nil    lhs.values = []
 | Cons   lhs.values = @hd.value : @tl.values

SEM GrTag
 | Lit     loc.constant = Constant_Alias (tagName @categ @nm)
           lhs.constant = @loc.constant
           lhs.value    = Value_Con (@loc.constant)
 | Var     lhs.value    = Value_Var (mkVar @nm)
 | Unboxed lhs.value    = Value_Con (Constant_Alias "UNBOXED")
 | Any     lhs.value    = error "GrTag:Any value"
 | Unboxed lhs.constant = Constant_Alias "UNBOXED"
 | Any     lhs.constant = Constant_Alias "ANY"
 | * - Lit Unboxed Any
           lhs.constant = error "GrTag:other constant"

SEM GrPat
 | Tag     lhs.value    = @tag.value
           lhs.constant = @tag.constant
 | * - Tag lhs.value    = error "GrPat:other value"
           lhs.constant = error "GrPat:other constant"



SEM GrExpr
 | Seq     lhs.tailJumps = @body.tailJumps
 | Call    lhs.tailJumps = @isLastExpr && @lhs.optJumpTailCalls
 | Case    lhs.tailJumps = @altL.tailJumps
 | * - Seq Call Case
           lhs.tailJumps = False


%%]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Determining the target
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%[8

ATTR AllGrExpr [ targets : {[HsName]} | | ]
ATTR GrPat GrTag [ | |  patternNames: {[HsName]} ]

SEM GrBind
  | Bind     expr . targets = []

SEM GrExpr
  | Seq      expr . targets = @pat.patternNames
             body . targets = @lhs.targets

SEM GrPat
  | Var   lhs  .  patternNames = [@nm]
  | Node  lhs  .  patternNames = @tag.patternNames ++ @fldL
  | * - Var Node Tag  lhs  .  patternNames  =  []

SEM GrTag
  | Var      lhs  .  patternNames  = [@nm]
  | Unboxed  lhs  .  patternNames  = [wildcardNr]
  | * - Var Unboxed lhs  .  patternNames  = [wildcardNr]
%%]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Options to adapt the structure of the generated code
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%[8


ATTR GrAGItf
  [ opts : {EHCOpts} | | ]

ATTR GrModule GrBind GrBindL GrExpr GrAlt GrAltL
  [ optJumpTailCalls : {Bool} -- when True, tail calls are implemented with a goto
    optOwnParameters : {Bool} -- when True, parameter passing is via the Stack datastructure
    optOwnLocals     : {Bool} -- when True, local variables are allocated on the Stack datastructure
  | | ]

SEM GrAGItf
  | AGItf loc.optOwnParameters   = ehcOptGenOwnParams @lhs.opts
          loc.optOwnLocals       = ehcOptGenOwnLocals @lhs.opts
          loc.optOwnCalls        = ehcOptGenOwnCalls  @lhs.opts
          loc.optGenAsmSP        = ehcOptGenAsmSP     @lhs.opts
          loc.optJumpTailCalls   = ehcOptGenTailCall  @lhs.opts
          -- Force some options to imply some others
          module.optOwnParameters = @loc.optOwnParameters  || @loc.optOwnLocals || @loc.optJumpTailCalls || @loc.optOwnCalls || @loc.optGenAsmSP
          module.optOwnLocals     =                           @loc.optOwnLocals || @loc.optJumpTailCalls || @loc.optOwnCalls || @loc.optGenAsmSP
          
%%]





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Auxiliary Haskell
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%[8 hs

yielding what own values numberParameters
  =  let nMyRes  = length values
         moveRet = nMyRes > numberParameters
     in  Statement_Comment [what ++ " (Yielding)"]
         : if own
            then [ Statement_Smart (values ++ [Value_Var (Variable_Subs Variable_BP 1) | moveRet])
                 , Statement_Assignment Variable_SP (Value_Offset Variable_BP (numberParameters+2))
                 , Statement_Return (max nMyRes numberParameters + 1)
                 ]
            else [ Statement_Assignment v e
                 | (v,e) <-zip [arrayVariab Variable_RP i | i <- [0..] ]
                               values
                 ]

internal1 what targets values
   = Statement_Comment [what ++ " (Internal)"]
     : [ Statement_Assignment v e
       | (v,e) <-zip [mkVar x | x <- targets]
                     values
       , isRealVar v
       ]                         

internal2 what name values
  =  Statement_Comment [what] 
     :  
     --Statement_Assignment Variable_Ptr (Value_Var @loc.name) :                -- if this line is enabled, uses option 2 instead of option 1
     zipWith Statement_Assignment
             (map (arrayVariab name) [0..])                                -- option 1
             --(map (Variable_Subs Variable_Ptr) [0..])   -- option 2
             values
                        

internal3 what name targets values
  = Statement_Comment [what] 
    :
    [ if isRealVar v1
       then (if isRealVar v2
              then Statement_Assignment2 v2 v1 e
              else Statement_Assignment v1 e
            )
       else Statement_Assignment v2 e
    | (v1,v2,e) <-zip3 (map (arrayVariab name) [0..])
                       [mkVar x | x <- targets]
                       values
    , isRealVar v1 || isRealVar v2
    ]













isRealVar Variable_None = False
isRealVar (Variable_Unembedded (HNmNr 0 _)) = False
isRealVar _             = True

-- n1 is the number of parameters of the tag
-- n2 is the maximum number of parameters of all constructorfunctions
-- tags other than C may be overwritten later with a C-tag, which might have more parameters.
-- We anticipate here for the maximum number of parameters.
-- Obvious improvement: do not take the global maximum, but only the maximum over the constructors
-- that are actually possible for this function.
-- Source of this information could be the Haskell-type, or the Grin HPT-analysis.

allocate :: Char -> Int -> Int -> Value
allocate 'C' n1 _  = Value_Alloc n1
allocate _   n1 n2 = Value_Alloc (max n1 n2)
       
-- tagcat is "C" for constructors, "F" for function thunks, "P" for partialapp thunks, "U" for unboxed, etc.
tagcat :: [Value] -> Char
tagcat (Value_Con (Constant_Alias (c:_)):_) = c
tagcat _ = ' '


mkVar :: HsName -> Variable
mkVar = Variable_Unembedded

store :: Variable -> Int -> Int -> [Value] -> Statements
store v n1 n2 vs
       =  let cat = tagcat vs
          in  if    cat=='U'
              then [Statement_Assignment v (Value_UnboxCon (head (tail vs)))]
              else Statement_Assignment v (allocate cat n1 n2)
                   : zipWith Statement_Assignment
                             (map (arrayVariab v) [0..])
                             vs

arrayValue :: Variable -> Int -> Value
arrayValue a i = Value_Var (Variable_Subs a i)

arrayVariab :: Variable -> Int -> Variable
arrayVariab a i = Variable_Subs a i

tagConstants :: EvApTagMp -> [(String,Int)]
tagConstants eas
 = let f ((t,s),k) n = (showGrTag t,n)
   in  zipWith f eas [0..]



showGrTagCateg :: GrTagCateg -> String
showGrTagCateg (GrTagPApp need) = "P" ++ show need ++ "_"
showGrTagCateg x = showGrTagCategLetter x


tagName categ nm = showGrTagCateg categ ++ hsnShowAlphanumeric nm

showGrTag :: GrTag -> String
showGrTag (GrTag_Lit categ n nm) = tagName categ nm
showGrTag (GrTag_Var nm) = hsnShowAlphanumeric nm
showGrTag (GrTag_Unboxed) = "GrTag:Unboxed"
showGrTag (GrTag_Any    ) = "GrTag:Any"

%%]
