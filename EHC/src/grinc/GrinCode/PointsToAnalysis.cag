TODO: Mark unique variables as Unique

%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[8 import({GrinCode/AbsSyn})
%%]

%%[8 hs module {%{GRIN}GrinCode.PointsToAnalysis} import(Data.List(transpose), Debug.Trace)
%%]

%%[8.wrapper
WRAPPER GrAGItf
%%]

%%[8 hs import(qualified Data.Map as Map, qualified Data.Set as Set, Data.Maybe, Control.Monad, Control.Monad.ST, Data.Array.ST, Data.Array.IArray)
%%]

%%[8 hs import(Debug.Trace)
%%]
%%[8 hs import(System.IO.Unsafe(unsafePerformIO))
%%]

%%[8 hs import({%{GRIN}GRINCCommon}, {%{EH}Base.Common}, {%{EH}GrinCode},{%{GRIN}HeapPointsToFixpoint}) export(heapPointsToAnalysis)

fromJust' _ (Just a ) = a
fromJust' m (Nothing) = error $ "fromJust: " ++ m

-- a grin node is either a single variable or a complete node (with a known tag)
type NodeInfo a = Either Int (GrTag, [a])

type Action          = ST RealWorld ()
type EnvAction       = ST RealWorld (AbstractEnv RealWorld)
type EnvAction2      = ST RealWorld (STArray RealWorld Variable AbstractEnvModifier)
type HeapAction      = ST RealWorld (AbstractHeap RealWorld)
type SetEnv          = Variable -> AbstractEnvModifier -> Action
type GetEnv          = Variable -> ST RealWorld AbstractEnvModifier

absEnvEltNoEquat v
   =  EnvSetAV (AV_Error ("no equation for variable " ++ show v))
                         
makeHeapElem l eq =  (l, AbstractHeapElement  {  ahBaseSet = AV_Nothing
                                              ,  ahSharedSet = Just AV_Nothing
                                              ,  ahMod = eq
                                              }
                     )


heapPointsToAnalysis :: Int -> GrModule -> (Int,HptMap)
heapPointsToAnalysis unique grmod 
    = unsafePerformIO $ stToIO $ 
    do
    { let low      = 3
          high     = unique-1
          applyArg = low - 1 ;
          
    -- create an empty environment          
    ; envMods <- (newArray_ (applyArg,high) )  :: EnvAction2
    ; foldM_ (\_ v -> writeArray envMods v (absEnvEltNoEquat v)) () [applyArg..high]

    -- functions that can update the environment, w.r.t. its 2nd and 3rd component
    --       and that can read the environment (all components, but the 1st is always AV_Nothing)
    ; let setEnvVar v  eq = writeArray envMods v eq
    ; let getEnvVar v     = readArray  envMods v
    
    -- traverse the program, allowing updates to the environment using the functions above
    ; let inh = Inh_GrAGItf { setEnvVar_Inh_GrAGItf  = setEnvVar
                            , getEnvVar_Inh_GrAGItf  = getEnvVar
                            , tmpVar_Inh_GrAGItf     = applyArg
                            }
    ; let syn = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf grmod)) inh

    -- we get three synthesized attributes
    -- execute the first to actually update the environment
    ;                 fillEnv_Syn_GrAGItf syn
    -- execute the first to create an abstract heap
    ; absHeap     <- makeHeap_Syn_GrAGItf syn
    -- use the third to retrieve the applyMap for later use
    ; let applyMap = applyMap_Syn_GrAGItf syn

    -- reset the value of the temporary variable in the environment
    ; setEnvVar applyArg (EnvSetAV AV_Nothing)


    ; absEnv  <- (newArray (applyArg,high) AV_Nothing)    :: EnvAction
    ; envMods <- unsafeFreeze envMods

    -- now solve the equations
    ; count   <- solveEquations envMods absEnv absHeap applyMap
    ; absHeap <- unsafeFreeze absHeap
    ; absEnv  <- unsafeFreeze absEnv
    ; return (count, ((absEnv, absHeap), Map.empty))
    }
%%]

%%[8.toplevelCombining
ATTR GrAGItf GrModule AllGlobal AllBind AllGrExpr [ getEnvVar: {GetEnv}  setEnvVar: {SetEnv} tmpVar: Variable | | fillEnv USE {>>} {return ()}: {Action} ]
ATTR         GrModule AllGlobal AllBind AllGrExpr [ | heapList: {[(Location, AbstractHeapElement)]} | ]
ATTR GrAGItf                                      [ | | makeHeap: HeapAction ]

SEM GrAGItf
  | AGItf  lhs     .  makeHeap  =  do { arr <- newArray_ (0, @module.heapPointer - 1)
                                      ; mapM (uncurry $ writeArray arr ) @module.heapList
                                      ; return arr
                                      }
           module  . heapList   =  []

SEM GrBind
  | Bind  loc  .  prune     = (@nm == evalNr) || (@nm == applyNr)
          lhs  .  heapList  = if @prune then @lhs.heapList else @expr.heapList
               .  fillEnv   = if @prune then (return ()) else @fillEnvBind >> @exceptEq >> @expr.fillEnv
%%]


%%%%%%%%%%%%%%%%%%%%%%
%% evalMap/applyMap %%
%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR AllGlobal AllBind AllGrExpr [ evalMap: {EvalMap} | | ]
ATTR GrModule GrAGItf [ | | applyMap : {ApplyMap} ]

SEM GrModule
  | Mod     loc . evalMap = [ (t, f) | ((t,_), EvApTagVar (HNmNr f _)) <- @evalTagMp ]
            loc . applyMap = let rewrite (EvApTagVar (HNmNr f _)) = Right f
                                 rewrite (EvApTagTag t          ) = Left  t
                             in [ (t, rewrite v) | ((t,_), v) <- @applyTagMp ]
%%]

%%%%%%%%%%%%%%%%%%%%%
%% Unique Pointers %%
%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR GrModule AllBind AllGlobal AllGrExpr [ | heapPointer: Int | ]
SEM GrAGItf
  | AGItf  module . heapPointer = 0
%%]

%%%%%%%%%%%%%
%% TagName %%
%%%%%%%%%%%%%

%We use the name @UNBOXED for unboxed nodes.
%Any other node should have a named tag.

%%[8.tagName
SEM GrTag [ | | tagName: SELF ]
  | Var     lhs . tagName = error "Tag variables are not allowed in GRIN Points-To Analysis"
%%]


%%%%%%%%%%%%%%%%
%% value Info %%
%%%%%%%%%%%%%%%%

A grin value is either a single variable or a complete node (known tag)

%%[8.valInfo
SEM GrValL [ | | valsInfo : {[NodeInfo (Maybe Int)]}]
  | Cons      lhs . valsInfo = @hd.valInfo : @tl.valsInfo
  | Nil       lhs . valsInfo = []

SEM GrVal [ | | valInfo : {NodeInfo (Maybe Int)}]
  | Node      lhs . valInfo = Right (@tag.tagName, @fldL.depVars)
  | Tag       lhs . valInfo = Right (@tag.tagName, [])
  | Var       lhs . valInfo = Left (getNr @nm)
  | Empty     lhs . valInfo = error "no empty value expected!"
  | LitInt LitStr
              lhs . valInfo = error "no literal value expected!"
  | NodeAdapt lhs . valInfo = error "no support for NodeAdapt"
%%]

%%[8.depVars
SEM GrVal  [ | | depVar:  {Maybe Int} ]
  | Var      lhs . depVar = Just (getNr @nm)
  | * - Var  lhs . depVar = Nothing
SEM GrValL [ | | depVars: {[Maybe Int]}  ]
  | Cons     lhs . depVars = @hd.depVar : @tl.depVars
  | Nil      lhs . depVars = []
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%
%% Pattern Information %%
%%%%%%%%%%%%%%%%%%%%%%%%%

A grin pattern is either a single variable or a compete node pattern (known tag)

%%[8.patInfo
SEM GrPat [ | | patInfo: {NodeInfo Int} ]
  | Node       lhs . patInfo = Right (@tag.tagName, map getNr @fldL)
  | Tag        lhs . patInfo = Right (@tag.tagName, [])
  | Var        lhs . patInfo = Left (getNr @nm)
  | Empty      lhs . patInfo = Left (getNr wildcardNr)
  | LitInt     lhs . patInfo = error "literal int in pattern? I did not know that..."
  | NodeSplit  lhs . patInfo = error "no support for NodeSplit"
%%]

%%%%%%%%%%%%%%%%%%%%%%%%
%% Target Information %%
%%%%%%%%%%%%%%%%%%%%%%%%

The target info is basicly the pattern information. However, for the last
expression in a binding it is the result variable of that binding.

%%[8.targetInformation
ATTR AllGrExpr [ targetInfo: {NodeInfo Int} | exceptions: {[Int]} | ]

SEM GrBind
  | Bind  loc  . resultVar   =  getNr @nm
          expr . targetInfo  =  Left @resultVar

SEM GrExpr
  | Seq    expr     .  targetInfo = @pat.patInfo
           body     .  targetInfo = @lhs.targetInfo
%%]

4 possibilities of source and target info

%%[8.genInfo hs
genInfo :: NodeInfo a
        -> NodeInfo b
        -> (Int->Int->c)
        -> (Int->GrTag->[b]->c)
        -> (GrTag->[a]->Int->c)
        -> (GrTag->[a]->GrTag->[b]->c)
        -> c
genInfo sourceInfo targetInfo llf lrf rlf rrf =
  case (sourceInfo, targetInfo) of
    (Left  sn      , Left  tn       ) -> llf sn     tn
    (Left  sn      , Right (tt, tns)) -> lrf sn     tt  tns
    (Right (st,sns), Left  tn       ) -> rlf st sns tn
    (Right (st,sns), Right (tt, tns)) -> rrf st sns tt  tns
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%
%% Unit %%
%%%%%%%%%%

unit node;           -> \n              => n:
                                             absVal = Nothing
                                             envMod = Union [node]
unit (Tag e1 .. en); -> \n              => n:
                                             absVal = Tag[(absVal e1), .., (absVal en)]
                                             envMod = Tag[(depVar e1), .., (depVar en)]
unit node;           -> \(Tag e1 .. en) => e1:
                                             absVal = Nothing
                                             envMod = node ! Tag ! 1
                                           en:
                                             absVal = Nothing
                                             envMod = node ! Tag ! n
unit (Tag d1 .. dn); -> \(Tag e1 .. en) => e1:
                                             absVal = (absVal d1)
                                             envMod = Union (depVar d1)
                                           en:
                                             absVal = (absVal dn)
                                             envMod = Union (depVar dn)

note: The resultVar will always be Nothing.
      A node not in the heap representing a function is strange at least...

%%[8.unit
SEM GrExpr
  | Unit   loc . fVar2Var   = \s t         -> @lhs.setEnvVar t (EnvUnion1 [s])
               . fNode2Var  = \tag names t -> let resultVar = lookup tag @lhs.evalMap
                                                  env       = @lhs.setEnvVar t (EnvTag tag names Nothing)
                                              in env
               . fVar2Node  = buildSelectElems @lhs.setEnvVar
               . fNode2Node = \st snms tt tnms -> let sn2mod = maybe (EnvSetAV AV_Basic) (\x -> EnvUnion1 [x])
                                                      toEnvElem sn tn = if tn == getNr wildcardNr
                                                                        then return ()
                                                                        else @lhs.setEnvVar tn (sn2mod sn)
                                                  in zipWithM_ toEnvElem snms tnms -- note: st == tt
               . fillEnv    = genInfo @val.valInfo @lhs.targetInfo @fVar2Var @fVar2Node @fNode2Var @fNode2Node
%%]

%%[8.selectVar hs
buildSelectElems :: SetEnv -> Variable -> GrTag -> [Variable] -> Action
buildSelectElems setEnvVar selectVar tag nms
  = let step (i, f) v     = (i+1, if v == getNr wildcardNr then f else f >> setEnvVar v (EnvSelect selectVar tag i))
        (count, envElems) = foldl step (0, return ()) nms
    in envElems
%%]


%%%%%%%%%%%
%% Store %%
%%%%%%%%%%%

store (Tag e1 .. en); -> \n              => n:
                                              absVal = newLocation
                                              envMod = setAV absVal
                                            newLocation:
                                              absVal  = Tag[(absVal e1), .., (absVal en)]
                                              heapMod = Tag[(depVar e1), .., (depVar en)] |_| resultVar(Tag)

%%[8.store
SEM GrExpr
  | Store  loc . (heapPointer, fillEnv, heapElem) = makeStore @lhs.setEnvVar
                                                              @lhs.evalMap
                                                              @lhs.heapPointer
                                                              @val.valInfo
                                                              @lhs.targetInfo
           lhs . heapList  = @heapElem : @lhs.heapList
%%]

%%[8.store hs
makeStore setEnvVar evalMap heapPointer valInfo targetInfo
    = let fNode2Var  tag names t = let resultVar   = lookup tag evalMap
                                       av          = AV_Locations (Set.singleton heapPointer)
                                       env         = setEnvVar t envMod
                                       heap        = makeHeapElem heapPointer
                                                                 ((tag, names), resultVar)
                                       envMod      = EnvSetAV av
                                   in ( env, heap )
          fVar2Var   = error "Single variable in a store not allowed!"
          fVar2Node  = error "No location variable afer a store!"
          fNode2Node = error "No location variable afer a store! (And always store a node!)"
          (fillEnv, absHeap) = genInfo valInfo targetInfo fVar2Var fVar2Node fNode2Var fNode2Node
      in (heapPointer + 1, fillEnv, absHeap)
%%]

%%%%%%%%%%
%% Eval %%
%%%%%%%%%%

eval(l); -> \n              => n:
                                 absVal = AV_Nodes []
                                 envMod = Eval l

the next is not needed because of normalisation:

eval(l); -> \(Tag e1 .. en) => @eval@l:
                                 absVal = Nothing
                                 envMod = Eval l
                               e1:
                                 absVal = Nothing
                                 envMod = @eval@l ! Tag ! 1
                               en:
                                 absVal = Nothing
                                 envMod = @eval@l ! Tag ! n
%%[8.eval
SEM GrExpr
  | Eval   loc . fillEnv = case @lhs.targetInfo of
                             Left  n           -> @lhs.setEnvVar n (EnvEval (getNr @nm) @lhs.exceptVar)
                             Right (tag,names) -> error "NormForHPT not executed"
%%]

%%%%%%%%%%
%% Call %%
%%%%%%%%%%

foo a1 .. an; -> \n             => n:
                                     absVal = Nothing
                                     envMod = Union [@foo]

foo a1 ..an; -> \(Tag e1 .. en) => e1:
                                     absVal = Nothing
                                     envMod = @foo ! Tag ! 1
                                   en:
                                     absVal = Nothing
                                     envMod = @foo ! Tag ! n
%%[8.call
SEM GrExpr
  | Call  loc  .  resultVar   =  getNr @nm
               .  fillEnv     =  case @lhs.targetInfo of
                                     Left  n           -> @lhs.setEnvVar n (EnvUnion1 [@resultVar])
                                     Right (tag,names) -> buildSelectElems @lhs.setEnvVar @resultVar tag names
               .  exceptions  =  @resultVar + 1 : @lhs.exceptions
%%]

%%%%%%%%%%%%%%%%%%%%%%
%% Case Alternative %%
%%%%%%%%%%%%%%%%%%%%%%

case node of (T e1 .. en)             => e1:
                                           absVal = Nothing
                                           envMod = node ! Tag ! 1
                                         en:
                                           absVal = Nothing
                                           envMod = node ! Tag ! n

the following is not needed because of normalisation
case (Tag d1 .. dn) of (Tag e1 .. en) => e1:
                                           absVal = (absVal d1)
                                           envMod = Union (depVar d1)
                                         en:
                                           absVal = (absVal dn)
                                           envMod = Union (depVar dn)

%%[8.alt
ATTR AllAlt [ valInfo: {NodeInfo (Maybe Int)} | | ]

SEM GrAlt
  | Alt  loc . fVar2Node  = buildSelectElems @lhs.setEnvVar
             . fNode2Node = error "NormForHPT not executed"
             . fVar2Var   = error "no variable in alternative pattern expected!"
             . fNode2Var  = error "no variable in alternative pattern expected!"
             . fillEnv    = genInfo @lhs.valInfo @pat.patInfo @fVar2Var @fVar2Node @fNode2Var @fNode2Node
         lhs . fillEnv    = @fillEnv >> @expr.fillEnv
%%]

%%%%%%%%%%%%%%%%%%%%
%% Case and Catch %%
%%%%%%%%%%%%%%%%%%%%

We can have multiple arms in a case, how do we merge the result of each arm?

Since we normalise each case to end with a simple unit (e.g. unit v). So we
collect the last elements of the arms and join these afterwards.

We use the targetName of the wildcard variable so that these last equations and
partial collections are filtered afterwards.

%%[8.case
SEM GrAltL
  | Cons  lhs   .   fillEnv    =  do { @hd.fillEnv
                                     ; elem <- @lhs.getEnvVar @lhs.tmpVar
                                     ; let (EnvUnion1 hdn) = elem
                                     ; @tl.fillEnv
                                     ; elem <- @lhs.getEnvVar @lhs.tmpVar
                                     ; let (EnvUnion1 tln) = elem
                                     ; @lhs.setEnvVar @lhs.tmpVar (EnvUnion1 (tln ++ hdn))
                                     }
  | Nil   lhs   .   fillEnv    =  @lhs.setEnvVar @lhs.tmpVar (EnvUnion1 [])
SEM GrAlt
  | Alt  expr   .  targetInfo   =  Left @lhs.tmpVar

SEM GrExpr
  | Case   loc   .  fillEnv     =  case @lhs.targetInfo of
                                     Left resVar     -> do { elem <- @lhs.getEnvVar @lhs.tmpVar
                                                           ; @lhs.setEnvVar resVar elem
                                                           }
                                     Right (tag,nms) -> error "No node expected after a case expression!"
           lhs   .  fillEnv     =  @altL.fillEnv >> @fillEnv
  | Catch  loc   .  targetInfo  =  Left @lhs.tmpVar
           lhs   .  fillEnv     =  do { @body.fillEnv
                                      ; elem <- @lhs.getEnvVar @lhs.tmpVar
                                      ; let (EnvUnion1 bn) = elem
                                      ; @handler.fillEnv
                                      ; elem <- @lhs.getEnvVar @lhs.tmpVar
                                      ; let (EnvUnion1 hn) = elem
                                      ;  case @lhs.targetInfo of
                                           Left resVar     -> @lhs.setEnvVar resVar (EnvUnion1 (bn ++ hn))
                                           Right (tag,nms) -> error "No node expected after a Catch expression!"
                                      ; @exceptEq
                                      }
%%]

%%%%%%%%%%
%% FFI %%%
%%%%%%%%%%

ffi "primFoo"; \(Tag e1 en)  => e1:
                                  absVal = prim(Foo) ! Tag ! 1
                                  envMod = SetAv absVal
                                en:
                                  absVal = prim(Foo) ! Tag ! n
                                  envMod = SetAV absVal
ffi "primFoo"; \r            => r:
                                 absVal  = prim(Foo)

ffi "foo"; \(Tag e1 e2)      => note: (Tag == Unboxed)
                                e1: Basic
                                en: Basic

%%[8.ffi

ATTR AllGrTag [ | | self: SELF ]

SEM GrExpr
  | FFI  loc . primAbsVal = let l = case @resTagL.self of
                                      (GrTag_Unboxed : _) -> [(GrTag_Unboxed,[AV_Basic])]
                                      ts                  -> map (\t -> (t,avForArity)) ts
                            in  AV_Nodes (Map.fromList l)
             . prim       = case @lhs.targetInfo of
                              Left nm          -> @lhs.setEnvVar nm (EnvSetAV @primAbsVal)
                              Right (tag, nms) -> let (AV_Nodes nodes) = @primAbsVal
                                                      tagElementsAV    = fromJust' "PointsToAnalysis.GrExpr.FFI" $ Map.lookup tag nodes
                                                      makeAV teAV nm   = @lhs.setEnvVar nm (EnvSetAV teAV)
                                                  in zipWithM_ makeAV tagElementsAV nms
             . ffi        = case @lhs.targetInfo of
                              Left  nm         -> error "FFI should be followed by an unboxed node pattern"
                              Right (tag, nms) -> mapM_ (\e -> @lhs.setEnvVar e (EnvSetAV AV_Basic)) nms
             . fillEnv    = if isPrim @nm then @prim else @ffi
%%]
  | FFI  loc . primAbsVal = primAV @nm

Note: we have the ctable, can we do something with that?
      e.g. we could get the result Tags from it. If we save result type for a FFI.

%%[8.prim hs import({%{GRIN}Primitives})
%%]

%%%%%%%%%%%
%% Apply %%
%%%%%%%%%%%

Every call to apply equals to an rewrite using the apply map. We must join all
these apply into one argument, so we join them in a list and put them in the
equation array at the top level.

apply (P2upto  ) a => (P1upto a)
apply (P1upto a) b => (Fupto  a b)


apply (P/1/apply f) a == apply f a  -- a P/1/apply should not occur? right?!

notes: - all tags should be of type Partial application
       - all tags should miss the same number of arguments

eval (Fapply a b)

%%[8.apply
SEM GrExpr
  | App    loc . fillEnv  = case @lhs.targetInfo of
                              Right (tag, nms) -> error "Apply bound to pattern?!"
                              Left  nm         -> let makeAppArgInfo = map mkAppInfo
                                                      mkAppInfo :: NodeInfo (Maybe Int) -> Either Variable AbstractEnvModifier
                                                      mkAppInfo l = case l of
                                                                        Left  v  -> Left v
                                                                        Right n  -> error $ "Node in apply argument not implemented: " ++ show n
                                                  in @lhs.setEnvVar nm (EnvApp (getNr @nm) (makeAppArgInfo @argL.valsInfo) @lhs.exceptVar)

%%]


%%%%%%%%%%%
%% Fetch %%
%%%%%%%%%%%

%%[8.fetch
SEM GrExpr
  | Fetch  loc . fillEnv  =  case @lhs.targetInfo of
                                  Left resVar     -> do { elem <- @lhs.getEnvVar (getNr @nm)
                                                        ; @lhs.setEnvVar resVar elem
                                                        }
                                  Right (tag,nms) -> error "HPT expects variable after fetch, not a node"


%%]

%%%%%%%%%%%%
%% Update %%
%%%%%%%%%%%%

%%[8.update

ATTR GrVal [ | | getName : {HsName} ]

SEM GrVal
  | Var      lhs.getName = @nm
  | * - Var  lhs.getName = error "HPT expects variable in update"


SEM GrExpr
  | Update  loc . fillEnv  =  @lhs.setEnvVar (getNr @nm) (EnvUnion1 [getNr @nm, getNr @val.getName])
                                 
%%]


%%%%%%%%%%%%%%%%%
%% FetchUpdate %%
%%%%%%%%%%%%%%%%%

%%[8

SEM GrExpr
  | FetchUpdate  loc . fillEnv  =  @lhs.setEnvVar (getNr @dst) (EnvUnion1 [getNr @dst, getNr @src])
                                 
%%]


%%%%%%%%%%%
%% Throw %%
%%%%%%%%%%%

TODO: targetInfo should allow empty patterns to be expressed

%%[8.throw
SEM GrExpr
  | Throw  loc  .  exceptions  =  getNr @nm : @lhs.exceptions
                .  fillEnv     =  case @lhs.targetInfo of
                                      Left  n | n /= getNr wildcardNr -> @lhs.setEnvVar n (EnvSetAV AV_Nothing)
                                      otherwise                       -> return ()
%%]

%%%%%%%%%%%
%% Catch %%
%%%%%%%%%%%

%%[8.catch
SEM GrExpr
  | Catch  body    . exceptions  =  []
                   . exceptVar   =  @handlerVar
           handler . exceptions  =  @lhs.exceptions
           lhs     . exceptions  =  @handler.exceptions
           loc     . exceptEq    =  @lhs.setEnvVar @handlerVar (EnvUnion1 @body.exceptions)
                   . handlerVar  =  getNr @arg
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Non local exceptions %%
%%%%%%%%%%%%%%%%%%%%%%%%%%

Exceptions not caught in the same binding, and support for exceptions which can only found while analysing (eval calls)

%%[8.catch
ATTR AllGrExpr [ exceptVar: Variable | | ]
SEM GrBind
  | Bind  expr    . exceptions  =  []
          loc     . exceptVar   = @resultVar + 1
          loc     . exceptEq    =  @lhs.setEnvVar @exceptVar (EnvUnion1 @expr.exceptions)
%%]


%%%%%%%%%%%%%
%% Actuals %%
%%%%%%%%%%%%%

%%[8.actuals
ATTR AllNT [ | | actualsEnv USE {.} {id} : {[(Int, [Maybe Int])] -> [(Int, [Maybe Int])]} ]
ATTR AllBind [ allActuals: {[(Int, [Maybe Int])]} | | ]

SEM GrExpr
  | Store Unit  loc  .  fGenActuals  = \tag mns n -> let args      = if grinStoreArity
                                                                      then tail mns -- first element is the size of the rest of the node
                                                                      else      mns
                                                         resultVar = lookup tag @lhs.evalMap
                                                         actuals r = ((r, args) :)
                                                     in maybe id actuals resultVar
                loc  .  actualsEnv   = case (@val.valInfo, @lhs.targetInfo) of
                                           (Right (st,snms), Left tn) -> @fGenActuals st snms tn
                                           otherwise                  -> id
  | Call        loc  .  actualsEnv   = ((@resultVar, @argL.depVars) :)

SEM GrModule
  | Mod       bindL  .  allActuals   = @bindL.actualsEnv []

SEM GrBind
  | Bind      loc    .  bindActuals  = transpose [ actuals
                                                 | (resVar, actuals) <- @lhs.allActuals
                                                 , resVar == @resultVar
                                                 ]
                     .  fillEnvBind  = let envElem (formal, i) actuals
                                            = @lhs.setEnvVar (getNr formal)
                                                             (EnvUnion2 [ actual | Just actual <- actuals] @lhs.tmpVar (GrTag_Var @nm) i)
                                       in zipWithM_ envElem
                                                    (zip @argNmL [(if grinStoreArity then 1 else 0)..])
                                                    ( if    null @bindActuals
                                                       then replicate (length @argNmL) []
                                                       else @bindActuals
                                                    )
                     .  actualsEnv   = if @prune then id else @expr.actualsEnv
                     .  applySelect  = EnvSelect @lhs.tmpVar (GrTag_Var @nm)
%%]

%%%%%%%%%%%%%
%% Globals %%
%%%%%%%%%%%%%

The globals look like the expression

store (Tag f1 fn); \bla ->

%%[8.global
SEM GrGlobal
  | Global  loc  .  (heapPointer, fillEnv, heapElem)  =  makeStore @lhs.setEnvVar @lhs.evalMap @lhs.heapPointer @val.valInfo (Left $ getNr @nm)
            lhs  .  heapList                          =  @heapElem : @lhs.heapList
%%]
