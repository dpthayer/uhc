%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]
%%[8 import({GrinCode/AbsSyn})
%%]
%%[8.wrapper
WRAPPER GrAGItf
%%]
%%[8 hs module {%{GRIN}GrinCode.PointsToAnalysis}
%%]
%%[8 hs import(qualified Data.Map as Map, qualified Data.Set as Set, Data.Maybe, Data.List(transpose))
%%]
%%[8 hs import({%{EH}Base.Common}, {%{EH}GrinCode})
%%]
%%[8 hs import({%{GRIN}GRINCCommon}, {%{GRIN}HeapPointsToFixpoint})
%%]
%%[8 hs import(Debug.Trace)
%%]


%%[8 hs export(heapPointsToAnalysis)

{-
Main module entry point:
Given a Grin-program, traverse it and collect equations for variables and locations.
Then solve the constraints, and return the resulting abstract environment&heap: the "HptMap".
As an additional Int parameter, take the first number that is not the number of any variable.
Also return it, possibly modified.
As an additional Int result, return the number of iterations that it took to solve the equations.
-}

heapPointsToAnalysis :: GrModule -> Int -> (Int,Int,HptMap)
heapPointsToAnalysis grmod unique
  = let -- traverse the tree
        inh = Inh_GrAGItf { location_Inh_GrAGItf = 0, unique_Inh_GrAGItf = unique  }
        syn = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf grmod)) inh

        -- get four synthesized attributes
        equations = equations_Syn_GrAGItf syn
        heapEqs   = heapEqs_Syn_GrAGItf syn
        applyMap  = applyMap_Syn_GrAGItf syn
        lenHeap   = location_Syn_GrAGItf syn
        
        -- now solve the equations
        (iterCount,hptMap) = solveEquations unique lenHeap equations heapEqs applyMap
        
        -- no new variables were introduced in the tree traversal, 
        -- but the equation-solver uses a variable for each applyMap-entry
        unique2   = unique + Map.size applyMap
        
     in (iterCount, unique2, hptMap)
     
%%]

%%%%%%%%%%%%%%%%%%%%%
%% Main attributes %%
%%%%%%%%%%%%%%%%%%%%%
%%[8
{- 
The overall goal is to collect equations that express
what constraints variables and heaplocations satisfy.
-}

ATTR GrAGItf GrModule AllGlobal AllBind AllGrExpr [ | | equations  USE {++} {[]} : {Equations}
                                                        heapEqs    USE {++} {[]} : {HeapEquations}
                                                  ]

{-
The EvalMap (slightly rewritten) is passed down to all expressions, and passed up to the Module itself
The ApplyMap (slightly rewritten) is passed up to the root
A unique integer "location" is threaded through all expressions to number all Stores locations
The value "unique", the first unused variable number, is made available to the root
-}

ATTR                  AllGlobal AllBind AllGrExpr [ evalMap: {EvalMap} |               |                       ]
ATTR         GrModule                             [                    |               | evalMap  : {EvalMap}  ]
ATTR GrAGItf GrModule                             [                    |               | applyMap : {ApplyMap} ]
ATTR GrAGItf GrModule AllGlobal AllBind AllGrExpr [                    | location: Int |                       ]
ATTR GrAGItf GrModule                             [ unique: {Int}      |               |                       ]

SEM GrModule
  | Mod     loc . applyList  =  let  rewrite (EvApTagVar (HNmNr f _)) = Right f
                                     rewrite (EvApTagTag t          ) = Left  t
                                in   [ (t, rewrite v)  | ((t,_), v) <- @applyTagMp ]
            loc . evalList   =       [ (t, f)          | ((t,_), EvApTagVar (HNmNr f _)) <- @evalTagMp ]
            loc . evalMap    =  Map.fromList @loc.evalList
            loc . applyMap   =  Map.fromList @loc.applyList

            loc . partPar    =  let  f (u,        xss)  (_, Right n)  = (u+1, (n,(Just u):[]):xss )
                                     f (u, (n,xs):xss)  (_, Left  _)  = (u+1, (n,(Just u):xs):xss )
                                in   snd (foldl f (@lhs.unique, []) (Map.toAscList @loc.applyMap))


SEM GrAGItf
  | AGItf  module . location = 0

SEM GrAGItf
  | AGItf  lhs.equations = genDynApplyEqs @module.applyMap @module.evalMap @module.appPappNodes  
                           ++   filter nonTrivEq @module.equations
%%]

%%[8 hs

nonTrivEq :: Equation -> Bool
nonTrivEq (IsEqual _ []) = False
nonTrivEq _              = True

%%]

%%[8
ATTR AllGrVal 
     AllGrTag 
%%[[10
     AllAdapt     
%%]]
              [ | | self : SELF ]
%%]



%%[8
-- Collect all PApp and App nodes

ATTR AllGrVal AllGrExpr AllBind AllGlobal GrModule [ | | appPappNodes USE {++} {[]} : {[NodeInfo (Maybe Variable)]} 
                                                   ]
ATTR GrTag [ | | isAppPApp : {Bool}   ]


SEM GrVal
  |  Node   lhs . appPappNodes =  if @tag.isAppPApp then [ InNode @tag.self @fldL.vars ] else []

SEM GrTag
  | App     lhs . isAppPApp  = True
  | PApp    lhs . isAppPApp  = True
  | * - App PApp 
            lhs . isAppPApp  = False
 

%%]

%%[8 hs

genDynApplyEqs applyMap evalMap appPappNodes 
  = [ IsApplication Nothing (map fromJust args) (fromJust (Map.lookup tag evalMap))
    | (InNode tag@(GrTag_App _) args) <- appPappNodes
    ]
    ++
    concat
    [ let  lasttag = GrTag_PApp 1 nm
           funnr   = either undefined id (fromJust $ Map.lookup lasttag applyMap)
      in   zipWith IsEqual [funnr+1+needs+length args ..] (map ((:[]).fromJust) (reverse args))
    | (InNode (GrTag_PApp needs nm) args) <- appPappNodes
    ]

%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% value and pattern nodes  %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%[8 hs
-- A grin value is either a single variable or a complete node denotation (with known tag)
data NodeInfo a 
  =  InVar   Variable 
  |  InNode  GrTag [a]
  deriving Show
  
fromInVar :: NodeInfo a -> Variable
fromInVar (InVar v)  = v
fromInVar _          = error "HPT: Apply arguments should all be variables"  

%%]

%%[8.valInfo

ATTR GrVal             [ | | valInfo : { NodeInfo (Maybe Variable) }  var   : { Maybe Variable } ]
ATTR GrValL            [ | | valsInfo: {[NodeInfo (Maybe Variable)]}  vars  : {[Maybe Variable]} ]
ATTR GrPatAlt GrPatLam [ | | patInfo : { NodeInfo        Variable  }                             ]
ATTR GrVar             [ | | tag     : GrTag                          var   : { Variable }       ]
ATTR GrVarL            [ | | headTag : GrTag                          vars  : {[Variable]}       ]


SEM GrVal
  | Tag       lhs.valInfo  =  InNode  @tag.self []
  | Var       lhs.valInfo  =  InVar   (getNr @nm)
  | Node      lhs.valInfo  =  InNode  @tag.self @fldL.vars
  | Empty
    LitInt
    LitStr
    VarNode
%%[[10
    NodeAdapt 
%%]]
              lhs.valInfo  =  error $ "HPT: valinfo: " ++ show @loc.self ++ " has no known tag"
              

SEM GrValL
  | Cons      lhs.valsInfo  =  @hd.valInfo : @tl.valsInfo
  | Nil       lhs.valsInfo  =  []

SEM GrVal
  | Var      lhs.var  =  Just (getNr @nm)
  | * - Var  lhs.var  =  Nothing

SEM GrValL
  | Cons     lhs.vars  =  @hd.var : @tl.vars
  | Nil      lhs.vars  =  []

SEM GrPatAlt
  | LitInt     lhs.patInfo  =  error "HPT: patInfo: literal"
  | Tag        lhs.patInfo  =  InNode @tag.self []
  | Node       lhs.patInfo  =  InNode @tag.self (map getNr @fldL)
  | Otherwise  lhs.patInfo  =  error "HPT: patInfo: Otherwise"
%%[[10
  | NodeSplit  lhs.patInfo  =  error "HPT: patInfo: nodesplit"
%%]]

SEM GrPatLam
  | Empty      lhs.patInfo  =  InVar (getNr wildcardNr)
  | Var        lhs.patInfo  =  InVar (getNr @nm)
  | VarNode    lhs.patInfo  =  InNode (@fldL.headTag) (tail @fldL.vars)

SEM GrVarL  
  | Cons         lhs.headTag  =  @hd.tag
  | Nil          lhs.headTag  =  error "GrVarL headtag"
  
SEM GrVarL
  | Nil          lhs.vars  =  []
  | Cons         lhs.vars  =  @hd.var : @tl.vars  

SEM GrVar
  | KnownTag     lhs.tag   =  @tag.self
  | * - KnownTag lhs.tag   =  error "GrVar tag"
  | Var          lhs.var   =  getNr @nm
  | * - Var      lhs.var   =  error "GrVar name"

%%]

%%%%%%%%%%%%%%%%%%%%%%%%
%% Target Information %%
%%%%%%%%%%%%%%%%%%%%%%%%

%%[8.targetInformation
{- 
Target information is either:
- the variable to which an expression is bound in a Sequence
- the result of a binding
- nothing (in the body of a Case and a Catch)
-}

ATTR AllGrExpr [ targetInfo: {NodeInfo Variable} | | ]

SEM GrBind
  | Bind  expr     . targetInfo  = InVar (getNr @nm)

SEM GrExpr
  | Seq    expr    . targetInfo  = @pat.patInfo
           body    . targetInfo  = @lhs.targetInfo


-- The value of the scrutinee is passed down to all alternatives
ATTR AllAlt [ valInfo: {NodeInfo (Maybe Variable)} | | ]


%%]


%%%%%%%%%%
%% Unit %%
%%%%%%%%%%
%%[8.unit
{-
There are five cases, depending on the structure of target and source
If there is no target, no equations are necessary
(this is the case for the unit at the end of an Case- or Catch-alternative).
If the target is a variable, we generate a single equation for it
 - if the source is a variable as well, the equation states that they should be the same
 - if the source is a node, the equation states that the variable refers to the node
If the target is a node, we generate a list of equations: one for each variable in the target
 - if the source is a variable, selections are created
 - if the source is a node, corresponding elements are equated
-}

SEM GrExpr
  | Unit 
    UpdateUnit
               loc.equations1 = case (@lhs.targetInfo, @val.valInfo) of
                                 (InVar tvar        ,  InVar svar        )  -> [IsEqual tvar [svar]]
                                 (InVar tvar        ,  InNode stag snms  )  -> [IsConstruction tvar stag snms Nothing]
                                 (InNode ttag tnms  ,  InVar svar        )  -> buildSelectEquations svar ttag tnms
                                 (InNode ttag tnms  ,  InNode stag snms  )  -> buildUnifyEquations  snms tnms
  | UpdateUnit loc.equations2 =  [ IsEqual (getNr @nm)  [fromJust @val.var] ]
  | Unit       lhs.equations  =  @loc.equations1
  | UpdateUnit lhs.equations  =  @loc.equations2 ++ @loc.equations1

                                                       
%%]
%%[8.unitaux hs

buildSelectEquations :: Variable -> GrTag -> [Variable] -> Equations
buildSelectEquations svar ttag tnms
  = [ IsSelection tvar svar i ttag
    | (tvar,i) <- zip tnms [0..]
    , tvar /= getNr wildcardNr
    ]

buildUnifyEquations :: [Maybe Variable] -> [Variable] -> Equations
buildUnifyEquations snms tnms
  = [ case mbSvar of
       Nothing    -> IsKnown tvar AbsBasic
       Just svar  -> IsEqual tvar [svar]
    | (tvar,mbSvar) <- zip tnms snms
    , tvar /= getNr wildcardNr
    ]

%%]


%%%%%%%%%%%
%% Store %%
%%%%%%%%%%%
%%[8.store
{-
A unique heaplocation is allocated.
A heap-equation is generated, which associates the heaplocation with the node to be stored.
An equation is generated, which states that the targetvariable is known to be associated with this heaplocation.
-}

SEM GrExpr
  | Store  lhs . location    =  @lhs.location + 1  
           lhs . heapEqs     =  case @val.valInfo of
                                  InNode stag snms  -> [ WillStore @lhs.location stag snms (Map.lookup stag @lhs.evalMap) ]
                                  _                 -> error "HPT: source of Store should be a node"
           lhs . equations   =  case (@val.valInfo, @lhs.targetInfo) of
                                  (InNode stag snms, InVar tvar)  -> [IsKnown tvar (AbsLocs (Set.singleton @lhs.location))] 
                                  _                               -> error "HPT: destination of Store should be a variable, source a node"

{-
A global definition is similar to a Store expression
-}

SEM GrGlobal
  | Global lhs . location    =  @lhs.location + 1
           lhs . heapEqs     =  case @val.valInfo of
                                  InNode stag snms  -> [ WillStore @lhs.location stag snms (Map.lookup stag @lhs.evalMap) ]
                                  _                 -> error "HPT: source of Global should be a node"
           loc . tvar        =  getNr @nm
           lhs . equations   =  case @val.valInfo of
                                  InNode stag snms  -> [IsKnown @loc.tvar (AbsLocs (Set.singleton @lhs.location))]
                                  _                 -> error "HPT: source of Global should be a node"
%%]

%%%%%%%%%%%%%%%%%%%%%%
%% Case Alternative %%
%%%%%%%%%%%%%%%%%%%%%%
%%[8.alt

{-
In every alternative,
a select-equation is generated for each variable in the pattern: the values are selected from the scrutinee
The scrutinee is always a variable because of earlier normalisation.
-}
SEM GrAlt
  | Alt  lhs . equations  =  case (@pat.patInfo, @lhs.valInfo) of
                               (InNode ttag tnms, InVar svar)  -> buildSelectEquations svar ttag tnms
                               _                               -> error "HPT: Alternative scrutinee must be a variable, pattern a node"
                             ++ @expr.equations
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Fetch, Update, FetchUpdate %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%[8.fetch
SEM GrExpr
  | FetchNode    lhs . equations =  case @lhs.targetInfo of
                                      InVar tvar  -> [ IsEqual tvar [getNr @nm] ]
                                      _           -> error "HPT: FetchNode target should be a variable"
  | FetchUpdate  lhs . equations =  [ IsEqual (getNr @dst) [getNr @src] ]
  | FetchField   lhs . equations =  case @lhs.targetInfo of
                                      InVar tvar  ->  [ IsSelection tvar (getNr @nm) @offset (fromJust @mbTag) ]
                                      _           -> error "HPT: FetchField target should be a variable"
  
%%]




%%%%%%%%%%
%% Call %%
%%%%%%%%%%
%%[8.call
{-
If the target is a single variable, it is required to have the same value as the function result.
If the target is a node denotation, a select-equation is generated for each variable in the node.
-}
SEM GrExpr
  | Call  loc  .  exceptions  =  getNr @nm + 1 : @lhs.exceptions
          lhs  .  equations   =  case @lhs.targetInfo of
                                   InVar  tvar       -> [ IsEqual tvar [getNr @nm] ]
                                   InNode ttag tnms  -> buildSelectEquations (getNr @nm) ttag tnms
%%]


%%%%%%%%%%
%% FFI %%%
%%%%%%%%%%
%%[8.ffi

{
avForArity = if grinStoreArity
              then [AbsBasic]
              else []
}

SEM GrExpr
  | FFI  loc . nodemap   =  Map.fromList ( [ (con, if con==GrTag_Unboxed then [AbsBasic] else avForArity ) | con <- @tagL.self ] )
         lhs . equations =  case @lhs.targetInfo of
                              InVar tvar        -> [ IsKnown tvar (AbsNodes @loc.nodemap) ]
                              InNode ttag tnms  -> zipWith IsKnown tnms (fromJust (Map.lookup ttag @loc.nodemap))
%%]

%%%%%%%%%%
%% Eval %%
%%%%%%%%%%
%%[8.eval
{-
A single equation is generated, associating the targetvariable with the evaluation result of the function
The target cannot be a node; these have been simplified earlier by the NormForHPT transformation
-}
SEM GrExpr
  | Eval  lhs . equations = case @lhs.targetInfo of
                              InVar tvar  -> [ IsEvaluation tvar (getNr @nm) @lhs.exceptVar ]
                              _        -> error "HPT: Eval target must be variable (NormForHPT should have made it so)"
%%]



%%%%%%%%%%%
%% Apply %%
%%%%%%%%%%%
%%[8.apply
SEM GrExpr
  | App  lhs . equations = case @lhs.targetInfo of
                             InVar tvar -> [ IsApplication (Just tvar) (getNr @nm : map fromInVar @argL.valsInfo) @lhs.exceptVar ]
                             _          -> error "HPT: Apply target should be a variable"
%%]


%%%%%%%%%%%%%%%%%%
%% Throw, Catch %%
%%%%%%%%%%%%%%%%%%
%%[8.throw
SEM GrExpr
  | Throw  loc     .  exceptions =  getNr @nm : @lhs.exceptions
           lhs     .  equations  =  case @lhs.targetInfo of
                                      InVar tvar  -> [ IsKnown tvar AbsBottom ]
                                      _           -> []

  | Catch  body    . exceptions  =  []
                   . exceptVar   =  @handlerVar
           handler . exceptions  =  @lhs.exceptions
           lhs     . exceptions  =  @handler.exceptions
           loc     . exceptEq    =  IsEqual @handlerVar @body.exceptions
                   . handlerVar  =  getNr @arg

SEM GrExpr
  | Catch  lhs   .  equations   =   @loc.exceptEq : @body.equations ++ @handler.equations

-- Exceptions not caught in the same binding, and support for exceptions which can only found while analysing (eval calls)
ATTR AllGrExpr [ exceptVar: Variable | exceptions: {[Variable]} | ]

SEM GrBind
  | Bind  expr    . exceptions  =  []
          loc     . exceptVar   =  getNr @nm + 1
          loc     . exceptEq    =  IsEqual @exceptVar @expr.exceptions
%%]


%%%%%%%%%%%%%
%% Actuals %%
%%%%%%%%%%%%%

%%[8.actuals
ATTR AllBind AllGrExpr [                                | | actualsEnv USE {.} {id} : {AbstractCallList -> AbstractCallList} ]
ATTR AllBind           [ allActuals: {AbstractCallList} | |                                                            ]


SEM GrExpr
  | Store Unit  loc  .  fGenActuals  = \tag mns n -> let args      = if grinStoreArity
                                                                      then tail mns -- first element is the size of the rest of the node
                                                                      else      mns
                                                         resultVar = Map.lookup tag @lhs.evalMap
                                                         actuals r = ((r, args) :)
                                                     in maybe id actuals resultVar
                loc  .  actualsEnv   = case (@val.valInfo, @lhs.targetInfo) of
                                           (InNode st snms, InVar tn)  -> @fGenActuals st snms tn
                                           _                           -> id
  | Call        loc  .  actualsEnv   = ((getNr @nm, @argL.vars) :)

SEM GrModule
  | Mod       bindL  .  allActuals   = @bindL.actualsEnv @loc.partPar

SEM GrBind
  | Bind      loc    .  bindActuals  = transpose [ actuals
                                                 | (resVar, actuals) <- @lhs.allActuals
                                                 , resVar == getNr @nm
                                                 ]
              loc    .  prune        = (@nm == evalNr) || (@nm == applyNr)
              loc    .  actualsEnv   = if @loc.prune then id else @expr.actualsEnv
              lhs    .  equations    = @loc.exceptEq                                                  
                                       :  [ IsEqual (getNr formal) [ actual | Just actual <- actuals]
                                          | (formal, actuals) <- zip @argNmL ( if    null @bindActuals
                                                                                then replicate (length @argNmL) []
                                                                                else @bindActuals
                                                                             )
                                          ]
                                       ++ @expr.equations

              lhs    .  heapEqs      = if @prune 
                                        then [] 
                                        else @expr.heapEqs
%%]
