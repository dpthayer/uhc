%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]
%%[8 import({GrinCode/AbsSyn})
%%]
%%[8.wrapper
WRAPPER GrAGItf
%%]
%%[8 hs module {%{GRIN}GrinCode.PointsToAnalysis}
%%]
%%[8 hs import(qualified Data.Map as Map, qualified Data.Set as Set, Data.Maybe, Data.List(transpose))
%%]
%%[8 hs import({%{EH}Base.Common}, {%{EH}GrinCode})
%%]
%%[8 hs import({%{GRIN}GRINCCommon}, {%{GRIN}Primitives}, {%{GRIN}HeapPointsToFixpoint})
%%]
%%[8 hs  export(heapPointsToAnalysis)
fromJust' _ (Just a ) = a
fromJust' m (Nothing) = error $ "fromJust: " ++ m

data NodeInfo a 
  = NodeVar Int 
  | NodeDen GrTag [a]
  | NodeXXX

heapPointsToAnalysis :: Int -> GrModule -> (Int,HptMap)
heapPointsToAnalysis unique grmod 
  = let -- traverse the tree
        inh = Inh_GrAGItf { heapPointer_Inh_GrAGItf = 0  }
        syn = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf grmod)) inh

        -- we get four synthesized attributes
        heapEqs   = heapList_Syn_GrAGItf syn
        applyMap  = applyMap_Syn_GrAGItf syn
        equations = equations_Syn_GrAGItf syn
        maxHeap   = heapPointer_Syn_GrAGItf syn - 1

        -- now solve the equations
    in  solveEquations (unique-1) maxHeap equations heapEqs applyMap
%%]

%%[8.toplevelCombining
ATTR GrAGItf GrModule AllBind AllGrExpr AllGlobal [ | | equations USE {++} {[]} : {Equations}
                                                        heapList  USE {++} {[]} : {HeapEquations}
                                                  ]

SEM GrBind
  | Bind  loc  .  prune     = (@nm == evalNr) || (@nm == applyNr)
          lhs  .  heapList  = if @prune then [] else @expr.heapList
%%]


%%%%%%%%%%%%%%%%%%%%%%
%% evalMap/applyMap %%
%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR AllGlobal AllBind AllGrExpr [ evalMap: {EvalMap} | | ]
ATTR GrModule GrAGItf [ | | applyMap : {ApplyMap} ]

SEM GrModule
  | Mod     loc . evalMap = [ (t, f) | ((t,_), EvApTagVar (HNmNr f _)) <- @evalTagMp ]
            loc . applyMap = let rewrite (EvApTagVar (HNmNr f _)) = Right f
                                 rewrite (EvApTagTag t          ) = Left  t
                             in [ (t, rewrite v) | ((t,_), v) <- @applyTagMp ]
%%]

%%%%%%%%%%%%%%%%%%%%%
%% Unique Pointers %%
%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR GrAGItf GrModule AllBind AllGlobal AllGrExpr [ | heapPointer: Int | ]
SEM GrAGItf
  | AGItf  module . heapPointer = 0
%%]

%%%%%%%%%%%%%
%% TagName %%
%%%%%%%%%%%%%

%We use the name @UNBOXED for unboxed nodes.
%Any other node should have a named tag.

%%[8.tagName
SEM GrTag [ | | tagName: SELF ]
  | Var     lhs . tagName = error "HPT: Tag variables not allowed"
%%]


%%%%%%%%%%%%%%%%
%% value Info %%
%%%%%%%%%%%%%%%%

A grin value is either a single variable or a complete node (known tag)

%%[8.valInfo
SEM GrValL [ | | valsInfo : {[NodeInfo (Maybe Int)]}]
  | Cons      lhs . valsInfo = @hd.valInfo : @tl.valsInfo
  | Nil       lhs . valsInfo = []

SEM GrVal [ | | valInfo : {NodeInfo (Maybe Int)}]
  | Node      lhs . valInfo = NodeDen @tag.tagName @fldL.depVars
  | Tag       lhs . valInfo = NodeDen @tag.tagName []
  | Var       lhs . valInfo = NodeVar (getNr @nm)
  | Empty     lhs . valInfo = error "HPT: valinfo: empty"
  | LitInt 
    LitStr    lhs . valInfo = error "HPT: valinfo: literal"
  | NodeAdapt lhs . valInfo = error "HPT: valinfo: nodeadapt"
%%]

%%[8.depVars
SEM GrVal  [ | | depVar:  {Maybe Int} ]
  | Var      lhs . depVar = Just (getNr @nm)
  | * - Var  lhs . depVar = Nothing
SEM GrValL [ | | depVars: {[Maybe Int]}  ]
  | Cons     lhs . depVars = @hd.depVar : @tl.depVars
  | Nil      lhs . depVars = []
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%
%% Pattern Information %%
%%%%%%%%%%%%%%%%%%%%%%%%%

A grin pattern is either a single variable or a compete node pattern (known tag)

%%[8.patInfo
SEM GrPat [ | | patInfo: {NodeInfo Int} ]
  | Node       lhs . patInfo = NodeDen @tag.tagName (map getNr @fldL)
  | Tag        lhs . patInfo = NodeDen @tag.tagName []
  | Var        lhs . patInfo = NodeVar (getNr @nm)
  | Empty      lhs . patInfo = NodeVar (getNr wildcardNr)
  | LitInt     lhs . patInfo = error "HPT: patInfo: literal"
  | NodeSplit  lhs . patInfo = error "HPT: patInfo: nodesplit"
%%]

%%%%%%%%%%%%%%%%%%%%%%%%
%% Target Information %%
%%%%%%%%%%%%%%%%%%%%%%%%

The target info is basicly the pattern information. However, for the last
expression in a binding it is the result variable of that binding.

%%[8.targetInformation
ATTR AllGrExpr [ targetInfo: {NodeInfo Int} | | ]

SEM GrBind
  | Bind  loc      . resultVar   = getNr @nm
          expr     . targetInfo  = NodeVar @resultVar

SEM GrExpr
  | Seq    expr    . targetInfo  = @pat.patInfo
           body    . targetInfo  = @lhs.targetInfo
  | Catch  body    . targetInfo  = NodeXXX
           handler . targetInfo  = NodeXXX
  | Case   altL    . targetInfo  = NodeXXX

%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



%%%%%%%%%%
%% Unit %%
%%%%%%%%%%

unit node;           -> \n              => n:
                                             absVal = Nothing
                                             envMod = Union [node]
unit (Tag e1 .. en); -> \n              => n:
                                             absVal = Tag[(absVal e1), .., (absVal en)]
                                             envMod = Tag[(depVar e1), .., (depVar en)]
unit node;           -> \(Tag e1 .. en) => e1:
                                             absVal = Nothing
                                             envMod = node ! Tag ! 1
                                           en:
                                             absVal = Nothing
                                             envMod = node ! Tag ! n
unit (Tag d1 .. dn); -> \(Tag e1 .. en) => e1:
                                             absVal = (absVal d1)
                                             envMod = Union (depVar d1)
                                           en:
                                             absVal = (absVal dn)
                                             envMod = Union (depVar dn)

note: The resultVar will always be Nothing.
      A node not in the heap representing a function is strange at least...

%%[8.unit
SEM GrExpr
  | Unit   lhs . equations  = case @lhs.targetInfo of
                                NodeXXX           -> []
                                NodeVar tvar      -> case @val.valInfo of
                                                       NodeVar svar      -> [(tvar, EnvUnion [svar])]
                                                       NodeDen stag snms -> [(tvar, EnvTag stag snms Nothing)]
                                NodeDen ttag tnms -> case @val.valInfo of
                                                       NodeVar svar      -> buildSelectEquations svar ttag tnms
                                                       NodeDen stag snms -> [ (tn, maybe (EnvSetAV AV_Basic) 
                                                                                         (\x -> EnvUnion [x]) 
                                                                                         sn                   )
                                                                            | (tn,sn) <- zip tnms snms
                                                                            , tn /= getNr wildcardNr
                                                                            ]
%%]

%%[8.selectVar hs
buildSelectEquations :: Variable -> GrTag -> [Variable] -> Equations
buildSelectEquations selectVar tag nms
  = let step (i, f) v     = (i+1, if v == getNr wildcardNr then f else (v,EnvSelect selectVar tag i):f )
        (count, envEqs) = foldl step (0, []) nms
    in envEqs
%%]


%%%%%%%%%%%
%% Store %%
%%%%%%%%%%%

store (Tag e1 .. en); -> \n              => n:
                                              absVal = newLocation
                                              envMod = setAV absVal
                                            newLocation:
                                              absVal  = Tag[(absVal e1), .., (absVal en)]
                                              heapMod = Tag[(depVar e1), .., (depVar en)] |_| resultVar(Tag)

%%[8.store
SEM GrExpr
  | Store  loc . (heapPointer, eqs, heapElem)   = makeStoreEquations
                                                              @lhs.evalMap
                                                              @lhs.heapPointer
                                                              @val.valInfo
                                                              @lhs.targetInfo
           lhs . heapList  = [ @loc.heapElem ]
           lhs . equations = @loc.eqs
%%]

%%[8.store hs
makeStoreEquations evalMap heapPointer valInfo targetInfo
    = case targetInfo of
        NodeVar tvar -> case valInfo of
                         NodeDen stag snms -> let envEqs      = [(tvar,EnvSetAV (AV_Locations (Set.singleton heapPointer)))]
                                                  heapEq      = ( heapPointer, ((stag, snms), lookup stag evalMap) )
                                              in (heapPointer + 1, envEqs, heapEq )
                         _                 -> error "HPT: source of Store should be a node"
        _            -> error "HPT: destination of Store should be a variable"
%%]

%%%%%%%%%%
%% Eval %%
%%%%%%%%%%

eval(l); -> \n              => n:
                                 absVal = AV_Nodes []
                                 envMod = Eval l

the next is not needed because of normalisation:

eval(l); -> \(Tag e1 .. en) => @eval@l:
                                 absVal = Nothing
                                 envMod = Eval l
                               e1:
                                 absVal = Nothing
                                 envMod = @eval@l ! Tag ! 1
                               en:
                                 absVal = Nothing
                                 envMod = @eval@l ! Tag ! n
%%[8.eval
SEM GrExpr
  | Eval   lhs . equations = case @lhs.targetInfo of
                              NodeVar n  -> [ ( n , EnvEval (getNr @nm) @lhs.exceptVar) ]
                              _          -> error "HPT: Eval target must be variable (NormForHPT should have made it so)"
%%]

%%%%%%%%%%
%% Call %%
%%%%%%%%%%

foo a1 .. an; -> \n             => n:
                                     absVal = Nothing
                                     envMod = Union [@foo]

foo a1 ..an; -> \(Tag e1 .. en) => e1:
                                     absVal = Nothing
                                     envMod = @foo ! Tag ! 1
                                   en:
                                     absVal = Nothing
                                     envMod = @foo ! Tag ! n
%%[8.call
SEM GrExpr
  | Call  loc  .  resultVar   =  getNr @nm
               .  exceptions  =  @resultVar + 1 : @lhs.exceptions
          lhs  .  equations   = case @lhs.targetInfo of
                                 NodeVar n         -> [ (n, EnvUnion [@resultVar]) ]
                                 NodeDen tag names -> buildSelectEquations @resultVar tag names
%%]

%%%%%%%%%%%%%%%%%%%%%%
%% Case Alternative %%
%%%%%%%%%%%%%%%%%%%%%%

case node of (T e1 .. en)             => e1:
                                           absVal = Nothing
                                           envMod = node ! Tag ! 1
                                         en:
                                           absVal = Nothing
                                           envMod = node ! Tag ! n

the following is not needed because of normalisation
case (Tag d1 .. dn) of (Tag e1 .. en) => e1:
                                           absVal = (absVal d1)
                                           envMod = Union (depVar d1)
                                         en:
                                           absVal = (absVal dn)
                                           envMod = Union (depVar dn)

%%[8.alt
ATTR AllAlt [ valInfo: {NodeInfo (Maybe Int)} | | ]

SEM GrAlt
  | Alt  lhs . equations  = case @pat.patInfo of
                                      NodeDen ttag tnms -> case @lhs.valInfo of
                                                            NodeVar svar -> buildSelectEquations svar ttag tnms
                                                            _            -> error "HPT: Alternative scrutinee should be a variable"
                                      _                 -> error "HPT: Alternative pattern must be a node"                                                            
                            ++ @expr.equations
%%]

%%%%%%%%%%%%%%%%%%%%
%% Case and Catch %%
%%%%%%%%%%%%%%%%%%%%

We can have multiple arms in a case, how do we merge the result of each arm?

Since we normalise each case to end with a simple unit (e.g. unit v). So we
collect the last elements of the arms and join these afterwards.

We use the targetName of the wildcard variable so that these last equations and
partial collections are filtered afterwards.

%%[8.case

ATTR GrExpr AllAlt [ | | altVars USE {++} {[]} : {[Int]} ]

SEM GrExpr
  | * - Seq Unit
           lhs   .  altVars     = []
  | Seq    lhs   .  altVars     = @body.altVars
  | Unit   lhs   .  altVars     = case @lhs.targetInfo of
                                    NodeXXX           -> case @val.valInfo of
                                                           NodeVar svar -> [svar]
                                                           _            -> error "HPT: Unit of alternative should be a variable"
                                    _                 -> []


SEM GrExpr
  | Case   loc   .  equat       =  case @lhs.targetInfo of
                                     NodeVar resVar  -> (resVar, EnvUnion @altL.altVars)
                                     _               -> error "Scrutinee of Case should be a variable"
           lhs   .  equations   =  @loc.equat : @altL.equations
           
  | Catch  loc   .  equat       =  case @lhs.targetInfo of
                                     NodeVar resVar  -> (resVar, EnvUnion (@body.altVars ++ @handler.altVars))
                                     _               -> error "result of Catch should be a variable"
           lhs   .  equations   =  @loc.equat : @loc.exceptEq : @body.equations ++ @handler.equations

%%]

%%%%%%%%%%
%% FFI %%%
%%%%%%%%%%

ffi "primFoo"; \(Tag e1 en)  => e1:
                                  absVal = prim(Foo) ! Tag ! 1
                                  envMod = SetAv absVal
                                en:
                                  absVal = prim(Foo) ! Tag ! n
                                  envMod = SetAV absVal
ffi "primFoo"; \r            => r:
                                 absVal  = prim(Foo)

ffi "foo"; \(Tag e1 e2)      => note: (Tag == Unboxed)
                                e1: Basic
                                en: Basic

%%[8.ffi

ATTR AllGrTag [ | | self: SELF ]

SEM GrExpr
  | FFI  loc . primAbsVal = let l = case @resTagL.self of
                                      (GrTag_Unboxed : _) -> [(GrTag_Unboxed,[AV_Basic])]
                                      ts                  -> map (\t -> (t,avForArity)) ts
                            in  AV_Nodes (Map.fromList l)
             . primEquat  = case @lhs.targetInfo of
                              NodeVar nm      -> [ (nm, EnvSetAV @primAbsVal) ]
                              NodeDen tag nms -> let (AV_Nodes nodes) = @primAbsVal
                                                     tagElementsAV    = fromJust' "PointsToAnalysis.GrExpr.FFI" $ Map.lookup tag nodes
                                                     makeAV teAV nm   = (nm, EnvSetAV teAV)
                                                 in zipWith makeAV tagElementsAV nms
             . ffiEquat   = case @lhs.targetInfo of
                              NodeDen tag nms -> map (\e -> (e, EnvSetAV AV_Basic)) nms
                              _               -> error "FFI should be followed by an unboxed node pattern"
         lhs . equations  = if isPrim @nm then @loc.primEquat else @loc.ffiEquat
             
             
             
             
             
%%]

Note: we have the ctable, can we do something with that?
      e.g. we could get the result Tags from it. If we save result type for a FFI.


%%%%%%%%%%%
%% Apply %%
%%%%%%%%%%%

Every call to apply equals to an rewrite using the apply map. We must join all
these apply into one argument, so we join them in a list and put them in the
equation array at the top level.

apply (P2upto  ) a => (P1upto a)
apply (P1upto a) b => (Fupto  a b)


apply (P/1/apply f) a == apply f a  -- a P/1/apply should not occur? right?!

notes: - all tags should be of type Partial application
       - all tags should miss the same number of arguments

eval (Fapply a b)

%%[8.apply
SEM GrExpr
  | App    lhs . equations= case @lhs.targetInfo of
                              NodeVar nm -> let makeAppArgInfo = map mkAppInfo
                                                mkAppInfo :: NodeInfo (Maybe Int) -> Either Variable AbstractEnvModifier
                                                mkAppInfo l = case l of
                                                                NodeVar  v  -> Left v
                                                                _           -> error "HPT: Apply argument should be variable"
                                            in  [ (nm, EnvApp (getNr @nm) (makeAppArgInfo @argL.valsInfo) @lhs.exceptVar) ]
                              _          -> error "Apply bound to pattern?!"
%%]


%%%%%%%%%%%
%% Fetch %%
%%%%%%%%%%%

%%[8.fetch
SEM GrExpr
  | Fetch  lhs . equations=  case @lhs.targetInfo of
                                  NodeVar resVar -> [ (resVar, EnvUnion [getNr @nm]) ]
                                  _              -> error "HPT expects variable after fetch, not a node"
%%]

%%%%%%%%%%%%
%% Update %%
%%%%%%%%%%%%

%%[8.update

SEM GrVal [ | | getName : {HsName} ]
  | Var      lhs.getName = @nm
  | * - Var  lhs.getName = error "HPT expects variable in update"


SEM GrExpr
  | Update  loc . equations=  [ (getNr @nm, EnvUnion [getNr @nm, getNr @val.getName]) ]
                                 
%%]


%%%%%%%%%%%%%%%%%
%% FetchUpdate %%
%%%%%%%%%%%%%%%%%

%%[8
SEM GrExpr
  | FetchUpdate  loc . equations=  [ (getNr @dst, EnvUnion [getNr @dst, getNr @src]) ]
                                 
%%]


%%%%%%%%%%%
%% Throw %%
%%%%%%%%%%%

TODO: targetInfo should allow empty patterns to be expressed

%%[8.throw
SEM GrExpr
  | Throw  loc  .  exceptions  =  getNr @nm : @lhs.exceptions
           lhs  .  equations   =  case @lhs.targetInfo of
                                      NodeVar n  -> [ (n, EnvSetAV AV_Nothing) ]
                                      _          -> []
%%]

%%%%%%%%%%%
%% Catch %%
%%%%%%%%%%%

%%[8.catch
SEM GrExpr
  | Catch  body    . exceptions  =  []
                   . exceptVar   =  @handlerVar
           handler . exceptions  =  @lhs.exceptions
           lhs     . exceptions  =  @handler.exceptions
           loc     . exceptEq    =  (@handlerVar, EnvUnion @body.exceptions)
                   . handlerVar  =  getNr @arg
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Non local exceptions %%
%%%%%%%%%%%%%%%%%%%%%%%%%%

Exceptions not caught in the same binding, and support for exceptions which can only found while analysing (eval calls)

%%[8.catch
ATTR AllGrExpr [ exceptVar: Variable | exceptions: {[Int]} | ]

SEM GrBind
  | Bind  expr    . exceptions  =  []
          loc     . exceptVar   = @resultVar + 1
          loc     . exceptEq    =  (@exceptVar, EnvUnion @expr.exceptions)
%%]


%%%%%%%%%%%%%
%% Actuals %%
%%%%%%%%%%%%%

%%[8.actuals
ATTR AllBind AllGrExpr [                                    | | actualsEnv USE {.} {id} : {[(Int, [Maybe Int])] -> [(Int, [Maybe Int])]} ]
ATTR AllBind           [ allActuals: {[(Int, [Maybe Int])]} | | ]

SEM GrExpr
  | Store Unit  loc  .  fGenActuals  = \tag mns n -> let args      = if grinStoreArity
                                                                      then tail mns -- first element is the size of the rest of the node
                                                                      else      mns
                                                         resultVar = lookup tag @lhs.evalMap
                                                         actuals r = ((r, args) :)
                                                     in maybe id actuals resultVar
                loc  .  actualsEnv   = case (@val.valInfo, @lhs.targetInfo) of
                                           (NodeDen st snms, NodeVar tn) -> @fGenActuals st snms tn
                                           _                             -> id
  | Call        loc  .  actualsEnv   = ((@resultVar, @argL.depVars) :)

SEM GrModule
  | Mod       bindL  .  allActuals   = @bindL.actualsEnv []

SEM GrBind
  | Bind      loc    .  bindActuals  = transpose [ actuals
                                                 | (resVar, actuals) <- @lhs.allActuals
                                                 , resVar == @resultVar
                                                 ]
                     .  actualsEnv   = if @loc.prune then id else @expr.actualsEnv
                     
              lhs    .  equations    = let envElem formal actuals = (getNr formal, EnvUnion [ actual | Just actual <- actuals])
                                       in zipWith envElem
                                                  @argNmL
                                                  ( if    null @bindActuals
                                                     then replicate (length @argNmL) []
                                                     else @bindActuals
                                                  )
                                       ++ [ @loc.exceptEq ]
                                       ++ @expr.equations
%%]

%%%%%%%%%%%%%
%% Globals %%
%%%%%%%%%%%%%

The globals look like the expression

store (Tag f1 fn); \bla ->

%%[8.global
SEM GrGlobal
  | Global  loc  .  (heapPointer, eqs, heapElem)      =  makeStoreEquations @lhs.evalMap @lhs.heapPointer @val.valInfo (NodeVar $ getNr @nm)
            lhs  .  equations                         =  @loc.eqs
            lhs  .  heapList                          =  [ @loc.heapElem ]
            
%%]
