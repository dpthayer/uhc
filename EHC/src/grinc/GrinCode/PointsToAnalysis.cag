%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]
%%[8 import({GrinCode/AbsSyn})
%%]
%%[8.wrapper
WRAPPER GrAGItf
%%]
%%[8 hs module {%{GRIN}GrinCode.PointsToAnalysis}
%%]
%%[8 hs import(qualified Data.Map as Map, qualified Data.Set as Set, Data.Maybe, Data.List(transpose))
%%]
%%[8 hs import({%{EH}Base.Common}, {%{EH}GrinCode})
%%]
%%[8 hs import({%{GRIN}GRINCCommon}, {%{GRIN}HeapPointsToFixpoint})
%%]
%%[8 hs import(Debug.Trace)
%%]


%%[8 hs export(heapPointsToAnalysis)

{-
Main module entry point:
Given a Grin-program, traverse it and collect equations for variables and locations.
Then solve the constraints, and return the resulting abstract environment&heap: the "HptMap".
As an additional Int parameter, take the first number that is not the number of any variable.
Also return it, possibly modified.
As an additional Int result, return the number of iterations that it took to solve the equations.
-}

heapPointsToAnalysis :: GrModule -> Int -> (Int,Int,HptMap)
heapPointsToAnalysis grmod unique
  = let -- traverse the tree
        inh = Inh_GrAGItf { heapPointer_Inh_GrAGItf = 0, unique_Inh_GrAGItf = unique  }
        syn = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf grmod)) inh

        -- get four synthesized attributes
        equations = equations_Syn_GrAGItf syn
        heapEqs   = heapEqs_Syn_GrAGItf syn
        applyMap  = applyMap_Syn_GrAGItf syn
        lenHeap   = heapPointer_Syn_GrAGItf syn
        
        -- now solve the equations
        (iterCount,hptMap) = solveEquations unique lenHeap equations heapEqs applyMap
        
        -- no new variables were introduced in the tree traversal, 
        -- but the equation-solver uses a variable for each applyMap-entry
        unique2   = unique + Map.size applyMap
        
     in (iterCount, unique2, hptMap)
     
%%]

%%%%%%%%%%%%%%%%%%%%%
%% Main attributes %%
%%%%%%%%%%%%%%%%%%%%%
%%[8
{- 
The overall goal is to collect equations that express
what constraints variables and heaplocations satisfy.
-}

ATTR GrAGItf GrModule AllGlobal AllBind AllGrExpr [ | | equations  USE {++} {[]} : {Equations}
                                                        heapEqs    USE {++} {[]} : {HeapEquations}
                                                  ]

{-
The EvalMap (slightly rewritten) is passed down to all expressions, and passed up to the Module itself
The ApplyMap (slightly rewritten) is passed up to the root
A unique integer "heapPointer" is threaded through all expressions to number all Stores locations
The value "unique", the first unused variable number, is made available to the root
-}

ATTR                  AllGlobal AllBind AllGrExpr [ evalMap: {EvalMap} |                  |                       ]
ATTR         GrModule                             [                    |                  | evalMap  : {EvalMap}  ]
ATTR GrAGItf GrModule                             [                    |                  | applyMap : {ApplyMap} ]
ATTR GrAGItf GrModule AllGlobal AllBind AllGrExpr [                    | heapPointer: Int |                       ]
ATTR GrAGItf GrModule                             [ unique: {Int}      |                  |                       ]

SEM GrModule
  | Mod     loc . evalMap  = Map.fromList [ (t, f) | ((t,_), EvApTagVar (HNmNr f _)) <- @evalTagMp ]
            loc . applyMap = let rewrite (EvApTagVar (HNmNr f _)) = Right f
                                 rewrite (EvApTagTag t          ) = Left  t
                             in Map.fromList [ (t, rewrite v) | ((t,_), v) <- @applyTagMp ]

SEM GrAGItf
  | AGItf  module . heapPointer = 0

SEM GrAGItf
  | AGItf  lhs.equations = genDynApplyEqs @module.applyMap @module.evalMap @module.appPappNodes  
                           ++   filter nonTrivEq @module.equations
%%]

%%[8 hs

nonTrivEq :: Equation -> Bool
nonTrivEq (IsEqual _ []) = False
nonTrivEq _              = True

%%]

%%[8
ATTR AllGrVal 
     AllGrTag 
%%[[10
     AllAdapt     
%%]]
              [ | | self : SELF ]
%%]



%%[8
-- Collect all PApp and App nodes

ATTR AllGrVal AllGrExpr AllBind AllGlobal GrModule [ | | appPappNodes USE {++} {[]} : {[NodeInfo (Maybe Variable)]} 
                                                   ]
ATTR GrTag [ | | isAppPApp : {Bool}   ]


SEM GrVal
  |  Node   lhs . appPappNodes =  if @tag.isAppPApp then [ InNode @tag.self @fldL.depVars ] else []

SEM GrTag
  | Lit     lhs . isAppPApp  =  case @categ of
                                 GrTagPApp _ -> True
                                 GrTagApp    -> True
                                 _           -> False
  | * - Lit lhs . isAppPApp  =  False
  

%%]

%%[8 hs

genDynApplyEqs applyMap evalMap appPappNodes 
  = [ IsApplication Nothing (map fromJust args) (fromJust (Map.lookup tag evalMap))
    | (InNode tag@(GrTag_Lit GrTagApp x y) args) <- appPappNodes
    ]
    ++
    concat
    [ let  lasttag = GrTag_Lit (GrTagPApp 1        ) 0 nm
           funnr   = either undefined id (fromJust $ Map.lookup lasttag applyMap)
      in   zipWith IsEqual [funnr+1+needs+length args ..] (map ((:[]).fromJust) (reverse args))
    | (InNode (GrTag_Lit (GrTagPApp needs) _ nm) args) <- appPappNodes
    ]

%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% value and pattern nodes  %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%[8 hs
-- A grin value is either a single variable or a complete node denotation (with known tag)
data NodeInfo a 
  =  InVar   Variable 
  |  InNode  GrTag [a]
  deriving Show
%%]

%%[8.valInfo

ATTR GrVal             [ | | valInfo : { NodeInfo (Maybe Variable) }  depVar : { Maybe Variable } ]
ATTR GrValL            [ | | valsInfo: {[NodeInfo (Maybe Variable)]}  depVars: {[Maybe Variable]} ]
ATTR GrPatAlt GrPatLam [ | | patInfo : { NodeInfo        Variable  }                              ]
ATTR GrVar             [ | | tag     : GrTag                          name   : { HsName }         ]
ATTR GrVarL            [ | | headTag : GrTag                          names  : {[HsName]}         ]


SEM GrVal
  | Tag       lhs . valInfo = InNode  @tag.self []
  | Var       lhs . valInfo = InVar   (getNr @nm)
  | Node      lhs . valInfo = InNode  @tag.self @fldL.depVars
  | Empty
    LitInt
    LitStr
    VarNode
%%[[10
    NodeAdapt 
%%]]
              lhs . valInfo = error $ "HPT: valinfo: " ++ show @loc.self ++ " has no known tag"
              

SEM GrValL
  | Cons      lhs . valsInfo = @hd.valInfo : @tl.valsInfo
  | Nil       lhs . valsInfo = []

SEM GrVal
  | Var      lhs . depVar = Just (getNr @nm)
  | * - Var  lhs . depVar = Nothing

SEM GrValL
  | Cons     lhs . depVars = @hd.depVar : @tl.depVars
  | Nil      lhs . depVars = []

SEM GrPatAlt
  | LitInt     lhs . patInfo = error "HPT: patInfo: literal"
  | Tag        lhs . patInfo = InNode @tag.self []
  | Node       lhs . patInfo = InNode @tag.self (map getNr @fldL)
  | Otherwise  lhs . patInfo = error "HPT: patInfo: Otherwise"
%%[[10
  | NodeSplit  lhs . patInfo = error "HPT: patInfo: nodesplit"
%%]]

SEM GrPatLam
  | Empty      lhs . patInfo = InVar (getNr wildcardNr)
  | Var        lhs . patInfo = InVar (getNr @nm)
  | VarNode    lhs . patInfo = InNode (@fldL.headTag) (map getNr (tail @fldL.names))

SEM GrVarL  
  | Cons         lhs.headTag = @hd.tag
  | Nil          lhs.headTag = error "GrVarL headtag"
  
SEM GrVarL
  | Nil          lhs.names = []
  | Cons         lhs.names = @hd.name : @tl.names  

SEM GrVar
  | KnownTag     lhs.tag   = @tag.self
  | * - KnownTag lhs.tag   = error "GrVar tag"
  | Var          lhs.name  = @nm
  | * - Var      lhs.name  = error "GrVar name"

%%]

%%%%%%%%%%%%%%%%%%%%%%%%
%% Target Information %%
%%%%%%%%%%%%%%%%%%%%%%%%

%%[8.targetInformation
{- 
Target information is either:
- the variable to which an expression is bound in a Sequence
- the result of a binding
- nothing (in the body of a Case and a Catch)
-}

ATTR AllGrExpr [ targetInfo: {Maybe (NodeInfo Variable)} | | ]

SEM GrBind
  | Bind  loc      . resultVar   = getNr @nm
          expr     . targetInfo  = Just (InVar @resultVar)

SEM GrExpr
  | Seq    expr    . targetInfo  = Just @pat.patInfo
           body    . targetInfo  = @lhs.targetInfo
  | Case   altL    . targetInfo  = Nothing
  | Catch  body    . targetInfo  = Nothing
           handler . targetInfo  = Nothing

%%]


%%%%%%%%%%
%% Unit %%
%%%%%%%%%%
%%[8.unit
{-
There are five cases, depending on the structure of target and source
If there is no target, no equations are necessary
(this is the case for the unit at the end of an Case- or Catch-alternative).
If the target is a variable, we generate a single equation for it
 - if the source is a variable as well, the equation states that they should be the same
 - if the source is a node, the equation states that the variable refers to the node
If the target is a node, we generate a list of equations: one for each variable in the target
 - if the source is a variable, selections are created
 - if the source is a node, corresponding elements are equated
-}

SEM GrExpr
  | Unit 
    UpdateUnit
               loc.equations1 = case (@lhs.targetInfo, @val.valInfo) of
                                 (Nothing                  ,  _                 )  -> []
                                 (Just (InVar tvar)        ,  InVar svar        )  -> [IsEqual tvar [svar]]
                                 (Just (InVar tvar)        ,  InNode stag snms  )  -> [IsConstruction tvar stag snms Nothing]
                                 (Just (InNode ttag tnms)  ,  InVar svar        )  -> buildSelectEquations svar ttag tnms
                                 (Just (InNode ttag tnms)  ,  InNode stag snms  )  -> buildUnifyEquations  snms tnms
  | UpdateUnit loc.equations2 =  [ IsEqual (getNr @nm)  [getNr @nm,  getNr @val.getName] ]
  | Unit       lhs.equations  =  @loc.equations1
  | UpdateUnit lhs.equations  =  @loc.equations2 ++ @loc.equations1

                                                       
%%]
%%[8.unitaux hs

buildSelectEquations :: Variable -> GrTag -> [Variable] -> Equations
buildSelectEquations svar ttag tnms
  = [ IsSelection tvar svar i ttag
    | (tvar,i) <- zip tnms [0..]
    , tvar /= getNr wildcardNr
    ]

buildUnifyEquations :: [Maybe Variable] -> [Variable] -> Equations
buildUnifyEquations snms tnms
  = [ case mbSvar of
       Nothing    -> IsKnown tvar AbsBasic
       Just svar  -> IsEqual tvar [svar]
    | (tvar,mbSvar) <- zip tnms snms
    , tvar /= getNr wildcardNr
    ]

%%]


%%%%%%%%%%%
%% Store %%
%%%%%%%%%%%
%%[8.store
{-
A unique heaplocation is allocated.
A heap-equation is generated, which associates the heaplocation with the node to be stored.
An equation is generated, which states that the targetvariable is known to be associated with this heaplocation.
-}

SEM GrExpr
  | Store  lhs . heapPointer = @lhs.heapPointer + 1  
           lhs . heapEqs     = case @val.valInfo of
                                 InNode stag snms  -> [ WillStore @lhs.heapPointer stag snms (Map.lookup stag @lhs.evalMap) ]
                                 _                 -> error "HPT: source of Store should be a node"
           lhs . equations   = case (@val.valInfo, @lhs.targetInfo) of
                                 (InNode stag snms, Just (InVar tvar))  -> [IsKnown tvar (AbsLocs (Set.singleton @lhs.heapPointer))] 
                                 _                                      -> error "HPT: destination of Store should be a variable, source a node"

{-
A global definition is similar to a Store expression
-}

SEM GrGlobal
  | Global lhs . heapPointer = @lhs.heapPointer + 1
           lhs . heapEqs     = case @val.valInfo of
                                 InNode stag snms  -> [ WillStore @lhs.heapPointer stag snms (Map.lookup stag @lhs.evalMap) ]
                                 _                 -> error "HPT: source of Global should be a node"
           loc . tvar        = getNr @nm
           lhs . equations   = case @val.valInfo of
                                 InNode stag snms  -> [IsKnown @loc.tvar (AbsLocs (Set.singleton @lhs.heapPointer))]
                                 _                 -> error "HPT: source of Global should be a node"
%%]


%%%%%%%%%%
%% Eval %%
%%%%%%%%%%
%%[8.eval
{-
A single equation is generated, associating the targetvariable with the evaluation result of the function
The target cannot be a node; these have been simplified earlier by the NormForHPT transformation
-}
SEM GrExpr
  | Eval  loc . function  = getNr @nm 
          lhs . equations = case @lhs.targetInfo of
                              Just (InVar n)  -> [ IsEvaluation n @loc.function @lhs.exceptVar ]
                              _               -> error "HPT: Eval target must be variable (NormForHPT should have made it so)"
%%]

%%%%%%%%%%
%% Call %%
%%%%%%%%%%
%%[8.call
{-
If the target is a single variable, it is required to have the same value as the function result.
If the target is a node denotation, a select-equation is generated for each variable in the node.
-}
SEM GrExpr
  | Call  loc  .  resultVar   =  getNr @nm
               .  exceptions  =  @resultVar + 1 : @lhs.exceptions
          lhs  .  equations   = case @lhs.targetInfo of
                                 Just (InVar n)           -> [ IsEqual n [@resultVar] ]
                                 Just (InNode tag names)  -> buildSelectEquations @resultVar tag names
%%]

%%%%%%%%%%%%%%%%%%%%%%
%% Case Alternative %%
%%%%%%%%%%%%%%%%%%%%%%
%%[8.alt
-- The value of the scrutinee is passed to all alternatives
ATTR AllAlt [ valInfo: {NodeInfo (Maybe Variable)} | | ]

{-
In every alternative,
a select-equation is generated for each variable in the pattern: the values are selected from the scrutinee
The scrutinee is always a variable because of earlier normalisation.
-}
SEM GrAlt
  | Alt  lhs . equations  = case (@pat.patInfo, @lhs.valInfo) of
                              (InNode ttag tnms, InVar svar)  -> buildSelectEquations svar ttag tnms
                              _                               -> error "HPT: Alternative scrutinee must be a variable, pattern a node"
                            ++ @expr.equations
%%]

%%%%%%%%%%%%%%%%%%%%
%% Case and Catch %%
%%%%%%%%%%%%%%%%%%%%
%%[8.case
{-
We collect all variables that appear in a Unit at the end of each alternative.
Note that such a Unit is required to be a single variable, not a node-denotation.
-}
ATTR GrExpr AllAlt [ | | altVars USE {++} {[]} : {[Variable]} ]

SEM GrExpr
  | * - Seq Unit Case
           lhs   .  altVars     = []
  | Seq    lhs   .  altVars     = @body.altVars
  | Case   lhs   .  altVars     = @altL.altVars
  | Unit   lhs   .  altVars     = case (@lhs.targetInfo, @val.valInfo) of
                                    (Nothing  , InVar svar  ) -> [svar]
                                    (Nothing  , _           ) -> error "HPT: Unit of alternative should be a variable"
                                    (Just _   , _           ) -> []

{-
We generate a single equation for the destination variable: it can be equal to the variables collected from all alternatives.
For a Catch we proceed similarly, the body and the handler being the two alternatives.
-}

SEM GrExpr
  | Case   loc   .  equat       =  case @lhs.targetInfo of
                                     Just (InVar tvar)  -> [IsEqual tvar @altL.altVars]
                                     Nothing            -> []
                                     t                  -> error ("Destination of Case " ++ show @val.self ++ " should be a variable, " ++ show t ++ " is not.")
           lhs   .  equations   =  @loc.equat ++ @altL.equations
           
  | Catch  loc   .  equat       =  case @lhs.targetInfo of
                                     Just (InVar tvar)  -> IsEqual tvar (@body.altVars ++ @handler.altVars)
                                     _                  -> error "result of Catch should be a variable"
           lhs   .  equations   =  @loc.equat : @loc.exceptEq : @body.equations ++ @handler.equations

%%]

%%%%%%%%%%
%% FFI %%%
%%%%%%%%%%
%%[8.ffi

{
avForArity = if grinStoreArity
              then [AbsBasic]
              else []
}

SEM GrExpr
  | FFI  loc . absVal     = Map.fromList ( case @resTagL.self of
                                            (GrTag_Any:_)     -> error "FFI result type should be a datatype or an unboxable type"
                                            (GrTag_Unboxed:_) -> [ (GrTag_Unboxed, [AbsBasic] )                       ]
                                            constructors      -> [ (con          , avForArity ) | con <- constructors ]
                                         )
         lhs . equations = case @lhs.targetInfo of
                             Just (InVar tvar)        -> [ IsKnown tvar (AbsNodes @loc.absVal) ]
                             Just (InNode ttag tnms)  -> zipWith IsKnown tnms (fromJust (Map.lookup ttag @loc.absVal))
%%]

%%%%%%%%%%%
%% Apply %%
%%%%%%%%%%%
%%[8.apply
SEM GrExpr
  | App  lhs . equations = case @lhs.targetInfo of
                             Just (InVar tvar) -> let argvar :: NodeInfo a -> Variable
                                                      argvar (InVar v)  = v
                                                      argvar _          = error "HPT: Apply arguments should all be variables"
                                                  in  [ IsApplication (Just tvar) (getNr @nm : map argvar @argL.valsInfo) @lhs.exceptVar ]
                             _                 -> error "HPT: Apply target should be a variable"
%%]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Fetch, Update, FetchUpdate %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%[8.fetch
SEM GrExpr
  | FetchNode    lhs . equations =  case @lhs.targetInfo of
                                      Just (InVar tvar)  -> [ IsEqual tvar [getNr @nm] ]
                                      _                  -> error "HPT: Fetch target should be a variable"
  | FetchField   lhs . equations =  error "FetchField found during HPT"
  | FetchUpdate  lhs . equations =  [ IsEqual (getNr @dst) [getNr @dst, getNr @src] ]
  
SEM GrVal [ | | getName : {HsName} ]
  | Var      lhs.getName = @nm
  | * - Var  lhs.getName = error "HPT: Update source should be a variable"

%%]


%%%%%%%%%%%%%%%%%%
%% Throw, Catch %%
%%%%%%%%%%%%%%%%%%
%%[8.throw
SEM GrExpr
  | Throw  loc     .  exceptions =  getNr @nm : @lhs.exceptions
           lhs     .  equations  =  case @lhs.targetInfo of
                                      Just (InVar tvar)  -> [ IsKnown tvar AbsBottom ]
                                      _                  -> []

  | Catch  body    . exceptions  =  []
                   . exceptVar   =  @handlerVar
           handler . exceptions  =  @lhs.exceptions
           lhs     . exceptions  =  @handler.exceptions
           loc     . exceptEq    =  IsEqual @handlerVar @body.exceptions
                   . handlerVar  =  getNr @arg

-- Exceptions not caught in the same binding, and support for exceptions which can only found while analysing (eval calls)
ATTR AllGrExpr [ exceptVar: Variable | exceptions: {[Variable]} | ]

SEM GrBind
  | Bind  expr    . exceptions  =  []
          loc     . exceptVar   =  @loc.resultVar + 1
          loc     . exceptEq    =  IsEqual @exceptVar @expr.exceptions
%%]


%%%%%%%%%%%%%
%% Actuals %%
%%%%%%%%%%%%%

%%[8.actuals
ATTR AllBind AllGrExpr [                                | | actualsEnv USE {.} {id} : {AbstractCallList -> AbstractCallList} ]
ATTR AllBind           [ allActuals: {AbstractCallList} | |                                                            ]



SEM GrModule
  | Mod     loc . partPar  = let  f (u,        xss) (_, EvApTagVar (HNmNr n _))  = (u+1, (n,(Just u):[]):xss )
                                  f (u, (n,xs):xss) (_, EvApTagTag _          )  = (u+1, (n,(Just u):xs):xss )
                             in snd (foldl f (@lhs.unique, []) @applyTagMp)


SEM GrExpr
  | Store Unit  loc  .  fGenActuals  = \tag mns n -> let args      = if grinStoreArity
                                                                      then tail mns -- first element is the size of the rest of the node
                                                                      else      mns
                                                         resultVar = Map.lookup tag @lhs.evalMap
                                                         actuals r = ((r, args) :)
                                                     in maybe id actuals resultVar
                loc  .  actualsEnv   = case (@val.valInfo, @lhs.targetInfo) of
                                           (InNode st snms, Just (InVar tn))  -> @fGenActuals st snms tn
                                           _                                  -> id
  | Call        loc  .  actualsEnv   = ((@loc.resultVar, @argL.depVars) :)

SEM GrModule
  | Mod       bindL  .  allActuals   = @bindL.actualsEnv @loc.partPar

SEM GrBind
  | Bind      loc    .  bindActuals  = transpose [ actuals
                                                 | (resVar, actuals) <- @lhs.allActuals
                                                 , resVar == @loc.resultVar
                                                 ]
              loc    .  prune        = (@nm == evalNr) || (@nm == applyNr)
              loc    .  actualsEnv   = if @loc.prune then id else @expr.actualsEnv
              lhs    .  equations    = @loc.exceptEq                                                  
                                       :  [ IsEqual (getNr formal) [ actual | Just actual <- actuals]
                                          | (formal, actuals) <- zip @argNmL ( if    null @bindActuals
                                                                                then replicate (length @argNmL) []
                                                                                else @bindActuals
                                                                             )
                                          ]
                                       ++ @expr.equations

              lhs    .  heapEqs      = if @prune 
                                        then [] 
                                        else @expr.heapEqs
%%]
