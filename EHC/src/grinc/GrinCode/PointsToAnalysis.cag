%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]
%%[8 import({GrinCode/AbsSyn})
%%]
%%[8.wrapper
WRAPPER GrAGItf
%%]
%%[8 hs module {%{GRIN}GrinCode.PointsToAnalysis}
%%]
%%[8 hs import(qualified Data.Map as Map, qualified Data.Set as Set, Data.Maybe, Data.List(transpose))
%%]
%%[8 hs import({%{EH}Base.Common}, {%{EH}GrinCode})
%%]
%%[8 hs import({%{GRIN}GRINCCommon}, {%{GRIN}HeapPointsToFixpoint})
%%]
%%[8 hs import(Debug.Trace)
%%]

%%[8 hs export(heapPointsToAnalysis)

{-
Main module entry point:
Given a Grin-program, traverse it and collect equations for variables and locations.
Then solve the constraints, and return the resulting abstract environment&heap: the "HptMap".
As an additional Int parameter, take the first number that is not the number of any variable.
Also return it, possibly modified.
As an additional Int result, return the number of iterations that it took to solve the equations.
-}

heapPointsToAnalysis :: GrModule -> Int -> (Int,Int,HptMap)
heapPointsToAnalysis grmod unique
  = let -- traverse the tree
        inh = Inh_GrAGItf { heapPointer_Inh_GrAGItf = 0, unique_Inh_GrAGItf = unique  }
        syn = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf grmod)) inh

        -- get four synthesized attributes
        equations = equations_Syn_GrAGItf syn
        heapEqs   = heapEqs_Syn_GrAGItf syn
        applyMap  = applyMap_Syn_GrAGItf syn
        lenHeap   = heapPointer_Syn_GrAGItf syn
        
        -- now solve the equations
        (iterCount,hptMap) = solveEquations unique lenHeap equations heapEqs applyMap
        
        -- no new variables were introduced in the tree traversal, 
        -- but the equation-solver uses a variable for each applyMap-entry
        unique2   = unique + length applyMap
        
     in (iterCount, unique2, hptMap)
     
%%]

%%%%%%%%%%%%%%%%%%%%%
%% Main attributes %%
%%%%%%%%%%%%%%%%%%%%%
%%[8
{- 
The overall goal is to collect equations that express
what constraints variables and heaplocations satisfy.
-}

ATTR GrAGItf GrModule AllGlobal AllBind AllGrExpr [ | | equations  USE {++} {[]} : {Equations}
                                                        heapEqs    USE {++} {[]} : {HeapEquations}
                                                  ]

{-
The EvalMap is passed down to all expressions
The ApplyMap (slightly rewritten) is passed up to the root
A unique integer "heapPointer" is threaded through all expressions to number all Stores locations
The vaue "unique" is the first unused variable number
-}

ATTR                  AllGlobal AllBind AllGrExpr [ evalMap: {EvalMap} |                  |                       ]
ATTR GrAGItf GrModule                             [                    |                  | applyMap : {ApplyMap} ]
ATTR GrAGItf GrModule AllGlobal AllBind AllGrExpr [                    | heapPointer: Int |                       ]
ATTR GrAGItf GrModule                             [ unique: {Int}      |                  |                       ]

SEM GrModule
  | Mod     loc . evalMap = [ (t, f) | ((t,_), EvApTagVar (HNmNr f _)) <- @evalTagMp ]
            loc . applyMap = let rewrite (EvApTagVar (HNmNr f _)) = Right f
                                 rewrite (EvApTagTag t          ) = Left  t
                             in [ (t, rewrite v) | ((t,_), v) <- @applyTagMp ]

SEM GrAGItf
  | AGItf  module . heapPointer = 0

-- We use the name @UNBOXED for unboxed nodes.
-- Any other node should have a named tag.
SEM GrTag [ | | tagName: SELF ]
  | Var     lhs . tagName = error "HPT: Tag variables not allowed"



SEM GrAGItf
  | AGItf  lhs.equations = genDynApplyEqs @module.applyMap @module.heapEqs ++ @module.equations
%%]

%%[8 hs

genDynApplyEqs applyMap hEqs 
  = [ EquationDynApp (map fromJust vs) (fromJust ev)
    | (_,((GrTag_Lit GrTagApp _ _, vs), ev)) <- hEqs
    ]
    ++
    concat
    [ let  lasttag = GrTag_Lit (GrTagPApp 1        ) 0 nm
           funnr   = either undefined id (fromJust $ lookup lasttag applyMap)
           sfx     = zipWith EquationShouldBe [funnr+1+needs+length args ..] (map ((:[]).fromJust) (reverse args))
      in   sfx
    | (_,((GrTag_Lit (GrTagPApp needs) _ nm, args), ev)) <- hEqs
    ]
                      

%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% value and pattern nodes  %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%[8 hs
-- A grin value is either a single variable or a complete node denotation (with known tag)
data NodeInfo a 
  = NodeVar Int 
  | NodeDen GrTag [a]
  | NodeXXX
  deriving Show
%%]

%%[8.valInfo

SEM GrVal [ | | valInfo : {NodeInfo (Maybe Int)}]
  | Node      lhs . valInfo = NodeDen @tag.tagName @fldL.depVars
  | Tag       lhs . valInfo = NodeDen @tag.tagName []
  | Var       lhs . valInfo = NodeVar (getNr @nm)
  | Empty     lhs . valInfo = error "HPT: valinfo: empty"
  | LitInt 
    LitStr    lhs . valInfo = error "HPT: valinfo: literal"
  | NodeAdapt lhs . valInfo = error "HPT: valinfo: nodeadapt"

SEM GrValL [ | | valsInfo : {[NodeInfo (Maybe Int)]}]
  | Cons      lhs . valsInfo = @hd.valInfo : @tl.valsInfo
  | Nil       lhs . valsInfo = []

SEM GrVal  [ | | depVar:  {Maybe Int} ]
  | Var      lhs . depVar = Just (getNr @nm)
  | * - Var  lhs . depVar = Nothing

SEM GrValL [ | | depVars: {[Maybe Int]}  ]
  | Cons     lhs . depVars = @hd.depVar : @tl.depVars
  | Nil      lhs . depVars = []

SEM GrPat [ | | patInfo: {NodeInfo Int} ]
  | Node       lhs . patInfo = NodeDen @tag.tagName (map getNr @fldL)
  | Tag        lhs . patInfo = NodeDen @tag.tagName []
  | Var        lhs . patInfo = NodeVar (getNr @nm)
  | Empty      lhs . patInfo = NodeVar (getNr wildcardNr)
  | LitInt     lhs . patInfo = error "HPT: patInfo: literal"
  | NodeSplit  lhs . patInfo = error "HPT: patInfo: nodesplit"
%%]

%%%%%%%%%%%%%%%%%%%%%%%%
%% Target Information %%
%%%%%%%%%%%%%%%%%%%%%%%%

%%[8.targetInformation
{- 
Target information is either:
- the variable to which an expression is bound in a Sequence
- the result of a binding
- nothing (in the body of a Case and a Catch)
-}

ATTR AllGrExpr [ targetInfo: {NodeInfo Int} | | ]

SEM GrBind
  | Bind  loc      . resultVar   = getNr @nm
          expr     . targetInfo  = NodeVar @resultVar

SEM GrExpr
  | Seq    expr    . targetInfo  = @pat.patInfo
           body    . targetInfo  = @lhs.targetInfo
  | Catch  body    . targetInfo  = NodeXXX
           handler . targetInfo  = NodeXXX
  | Case   altL    . targetInfo  = NodeXXX

%%]


%%%%%%%%%%
%% Unit %%
%%%%%%%%%%
%%[8.unit
{-
There are five cases, depending on the structure of target and source
If there is no target, no equations are necessary
(this is the case for the unit at the end of an Case- or Catch-alternative).
If the target is a variable, we generate a single equation for it
 - if the source is a variable as well, the equation states that they should be the same
 - if the source is a node, the equation states that the variable refers to the node
If the target is a node, we generate a list of equations: one for each variable in the target
 - if the source is a variable, selections are created
 - if the source is a node, corresponding elements are equated
-}

SEM GrExpr
  | Unit   lhs . equations  = case @lhs.targetInfo of
                                NodeXXX           -> []
                                NodeVar tvar      -> case @val.valInfo of
                                                       NodeVar svar      -> [EquationShouldBe tvar [svar]]
                                                       NodeDen stag snms -> [EquationTag tvar stag snms Nothing]
                                NodeDen ttag tnms -> case @val.valInfo of
                                                       NodeVar svar      -> buildSelectEquations svar ttag tnms
                                                       NodeDen stag snms -> buildUnifyEquations  snms tnms
%%]
%%[8.unitaux hs

buildSelectEquations :: Variable -> GrTag -> [Variable] -> Equations
buildSelectEquations svar ttag tnms
  = [ EquationSelect tvar svar ttag i
    | (tvar,i) <- zip tnms [0..]
    , tvar /= getNr wildcardNr
    ]

buildUnifyEquations :: [Maybe Variable] -> [Variable] -> Equations
buildUnifyEquations snms tnms
  = [ case mbSvar of
       Nothing    -> EquationKnownToBe tvar AV_Basic
       Just svar  -> EquationShouldBe  tvar [svar]
    | (tvar,mbSvar) <- zip tnms snms
    , tvar /= getNr wildcardNr
    ]

%%]


%%%%%%%%%%%
%% Store %%
%%%%%%%%%%%
%%[8.store
{-
A unique heaplocation is allocated.
A heap-equation is generated, which associates the heaplocation with the node to be stored.
An equation is generated, which states that the targetvariable is known to be associated with this heaplocation.
-}

SEM GrExpr
  | Store  lhs . heapPointer = @lhs.heapPointer + 1  
           lhs . heapEqs     = case @val.valInfo of
                                 NodeDen stag snms -> [( @lhs.heapPointer, ((stag, snms), lookup stag @lhs.evalMap) )]
                                 _                 -> error "HPT: source of Store should be a node"
           lhs . equations   = case @val.valInfo of
                                 NodeDen stag snms -> case @lhs.targetInfo of
                                                        NodeVar tvar -> [EquationKnownToBe tvar (AV_Locations (Set.singleton @lhs.heapPointer))] 
                                                        _            -> error "HPT: destination of Store should be a variable"
                                 _                 -> error "HPT: source of Store should be a node"

{-
A global definition is similar to a Store expression
-}

SEM GrGlobal
  | Global lhs . heapPointer = @lhs.heapPointer + 1
           lhs . heapEqs     = case @val.valInfo of
                                 NodeDen stag snms -> [( @lhs.heapPointer, ((stag, snms), lookup stag @lhs.evalMap) )]
                                 _                 -> error "HPT: source of Global should be a node"
           loc . tvar        = getNr @nm
           lhs . equations   = case @val.valInfo of
                                 NodeDen stag snms -> [EquationKnownToBe @loc.tvar (AV_Locations (Set.singleton @lhs.heapPointer))]
                                 _                 -> error "HPT: source of Global should be a node"
%%]


%%%%%%%%%%
%% Eval %%
%%%%%%%%%%
%%[8.eval
{-
A single equation is generated, associating the targetvariable with the evaluation result of the function
The target cannot be a node; these have been simplified earlier by the NormForHPT transformation
-}
SEM GrExpr
  | Eval  loc . function  = getNr @nm 
          lhs . equations = case @lhs.targetInfo of
                              NodeVar n  -> [ EquationEval n @loc.function @lhs.exceptVar ]
                              _          -> error "HPT: Eval target must be variable (NormForHPT should have made it so)"
%%]

%%%%%%%%%%
%% Call %%
%%%%%%%%%%
%%[8.call
{-
If the target is a single variable, it is required to have the same value as the function result.
If the target is a node denotation, a select-equation is generated for each variable in the node.
-}
SEM GrExpr
  | Call  loc  .  resultVar   =  getNr @nm
               .  exceptions  =  @resultVar + 1 : @lhs.exceptions
          lhs  .  equations   = case @lhs.targetInfo of
                                 NodeVar n         -> [ EquationShouldBe n [@resultVar] ]
                                 NodeDen tag names -> buildSelectEquations @resultVar tag names
%%]

%%%%%%%%%%%%%%%%%%%%%%
%% Case Alternative %%
%%%%%%%%%%%%%%%%%%%%%%
%%[8.alt
-- The value of the scrutinee is passed to all alternatives
ATTR AllAlt [ valInfo: {NodeInfo (Maybe Int)} | | ]

{-
In every alternative,
a select-equation is generated for each variable in the pattern: the values are selected from the scrutinee
The scrutinee is always a variable because of earlier normalisation.
-}
SEM GrAlt
  | Alt  lhs . equations  = case @pat.patInfo of
                              NodeDen ttag tnms -> case @lhs.valInfo of
                                                     NodeVar svar -> buildSelectEquations svar ttag tnms
                                                     _            -> error "HPT: Alternative scrutinee must be a variable"
                              _                 -> error "HPT: Alternative pattern must be a node"                                                            
                            ++ @expr.equations
%%]

%%%%%%%%%%%%%%%%%%%%
%% Case and Catch %%
%%%%%%%%%%%%%%%%%%%%
%%[8.case
{-
We collect all variables that appear in a Unit at the end of each alternative.
Note that such a Unit is required to be a single variable, not a node-denotation.
-}
ATTR GrExpr AllAlt [ | | altVars USE {++} {[]} : {[Int]} ]

SEM GrExpr
  | * - Seq Unit Case
           lhs   .  altVars     = []
  | Seq    lhs   .  altVars     = @body.altVars
  | Case   lhs   .  altVars     = @altL.altVars
  | Unit   lhs   .  altVars     = case @lhs.targetInfo of
                                    NodeXXX           -> case @val.valInfo of
                                                           NodeVar svar -> [svar]
                                                           _            -> error "HPT: Unit of alternative should be a variable"
                                    _                 -> []

{-
We generate a single equation for the destination variable: it can be equal to the variables collected from all alternatives.
For a Catch we proceed similarly, the body and the handler being the two alternatives.
-}

ATTR GrVal GrValL GrAdaptL GrAdapt [ | | self : SELF ]

SEM GrExpr
  | Case   loc   .  equat       =  case @lhs.targetInfo of
                                     NodeVar tar  -> [EquationShouldBe tar @altL.altVars]
                                     NodeXXX      -> []
                                     dest         -> error ("Destination of Case " ++ show @val.self ++ " should be a variable, " ++ show dest ++ " is not.")
           lhs   .  equations   =  @loc.equat ++ @altL.equations
           
  | Catch  loc   .  equat       =  case @lhs.targetInfo of
                                     NodeVar tvar -> EquationShouldBe tvar (@body.altVars ++ @handler.altVars)
                                     _            -> error "result of Catch should be a variable"
           lhs   .  equations   =  @loc.equat : @loc.exceptEq : @body.equations ++ @handler.equations

%%]

%%%%%%%%%%
%% FFI %%%
%%%%%%%%%%
%%[8.ffi

{
avForArity = if grinStoreArity
              then [AV_Basic]
              else []
}

ATTR AllGrTag [ | | self: SELF ]

SEM GrExpr
  | FFI  loc . absVal     = Map.fromList ( case @resTagL.self of
                                            (GrTag_Any:_)     -> error "FFI result type should be a datatype or an unboxable type"
                                            (GrTag_Unboxed:_) -> [ (GrTag_Unboxed, [AV_Basic] )                       ]
                                            constructors      -> [ (con          , avForArity ) | con <- constructors ]
                                         )
         lhs . equations  = case @lhs.targetInfo of
                              NodeVar tvar      -> [ EquationKnownToBe tvar (AV_Nodes @loc.absVal) ]
                              NodeDen ttag tnms -> let f = EquationKnownToBe
                                                   in zipWith f tnms (fromJust (Map.lookup ttag @loc.absVal))
%%]

%%%%%%%%%%%
%% Apply %%
%%%%%%%%%%%
%%[8.apply
SEM GrExpr
  | App    lhs . equations= case @lhs.targetInfo of
                              NodeVar tvar -> let mkAppInfo :: NodeInfo (Maybe Int) -> Variable
                                                  mkAppInfo l = case l of
                                                                  NodeVar  v  -> v
                                                                  _           -> error "HPT: Apply arguments should all be variables"
                                              in  [ EquationApply tvar (getNr @nm) (map mkAppInfo @argL.valsInfo) @lhs.exceptVar ]
                              _            -> error "HPT: Apply target should be a variable"
%%]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Fetch, Update, FetchUpdate %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%[8.fetch
SEM GrExpr
  | FetchNode    lhs . equations =  case @lhs.targetInfo of
                                      NodeVar tvar -> [ EquationShouldBe tvar [getNr @nm] ]
                                      _            -> error "HPT: Fetch target should be a variable"
  | FetchField   lhs . equations =  error "FetchField found during HPT"
  | Update       lhs . equations =  [ EquationShouldBe (getNr @nm)  [getNr @nm,  getNr @val.getName] ]
  | FetchUpdate  lhs . equations =  [ EquationShouldBe (getNr @dst) [getNr @dst, getNr @src        ] ]
  
SEM GrVal [ | | getName : {HsName} ]
  | Var      lhs.getName = @nm
  | * - Var  lhs.getName = error "HPT: Update source should be a variable"

%%]


%%%%%%%%%%%%%%%%%%
%% Throw, Catch %%
%%%%%%%%%%%%%%%%%%
%%[8.throw
SEM GrExpr
  | Throw  loc     .  exceptions =  getNr @nm : @lhs.exceptions
           lhs     .  equations  =  case @lhs.targetInfo of
                                      NodeVar tvar  -> [ EquationKnownToBe tvar AV_Nothing ]
                                      _             -> []

  | Catch  body    . exceptions  =  []
                   . exceptVar   =  @handlerVar
           handler . exceptions  =  @lhs.exceptions
           lhs     . exceptions  =  @handler.exceptions
           loc     . exceptEq    =  EquationShouldBe @handlerVar @body.exceptions
                   . handlerVar  =  getNr @arg

-- Exceptions not caught in the same binding, and support for exceptions which can only found while analysing (eval calls)
ATTR AllGrExpr [ exceptVar: Variable | exceptions: {[Int]} | ]

SEM GrBind
  | Bind  expr    . exceptions  =  []
          loc     . exceptVar   = @resultVar + 1
          loc     . exceptEq    =  EquationShouldBe @exceptVar @expr.exceptions
%%]


%%%%%%%%%%%%%
%% Actuals %%
%%%%%%%%%%%%%

%%[8.actuals
ATTR AllBind AllGrExpr [                                    | | actualsEnv USE {.} {id} : {[(Int, [Maybe Int])] -> [(Int, [Maybe Int])]} ]
ATTR AllBind           [ allActuals: {[(Int, [Maybe Int])]} | | ]



SEM GrModule
  | Mod     loc . partPar  = let  f (u,        xss) (_, EvApTagVar (HNmNr n _))  = (u+1, (n,(Just u):[]):xss )
                                  f (u, (n,xs):xss) (_, EvApTagTag _          )  = (u+1, (n,(Just u):xs):xss )
                             in snd (foldl f (@lhs.unique, []) @applyTagMp)


SEM GrExpr
  | Store Unit  loc  .  fGenActuals  = \tag mns n -> let args      = if grinStoreArity
                                                                      then tail mns -- first element is the size of the rest of the node
                                                                      else      mns
                                                         resultVar = lookup tag @lhs.evalMap
                                                         actuals r = ((r, args) :)
                                                     in maybe id actuals resultVar
                loc  .  actualsEnv   = case (@val.valInfo, @lhs.targetInfo) of
                                           (NodeDen st snms, NodeVar tn) -> @fGenActuals st snms tn
                                           _                             -> id
  | Call        loc  .  actualsEnv   = ((@resultVar, @argL.depVars) :)

SEM GrModule
  | Mod       bindL  .  allActuals   = @bindL.actualsEnv @loc.partPar

SEM GrBind
  | Bind      loc    .  bindActuals  = transpose [ actuals
                                                 | (resVar, actuals) <- @lhs.allActuals
                                                 , resVar == @resultVar
                                                 ]
              loc    .  prune        = (@nm == evalNr) || (@nm == applyNr)
              loc    .  actualsEnv   = if @loc.prune then id else @expr.actualsEnv
              lhs    .  equations    = @loc.exceptEq                                                  
                                       :  [ EquationShouldBe (getNr formal) [ actual | Just actual <- actuals]
                                          | (formal, actuals) <- zip @argNmL ( if    null @bindActuals
                                                                                then replicate (length @argNmL) []
                                                                                else @bindActuals
                                                                             )
                                          ]
                                       ++ @expr.equations

              lhs    .  heapEqs      = if @prune 
                                        then [] 
                                        else @expr.heapEqs
%%]
