%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Eliminate unnecessary evaluations
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 import({GrinCode/AbsSyn})
%%]

%%[8 hs module {%{GRIN}GrinCode.TrfLocal.EvalElim}
%%]

%%[8 hs import(qualified Data.Set as Set,qualified Data.Map as Map)
%%]

%%[8 hs import({%{EH}Base.Builtin}, {%{EH}Base.Common}, {%{GRIN}GRINCCommon}, {%{EH}GrinCode})
%%]

%%[8 import({GrinCode/TrfLocal/CommonAliasAG})
%%]

%%[8 hs export(grEvalElim)
grEvalElim :: GrModule -> GrModule
grEvalElim grmod
  = trf_Syn_GrAGItf t
  where t = wrap_GrAGItf (sem_GrAGItf $ GrAGItf_AGItf grmod)
            $ Inh_GrAGItf
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Wrapper
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8.wrapper
WRAPPER GrAGItf
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Is name evaluated later on? Then (e.g.) building of closures can be avoided.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR GrExpr [ | | willEvalNmS: {Set.Set HsName} ]

SEM GrExpr
  | Eval        lhs         .   willEvalNmS     =   Set.singleton @nm
  | Seq         expr        .   willEval        =   case @pat.nmAlias of
                                                      NmAlias_Nm nmp
                                                        -> nmp `Set.member` @body.willEvalNmS
                                                      _ -> False
                lhs         .   willEvalNmS     =   @expr.willEvalNmS `Set.union` @body.willEvalNmS
  | * - Eval Seq
                lhs         .   willEvalNmS     =   Set.empty
%%]

%%[8
ATTR GrExpr GrVal [ willEval: Bool | | ]

SEM GrAlt
  | Alt         expr        .   willEval        =   False

SEM GrGlobal
  | Global      loc         .   willEval        =   False

SEM GrBind
  | Bind        expr        .   willEval        =   False

SEM GrAdapt
  | *           loc         .   willEval        =   False

SEM GrSplit
  | *           loc         .   willEval        =   False

SEM GrValL
  | Cons        hd          .   willEval        =   False
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Is name evaluated already evaluated? Then eval can be avoided.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs
data IsEval
  = IsEval_Eval
  | IsEval_Apply
  | IsEval_None
  deriving Eq

type IsEvalMp = Map.Map HsName IsEval
%%]

%%[8
ATTR AllGrExpr [ isEvalMp: IsEvalMp | | ]

SEM GrExpr
  | Seq         body        .   isEvalMp        =   case @pat.nmAlias of
                                                      NmAlias_Nm nmp | @expr.isEval /= IsEval_None
                                                        -> Map.insert nmp @expr.isEval @lhs.isEvalMp
                                                      _ -> @lhs.isEvalMp

SEM GrBind
  | Bind        expr        .   isEvalMp        =   Map.empty

SEM GrAlt
  | Alt         expr        .   isEvalMp        =   @lhs.isEvalMp `Map.difference` Map.fromList (zip @pat.introNmL @pat.introNmL)
%%]

%%[8
ATTR GrExpr GrVal [ | | isEval: IsEval ]

SEM GrExpr
  | FFI Call Eval App
                lhs         .   isEval          =   IsEval_Eval
  | * - Store FFI Unit Call Eval App
                lhs         .   isEval          =   IsEval_None

SEM GrVal
  | LitInt      lhs         .   isEval          =   IsEval_Eval
  | * - Node LitInt
                lhs         .   isEval          =   IsEval_None
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Transformation: 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR GrAGItf [ | | trf: GrModule ]
ATTR AllNT [ | | trf: SELF ]
%%]

%%[8
ATTR GrVal [ | | mbGrExpr: {Maybe GrExpr} ]

SEM GrVal
  | Node        (lhs.mbGrExpr,lhs.isEval)       =   case (@tag.trf,@fldL.trf) of
                                                      (GrTag_Lit GrTagFun _ nm,_) | @lhs.willEval
                                                        -> (Just $ GrExpr_Call nm @fldL.trf,IsEval_Eval)
                                                      (GrTag_Lit GrTagApp _ _,(GrVal_Var f:fs)) | @lhs.willEval
                                                        -> (Just $ GrExpr_App f fs,IsEval_Eval)
                                                      (GrTag_Lit GrTagCon _ _,_)
                                                        -> (Nothing,IsEval_Eval)
                                                      (GrTag_Lit GrTagRec _ _,_)
                                                        -> (Nothing,IsEval_Eval)
                                                      (GrTag_Lit (GrTagPApp _) _ _,_)
                                                        -> (Nothing,IsEval_Eval)
                                                      (t,_)
                                                        -> (Nothing,IsEval_None)
  | * - Node    lhs         .   mbGrExpr        =   Nothing
%%]

%%[8
SEM GrExpr
  | Store       lhs         .   trf             =   maybe @trf id @val.mbGrExpr
  | Eval        lhs         .   trf             =   case Map.lookup @nm @lhs.isEvalMp of
                                                      Just IsEval_Eval -> GrExpr_Unit (GrVal_Var @nm)
                                                      _ -> @trf
%%]

