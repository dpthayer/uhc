%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell importable interface to Grin's byte code gen
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs module {%{GRIN}GrinCode.ToGrinByteCode}
%%]

%%[8 hs import(Data.Maybe,Data.List,UU.Pretty,EH.Util.FastSeq,EH.Util.Utils,qualified Data.Set as Set,qualified Data.Map as Map,{%{EH}Base.Common},{%{EH}Base.Opts})
%%]

%%[8 hs import({%{EH}GrinCode.Pretty},{%{EH}Base.Builtin},qualified {%{GRIN}GrinByteCode} as GB,{%{EH}Core},{%{EH}GrinCode},{%{GRIN}GrinByteCode.BuiltinPrims})
%%]

%%[8 hs export(grinMod2ByteCodeMod)
%%]

%%[12 hs import({%{EH}Ty(tyRowCanonOrder)})
%%]

%%[8.WRAPPER import({GrinCode/AbsSyn})
WRAPPER GrAGItf
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell itf
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8.grinMod2ByteCodeMod hs
grinMod2ByteCodeMod :: EHCOpts -> GrModule -> GB.Module
grinMod2ByteCodeMod opts gmod
  =  let  t = wrap_GrAGItf  (sem_GrAGItf (GrAGItf_AGItf gmod))
                            (Inh_GrAGItf
                               {opts_Inh_GrAGItf = opts
                               })
     in   gbMod_Syn_GrAGItf t
%%]

%%[12 -8.grinMod2ByteCodeMod hs
grinMod2ByteCodeMod :: EHCOpts -> [HsName] -> HsName2OffsetMpMp -> HsName2OffsetMp -> GrModule -> GB.Module
grinMod2ByteCodeMod opts allImpNmL impNmOffMpMp expNmOffMp gmod
  =  let  t = wrap_GrAGItf  (sem_GrAGItf (GrAGItf_AGItf gmod))
                            (Inh_GrAGItf
                               { expNmOffMp_Inh_GrAGItf = expNmOffMp
                               , impNmOffMpMp_Inh_GrAGItf = impNmOffMpMp
                               , allImpNmL_Inh_GrAGItf = allImpNmL
                               , opts_Inh_GrAGItf = opts
                               })
     in   gbMod_Syn_GrAGItf t
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Global info
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR AllBind AllGrExpr GrModule GrAGItf [ opts: EHCOpts | | ]
%%]

%%[8
ATTR AllNTNoMod [ modNmConstInx: Int | | ]
%%]

%%[12
ATTR GrAGItf GrModule [ expNmOffMp: HsName2OffsetMp  allImpNmL: {[HsName]} | | ]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Module name map to field nr in node with imported modules
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[12
ATTR GrAGItf GrModule AllBind AllGrExpr [ impNmOffMpMp: HsName2OffsetMpMp | | ]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Constants
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs
type ConstMp = Map.Map GB.Const Int
%%]

%%[8
ATTR AllNTNoMod [ | constMp: ConstMp | ]

SEM GrModule
  | Mod         loc         .   moduleNmAlpha   =   hsnShowAlphanumeric @moduleNm
                (loc.modNmConstInx,globalL.strMp,globalL.constMp)
                                                =   constStrAdd @moduleNmAlpha Map.empty Map.empty
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Strings
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs
type StrMp = Map.Map String GB.Const

constStrAdd :: String -> StrMp -> ConstMp -> (Int,StrMp,ConstMp)
constStrAdd str strMp constMp
  = case Map.lookup str strMp of
      Just c -> (panicJust "constStrAdd" $ Map.lookup c constMp,strMp,constMp)
      _      -> (constInx,Map.insert str c strMp,Map.insert c constInx constMp)
             where strInx   = Map.size strMp
                   constInx = Map.size constMp
                   c        = GB.Const_Str strInx

constAdd :: GB.Const -> ConstMp -> (Int,ConstMp)
constAdd c constMp
  = case Map.lookup c constMp of
      Just i -> (i,constMp)
      _      -> (constInx,Map.insert c constInx constMp)
             where constInx = Map.size constMp

constCFunAdd :: String -> ConstMp -> (Int,ConstMp)
constCFunAdd nm = constAdd (GB.Const_CFunction nm)
%%]

%%[12 hs
constImpNodeAdd :: ConstMp -> (Int,ConstMp)
constImpNodeAdd = constAdd GB.Const_ImpNode
%%]

%%[8
ATTR AllNTNoMod [ | strMp: StrMp | ]

SEM GrVal
  | LitStr      (loc.constInx,lhs.strMp,lhs.constMp)
                                                =   constStrAdd @str @lhs.strMp @lhs.constMp

SEM GrExpr
  | FFI         (loc.constInx,lhs.constMp)      =   constCFunAdd @nm @lhs.constMp
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Labels
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR AllGrExpr AllBind [ | labelId: {GB.LabelId} | ]

SEM GrModule
  | Mod         loc         .   labelId         =   0

SEM GrAlt
  | Alt         (expr.labelId,loc.altLabel)     =   GB.newLabelId @lhs.labelId

SEM GrExpr
  | Case        (loc.labelId',loc.aftCaseLabel) =   GB.newLabelId @lhs.labelId
                (altL.labelId,loc.at1stOffLabel)=   GB.newLabelId @labelId'
%%]

%%[8
ATTR AllAlt [ | | altLocRefs USE {++} {[]}: {[GB.LocRef]} ]

SEM GrAlt
  | Alt         loc         .   altLocRef       =   GB.LocRef_Label @altLabel
                loc         .   altLocRefs      =   [@altLocRef]

SEM GrExpr
  | Case        loc         .   aftCaseLocRef   =   GB.LocRef_Label @aftCaseLabel
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Case labels
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
SEM GrExpr
  | Case        loc         .   nrOfAlts        =   length @altL.altLocRefs
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Stack depth simulation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR AllGrExpr [ | stkDepth: {GB.StackDepth} | ]

SEM GrBind
  | Bind        loc         .   stkDepth        =   0

SEM GrExpr
  | Unit Store Call Eval App Case FFI FetchUpdate
                loc         .   valDepth        =   @lhs.stkDepth + @valStkInc
                lhs         .   stkDepth        =   @valDepth
  | Seq         body        .   stkDepth        =   @expr.stkDepth + @seqStkInc
  | Case        altL        .   stkDepth        =   @lhs.stkDepth + @scrutineeStkInc

SEM GrAlt
  | Alt         loc         .   stkDepth        =   @lhs.stkDepth + length @pat.introNmL - 1
                lhs         .   stkDepth        =   @lhs.stkDepth

%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Tail call info
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs
data ReturnCtxt
  = ReturnCtxt_Returns      Int                         -- return from function (nr of arguments)
  | ReturnCtxt_Continues                                -- don't return, leave result on stack
  | ReturnCtxt_CaseReturns  GB.LabelId GB.StackDepth    -- return from case alt (return destination, return stack depth)

%%]

%%[8
ATTR AllGrExpr [ returnCtxt: ReturnCtxt | | ]

SEM GrBind
  | Bind        expr        .   returnCtxt      =   ReturnCtxt_Returns (length @argNmL)

SEM GrExpr
  | Seq         expr        .   returnCtxt      =   ReturnCtxt_Continues
  | Case        altL        .   returnCtxt      =   case @lhs.returnCtxt of
                                                      ReturnCtxt_Continues -> ReturnCtxt_CaseReturns @aftCaseLabel @lhs.stkDepth
                                                      _                    -> @lhs.returnCtxt
%%]

Optimisations determine whether return has been handled, if not, return the context requiring dealing with

%%[8
ATTR GrExpr [ | | mbOptimReturnCtxt: {Maybe ReturnCtxt} ]

SEM GrExpr
  | * - Eval    lhs         .   mbOptimReturnCtxt
                                                =   Nothing
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Named value introduction
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
%%]
ATTR AllGrPat [ | introOff: {GB.StackDepth} | ]

SEM GrPat
  | Var         lhs         .   introOff        =   @lhs.introOff + 1

SEM GrAlt
  | Alt         pat         .   introOff        =   0

SEM GrExpr
  | Seq         pat         .   introOff        =   0

%%[8
ATTR AllGrPat [ | | introNmL USE {++} {[]}: {[HsName]} ]

SEM GrPat
  | Var         lhs         .   introNmL        =   [@nm]
  | Node        lhs         .   introNmL        =   @fldL
%%]
  | Var         lhs         .   introNmL        =   [(@nm,@lhs.introOff)]

%%[8 hs
data NmIntro
  = NmIntro_Single    HsName
  | NmIntro_Grp       GrTag [HsName]
  | NmIntro_None
%%]

%%[8
ATTR GrPat [ | | nmIntro: NmIntro ]

SEM GrPat
  | Var         lhs         .   nmIntro         =   NmIntro_Single @nm
  | Node        lhs         .   nmIntro         =   case (@tag.self,@fldL) of
                                                      (t,[f]) | GB.tagIsUnboxed t
                                                        -> NmIntro_Single f
                                                      _ -> NmIntro_Grp @tag.self @fldL
  | * - Var Node
                lhs         .   nmIntro         =   NmIntro_None
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Named value access
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs
patNmL2VAGam :: GB.StackDepth -> [HsName] -> GB.ValAccessGam
patNmL2VAGam dep nmL = Map.fromList [ (n,GB.Val_LocalOffset (dep+o)) | (n,o) <- zip (reverse nmL) [0..] ]
%%]

%%[8
ATTR AllGrExpr AllBind [ vaGam: {GB.ValAccessGam} | | ]

SEM GrModule
  | Mod         loc         .   vaGam           =   Map.fromList $ map (\(n,o) -> (n,GB.Val_GlobEntry o)) $ Map.toList @entryNmMp

SEM GrExpr
  | Seq         body        .   vaGam           =   @newVaGam `Map.union` @lhs.vaGam

SEM GrBind
  | Bind        loc         .   newVaGam        =   Map.fromList [ (n,GB.Val_LocalOffset (@stkDepth-o)) | (n,o) <- zip @argNmL [1..] ]
                expr        .   vaGam           =   @newVaGam `Map.union` @lhs.vaGam

SEM GrAlt
  | Alt         loc         .   newVaGam        =   patNmL2VAGam @lhs.stkDepth @pat.introNmL
                expr        .   vaGam           =   @newVaGam `Map.union` @lhs.vaGam
%%]

%%[8
SEM GrExpr
  | *           loc         .   nmEnv           =   GB.NmEnv
                                                      { GB.neVAGam = @lhs.vaGam
%%[[12
                                                      , GB.neImpNmMp = @lhs.impNmOffMpMp
%%]]
                                                      }

SEM GrBind
  | Bind        loc         .   nmEnv           =   GB.NmEnv
                                                      { GB.neVAGam = @lhs.vaGam
%%[[12
                                                      , GB.neImpNmMp = @lhs.impNmOffMpMp
%%]]
                                                      }

SEM GrModule
  | Mod         loc         .   nmEnv           =   GB.NmEnv
                                                      { GB.neVAGam = @vaGam
%%[[12
                                                      , GB.neImpNmMp = @lhs.impNmOffMpMp
%%]]
                                                      }
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% GrVal Value introduction
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR GrVal [ | | grvalIntro: {GB.GrValIntro} ]
ATTR GrValL [ | | grvalIntroL: {[GB.GrValIntro]} ]

SEM GrVal
  | Var         lhs         .   grvalIntro      =   GB.GrValIntro_Nm @nm
  | LitInt      lhs         .   grvalIntro      =   GB.GrValIntro_Int (toInteger @int)
  | LitStr      lhs         .   grvalIntro      =   GB.GrValIntro_Str @str (GB.Link @lhs.modNmConstInx GB.LinkTbl_ConstPtr @constInx)
  | Node        lhs         .   grvalIntro      =   GB.GrValIntro_Grp @tag.self @fldL.grvalIntroL
  | * - Var LitStr Node LitInt
                lhs         .   grvalIntro      =   GB.GrValIntro_None

SEM GrValL
  | Nil         lhs         .   grvalIntroL     =   []
  | Cons        lhs         .   grvalIntroL     =   @hd.grvalIntro : @tl.grvalIntroL
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Delayed unit gval
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs
data UnitIntro
  = UnitIntro   GB.GrValIntro
%%]

%%[8
ATTR GrExpr [ isSeqArgCtxt: Bool | | ]

SEM GrBind
  | Bind        expr        .   isSeqArgCtxt    =   False

SEM GrAlt
  | Alt         expr        .   isSeqArgCtxt    =   False

SEM GrExpr
  | Seq         expr        .   isSeqArgCtxt    =   True
  | * - Seq     loc         .   isSeqArgCtxt    =   False
%%]

%%[8
ATTR GrExpr [ | | mbUnitIntro: {Maybe UnitIntro} ]

SEM GrExpr
  | * - Unit    lhs         .   mbUnitIntro     =   Nothing
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Expr Value introduction
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs
data EValIntro
  = EValIntro_TOS_One   { eviDepth :: GB.StackDepth }
  | EValIntro_TOS_Grp   { eviDepth :: GB.StackDepth, eviSize :: Int }
  | EValIntro_None

%%]

%%[8
ATTR GrExpr [ | | evalIntro: EValIntro ]

SEM GrExpr
  | Unit Store Call Eval App Case FFI
                lhs         .   evalIntro       =   EValIntro_TOS_One @valDepth
  | * - Unit Store Call Eval App Case Seq FFI
                lhs         .   evalIntro       =   EValIntro_None
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% FFI primitives
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
SEM GrExpr
  | FFI         loc         .   mbGbPrim        =   Map.lookup @nm gbPrims
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Expr Value codegen
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
SEM GrExpr
  | Unit        loc         .   (valIns,valStkInc,retIsDone,mbUnitIntro)
                                                =   case GB.gviLd (GB.defaultOptimCtxt {GB.ocxOmitTOSLd = ehcOptOptimise @lhs.opts >= OptimiseNormal}) @nmEnv @lhs.modNmConstInx @lhs.stkDepth @val.grvalIntro of
                                                      GB.GrValIntroAlt_One ins inc _ | not @lhs.isSeqArgCtxt
                                                        -> (ins,inc,False,Nothing)
                                                      _ -> (FSeqNil,0,True,Just (UnitIntro @val.grvalIntro))
  | Store       loc         .   (valIns,valStkInc,retIsDone,gvOptimEffect)
                                                =   case GB.gviLd (GB.defaultOptimCtxt {GB.ocxWillEval = @lhs.willEval}) @nmEnv @lhs.modNmConstInx @lhs.stkDepth @val.grvalIntro of
                                                      GB.GrValIntroAlt_One ins inc optimEffect
                                                        -> (ins, inc, False, optimEffect)
  | Call        loc         .   (valIns,valStkInc,retIsDone)
                                                =   case GB.gviLdFold GB.defaultOptimCtxt @nmEnv @lhs.modNmConstInx @lhs.stkDepth @argL.grvalIntroL of
                                                      GB.GrValIntroAlt_One ins inc _
                                                        -> case @lhs.returnCtxt of
                                                             ReturnCtxt_Returns nrArgsOuter
                                                               -> (ins :++: fins :++: FSeqL [GB.tailcall GB.InsOp_LocB_TOS nArgMine nrArgsOuter retOffSurr], 0, True)
                                                               where (fins,fdep) = GB.nmLd GB.defaultOptimCtxt @nmEnv @lhs.modNmConstInx (@lhs.stkDepth + inc) @nm
                                                                     nArgMine    = length @argL.grvalIntroL
                                                                     retOffSurr  = @lhs.stkDepth + inc + fdep
                                                             _ -> (ins', inc', False)
                                                               where (ins',inc') = GB.gvCall @nmEnv @lhs.modNmConstInx ins inc @lhs.stkDepth @nm
  | FFI         loc         .   (valIns,valStkInc,retIsDone,gvOptimEffect)
                                                =   case @mbGbPrim of
                                                      Just gbPrim | ehcOptOptimise @lhs.opts >= OptimiseNormal
                                                        -> case gbprimMk gbPrim GB.defaultOptimCtxt @nmEnv @lhs.modNmConstInx @lhs.stkDepth $ map GB.GrValIntro_Nm $ @argL of
                                                             GB.GrValIntroAlt_One ins inc optimEffect
                                                               -> (ins, inc, False, optimEffect)
                                                      _ -> case GB.gviLdFold GB.defaultOptimCtxt @nmEnv @lhs.modNmConstInx @lhs.stkDepth $ map GB.GrValIntro_Nm $ @argL of
                                                             GB.GrValIntroAlt_One ins inc _
                                                               -> (ins :++: fins :++: FSeqL [GB.callc inc], 1, False, GB.defaultOptimEffect {GB.oefIsEvaluated = True})
                                                               where fins = FSeqL [GB.ldg GB.InsOp_LocB_TOS $ GB.Link @lhs.modNmConstInx GB.LinkTbl_Const @constInx]
  | FetchUpdate loc         .   (valIns,valStkInc,retIsDone)
                                                =   case GB.gviLdFold GB.defaultOptimCtxt @nmEnv @lhs.modNmConstInx @lhs.stkDepth $ map GB.GrValIntro_Nm $ [@src,@dst] of
                                                      GB.GrValIntroAlt_One ins inc _
                                                        -> (ins :++: FSeqL [GB.fetchupdate], 0, False)
  | Eval        loc         .   (valIns,valStkInc,retIsDone,mbOptimReturnCtxt)
                                                =   let (ins,inc) = GB.nmLd (GB.defaultOptimCtxt {GB.ocxOmitTOSLd = ehcOptOptimise @lhs.opts >= OptimiseNormal}) @nmEnv @lhs.modNmConstInx @lhs.stkDepth @nm
                                                        isEvaluated = @nm `Set.member` @lhs.isEvaluatedNmS
                                                    in  case @lhs.returnCtxt of
                                                          ReturnCtxt_Returns nrArgsOuter | not isEvaluated
                                                            -> (ins :++: eins, 0, True, Nothing)
                                                            where eins       = FSeqL [GB.taileval GB.InsOp_LocB_TOS nrArgsOuter retOffSurr]
                                                                  retOffSurr = @lhs.stkDepth + inc
                                                          _ | isEvaluated
                                                                -> (ins, inc, False, Just @lhs.returnCtxt)
                                                            | otherwise
                                                                -> (ins :++: eins, inc, False, Nothing)
                                                                where eins = FSeqL [GB.eval GB.InsOp_LocB_TOS]
  | App         loc         .   (valIns,valStkInc,retIsDone)
                                                =   case GB.gviLdFold GB.defaultOptimCtxt @nmEnv @lhs.modNmConstInx @lhs.stkDepth @argL.grvalIntroL of
                                                      GB.GrValIntroAlt_One ins inc _
                                                        -> (ins :++: FSeqL [GB.ldc (length @argL.grvalIntroL)] :++: fins :++: FSeqL [GB.apply GB.InsOp_LocB_TOS], 1, False)
                                                        where (fins,_) = GB.nmLd GB.defaultOptimCtxt @nmEnv @lhs.modNmConstInx (@lhs.stkDepth + inc + 1) @nm
  | Case        loc         .   (valIns,valStkInc,retIsDone,scrutineeStkInc)
                                                =   case GB.gviLd GB.defaultOptimCtxt @nmEnv @lhs.modNmConstInx @lhs.stkDepth @val.grvalIntro of
                                                      GB.GrValIntroAlt_One ins inc _
                                                        -> (ins :++: ins',1,True,inc)
                                                        where ins' = FSeqL [GB.casecall,GB.label (GB.LocRef_Label @at1stOffLabel)]
                                                                      :++: FSeqL [ GB.labelref l | l <- @altL.altLocRefs ]
                                                                      :++: @altL.i
                                                                      :++: FSeqL [GB.label @aftCaseLocRef]
  | Seq         loc         .   (seqIns,seqStkInc,newVaGam)
                                                =   let nm ins inc nmIntro
                                                          = case nmIntro of
                                                              (NmIntro_Single nm)
                                                                -> (ins,inc,Map.fromList [(nm,GB.Val_LocalOffset (@expr.stkDepth+inc))])
                                                              (NmIntro_Grp _ nmL)
                                                                -> (ins :++: fins, inc' + length nmL,g)
                                                                where fins = FSeqL [GB.fetch GB.InsOp_LocB_TOS]
                                                                      inc' = inc - 1
                                                                      g = patNmL2VAGam (@expr.stkDepth+inc) nmL
                                                              _ -> (ins,inc,Map.empty)
                                                    in  case (@expr.mbUnitIntro,@pat.nmIntro) of
                                                          (Just (UnitIntro (GB.GrValIntro_Nm nmv)),NmIntro_Single nmp)
                                                            | ehcOptOptimise @lhs.opts >= OptimiseNormal
                                                                && isJust mbV
                                                              -> (FSeqNil,0,Map.singleton nmp (fromJust mbV))
                                                              where mbV = Map.lookup nmv @lhs.vaGam
                                                          (Just (UnitIntro gvi),nmi)
                                                              -> nm ins inc nmi
                                                              where (GB.GrValIntroAlt_One ins inc _) = GB.gviLd GB.defaultOptimCtxt @nmEnv @lhs.modNmConstInx @expr.stkDepth gvi
                                                          _   -> nm FSeqNil 0 @pat.nmIntro
%%]
  | FFI         loc         .   (valIns,valStkInc,retIsDone)
                                                =   case GB.gviLdFold GB.defaultOptimCtxt @nmEnv @lhs.modNmConstInx @lhs.stkDepth $ map GB.GrValIntro_Nm $ @argL of
                                                      GB.GrValIntroAlt_One ins inc _
                                                        -> (ins :++: fins :++: FSeqL [GB.callc inc], 1, False)
                                                        where fins = FSeqL [GB.ldg GB.InsOp_LocB_TOS $ GB.Link @lhs.modNmConstInx GB.LinkTbl_Const @constInx]

%%[8 hs
mkRet :: ReturnCtxt -> GB.StackDepth -> GB.StackDepth -> GB.InsSeq
mkRet returnCtxt stkDepth inc
  = case returnCtxt of
      ReturnCtxt_Returns nrArgsOuter
        -> FSeqL [GB.retcall 1 nrArgsOuter retOffSurr]
        where retOffSurr  = stkDepth + inc
      ReturnCtxt_CaseReturns labelId dep
        -> FSeqL [GB.retcase 1 (stkDepth + inc - dep) (GB.LocRef_Label labelId)]
      _ -> FSeqNil
%%]

%%[8
SEM GrExpr
  | Unit Store Call Eval App Case FFI
                loc         .   retIns          =   if @retIsDone
                                                    then FSeqNil
                                                    else mkRet @lhs.returnCtxt @lhs.stkDepth @valStkInc
  | Seq         loc         .   retIns          =   case @body.mbOptimReturnCtxt of
                                                      Just cx -> mkRet cx @body.stkDepth @body.stkDepth
                                                      _       -> FSeqNil
  | * - Unit Store Call Eval App Case FFI Seq
                loc         .   retIns          =   FSeqNil
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Global entry points
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR AllBind [ | | entryNms USE {:++:} {FSeqNil}: {FastSeq (HsName,Bool)} ]

SEM GrBind
  | Bind        lhs         .   entryNms        =   FSeq (@nm,null @argNmL)
                loc         .   entryInx        =   GB.vaEntryInx $ panicJust "GrBind.Bind.entryInx" $ GB.nmEnvLookup @nm @nmEnv

SEM GrModule
  | Mod         loc         .   (entryNmMp,isCafL)
                                                =   let (nL,cafL) = unzip $ toList @bindL.entryNms
                                                    in  (Map.fromList $ zip nL [0..],cafL)
                            .   mainEntry       =   maybe 0 GB.vaEntryInx $ GB.nmEnvLookup hsnMain @nmEnv
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Code generation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR GrAGItf GrModule [ | | gbMod: {GB.Module} ]

SEM GrModule
  | Mod         lhs         .   gbMod           =   GB.Module_Mod @moduleNmAlpha
%%[[12
                                                      [ (n,hsnShowAlphanumeric n) | n <- @lhs.allImpNmL ]
                                                      [ (n,hsnShowAlphanumeric n) | (n,_) <- sortOn (fst.snd) $ Map.toList @lhs.impNmOffMpMp ]
                                                      [ (n,panicJust ("GrModule.Mod.entryNmMp:" ++ show n) $ Map.lookup n @entryNmMp) | (n,_) <- sortOn snd $ Map.toList @lhs.expNmOffMp ]
%%]]
                                                      (toList $ @bindL.i :++: FSeqL [GB.halt])
                                                      [ s | (s,_) <- sortOn (GB.constInx . snd) $ Map.toList @bindL.strMp ]
                                                      [ c | (c,_) <- sortOn snd $ Map.toList @bindL.constMp ]
                                                      [ i | (i,True) <- zip [0..] @isCafL ]
                                                      @mainEntry
                                                      (toList @bindL.fixOffsets)
%%]
                                                      [ e | e@(n,_) <- tyRowCanonOrder $ Map.toList @entryNmMp, n `Set.member` @lhs.expNmS ]

%%[8
ATTR AllBind AllGrExpr [ | | i USE {:++:} {FSeqNil}: {GB.InsSeq} ]

SEM GrBind
  | Bind        loc         .   yesCode         =   @nm `notElem` [hsnGrEval, hsnGrApply]
                lhs         .   i               =   if @yesCode then FSeqL [GB.label (GB.LocRef_CodeEntry @entryInx),GB.meta @nm] :++: @expr.i else FSeqNil

SEM GrExpr
  | Unit Store Call Eval App Case FFI FetchUpdate
                lhs         .   i               =   @valIns :++: @retIns
  | Seq         lhs         .   i               =   @expr.i :++: @seqIns :++: @body.i :++: @retIns

SEM GrAlt
  | Alt         lhs         .   i               =   FSeqL [GB.label @altLocRef,GB.fetch GB.InsOp_LocB_TOS] :++: @expr.i
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Fixing offsets, constructing FixOffset entries
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR AllBind AllGrExpr [ | | fixOffsets USE {:++:} {FSeqNil}: {FastSeq GB.FixOffset} ]

SEM GrExpr
  | Case        lhs         .   fixOffsets      =   FSeqL [GB.FixOffset @at1stOffLabel @nrOfAlts] :++: @altL.fixOffsets
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Is name evaluated later on? Then (e.g.) building of closures can be avoided.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR GrExpr [ willEval: Bool | | willEvalNmS: {Set.Set HsName} ]

SEM GrExpr
  | Eval        lhs         .   willEvalNmS     =   Set.singleton @nm
  | Seq         (lhs.willEvalNmS,expr.willEval) =   case (@expr.mbUnitIntro,@pat.nmIntro) of
                                                      (Just (UnitIntro (GB.GrValIntro_Nm nmv)),NmIntro_Single nmp)
                                                        | ehcOptOptimise @lhs.opts >= OptimiseNormal
                                                            && nmp `Set.member` @body.willEvalNmS
                                                          -> (Set.insert nmv @body.willEvalNmS,True)
                                                      (_,NmIntro_Single nmp)
                                                          -> (@body.willEvalNmS,nmp `Set.member` @body.willEvalNmS)
                                                      _   -> (@body.willEvalNmS,False)
  | * - Eval Seq
                lhs         .   willEvalNmS     =   Set.empty

SEM GrAlt
  | Alt         expr        .   willEval        =   False

SEM GrBind
  | Bind        expr        .   willEval        =   False
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Is name evaluated already evaluated? Then eval can be avoided.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR AllGrExpr [ | isEvaluatedNmS: {Set.Set HsName} | ]
ATTR GrExpr [ | | isEvaluated: Bool ]

SEM GrExpr
  | Store FFI   lhs         .   isEvaluated     =   ehcOptOptimise @lhs.opts >= OptimiseNormal && GB.oefIsEvaluated @gvOptimEffect
  | * - Store FFI
                lhs         .   isEvaluated     =   False

SEM GrExpr
  | Seq         body        .   isEvaluatedNmS  =   case (@expr.mbUnitIntro,@pat.nmIntro) of
                                                      (Just (UnitIntro (GB.GrValIntro_Nm nmv)),NmIntro_Single nmp)
                                                        | ehcOptOptimise @lhs.opts >= OptimiseNormal
                                                            && nmv `Set.member` @expr.isEvaluatedNmS
                                                          -> Set.insert nmp @expr.isEvaluatedNmS
                                                      (_,NmIntro_Single nmp)
                                                        | ehcOptOptimise @lhs.opts >= OptimiseNormal
                                                            && @expr.isEvaluated
                                                          -> Set.insert nmp @expr.isEvaluatedNmS
                                                      _   -> @expr.isEvaluatedNmS

SEM GrAlt
  | Alt         lhs         .   isEvaluatedNmS  =   @lhs.isEvaluatedNmS
                expr        .   isEvaluatedNmS  =   @lhs.isEvaluatedNmS

SEM GrBind
  | Bind        expr        .   isEvaluatedNmS  =   Set.empty
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% SELF
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR GrTag [ | | self: SELF ]
%%]

