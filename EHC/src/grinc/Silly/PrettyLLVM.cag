%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[8 hs module {%{GRIN}Silly.PrettyLLVM} import(EH.Util.Pretty, qualified Data.Map as Map, qualified Data.Set as Set,  {%{GRIN}GRINCCommon} hiding (Variable(..)),{%{GRIN}Silly}) export(prettyLLVM)
%%]
%%[8 hs import({%{EH}Base.Opts})
%%]
%%[8 hs import({%{EH}Base.Common})
%%]
%%[8 hs import({%{GRIN}ConfigDefines})
%%]
%%[8 hs import(Data.List(intersperse))
%%]
%%[8 import({Silly/AbsSyn})
%%]


%%[8 hs
prettyLLVM :: EHCOpts -> SilModule -> PP_Doc
prettyLLVM _ silmod
  = let intType = if sizeofPointer == 8
                  then I64
                  else I32
        ptrType = pLift intType
        t = wrap_SilModule (sem_SilModule silmod) 
                           (Inh_SilModule { intType_Inh_SilModule = 
                                              intType
                                          , pointerType_Inh_SilModule =
                                              ptrType
                                          }
                           )
     in  code_Syn_SilModule t
%%]

%%[8.LLVMCode

WRAPPER SilModule

--------------------------------------------------------------------------------
-- MODULE GENERATION
--------------------------------------------------------------------------------
ATTR SilModule Functions Function 
     Statements Statement 
     Values Value
     Variable
     Constant
     [ | | code USE {>-<} {empty} : {PP_Doc} ]    

SEM SilModule
  | SilModule   lhs.code  = mkComment "Map of constructor identifiers"
                            >-< mkCommentList @constants
                            >-< mkGlobalList 
                                  @lhs.pointerType 
                                  ( "RP" 
                                  : map hsnShowAlphanumeric @variables
                                  )
                            >-< @functions.code

-- Debug: We only work on the first function
--
ATTR Functions [ count : {Int} | | ]
SEM SilModule
  | SilModule   functions.count = 0

SEM Functions
  | Cons        lhs.code = if @lhs.count > 0
                           then @hd.code
                           else @hd.code >-< @tl.code
                tl.count = @lhs.count + 1
  | Nil         lhs.code = empty
-- End Debug
--
  
SEM Function  
  | Function    lhs.code = mkFunction @name 
                                      (zip @parameters (repeat @lhs.intType))
                                      (indent 2 (@loc.code >-< @body.code))
                                      
                body.uniqueNr =
                           @loc.uniqueNr
                                                 
                loc.(uniqueNr,code) =
                           mkRPInit (hsnShowAlphanumeric @name) @lhs.uniqueNr
                                    @lhs.intType 5   -- TODO make real max RP size


SEM Statement
  | Assignment  lhs.code = @source.code
                           >-< @dest.code
                           >-< @loc.code
                           >-< mkAssign @loc.resId (pLower @dstTp)
                                        @loc.dstId @loc.dstTp
                lhs.uniqueNr = @loc.uniqueNr
                
                dest.uniqueNr             = @lhs.uniqueNr
                
                source.uniqueNr           = @dest.uniqueNr
                               
                loc.(uniqueNr,resId,code) =
                           mkCast @source.uniqueNr @srcId 
                                  @srcTp (pLower @dstTp)
                loc.(srcId, srcTp)        = @source.resultId
                loc.(dstId, dstTp)        = @dest.resultId        
                      
  | Comment     lhs.code = mkCommentList @comment                    
                      
  | Call        lhs.code = @args.code
                           >-< mkCall (hsnShowAlphanumeric @name) 
                                      @args.resultIds
                                      Void
                                      @tailJumps 
  | Return      lhs.code = mkReturn
  | * - Call Return Assignment Comment
                lhs.code = mkComment "Statement not implemented yet"  
                
SEM Value
  | Alloc       lhs.code      = mkAlloc @loc.freshName @lhs.intType @size
                lhs.resultId  = (@loc.freshName,@lhs.pointerType)
                lhs.uniqueNr  = @lhs.uniqueNr + 1
                                
                loc.freshName = LocalVar (mkFreshName @lhs.uniqueNr)  

  | BoxVar      lhs.code      = @var.code >-< @loc.code
                lhs.resultId  = (@loc.resultVar,snd @var.resultId)
                lhs.uniqueNr  = @loc.uniqueNr
                
                var.uniqueNr  = @lhs.uniqueNr
  
                loc.(uniqueNr,resultVar,code) =
                                mkBox @var.uniqueNr @var.resultId 

  | Call        lhs.code      = @args.code >-< @loc.code
                lhs.resultId  = (@loc.resultVar,@lhs.intType)
                lhs.uniqueNr  = @loc.uniqueNr
                
                args.uniqueNr = @lhs.uniqueNr
                
                loc.(uniqueNr,resultVar,code) = 
                                mkNonSillyCall @name @args.uniqueNr 
                                               @lhs.constantMap
                                               @args.resultIds @lhs.intType
                                               
  | Con         lhs.code      = @con.code
                lhs.resultId  = @con.resultId
                
  | Var         lhs.code      = @var.code
                lhs.resultId  = @var.resultId
                              
  | * - Alloc Call Con BoxVar Var
                lhs.code      = text "TODO Value code"
                lhs.resultId  = (LocalVar "TODOVALUEID", @lhs.intType)               
 
SEM Variable
  | Global      lhs.code      = if @lhs.isMallocTarget
                                then empty
                                else @loc.code
                lhs.resultId  = if @lhs.isMallocTarget
                                then ( GlobalVar $ hsnShowAlphanumeric @name
                                     , pLift @lhs.pointerType)
                                else (@loc.resultVar,@lhs.pointerType)
                lhs.uniqueNr  = if @lhs.isMallocTarget
                                then @lhs.uniqueNr
                                else @loc.uniqueNr
                                
                loc.(uniqueNr,resultVar,code) =
                                mkLoad @lhs.uniqueNr 
                                       (GlobalVar $ hsnShowAlphanumeric @name) 
                                       (pLift @lhs.pointerType)                   

  | Local       lhs.code       = empty
                lhs.resultId   = if @name `Set.member` @lhs.locals
                                    && @lhs.inCaseOrIf
                                 then (LocalVar $ mkFreshName @lhs.uniqueNr
                                      , @lhs.intType)                                     
                                 else (LocalVar $ hsnShowAlphanumeric @name
                                      , @lhs.intType)
                lhs.uniqueNr   = if @name `Set.member` @lhs.locals
                                    && @lhs.inCaseOrIf
                                 then @lhs.uniqueNr + 1
                                 else @lhs.uniqueNr
  
  | Param       lhs.code       = empty
                lhs.resultId   = ( LocalVar $ hsnShowAlphanumeric @name
                                 , @lhs.pointerType )
                                 
  | RP          lhs.code       = @loc.code
                lhs.resultId   = (@loc.resultVar,@lhs.pointerType)
                lhs.uniqueNr   = @loc.uniqueNr
  
                loc.(uniqueNr,resultVar,code) =
                                 mkLoad @lhs.uniqueNr
                                        (GlobalVar "RP")
                                        (pLift @lhs.pointerType)
                
  | Subs        lhs.code       = if @lhs.isRHS
                                 then @array.code >-< @loc.code >-< @loc.code'
                                 else @array.code >-< @loc.code
                lhs.resultId   = if @lhs.isRHS
                                 then (@loc.resultVar', pLower @loc.resultType)
                                 else (@loc.resultVar, @loc.resultType)
                lhs.uniqueNr   = if @lhs.isRHS
                                 then @loc.uniqueNr'
                                 else @loc.uniqueNr
                
                array.uniqueNr = @lhs.uniqueNr
                
                loc.resultType = snd @array.resultId
                loc.(uniqueNr,resultVar,code) =
                           mkArrayAccess @array.uniqueNr @array.resultId @index
                loc.(uniqueNr',resultVar',code') =
                           mkLoad @loc.uniqueNr @loc.resultVar 
                                  @loc.resultType
                                  
  | * - Global Subs Param RP Local
                lhs.code       = text "TODOVariableCode"
                lhs.resultId   = (LocalVar "TODOVariableId",@lhs.pointerType)
  
%%]

%%[8.LLVMResults
--------------------------------------------------------------------------------
-- LLVM Results
-- We return in which variable the result is placed and what the type is of
-- this variable
--------------------------------------------------------------------------------
{
type Result = (LLVMValueType,LLVMType)
}

ATTR Values
     [ | | resultIds : {[Result]} ]     
ATTR Value
     Variable
     Constant
     [ | | resultId : {Result} ] 

SEM Values
  | Cons        lhs.resultIds = @hd.resultId : @tl.resultIds
  | Nil         lhs.resultIds = [] 

                           
SEM Constant
  | LiteralInt  lhs.resultId    = (Constant $ show @value,@lhs.intType)
  | LiteralStr  lhs.resultId    = error "Strings are not supported yet"
  | Alias       lhs.resultId    = let value = Map.findWithDefault 
                                              (error "No such constant")
                                              @name @lhs.constantMap
                                   in (Constant $ show value,@lhs.intType)
%%]

%%[8.LLVMTypes
--------------------------------------------------------------------------------
-- LLVM TYPES
-- In LLVM we have two types, Integers and Pointers.
-- Currently we only have 32 and 64 bit variants.
-- We require the integer size = pointer size
--------------------------------------------------------------------------------
{
data LLVMType
  = I64
  | I64Pointer
  | I64PointerPointer
  | I32
  | I32Pointer
  | I32PointerPointer
  | Void
  | Problem
  deriving (Eq)
  
instance Show LLVMType where
  show I64                = "i64"
  show I64Pointer         = "i64*"
  show I64PointerPointer  = "i64**"
  show I32                = "i32"
  show I32Pointer         = "i32*"
  show I32PointerPointer  = "i32**"
  show Void               = "void" 
  show Problem            = "PROBLEM" -- TODO 
  
data LLVMValueType
  = GlobalVar String
  | LocalVar  String
  | Constant  String
  
instance Show LLVMValueType where
  show (GlobalVar x) = "@" ++ x
  show (LocalVar x)  = "%" ++ x
  show (Constant x)  = x    
  
pLift :: LLVMType -> LLVMType
pLift I64                 = I64Pointer
pLift I64Pointer          = I64PointerPointer
pLift I32                 = I32Pointer
pLift I32Pointer          = I32PointerPointer
pLift x                   = Problem

pLower :: LLVMType -> LLVMType
pLower I64Pointer          = I64
pLower I64PointerPointer   = I64Pointer
pLower I32Pointer          = I32
pLower I32PointerPointer   = I32Pointer
pLower x                   = Problem

isPointerType :: LLVMType -> Bool
isPointerType (I64Pointer)          = True
isPointerType (I64PointerPointer)   = True
isPointerType (I32Pointer)          = True
isPointerType (I32PointerPointer)   = True
isPointerType _                     = False

ppType :: (Show a) => a -> PP_Doc
ppType = text.show
}  

ATTR SilModule Functions Function 
     Statements Statement
     Alternatives Alternative
     Values Value
     Variables Variable
     Constant
     [ pointerType, intType : LLVMType | | ]

%%]

%%[8.LLVMCounter
--------------------------------------------------------------------------------
-- Counter
-- The counter is used for generating fresh variables if needed.
--------------------------------------------------------------------------------
ATTR Functions Function 
     Statements Statement
     Alternatives Alternative
     Values Value
     Variables Variable
     [ | uniqueNr : Int | ]
     
SEM SilModule
  | SilModule   functions.uniqueNr = 0
%%]

%%[8.LLVMConstantMap
--------------------------------------------------------------------------------
-- Constant Map
-- We pass down a constructor map, containing the alias name and the 
-- corresponding Int value
--------------------------------------------------------------------------------
ATTR Functions Function 
     Statements Statement
     Alternatives Alternative
     Values Value
     Variables Variable
     Constant
     [ constantMap : {Map.Map String Int} | | ]

SEM SilModule
  | SilModule   functions.constantMap = Map.fromList @constants
%%]

%%[8.LLVMLocalsSet
--------------------------------------------------------------------------------
-- Local Set
-- We pass down a Set, containing all local variables
--------------------------------------------------------------------------------
ATTR Statements Statement
     Alternatives Alternative
     Values Value
     Variables Variable
     Constant
     [ locals : {Set.Set HsName} | | ]

SEM Function
  | Function   body.locals = Set.fromList @locals
%%]

%%[8.LLVMPositionCaseIf
--------------------------------------------------------------------------------
-- Local Set
-- We handle variables differently within case or if statements
--------------------------------------------------------------------------------
ATTR Statements Statement
     Alternatives Alternative
     Values Value
     Variables Variable
     [ inCaseOrIf : {Bool} | | ]

SEM Function
  | Function   body.inCaseOrIf = False
  
SEM Statement
  | If         body.inCaseOrIf = True
  | Switch     body.inCaseOrIf = True
%%]


%%[8.LLVMPosition
--------------------------------------------------------------------------------
-- Position
-- We need to know which position of the assign statement the value
-- or variable is located
--------------------------------------------------------------------------------
ATTR Values Value
     Variables Variable
     [ isLHS, isRHS : {Bool} | | ]

ATTR Variables Variable
     [ isMallocTarget : {Bool} | | ]
    
ATTR Value
     [ | | isMalloc USE {&&} {True} : {Bool} ]
    
SEM Value 
  | Alloc       lhs      .isMalloc = True
  | * - Alloc   lhs      .isMalloc = False 
  
SEM Variable
  | Subs        array    .isMallocTarget = @lhs.isMallocTarget
  
SEM Statement
  | Assignment  dest     .isMallocTarget = @source.isMalloc
  | Assignment2 dest1    .isMallocTarget = @source.isMalloc
                dest2    .isMallocTarget = @source.isMalloc

SEM Value
  | BoxVar      var      .isMallocTarget = False
  | Var         var      .isMallocTarget = False
  | Offset      var      .isMallocTarget = False                   
    
SEM Statement
  | Assignment  source   .isLHS = False
                source   .isRHS = True
                dest     .isLHS = True
                dest     .isRHS = False
  | Assignment2 dest1    .isLHS = True
                dest1    .isRHS = False
                dest2    .isLHS = True
                dest2    .isRHS = False
                source   .isLHS = False
                source   .isRHS = True
  | If          scrutinee.isLHS = False
                scrutinee.isRHS = True
  | Switch      scrutinee.isLHS = False
                scrutinee.isRHS = True
  | Call        args     .isLHS = False
                args     .isRHS = True
  | Smart       vals     .isLHS = error "Smart in LLVM Code Generation"
                vals     .isRHS = error "Smart in LLVM Code Generation"
                
%%]

%%[8.LLVMHelpers
{
--------------------------------------------------------------------------------
-- HELPER FUNCTIONS
--------------------------------------------------------------------------------
vlist' :: (a -> PP_Doc) -> [a] -> PP_Doc
vlist' f = foldr (\x xs -> f x >-< xs) empty 

mkComment :: (Show a) => a -> PP_Doc
mkComment x = ";" >#< show x

mkCommentList :: (Show a) => [a] -> PP_Doc
mkCommentList = vlist' mkComment

mkGlobalId :: String -> PP_Doc
mkGlobalId = ppType.GlobalVar

mkGlobalIdFromHsName :: HsName -> PP_Doc
mkGlobalIdFromHsName = mkGlobalId.hsnShowAlphanumeric 

mkVar :: String -> PP_Doc
mkVar = ppType.LocalVar

mkGlobal :: LLVMType -> String -> PP_Doc
mkGlobal tp id = mkGlobalId id 
                 >#< "= internal global" 
                 >#< ppType tp >#< "null"

mkGlobalList :: LLVMType-> [String] -> PP_Doc
mkGlobalList tp = vlist' (mkGlobal tp)

mkParamList :: [Result] -> [PP_Doc]
mkParamList params = 
  Data.List.intersperse (text ", ") $
  map (\(nm,tp) -> ppType tp >#< ppType nm) params

mkFunction :: HsName -> [(HsName,LLVMType)] -> PP_Doc -> PP_Doc
mkFunction id params body =
  let params' = mkParamList $ map (\(x,y) -> (LocalVar (hsnShowAlphanumeric x)
                                             ,y)) params
   in "define internal void" >#< mkGlobalIdFromHsName id
      >|< "(" >#< hlist params' >#< ")"
      >-< "{" >-< body >-< "}" 
      
mkCall :: String -> [Result] -> LLVMType -> Bool -> PP_Doc
mkCall id params retTp tail =
  let annotation = if tail then text "tail " else empty
      params' = mkParamList params      
   in annotation >|< "call" >#< ppType retTp >#< id
      >|< "(" >#< hlist params' >#< ")" 
      
mkReturn :: PP_Doc
mkReturn = text "ret void"      
      
mkFreshName :: Int -> String
mkFreshName nr = "fresh" ++ show nr

mkFreshVar :: Int -> PP_Doc
mkFreshVar = mkVar.mkFreshName

mkArrayAccess :: Int -> Result -> Int -> (Int,LLVMValueType,PP_Doc)
mkArrayAccess uniqueNr (resVar,resTp) index =
  let tmp  = LocalVar $ mkFreshName uniqueNr
      code = ppType tmp >#< "= getelementptr" >#< ppType resTp >#< ppType resVar
             >#< "," >#< "i32" >#< show index
   in (uniqueNr + 1, tmp, code)

mkAlloc :: LLVMValueType -> LLVMType -> Int -> PP_Doc
mkAlloc id tp size= 
  ppType id >#< "= malloc" >#< ppType tp 
            >|< "," >#< "i32" >#< show size
                       
mkAssign :: LLVMValueType -> LLVMType -> LLVMValueType -> LLVMType -> PP_Doc
mkAssign srcId srcTp dstId dstTp = 
  "store" >#< ppType srcTp >#< ppType srcId 
  >|< "," >#< ppType dstTp >#< ppType dstId   
 
mkLoad :: Int -> LLVMValueType -> LLVMType -> (Int,LLVMValueType,PP_Doc)
mkLoad uniqueNr srcId srcTp =
  let tmp  = LocalVar $ mkFreshName uniqueNr
      code = ppType tmp >#< "=" >#< "load" >#< ppType srcTp >#< ppType srcId
   in (uniqueNr + 1, tmp, code)
 
mkCast :: Int -> LLVMValueType -> LLVMType -> LLVMType 
          -> (Int,LLVMValueType,PP_Doc)
mkCast uniqueNr fromId fromType toType
  | fromType == Void 
    || toType == Void           = error "Void is uncastable" 
  | fromType == toType          = (uniqueNr,fromId,empty)
  | (  pLift fromType == toType
    || fromType == pLift toType
    )                           = let  tmp   = LocalVar $ mkFreshName uniqueNr
                                       castF = if isPointerType toType
                                               then if isPointerType fromType
                                                    then "bitcase"
                                                    else "inttoptr"
                                               else "ptrtoint"
                                       code  = ppType tmp >#< "=" >#< castF >#<
                                               ppType fromType >#< ppType fromId
                                               >#< "to" >#< ppType toType
                                   in (uniqueNr + 1,tmp,code)
  | isPointerType toType        = let (uniqueNr1,tmp,code) =
                                        mkCast uniqueNr fromId fromType 
                                               (pLift fromType)
                                      (uniqueNr2,tmp',code') =
                                        mkCast uniqueNr1 tmp (pLift fromType) toType
                                    in (uniqueNr2,tmp',code >-< code')
  | otherwise                   = (uniqueNr,fromId,empty) -- Problem case TODO

-- DIRTY HACK, HAS TO CHANGE
--
mkNonSillyCall :: String -> Int -> Map.Map String Int -> [Result]
               -> LLVMType -> (Int,LLVMValueType,PP_Doc)
mkNonSillyCall fnName =
  case fnName of
    "primGtInt"  -> mkCmp "sgt" 
    "primAddInt" -> error "Bla" -- mkInfix "add"      
    
mkCmp :: String-> Int -> Map.Map String Int -> [Result]
      -> LLVMType -> (Int,LLVMValueType,PP_Doc)
mkCmp op uniqueNr constantMap args intType=  
  let tmp    = LocalVar $ mkFreshName uniqueNr
      tmp'   = LocalVar $ mkFreshName (uniqueNr + 1)
      args'  = Data.List.intersperse (text ", ") $ map (ppType.fst) args
      trueV  = Map.findWithDefault (error "No CTrue") "CTrue" constantMap
      falseV = Map.findWithDefault (error "No CFalse") "CFalse" constantMap
      code   = ppType tmp >#< "= icmp" >#< op >#< ppType intType >#< hlist args'
               >-<
               ppType tmp' >#< "= select i1" >#< ppType tmp >#< "," >#<
               ppType intType >#< show trueV >#< "," >#<
               ppType intType >#< show falseV
   in (uniqueNr + 2, tmp', code)
 
mkRPInit :: String -> Int -> LLVMType -> Int -> (Int,PP_Doc)
mkRPInit fnName uniqueNr intType maxRPSize =
  let tmp       = LocalVar $ mkFreshName uniqueNr
      allocCode = mkAlloc tmp intType maxRPSize
      storeCode = mkAssign tmp (pLift intType) 
                           (GlobalVar "RP") (pLift $ pLift intType)
   in if fnName == "initialize"
      then (uniqueNr + 1, allocCode >-< storeCode)
      else (uniqueNr,empty)     
      
mkBox :: Int -> Result -> (Int,LLVMValueType,PP_Doc)
mkBox uniqueNr (tp,id) =
  let tmp  = LocalVar $ mkFreshName uniqueNr
      code = ppType tmp >#< "= ashr" >#< ppType tp >#< ppType id 
                                     >|< "," >#< show 1
   in (uniqueNr + 1, tmp, code)                  
}
%%]
