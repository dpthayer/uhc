%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[8 hs module {%{GRIN}Silly.ToLLVM} export(silly2llvm)
%%]
%%[8 hs import({%{GRIN}LLVM})
%%]
%%[8 hs import({%{GRIN}Silly})
%%]
%%[8 hs import({%{EH}Base.Common})
%%]
%%[8 hs import({%{GRIN}ConfigDefines})
%%]
%%[8 import({Silly/AbsSyn})
%%]
%%[8 hs import(qualified Data.Map)
%%]
%%[8
WRAPPER SilModule
%%]

%%[8 hs
silly2llvm :: SilModule -> LLVMModule
silly2llvm silmod = 
  let intType    = if sizeofPointer == 8
                   then I64
                   else I32
      ptrType    = pLift intType
      gblType    = pLift ptrType
      t = wrap_SilModule (sem_SilModule silmod)
                         (Inh_SilModule { intType_Inh_SilModule = intType 
                                        , pointerType_Inh_SilModule = ptrType
                                        , globalType_Inh_SilModule = gblType
                                        , gUniq_Inh_SilModule = uidStart
                                        } 
                         )
   in llvmCode_Syn_SilModule t
%%]

%%[8
{
type LLVMExpr = Either Var (Expression,LLVMType)

getExprType :: LLVMExpr -> LLVMType
getExprType (Left var) =
  getType var
getExprType (Right expr) =
  snd expr
}

ATTR SilModule
     [ | | llvmCode : {LLVMModule} ]

ATTR Functions
     [ | | llvmCode : {Funcs} ]

ATTR Function
     [ | | llvmCode : {Func} ] 
   
ATTR Statements Statement
     Values Value
     Variables Variable
     [ | | llvmCode : {Stmts} ]
     
ATTR Values
     Variables
     [ | | llvmExpr : {[LLVMExpr]} ]

ATTR Value
     Variable
     [ | | llvmExpr : {LLVMExpr} ]   
 
ATTR Alternatives
     [ | | jumpTargets : {[(Var,Var,Stmts)]} ]
     
ATTR Alternative
     [ | | jumpTarget : {(Var,Var,Stmts)} ] 
     
ATTR Constant    
     [ | | var : {Var} ]  
     
ATTR AllNT
     [ gUniq: UID | | ]      
           
SEM SilModule
  | SilModule   lhs.llvmCode = LLVMModule_LLVMModule @loc.comment
                                                     @loc.constants 
                                                     @loc.globals 
                                                     ( @loc.printfDecl
                                                     : gcInitFuncDecl
                                                     : gcMallocFuncDecl @lhs.intType
                                                     : gcMallocUncollectableFuncDecl @lhs.intType
                                                     : primPatternMatchFailureFuncDecl
                                                     : @functions.externFuncs 
                                                     )
                                                     ( @loc.main 
                                                     : @functions.llvmCode 
                                                     )
                                                     
                loc.comment  = map (\(s,i) -> s ++ "->" ++ show i) @constants  
                loc.constants= [ ( GlobalVar "STR_RES" (Array 22 I8)
                                  , StrConst "c\"Tag: %lld Value:%lld\\0A\\00\""
                                             (Array 22 I8)
                                  )
                               ]
                loc.globals  = GlobalVar "RP" (@lhs.globalType) :
                               mkVarList GlobalVar @variables @lhs.globalType                              
                loc.printfDecl =
                               FuncDecl_FuncDecl "printf" I32 True
                                                 [(LocalVar "str" (pLift I8))]                                               
                loc.main     = Func_Func 
                                 (FuncDecl_FuncDecl "main" I32 False []) False
                                 [ Stmt_Assignment 
                                     (LocalVar "rpArr" @lhs.pointerType)
                                     (mkMalloc True @lhs.intType 
                                                    (1 + @functions.maxRPSize)
                                     )
                                 , Stmt_Store
                                     (LocalVar "rpArr" @lhs.pointerType)
                                     (GlobalVar "RP" @lhs.globalType)
                                 , Stmt_Call
                                     (FuncDecl_FuncDecl "initialize" Void False [])
                                     False []
                                 , Stmt_Call
                                     (FuncDecl_FuncDecl "fun_main" Void False [])
                                     False []
                                 , Stmt_Assignment 
                                     (LocalVar "rp.0.val" @lhs.intType)
                                     (Expression_Load 
                                       (LocalVar "rpArr" @lhs.pointerType)
                                     )
                                 , Stmt_Assignment
                                     (LocalVar "rp.1" @lhs.pointerType)
                                     (Expression_GetElemPtr
                                       (LocalVar "rpArr" @lhs.pointerType) [1]
                                     )
                                 , Stmt_Assignment
                                     (LocalVar "rp.1.val" @lhs.intType)
                                     (Expression_Load 
                                       (LocalVar "rp.1" @lhs.pointerType)
                                     )
                                 , Stmt_Assignment
                                     (LocalVar "rp.2" @lhs.pointerType)
                                     (Expression_GetElemPtr
                                       (LocalVar "rpArr" @lhs.pointerType) [2]
                                     )
                                 , Stmt_Assignment
                                     (LocalVar "rp.2.val" @lhs.intType)
                                     (Expression_Load 
                                       (LocalVar "rp.2" @lhs.pointerType)
                                     )                                                                                 
                                 , Stmt_Assignment
                                     (LocalVar "cast.str.res" (pLift I8))
                                     (Expression_GetElemPtr 
                                       (GlobalVar "STR_RES" (pLift $ Array 22 I8))
                                       [0,0]
                                     )  
                                 , Stmt_Call
                                     @loc.printfDecl True
                                     [ LocalVar "cast.str.res" (pLift I8)
                                     , LocalVar "rp.0.val" @lhs.intType
                                     , LocalVar "rp.1.val" @lhs.intType
                                     ] 
                                 , Stmt_Return (Constant 0 I32)  
                                 ]                    
                               
SEM Functions
  | Cons        lhs.llvmCode = @hd.llvmCode : @tl.llvmCode
 
                (tl.gUniq, hd.gUniq) = 
                               mkNewLevUID @lhs.gUniq
  | Nil         lhs.llvmCode = []

SEM Function
  | Function    lhs.llvmCode = let locals = map (\nm -> Stmt_Assignment 
                                                          (LocalVar (hs2str nm) @lhs.pointerType)
                                                          (Expression_Alloca @lhs.intType 1)
                                                ) @locals
                                in Func_Func @loc.fnDecl True $
                                   locals ++ @body.llvmCode
 
SEM Statements
  | Cons        lhs.llvmCode = @hd.llvmCode ++ @tl.llvmCode
                
                (tl.gUniq, hd.gUniq) = 
                               mkNewLevUID @lhs.gUniq
                
  | Nil         lhs.llvmCode = []
  
SEM Statement
  -- A Silly assign will translate to a store. We have the following steps
  --   * If the RHS is an expression, assign the RHS to a fresh var
  --   * Do the same for the LHS
  --   * If the LHS is a localvar, then we just assign to a temporary
  --   * check if the LHS is a pointertype, otherwise cast to pointer
  --   * check if the RHS type fits in the pointertype of the LHS, otherwise
  --     cast the LHS
  --   * Store
  | Assignment  lhs.llvmCode = @dest.llvmCode ++
                               @source.llvmCode ++
                               @loc.rhsStmts ++
                               @loc.lhsStmts ++
                               @loc.lhsptrStmts ++
                               @loc.fitsStmts ++
                               [Stmt_Store @loc.fitsVar @loc.lhsptrVar] 
                
                (loc.uniqSeed, dest.gUniq, source.gUniq) =
                               mkNewLevUID2 @lhs.gUniq 
                
                loc.(uniqNr1,rhsVar,rhsStmts) =
                               expr2var @loc.uniqSeed @source.llvmExpr
                loc.(uniqNr2,lhsVar,lhsStmts) =
                               expr2var @loc.uniqNr1 @dest.llvmExpr
                loc.(uniqNr3,lhsptrVar,lhsptrStmts) =
                               cast2ptr @loc.uniqNr2 @loc.lhsVar 
                                        @lhs.pointerType
                loc.(uniqNr4,fitsVar,fitsStmts) =
                               makeFitting @loc.uniqNr3 @loc.rhsVar
                                           @loc.lhsptrVar                                         

  | Assignment2 lhs.llvmCode = @source.llvmCode ++
                               @loc.sourceStmts ++                               
                               @dest1.llvmCode ++
                               @loc.dest1Stmts ++
                               @loc.dest1ptrStmts ++
                               @loc.fits1Stmts ++
                               [ Stmt_Store @loc.fits1Var @loc.dest1ptrVar ] ++
                               @dest2.llvmCode ++
                               @loc.dest2Stmts ++                               
                               @loc.dest2ptrStmts ++                               
                               @loc.fits2Stmts ++
                               [ Stmt_Store @loc.fits2Var @loc.dest2ptrVar] 
                
                (loc.uniqSeed, dest1.gUniq, dest2.gUniq, source.gUniq) =
                               mkNewLevUID3 @lhs.gUniq 
                
                loc.(uniqNr1,sourceVar,sourceStmts) =
                               expr2var @loc.uniqSeed @source.llvmExpr
                loc.(uniqNr2,dest1Var,dest1Stmts) =
                               expr2var @loc.uniqNr1 @dest1.llvmExpr
                loc.(uniqNr3,dest2Var,dest2Stmts) =
                               expr2var @loc.uniqNr2 @dest2.llvmExpr
                loc.(uniqNr4,dest1ptrVar,dest1ptrStmts) =
                               cast2ptr @loc.uniqNr3 @loc.dest1Var 
                                        @lhs.pointerType
                loc.(uniqNr5,dest2ptrVar,dest2ptrStmts) =
                               cast2ptr @loc.uniqNr4 @loc.dest2Var 
                                        @lhs.pointerType                                        
                loc.(uniqNr6,fits1Var,fits1Stmts) =
                               makeFitting @loc.uniqNr5 @loc.sourceVar
                                           @loc.dest1ptrVar
                loc.(uniqNr7,fits2Var,fits2Stmts) =
                               makeFitting @loc.uniqNr6 @loc.sourceVar
                                           @loc.dest2ptrVar  

  | Call        lhs.llvmCode = let fDecl = Data.Map.findWithDefault 
                                             (error "No such function")
                                             (hs2str @name) @lhs.fnAvailDecls
                                in @args.llvmCode ++
                                   @loc.argStmts ++
                                   @loc.castStmts ++
                                   [ Stmt_Call fDecl @tailJumps @loc.castVars ]
 
                (loc.uniqSeed, args.gUniq) =
                               mkNewLevUID @lhs.gUniq 
                           
                -- It is very well possible that some arguments evaluate
                -- to a LLVMExpression and need to be reduced to a Var
                loc.(uniqNr1,argVars,argStmts) =
                               foldr (\x xs -> let (nr,val,stmt) =
                                                     expr2var (fstTup3 xs) x
                                                in ( nr, val : sndTup3 xs
                                                   , stmt ++ (trdTup3 xs)
                                                   )
                                     ) (@loc.uniqSeed,[],[]) @args.llvmExpr 
                -- Some arguments can be pointers and need to be casted
                -- to inttypes 
                loc.(uniqNr2,castVars,castStmts) =  
                               foldr (\x xs -> let (nr,val,stmt) =
                                                     cast2int (fstTup3 xs) x @lhs.intType
                                                in ( nr, val : sndTup3 xs
                                                   , stmt ++ (trdTup3 xs)
                                                   )
                                     ) (@loc.uniqNr1,[],[]) @loc.argVars  
                                   
  | Comment     lhs.llvmCode = [Stmt_Comment @comment]
  
  | If          lhs.llvmCode = @scrutinee.llvmCode ++
                               @loc.scrutineeStmts ++ 
                               @loc.scrutToIntStmts ++
                               @loc.scrutineeUnboxStmts ++
                               @loc.cmpStmts ++ 
                               [ Stmt_BranchIf 
                                 @loc.cmpVar
                                 @loc.fstLabel @loc.sndLabel
                               ] ++
                               @loc.fstStmts ++ 
                               [ Stmt_Branch @loc.resumeLabel] ++
                               @loc.sndStmts ++
                               [ Stmt_Branch @loc.resumeLabel
                               , Stmt_Label  @loc.resumeLabel
                               ]
  
                loc.(fstConst,fstLabel,fstStmts) =
                                     @loc.fstAlt
                loc.(sndConst,sndLabel,sndStmts) =
                                     @loc.sndAlt                     
                loc.(fstAlt,sndAlt) =
                               let f (x:y:[]) = (x,y)
                                   f _ = error "Not exactly 2 alts for If"
                                in f @body.jumpTargets                                              
                                
                (loc.uniqSeed, scrutinee.gUniq, body.gUniq) =
                               mkNewLevUID2 @lhs.gUniq 
                               
                loc.(uniqNr1, scrutineeVar, scrutineeStmts) =                               
                               expr2var @loc.uniqSeed @scrutinee.llvmExpr

                loc.(uniqNr2, scrutToIntVar, scrutToIntStmts) =
                              cast2int @loc.uniqNr1 @scrutineeVar
                                       @lhs.intType

                loc.(uniqNr3, scrutineeUnboxVar, scrutineeUnboxStmts) =                               
                              expr2var @loc.uniqNr2 $
                              Right ( Expression_BinOp AND @loc.scrutToIntVar
                                                       (Constant 1 @lhs.intType)
                                    , @lhs.intType)
                               
                loc.(uniqNr4, cmpVar, cmpStmts) =
                              expr2var @loc.uniqNr3 $
                              Right ( Expression_Compare CMPEQ 
                                                         @loc.scrutineeUnboxVar
                                                         @loc.fstConst
                                    , I1)               
                               
                loc.(uniqNr5, resumeLabel) =
                               newFresh @loc.uniqNr4 Label              

  | Switch      lhs.llvmCode = @scrutinee.llvmCode ++
                               @loc.scrutineeStmts ++ 
                               [ Stmt_Switch 
                                 @loc.scrutineeVar
                                 @loc.defaultLabel
                                 @loc.targets 
                               ] ++
                               @loc.altStmts ++
                               @loc.defaultBody ++
                               [ Stmt_Branch @loc.resumeLabel] ++
                               [ Stmt_Label  @loc.resumeLabel ]
                    
                loc.altStmts =  
                               concatMap (( ++ [Stmt_Branch @loc.resumeLabel]) . 
                                          trdTup3)
                                   @body.jumpTargets  
                
                loc.targets = map (\(x,y,z) -> (x,y)) @body.jumpTargets
                                                                            
                (loc.uniqSeed, scrutinee.gUniq, body.gUniq) =
                               mkNewLevUID2 @lhs.gUniq 
                               
                loc.(uniqNr1, scrutineeVar, scrutineeStmts) =                               
                               expr2var @loc.uniqSeed @scrutinee.llvmExpr                                            
                               
                loc.(uniqNr2, resumeLabel) =
                               newFresh @loc.uniqNr1 Label
                               
                loc.(uniqNr3, defaultLabel, defaultBody) =
                               defaultCase @loc.uniqNr2   
                               
  | Jump        lhs.llvmCode = error $ "Generated jump instructions not allowed"
                                     ++ " in LLVM. Is -g set to 0?"
  
  | Label       lhs.llvmCode = error $ "Generated label instructions not"
                                     ++ " allowed in LLVM. Is -g set to 0?"
  
  | Return      lhs.llvmCode = [Stmt_Return $ LocalVar (error "ReturnNoVar")
                                                       Void
                               ]  
                                    
  | Smart       lhs.llvmCode = error "Smart should be generated for ASM only"
                                    
  | * - Assignment Assignment2 Call Comment If Jump Label Return Smart Switch
                lhs.llvmCode = error "Unimplemented Statement"

SEM Alternatives
  | Cons        lhs.jumpTargets = 
                               @hd.jumpTarget : @tl.jumpTargets              
                (tl.gUniq, hd.gUniq) = 
                               mkNewLevUID @lhs.gUniq
                               
  | Nil         lhs.jumpTargets = 
                               []
                
SEM Alternative
  | Alternative lhs.jumpTarget = 
                               ( @when.var
                               , @loc.label
                               , Stmt_Label @loc.label : @body.llvmCode
                               )
                                        
                (loc.uniqSeed, body.gUniq) =
                               mkNewLevUID @lhs.gUniq                     
                (loc.uniqNr1, loc.label) = 
                               newFresh @loc.uniqSeed Label              
 
SEM Values
  | Cons        lhs.llvmExpr = @hd.llvmExpr : @tl.llvmExpr
                lhs.llvmCode = @hd.llvmCode ++ @tl.llvmCode
                (tl.gUniq, hd.gUniq) = 
                               mkNewLevUID @lhs.gUniq
                               
  | Nil         lhs.llvmExpr = [] 
                lhs.llvmCode = []       
       
SEM Value
  | Alloc       lhs.llvmExpr = Right
                               ( mkMalloc False @lhs.intType @size
                               , @lhs.pointerType)
                lhs.llvmCode = []

  -- Perform the required arithmic (>>1)
  -- 
  | BoxVar      lhs.llvmExpr = Right 
                               (Expression_BinOp SHR @loc.intVar 
                                                 (Constant 1 @lhs.intType)
                               , getType @loc.intVar)
                lhs.llvmCode = @var.llvmCode ++
                               @loc.varStms ++
                               @loc.intVarStms
                                               
                (loc.uniqSeed,var.gUniq) =
                               mkNewLevUID @lhs.gUniq 
  
                loc.(uniqNr1,varVar,varStms) =
                               expr2var @loc.uniqSeed @var.llvmExpr
                               
                loc.(uniqNr2,intVar,intVarStms) =
                               load2Value @loc.uniqNr1 @loc.varVar                           
                               
  | Call        lhs.llvmExpr = Right
                               ( Expression_Call @loc.fnDecl False @loc.castVars
                               , @lhs.intType)
                lhs.llvmCode = @args.llvmCode ++
                               @loc.argStmts ++
                               @loc.castStmts
 
                loc.fnDecl  = FuncDecl_FuncDecl @name @lhs.intType False @loc.params
 
                (loc.uniqSeed, args.gUniq) =
                               mkNewLevUID @lhs.gUniq 
                           
                -- It is very well possible that some arguments evaluate
                -- to a LLVMExpression and need to be reduced to a Var
                loc.(uniqNr1,argVars,argStmts) =
                               foldr (\x xs -> let (nr,val,stmt) =
                                                     expr2var (fstTup3 xs) x
                                                in ( nr, val : sndTup3 xs
                                                   , stmt ++ (trdTup3 xs)
                                                   )
                                     ) (@loc.uniqSeed,[],[]) @args.llvmExpr 
                -- Some arguments can be pointers and need to be casted
                -- to inttypes 
                loc.(uniqNr2,castVars,castStmts) =  
                               foldr (\x xs -> let (nr,val,stmt) =
                                                     cast2int (fstTup3 xs) x @lhs.intType
                                                in ( nr, val : sndTup3 xs
                                                   , stmt ++ (trdTup3 xs)
                                                   )
                                     ) (@loc.uniqNr1,[],[]) @loc.argVars  
                -- We generate the formal parameters by generating new names
                -- for the actual ones
                loc.(uniqNr3,params) =  
                               foldr (\x xs -> let (nr,fresh) = newFresh (fst xs) (getType x)
                                                in (nr, fresh : (snd xs))
                                     ) 
                                     (@loc.uniqNr2,[]) @loc.castVars

  | Con         lhs.llvmExpr = Left @con.var
                lhs.llvmCode = []
  
  -- Perform the required arithmic (<<1) | 0x01
  -- 
  | UnboxCon    lhs.llvmExpr = Right 
                               (Expression_BinOp OR @loc.shlVar 
                                                 (Constant 1 @lhs.intType)
                               , getType @loc.shlVar)
                lhs.llvmCode = @con.llvmCode ++
                               @loc.conStmts  ++  
                               @loc.intConStmts ++                      
                               [ Stmt_Assignment @loc.shlVar
                                   ( Expression_BinOp SHL @loc.intConVar
                                       (Constant 1 @lhs.intType)
                                   )
                               ]
                                               
                (loc.uniqSeed,con.gUniq) =
                               mkNewLevUID @lhs.gUniq 
  
                loc.(uniqNr1,conVar,conStmts) =
                               expr2var @loc.uniqSeed @con.llvmExpr  
                                                            
                loc.(uniqNr2,intConVar,intConStmts) =
                               load2Value @loc.uniqNr1 @loc.conVar 
                               
                loc.(uniqNr3,shlVar) =
                               newFresh @loc.uniqNr2 (getExprType @con.llvmExpr)
                                                                             
  | Var         lhs.llvmExpr = if getType @loc.var == @lhs.intType
                               then Left @loc.var
                               else Right
                                      ( Expression_Load @loc.var
                                      , pLower $ getType @loc.var
                                      ) 
                lhs.llvmCode = @var.llvmCode ++
                               @loc.varStmts                

                (loc.uniqSeed, var.gUniq) =
                               mkNewLevUID @lhs.gUniq
               
                loc.(uniqNr1,var,varStmts) =                
                               expr2var @loc.uniqSeed @var.llvmExpr                              
                
  | * - Alloc BoxVar Call Con Var UnboxCon
                lhs.llvmExpr = error $ "No Label, Cast or Offset Value expected"
                lhs.llvmCode = error $ "No Label, Cast or Offset Value expected"       
 
SEM Variables
  | Cons        lhs.llvmExpr = @hd.llvmExpr : @tl.llvmExpr
                lhs.llvmCode = @hd.llvmCode ++ @tl.llvmCode
  | Nil         lhs.llvmExpr = [] 
                lhs.llvmCode = [] 
                
SEM Variable
  | Global      lhs.llvmExpr = Left $ GlobalVar (hs2str @name) 
                                                @lhs.globalType
                lhs.llvmCode = []
                
  | Local       lhs.llvmExpr = Left $ LocalVar (hs2str @name) @lhs.pointerType                                        
                lhs.llvmCode = []               
  
  | Param       lhs.llvmExpr = Left $ LocalVar (hs2str @name) @lhs.intType                                       
                lhs.llvmCode = []                                                    
                                               
  | RP          lhs.llvmExpr = Left $ GlobalVar "RP" (pLift @lhs.pointerType) 
                lhs.llvmCode = []
                
  | Subs        lhs.llvmExpr = Right $ 
                               (Expression_GetElemPtr @loc.ptrVar [@index]
                               , getType @loc.ptrVar)
                lhs.llvmCode = @array.llvmCode ++
                               @loc.arrStmts ++
                               @loc.loadedStmts ++ 
                               @loc.ptrStmts 

                (loc.uniqSeed, array.gUniq) =
                               mkNewLevUID @lhs.gUniq                
                loc.(uniqNr1,arrVar,arrStmts) =
                               expr2var @loc.uniqSeed @array.llvmExpr
                loc.(uniqNr2,loadedVar,loadedStmts) =
                               if isGlobal @loc.arrVar || @array.isLocal
                               then load @loc.uniqNr1 @loc.arrVar
                               else (@loc.uniqNr1, @loc.arrVar, []) 
                loc.(uniqNr3,ptrVar,ptrStmts) =
                               cast2ptr @loc.uniqNr2 @loc.loadedVar 
                                        @lhs.pointerType  
                                                                                            
  | * - Global Local Param RP Subs
                lhs.llvmExpr = error "Variable contains an impossible construct"
                lhs.llvmCode = error "Variable contains an impossible construct"               
                
SEM Constant
  | LiteralInt  lhs.var      = Constant @value @lhs.intType
  | LiteralStr  lhs.var      = error "Strings not supported by LLVM"
  | Alias       lhs.var      = let value = Data.Map.findWithDefault
                                             (error "Alias not in constantmap")
                                             @name @lhs.constantMap 
                                in Constant value @lhs.intType                                                                 
%%]

%%[8
--------------------------------------------------------------------------------
-- Passing up the signatures of the functions declared and the functions 
-- defined in this module. If we have the set of these functions, we can 
-- query them for Calls and we can warn if undeclared/undefined functions are
-- called
--------------------------------------------------------------------------------
ATTR Functions Function
     Statements Statement
     Alternatives Alternative
     Values Value
     Variables Variable
     [ fnAvailDecls : {Data.Map.Map String FuncDecl} | | ]

ATTR Functions
     [ | | fnDecls : {[(String,FuncDecl)]} ]

ATTR Function
     [ | | fnDecl : {(String,FuncDecl)} ]

SEM SilModule
  | SilModule   functions.fnAvailDecls
                           = Data.Map.fromList @functions.fnDecls

SEM Functions
  | Cons        lhs.fnDecls
                           = @hd.fnDecl : @tl.fnDecls
  | Nil         lhs.fnDecls
                           = []

SEM Function
  | Function    lhs.fnDecl = (hs2str @name, @loc.fnDecl)
                loc.fnDecl = let prms = mkVarList LocalVar @parameters 
                                                           @lhs.intType
                              in FuncDecl_FuncDecl (hs2str @name) Void False prms
%%]
  
%%[8
--------------------------------------------------------------------------------
-- Passing down platform depended types.
--------------------------------------------------------------------------------

ATTR AllNT
     [ intType, pointerType, globalType : {LLVMType} | | ]
%%]

%%[8
--------------------------------------------------------------------------------
-- We pass down a map, containing the alias name and the 
-- corresponding Int value of constructor tags
--------------------------------------------------------------------------------
ATTR Functions Function 
     Statements Statement
     Alternatives Alternative
     Values Value
     Variables Variable
     Constant
     [ constantMap : {Data.Map.Map String Int} | | ]

SEM SilModule
  | SilModule   functions.constantMap = Data.Map.fromList @constants
%%]

%%[8
--------------------------------------------------------------------------------
-- TODO: Update comment
--------------------------------------------------------------------------------
ATTR Variable
     [ | | isLocal : {Bool} ]
                          
SEM Variable
  | Local       lhs.isLocal  = True
  | * - Local
                lhs.isLocal  = False                           
%%]

%%[8
--------------------------------------------------------------------------------
-- Pass the max size of the closure that is stored in RP up
-- so that we can initialize it at the start up.
--------------------------------------------------------------------------------
ATTR Functions Function 
     Statements Statement
     Alternatives Alternative
     Values Value
     Variables Variable
     [ | | maxRPSize USE {`max`} {0}: {Int} ]

SEM Variable
  | Subs        lhs.maxRPSize =
                             if @array.isRP then @index else 0  

ATTR Variable
     [ | | isRP : {Bool} ]
                          
SEM Variable
  | RP          lhs.isRP   = True
  | * - RP
                lhs.isRP   = False                           
%%]

%%[8
--------------------------------------------------------------------------------
-- Pass function declarations that are defined exetern
--------------------------------------------------------------------------------
ATTR Functions Function 
     Statements Statement
     Alternatives Alternative
     Values Value
     Variables Variable
     [ | | externFuncs USE {++} {[]}: {[FuncDecl]} ]
                       
SEM Value
  | Call        lhs.externFuncs = [@loc.fnDecl]                  
%%]

%%[8
{
--------------------------------------------------------------------------------
-- Misc functions
--------------------------------------------------------------------------------
-- Shortcut method to fetch the string representation of a HsName
hs2str :: HsName -> String
hs2str = hsnShowAlphanumeric

-- Get the first element of a 3 tuple
fstTup3 :: (a,b,c) -> a
fstTup3 (x,_,_) = x

-- Get the second element of a 3 tuple
sndTup3 :: (a,b,c) -> b
sndTup3 (_,x,_) = x

-- Get the third element of a 3 tuple
trdTup3 :: (a,b,c) -> c
trdTup3 (_,_,x) = x

primPatternMatchFailureFuncDecl :: FuncDecl
primPatternMatchFailureFuncDecl =
  FuncDecl_FuncDecl "primPatternMatchFailure" Void False [] 

gcInitFuncDecl :: FuncDecl
gcInitFuncDecl =
  FuncDecl_FuncDecl "llvmgc_init" Void False []
  
gcMallocFuncDecl :: LLVMType -> FuncDecl
gcMallocFuncDecl intType =
  FuncDecl_FuncDecl "llvmgc_malloc" (pLift intType) False [(LocalVar "x" intType)] 

gcMallocUncollectableFuncDecl :: LLVMType -> FuncDecl
gcMallocUncollectableFuncDecl intType =
  FuncDecl_FuncDecl "llvmgc_malloc_uncollectable" (pLift intType) 
                    False [(LocalVar "x" intType)] 

defaultCase :: UID -> (UID,Var,Stmts)
defaultCase nr =
  let (nr1, fresh1) = newFresh nr Label
   in (nr1, fresh1, [ Stmt_Label fresh1
                    , Stmt_Call primPatternMatchFailureFuncDecl
                                           False []
                    ])
  
toExpr :: LLVMExpr -> Expression
toExpr (Right (e,tp)) = e
toExpr (Left var) = Expression_Cast var (getType var)

toVar :: LLVMExpr -> Var
toVar (Right _)  = error "Expression toVar"
toVar (Left var) = var

mkMalloc :: Bool -> LLVMType -> Int -> Expression
mkMalloc unCollectable intType nrInts =
  if rtsUseGC
  then let size = nrInts * sizeofPointer
        in if unCollectable
           then Expression_Call (gcMallocUncollectableFuncDecl intType) 
                                False [Constant size intType]
           else Expression_Call (gcMallocFuncDecl intType)
                                False [Constant size intType]
  else Expression_Malloc intType nrInts

-- Make a list of variables with a given constructor, a list of HsNames and
-- one type
-- used primary for parameter lists
mkVarList :: (String -> LLVMType -> Var) -> [HsName] -> LLVMType -> [Var]
mkVarList constr names tp =
  zipWith (\x y -> constr (hs2str x) y) names (repeat tp)
   
cast2int :: UID -> Var -> LLVMType -> (UID,Var,Stmts)   
cast2int nr var intType =
  if isInt (getType var)
  then (nr,var,[])
  else let (nr', fresh) = newFresh nr intType
        in (nr', fresh, [Stmt_Assignment fresh $ Expression_Cast var intType])
        
cast2ptr :: UID -> Var -> LLVMType -> (UID,Var,Stmts)
cast2ptr nr var ptrType
  | isPointer (getType var) =
    (nr,var,[])
  | otherwise =
    let (nr', fresh) = newFresh nr ptrType
     in (nr', fresh, [Stmt_Assignment fresh $ Expression_Cast var ptrType])         
 
makeFitting :: UID -> Var -> Var -> (UID,Var,Stmts)
makeFitting nr what hole 
  -- Case 1 it already fits
  | getType what == pLower (getType hole) =
    (nr,what,[])
  | otherwise = 
    let targetType   = pLower $ getType hole 
        (nr', fresh) = newFresh nr targetType
     in (nr', fresh, [Stmt_Assignment fresh $ Expression_Cast what targetType])

-- Build a new fresh local variable
newFresh :: UID -> LLVMType -> (UID,Var)
newFresh nr tp = 
  (uidNext nr, LocalVar ("fresh" ++ show nr) tp)

-- A LLVMExpr can be either a Variable or an Expression. If it is an Expression
-- assign it to a fresh Variable and return it, otherwise, return the 
-- given variable
expr2var :: UID -> LLVMExpr -> (UID,Var,Stmts)
expr2var nr (Left var) =
  (nr,var,[])
expr2var nr (Right (expr,tp)) =
  let (nr', fresh) = newFresh nr tp
   in (nr', fresh, [Stmt_Assignment fresh expr])
   
-- Load a given LLVMExpr
load :: UID -> Var -> (UID,Var,Stmts)
load nr var =
  let loadType     = pLower (getType var)
      (nr', fresh) = newFresh nr loadType
   in (nr', fresh, [Stmt_Assignment fresh (Expression_Load var)])
   
load2Value :: UID -> Var -> (UID,Var,Stmts)
load2Value nr var 
  | isInt (getType var) = (nr,var,[])
  | otherwise           =
    let (nr1,var1,stmts1) = load nr var
        (nr2,var2,stmts2) = load2Value nr1 var1
     in (nr2,var2, stmts1 ++ stmts2)       
}
%%]
