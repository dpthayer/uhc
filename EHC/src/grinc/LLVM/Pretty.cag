%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[8 hs module {%{GRIN}LLVM.Pretty} export(prettyLLVMModule)
%%]
%%[8 hs import(qualified Data.List)
%%]
%%[8 hs import(EH.Util.Pretty)
%%]
%%[8 hs import({%{GRIN}LLVM})
%%]
%%[8 import({LLVM/AbsSyn})
%%]

%%[8
WRAPPER LLVMModule
%%]

%%[8 hs
prettyLLVMModule :: LLVMModule -> PP_Doc
prettyLLVMModule llvmmod
  = let t = wrap_LLVMModule (sem_LLVMModule llvmmod)
                            (Inh_LLVMModule { }
                            )
     in  pretty_Syn_LLVMModule t

%%]

%%[8
--------------------------------------------------------------------------------
-- Prettyprint a LLVM Module
--------------------------------------------------------------------------------
ATTR LLVMModule
     Func
     Stmts Stmt
     Expression
     [ | | pretty USE {>-<} {empty}: {PP_Doc} ]
   
ATTR Funcs
     [ | | pretty: {[PP_Doc]} ]   
     
ATTR FuncDecls
     [ | | prettySigs : {[PP_Doc]} ]     
     
ATTR FuncDecl
     [ | | prettyCall : {[Var] -> PP_Doc}
           prettySig : {PP_Doc} ]
          
     
SEM LLVMModule
  | LLVMModule  lhs.pretty = ppPrependList ";" @comments
                             >-< ""
                             >-< vlist (
                                 map (\(dst,src) ->
                                       ppAssignment dst ("internal constant" >#< show src)
                                     ) @constants
                                 )
                             >-< ppPrependList "declare" @fwdDecls.prettySigs
                             >-< ""
                             >-< ppGlobalList @globals
                             >-< ""
                             >-< vlist @funcs.pretty
 
SEM Funcs       
  | Cons        lhs.pretty = @hd.pretty : (text "") : @tl.pretty
  | Nil         lhs.pretty = []
 
  
SEM Func
  | Func        lhs.pretty = let annot = if @internal
                                         then "define internal"
                                         else "define"
                              in annot >#< @funcDecl.prettySig
                                 >-< "{"
                                 >-< indent 4 @body.pretty
                                 >-< "}"
  
SEM FuncDecls   
  | Cons        lhs.prettySigs = 
                             @hd.prettySig : @tl.prettySigs                           
  | Nil         lhs.prettySigs =
                             []
             
  
SEM FuncDecl
  | FuncDecl    lhs.prettySig =
                             if @varargs
                             then ppVarargsFunctionSignature @name @returnType
                                                             @params   
                             else ppFunctionSignature @name @returnType @params
                lhs.prettyCall = 
                             if @varargs
                             then ppVarargsFunctionCall @name @returnType @params
                             else ppFunctionSignature @name @returnType
                             
SEM Stmt
  | Assignment  lhs.pretty = ppAssignment @dest @source.pretty
  | Branch      lhs.pretty = ppBranch @target
  | BranchIf    lhs.pretty = ppBranchIf @cond @targetTrue @targetFalse
  | Call        lhs.pretty = ppCall @tailJumps (@func.prettyCall @args)
  | Comment     lhs.pretty = ppPrependList ";" @comment
  | Label       lhs.pretty = getPlainName @name >|< ":"
  | Store       lhs.pretty = ppStore @value @ptr
  | Switch      lhs.pretty = ppSwitch @scrutinee @default @targets
  | Return      lhs.pretty = ppReturn @result
  | * - Assignment Branch BranchIf Comment Call Label Store Switch Return
                lhs.pretty = error "Undefined Stmt"
                
SEM Expression
  | Alloca      lhs.pretty = ppAlloca @tp @amount
  | BinOp       lhs.pretty = ppBinOp @op @left @right
  | Call        lhs.pretty = ppCall @tailJumps (@func.prettyCall @args)
  | Cast        lhs.pretty = ppCast @from @to
  | Compare     lhs.pretty = ppCmpOp @op @left @right  
  | GetElemPtr  lhs.pretty = ppGetElementPtr @ptr @indexes
  | Load        lhs.pretty = ppLoad @ptr
  | Malloc      lhs.pretty = ppMalloc @tp @amount
  | Phi         lhs.pretty = ppPhi @tp @precessors
  | * - Alloca BinOp Call Cast Compare GetElemPtr Load Malloc Phi
                lhs.pretty = error "Undefined Expression"                                        
%%]

%%[8 hs
--------------------------------------------------------------------------------
-- Print functions
--------------------------------------------------------------------------------
ppGlobal :: Var -> PP_Doc
ppGlobal var =
  getName var >#< "= internal global" 
              >#< show (pLower $ getType var) >#< "zeroinitializer"

ppGlobalList :: [Var] -> PP_Doc
ppGlobalList = 
  vlist.(map ppGlobal)

ppFunctionSignature :: String -> LLVMType -> [Var] -> PP_Doc
ppFunctionSignature fnName returnType params =
  let ppParams = hlist $
                 Data.List.intersperse (text ", ") $ map (text.show) params 
   in show returnType >#< "@" >|< fnName >|< "(" >#< ppParams >#< ")"
 
ppVarargsFunctionSignature :: String -> LLVMType -> [Var] -> PP_Doc
ppVarargsFunctionSignature fnName returnType params =
  let ppParams = hlist $
                 ( ++ [ text ", ..." ] ) $
                 Data.List.intersperse (text ", ") $ map (text.show) params
   in show returnType >#< "@" >|< fnName >|< "(" >#< ppParams >#< ")"    
   
ppVarargsFunctionCall :: String -> LLVMType -> [Var] -> [Var] -> PP_Doc
ppVarargsFunctionCall fnName returnType varArgParams params =
  let ppParams = hlist $
                 Data.List.intersperse (text ", ") $ map (text.show) params
      ppTpList = hlist $
                 ( ++ [ text ", ..." ] ) $
                 Data.List.intersperse (text ", ") $ map (text.show.getType) varArgParams
   in show returnType >#< "(" >#< ppTpList >#< ")*" 
      >#< "@" >|< fnName >|< "(" >#< ppParams >#< ")"                 
   
ppCall :: Bool -> PP_Doc -> PP_Doc
ppCall tailCall ppFuncSig =
  let tailAnot = if tailCall then "tail " else ""
   in tailAnot >|< "call" >#< ppFuncSig   
   
ppBinOp :: BinOp -> Var -> Var -> PP_Doc
ppBinOp op left right =
  show op >#< show (getType left) >#< getName left 
  >|< "," >#< getName right

ppCmpOp :: CmpOp -> Var -> Var -> PP_Doc
ppCmpOp op left right =
  "icmp" >#< show op >#< show (getType left) >#< getName left
  >|< "," >#< getName right
   
ppAssignment :: Var -> PP_Doc -> PP_Doc
ppAssignment var expr =
  getName var >#< "=" >#< expr
  
ppLoad :: Var -> PP_Doc
ppLoad var =
  "load" >#< show var   
  
ppStore :: Var -> Var -> PP_Doc
ppStore rhs lhs =
  "store" >#< show rhs >|< "," >#< show lhs  
  
ppCast :: Var -> LLVMType -> PP_Doc
ppCast from to 
  | isInt to && (isPointer $ getType from) 
      = "ptrtoint" >#< show from >#< "to" >#< show to
  | (isPointer to) && (isInt $ getType from)
      = "inttoptr" >#< show from >#< "to" >#< show to
  | otherwise 
      = "bitcast" >#< show from >#< "to" >#< show to
      
ppMalloc :: LLVMType -> Int -> PP_Doc
ppMalloc tp amount = 
  "malloc" >#< show tp >|< ", i32" >#< show amount     

ppAlloca :: LLVMType -> Int -> PP_Doc
ppAlloca tp amount = 
  "alloca" >#< show tp >|< ", i32" >#< show amount 
  
ppGetElementPtr :: Var -> [Int] -> PP_Doc
ppGetElementPtr ptr idx =
  let indexes = hlist $ map ((", i32" >#<) . show) idx
  in "getelementptr" >#< show ptr >|< indexes  
  
ppReturn :: Var -> PP_Doc
ppReturn var 
  | getType var == Void    = "ret" >#< show (getType var)
  | otherwise              = "ret" >#< show var  
  
ppBranch :: Var -> PP_Doc
ppBranch var =
  "br" >#< show var
  
ppBranchIf :: Var -> Var -> Var -> PP_Doc
ppBranchIf cond trueT falseT =
  "br" >#< show cond >|< "," >#< show trueT >|< "," >#< show falseT  
  
ppPhi :: LLVMType -> [(Var,Var)] -> PP_Doc
ppPhi tp preds =
  let ppPreds (val,label) = "[" >#< getName val >|< "," >#< getName label >#< "]"  
   in "phi" >#< show tp 
       >#< (hlist $ Data.List.intersperse (text ",") (map ppPreds preds)) 
       
ppSwitch :: Var -> Var -> [(Var,Var)] -> PP_Doc
ppSwitch scrut dflt targets =
  let ppTarget  (val,lab) = show val >|< "," >#< show lab
      ppTargets  xs       = "[" >#< vlist (map ppTarget xs) >#< "]"
   in "switch" >#< show scrut >|< "," >#< show dflt >#< ppTargets targets        
%%]

%%[8 hs
--------------------------------------------------------------------------------
-- Misc functions
--------------------------------------------------------------------------------
ppPrependList :: (PP a) => String -> [a] -> PP_Doc
ppPrependList x = 
  vlist . (map (x >#<))
%%]
