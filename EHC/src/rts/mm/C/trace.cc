
%%[8
#include "../../rts.h"

extern int nodeDescriptor[];  // generated by compiling the user program; contains size of node for each tag

%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% MM_Trace implementation for C backend
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
void mm_trace_C_Init( MM_Trace* trace, void* traceSupply, MM_Allocator* allocator, MM_Collector* collector ) 
{
    printf("mm_trace_C_Init\n");

	// Store the given parameters in the trace object.
	trace->data      = (MM_Trace_Data_Priv*)traceSupply ;
	trace->collector = collector ;
	trace->allocator = allocator ;
}

Bool mm_trace_C_CanTraceObject( MM_Trace* trace, Word obj ) 
{
    printf("mm_trace_C_CanTraceObject should not be needed!\n");
    return 1;
}


#define FORWARDING_TAG 0xFFFFFFFF

Word mm_trace_C_TraceKnownToBeObject( MM_Trace* trace, Word obj ) 
{
    // This function is responsible for copying an object "from-space" to "to-space".
    // If the object was already copied before, the copy is returnd.
    // If the object was not yet copied, it is done now:
    // - a new object is allocated
    // - its payload is copied
    // - the pointers in the payload a queued for copying as well
    // The original object is overwritten with a forwarding node.
    // The new object is returned.
    
	Word tag;
	tag=((WPtr)obj)[0];
	if (tag==FORWARDING_TAG)
    {
        // The node is a forwarding node, indicating that the node was copied before,
        // so we can just return that and we're done
		obj = ((WPtr)obj)[1];
		return obj ;
	}

    // Now we are sure that node "obj", with tag "tag", must be copied.

    // Find out the size of the new object to be allocated

	Word szWords ;
	szWords = 1 + nodeDescriptor[tag*2];


    // Allocate the new object
	MM_Allocator *allocator  =  trace->allocator ;
    WPtr objRepl;
	objRepl = (WPtr)( allocator->alloc( allocator, szWords << Word_SizeInBytes_Log, 0 ) ) ;    // alloc wants the size in bytes, so multiply the szWords by the Word_Size


    // Initialize the new object
	Word* fieldTo   =       objRepl;
	Word* fieldFrom = (WPtr)obj;
	Word sz = szWords ;
	for ( sz-- ; sz >= 0 ; sz-- ) {
		*(fieldTo++) = *(fieldFrom++) ;
	}


    // Overwrite the original object with a forwarding node, which points to the new object
    // The forwarding node has a special tag

	((WPtr)obj)[0] = FORWARDING_TAG ;

	// The forwarding node has a single-word payload, which is the pointer to the new object
	((WPtr)obj)[1] = (Word)objRepl ;
	

    // Queue the payload of the freshly copied object to be processed as well
    MM_TraceSupply* traceSupply = (MM_TraceSupply*)trace->data;
	traceSupply->pushWork( traceSupply, (Word*)objRepl, szWords, allocator->lastAllocFragment(allocator) ) ;

	return (Word)objRepl ;
}

void mm_trace_C_TraceObjectPayload( MM_Trace* trace, Word obj ) 
{
    printf("mm_trace_C_TraceObjectPayload should not be needed!\n");
}

Word mm_trace_C_ObjectSize( MM_Trace* trace, Word obj ) 
{
	return 0;
}

Bool mm_trace_C_HasTraceableWords( MM_Trace* trace, Word obj ) 
{
	return 0;
}

Word mm_trace_C_EnsureNoIndirections( MM_Trace* trace, Word obj ) 
{
    return 0;
}

%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% MM_Trace interface object
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
MM_Trace mm_trace_C =
	{ NULL
	, NULL
	, NULL
	, 1              // size of node header in Words
	, sizeof(Word)   // size of node header in bytes
	, &mm_trace_C_Init
	, &mm_trace_C_CanTraceObject
	, &mm_trace_C_TraceKnownToBeObject
	, &mm_trace_C_TraceObjectPayload
	, &mm_trace_C_ObjectSize
	, &mm_trace_C_HasTraceableWords
	, &mm_trace_C_EnsureNoIndirections
	} ;
%%]
