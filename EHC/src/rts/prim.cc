%%[8
#include "rts.h"

/* Make sure these numbers are the same as generated by Grin/ToSilly */

#define CFalse 2
#define CTrue 3
#define Ccolon 4
#define Csubbus 5
#define CEQ 6
#define CGT 7
#define CLT 8
#define Ccomma0 9

%%]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Integer related primitives
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8

PRIM GrWord packedStringToInteger(GrWord s)
{
	GrWord res;
    res = heapalloc(1);
    ((Pointer)res)[0] = atoi( (char*)s );
    return res;
}


PRIM GrWord primIntToInteger(GrWord n)
{
	GrWord res;
    res = heapalloc(1);
    ((Pointer)res)[0] = n;
    return res;
}

PRIM GrWord primIntegerToInt(GrWord p)
{
	GrWord res;
    res = ((Pointer)p)[0];
    return res;
}

PRIM GrWord primCmpInteger(GrWord x, GrWord y)
{   if (((Pointer)x)[0] > ((Pointer)y)[0])
        return CGT;
    if (((Pointer)x)[0] == ((Pointer)y)[0])
        return CEQ;
    return CLT;
}

PRIM GrWord primEqInteger(GrWord x, GrWord y)
{
    if (((Pointer)x)[0] == ((Pointer)y)[0])
        return CTrue;
    return CFalse;
}



%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Int related primitives
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8


PRIM GrWord primNegInt(GrWord x)
{
	return -x;	
}

PRIM GrWord primAddInt(GrWord x, GrWord y)
{   
	//printf("add %d %d\n", x, y );
	return x+y;
}

PRIM GrWord primSubInt(GrWord x, GrWord y)
{   
	//printf("sub %d %d\n", x, y );
	return x-y;
}

PRIM GrWord primMulInt(GrWord x, GrWord y)
{   
	//printf("mul %d %d\n", x, y );
	return x*y;
}

/* This should be the Quot function */
PRIM GrWord primDivInt(GrWord x, GrWord y)
{   
	//printf("div %d %d\n", x, y );
	return x/y;
}

/* This should be the Rem function */
PRIM GrWord primModInt(GrWord x, GrWord y)
{   
	//printf("mod %d %d\n", x, y );
	return x%y;
}

PRIM GrWord primRemInt(GrWord x, GrWord y)
{   
	return x%y;
}
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Ord Int related primitives
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8

/* The Boolean functions below only return the constructor */


PRIM GrWord primGtInt(GrWord x, GrWord y)
{   if (x>y)
    { //  printf ("%d is groter dan %d\n", x, y );
        return CTrue;
    }
    //printf ("%d is niet groter dan %d\n", x, y );
    return CFalse;
}

PRIM GrWord primLtInt(GrWord x, GrWord y)
{   if (x<y)
        return CTrue;
    return CFalse;
}
%%]

%%[8
PRIM GrWord primCmpInt(GrWord x, GrWord y)
{   if (x>y)
        return CGT;
    if (x==y)
        return CEQ;
    return CLT;
}
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Eq Int related primitives
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
PRIM GrWord primEqInt(GrWord x, GrWord y)
{
	 //printf("eq %d %d\n", x, y );
	
    if (x==y)
        return CTrue;
    return CFalse;
}
%%]

%%[8
PRIM GrWord primNeInt(GrWord x, GrWord y)
{
	 //printf("neq %d %d\n", x, y );
	
    if (x!=y)
        return CTrue;
    return CFalse;
}
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Misc primitives
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
PRIM GrWord primUnsafeId(GrWord x)
{   return x ;
}

PRIM void primPatternMatchFailure()
{
    printf("Pattern match failure\n");
    exit(1);
}

PRIM GrWord primOrd(GrWord x)
{
	return x;	
}

PRIM GrWord primChr(GrWord x)
{
	return x;	
}

PRIM GrWord primOdd(GrWord x)
{
    if (x&1)
        return CTrue;
    return CFalse;
}


PRIM GrWord primPackedStringNull(GrWord s)
{
	if (*  ((char*)s) )	
    	return CFalse;	
    return CTrue;
}

PRIM GrWord primPackedStringTail(GrWord s)
{
	return  (GrWord)(((char*)s)+1);
}

PRIM GrWord primPackedStringHead(GrWord s)
{
	return (GrWord)(*((char*)s));
}


PRIM GrWord primOpenChanSimple(GrWord n)
{
	return (GrWord) stdout;	
}


GrWord *cafUnit = {Ccomma0};

PRIM GrWord primPutCharChanSimple(GrWord h, GrWord c)
{
	//FILE *f = (FILE *) h;
	
	// printf("primPutCharChanSimple is called\n"); fflush(stdout);
	putc(c, stdout);
	//return (GrWord) cafUnit;
	return Ccomma0;
}

PRIM GrWord primError(GrWord s)
{
	GrWord c;
	char x;

	printf("\nError function called from Haskell with message: ");
	fflush(stdout);
	
	while (  ((GrWord*)s)[0] == Ccolon )
	{
		c = ((GrWord*)s)[1];	
		x = ((GrWord*)c)[1];
		putc(x,stdout);
		s = ((GrWord*)s)[2];	
	}
	putc('\n', stdout);
	fflush(stdout);
	
	exit(1);
	return 0;	
}


PRIM GB_Word primMinInt()
{
	return 0x10000000;
}
PRIM GB_Word primMaxInt()
{
	return 0x0FFFFFFF;
}


%%]
