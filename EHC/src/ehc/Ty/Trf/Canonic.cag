%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell importable interface to making canonical type structure
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Compute canonic form of type w.r.t. Eq and Ord.
This matters at:
- rows, where fields may be in arbitrary order

This matters for:
- comparing types, in particular within predicates during proving

%%[9 hs module {%{EH}Ty.Trf.Canonic} import({%{EH}Base.Common},{%{EH}Base.Builtin},{%{EH}Ty})
%%]

%%[9 hs import(Data.Maybe,qualified Data.Set as Set)
%%]

%%[11 hs import({%{EH}Base.Opts})
%%]

%%[16 hs import({%{EH}Ty.Trf.MergePreds})
%%]

%%[9.WRAPPER ag import({Ty/AbsSyn},{Ty/CommonAG})
WRAPPER TyAGItf
%%]

%%[99
PRAGMA strictcase
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell importable interface to making canonical type structure
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[9 hs export(TyCanonicOpts(..),emptyTyCanonicOpts)
data TyCanonicOpts
  = TyCanonicOpts
%%[[11
      { tcoTyBetaRedFull 	:: Ty -> Ty
      }
%%]]

emptyTyCanonicOpts :: TyCanonicOpts
emptyTyCanonicOpts
  = TyCanonicOpts
%%[[11
      {	tcoTyBetaRedFull 	= \t -> t
      }
%%]]
%%]

%%[9 hs export(tyCanonic')
tyCanonic' :: TyCanonicOpts -> Ty -> Ty
tyCanonic' opts ty
  =  let  t =  wrap_TyAGItf
                 (sem_TyAGItf (TyAGItf_AGItf ty))
                 (Inh_TyAGItf
%%[[11
                   { opts_Inh_TyAGItf = opts
                   }
%%]]
                 )
     in   repl_Syn_TyAGItf t
%%]

%%[9 hs export(predCanonic')
predCanonic' :: TyCanonicOpts -> Pred -> Pred
%%[[16
predCanonic' opts (Pred_Eq t1 t2)
  = Pred_Eq (tmpoTy $ tyMergePreds [] t1') (tmpoTy $ tyMergePreds [] t2')
    where
      t1' = tyCanonic' opts t1
      t2' = tyCanonic' opts t2
%%]]
predCanonic' opts pr
  = case tyCanonic' opts $ Ty_Pred pr of
      Ty_Pred pr' -> pr'
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Context info
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[11
ATTR TyAGItf AllTy [ opts: TyCanonicOpts | | ]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Possible preds
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[9 hs
type MbPredL = Maybe [Pred]

mbPredLCmb :: MbPredL -> MbPredL -> MbPredL
mbPredLCmb Nothing Nothing = Nothing
mbPredLCmb m1      m2      = Just $ concat $ maybeToList m1 ++ maybeToList m2
%%]

%%[9
ATTR Ty Impls Pred [ | | mbPredL USE {`mbPredLCmb`} {Nothing}: MbPredL ]

SEM Impls
  | Tail            lhs     .   mbPredL         =   Just []

SEM Pred
  | *               lhs     .   mbPredL         =   Just [@repl]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Replacement
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[9
ATTR AllTyAndFlds [ | | repl: SELF ]
ATTR TyAGItf  [ | | repl: Ty ]
%%]

%%[9
SEM Ty
  | App             loc     .   replNoImplNil   =   case @func.mbPredL of
                                                      Nothing | @func.isPred
                                                        -> @arg.repl
                                                      _ -> @repl
                    lhs     .   repl            =   @replNoImplNil
%%]

%%[10
SEM Ty
  | Ext             lhs     .   repl            =   if @isSpineRoot
                                                    then let (row,exts) = tyRowExts @repl
                                                             exts' = tyRowCanonOrder exts
                                                         in  mkTyRow row exts'
                                                    else @repl
%%]

%%[11
SEM Ty
  | App             lhs     .   repl            :=  if @isSpineRoot
                                                    then tcoTyBetaRedFull @lhs.opts @replNoImplNil
                                                    else @replNoImplNil
  | Con             lhs     .   repl            =   tcoTyBetaRedFull @lhs.opts @repl
%%]


