%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Module itf
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(3 hmtyinfer || hmtyast) hs module {%{EH}Ty.Trf.Quantify} import(EH.Util.Utils,{%{EH}Base.Builtin},{%{EH}Base.Common},{%{EH}Ty},{%{EH}VarMp},{%{EH}Substitutable}) export(tyQuantify, tyQuantifyClosed)
%%]

%%[(4 hmtyinfer || hmtyast) hs import({%{EH}Base.Debug},EH.Util.Pretty)
%%]

%%[(4 hmtyinfer || hmtyast) hs import(qualified Data.Set as Set,qualified Data.Map as Map,Data.List as List)
%%]

%%[(4 hmtyinfer || hmtyast) ag import({Ty/AbsSyn},{Ty/CommonAG},{Ty/TyVarCommon})
WRAPPER TyAGItf
%%]

%%[(6 hmtyinfer || hmtyast) hs
%%]

%%[(9 hmtyinfer || hmtyast) hs import(Data.Maybe,EH.Util.Utils,EH.Util.Pretty) export(tyQuantifyRank)
%%]

%%[(99 hmtyinfer || hmtyast)
%%]
PRAGMA nostrictcase

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell importable interface to Ty quantify
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(3 hmtyinfer || hmtyast).tyQuantify hs
tyQuantify :: (TyVarId -> Bool) -> Ty -> Ty
tyQuantify tvIsBound ty = mkTyQu (filter (not.tvIsBound) (ftv ty)) ty
%%]

%%[(3 hmtyinfer || hmtyast).valTyQuantify hs export(valTyQuantify)
valTyQuantify :: (TyVarId -> Bool) -> Ty -> Ty
valTyQuantify = tyQuantify
%%]

%%[(3 hmtyinfer || hmtyast).tyQuantifyClosed hs
tyQuantifyClosed :: Ty -> Ty
tyQuantifyClosed = tyQuantify (const False)
%%]

%%[(9 hmtyinfer || hmtyast).tyQuantifyClosed -3.tyQuantifyClosed hs
tyQuantifyClosed :: Ty -> Ty
tyQuantifyClosed = tyQuantifyRank [1..]

tyQuantifyRank :: [Int] -> Ty -> Ty
tyQuantifyRank rL ty
  = tqoTy (tyQuantifyWithOpts (defaultTyQuOpts {tqoptQuRanks = rL, tqoptBaseQuant = tyQu_Forall, tqoptTvIsBound = const False}) ty)
%%]

%%[(4 hmtyinfer || hmtyast).tyQuantify -3.tyQuantify hs
tyQuantify :: (TyVarId -> Bool) -> Ty -> Ty
tyQuantify tvIsBound ty = tyQuantify' tvIsBound tyQu_Forall ty
%%]

%%[(4 hmtyinfer || hmtyast) hs export(tyQuantifyOuter)
tyQuantifyOuter :: (TyVarId -> Bool) -> Ty -> Ty
tyQuantifyOuter tvIsBound ty
  = tqoTy tqo
  where tqo = tyQuantifyWithOpts
                (defaultTyQuOpts
                  { tqoptAllowInnerQuant = False
                  , tqoptTvIsBound       = tvIsBound
%%[[6
                  , tqoptBaseQuant       = tyQu_Forall
%%]]
                  }
                )
                ty
%%]

%%[(6 hmtyinfer || hmtyast) -3.valTyQuantify hs export(kiQuantify,valTyQuantify)
kiQuantify :: (TyVarId -> Bool) -> Ty -> Ty
kiQuantify tvIsBound ty = tyQuantify' tvIsBound tyQu_KiForall ty

valTyQuantify :: (TyVarId -> Ty) -> (TyVarId -> Bool) -> Ty -> Ty
valTyQuantify tvKi tvIsBound ty
  = tqoTy $ tyQuantifyWithOpts opts ty
  where opts = defaultTyQuOpts
                  { tqoptTvIsBound      = tvIsBound
                  , tqoptTvKi       	= tvKi
                  }
%%]

Parameter baseQuant only is needed starting at variant 6.

%%[(4 hmtyinfer || hmtyast) hs
tyQuantify' :: (TyVarId -> Bool) -> TyQu -> Ty -> Ty
tyQuantify' tvIsBound baseQuant ty
  = tqoTy tqo
  where tqo = tyQuantifyWithOpts
                (defaultTyQuOpts
                  { tqoptTvIsBound       = tvIsBound
%%[[6
                  , tqoptBaseQuant       = baseQuant
%%]]
                  }
                )
                ty
%%]

%%[(3 hmtyinfer || hmtyast) hs export(TyQuOpts(..),defaultTyQuOpts)
data TyQuOpts
  = TyQuOpts
      { tqoptTvIsBound			:: TyVarId -> Bool
%%[[4
      , tqoptAllowInnerQuant	:: Bool
%%]]
%%[[6
      , tqoptBaseQuant			:: TyQu
      , tqoptTvKi				:: TyVarId -> Ty
%%]]
%%[[9
      , tqoptQuRanks 			:: [Int]
%%]]
      }

defaultTyQuOpts :: TyQuOpts
defaultTyQuOpts
  = TyQuOpts
      (const False)
%%[[4
      True
%%]]
%%[[6
      tyQu_Forall
      (const kiStar)
%%]]
%%[[9
      [1..]
%%]]
%%]

%%[(3 hmtyinfer || hmtyast) hs export(TyQuOut(..))
data TyQuOut
  = TyQuOut   { tqoTy               ::  Ty
              }
%%]

%%[(3 hmtyinfer || hmtyast) hs
tyQuantifyWithOpts :: TyQuOpts -> Ty -> TyQuOut
tyQuantifyWithOpts opts ty
  = let  t  =  wrap_TyAGItf
                  (sem_TyAGItf  (TyAGItf_AGItf ty))
                  (Inh_TyAGItf  { opts_Inh_TyAGItf          = opts
%%[[6
                                , baseQu_Inh_TyAGItf        = tqoptBaseQuant opts
%%]]
                                })
    in   TyQuOut
            { tqoTy                 = quTy_Syn_TyAGItf t
            }
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Init of pol
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(4 hmtyinfer || hmtyast)
SEM TyAGItf
  | AGItf       ty          .   pol         =   polCovariant
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Options
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(4 hmtyinfer || hmtyast)
ATTR TyAGItf AllTy [ opts: TyQuOpts | | ]
%%]

%%[(9 hmtyinfer || hmtyast)
SEM TyAGItf
  | AGItf       ty          .   opts        =   @lhs.opts
                                                  { tqoptQuRanks = take 5 (tqoptQuRanks @lhs.opts)
                                                  }
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Override hook vor quantifiable location
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(4 hmtyinfer || hmtyast)
SEM Ty
  | *           loc         .   isQuLocExtraHook
  											=   @lhs.isAtTop || tqoptAllowInnerQuant @lhs.opts
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Fixed tvars
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(4 hmtyinfer || hmtyast)
ATTR AllTy [ | | gathFxTvM USE {`Map.union`} {Map.empty}: TvCatMp ]
ATTR AllTy [ fxTvM: TvCatMp | | ]

SEM Ty
  | Var         lhs         .   gathFxTvM   =   @tv `Map.singleton` mkTvInfoTy @categ.self

SEM TyAGItf
  | AGItf       loc         .   fxTvM       =   @ty.gathFxTvM
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Free row vars
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(90 hmtyinfer || hmtyast)
ATTR Ty [ | | frRowTvL: TyVarIdL ]

SEM Ty
  | Ext         lhs         .   frRowTvL    =   @ty.frRowTvL
  | App         loc         .   frRowTvL    =   @func.frRowTvL `List.union` @arg.frRowTvL
  | * - App Ext
                lhs         .   frRowTvL    =   []
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Rank
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(4 hmtyinfer || hmtyast)
ATTR AllTy [ rank: Int | | ]

SEM Ty
  | App         arg         .   rank        =   @lhs.rank + (if @isArrowArg then 1 else 0)

SEM TyAGItf
  | AGItf       ty          .   rank        =   1
%%]

%%[(9 hmtyinfer || hmtyast)
SEM Ty
  | Var App Pred
                loc         .   isQuRank    =   @lhs.rank `elem` tqoptQuRanks @lhs.opts
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Is location in type a place where we treat quantification specially?
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(6_4 hmtyinfer || hmtyast).isSpecLoc
ATTR Ty [ | | isSpecLoc: Bool  isSpecLocL: [Bool] ]

SEM Ty
  | App         loc         .   isSpecLoc   =   @isSpineRoot && (@appIsArrow || @appIsLikeProd)
                            .   isSpecLocL  =   @arg.isSpecLoc : @func.isSpecLocL
  | * - App     loc         .   isSpecLoc   =   False
                            .   isSpecLocL  =   []
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Is location in type a place where quantification of previously existentialized tvar may be done?
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(6_4 hmtyinfer || hmtyast)
SEM Ty
  | App         loc         .   isReQuExLoc =   @lhs.rank > 1
                                                ||  @lhs.rank == 1
                                                    &&  (@lhs.tyCtxt == TyQuCtxtArrow && not @arg.isArrow
                                                        || @lhs.tyCtxt /= TyQuCtxtArrow
                                                        )
  | Var         loc         .   isReQuExLoc =   True
%%]

%%[(9 hmtyinfer || hmtyast)
%%]
SEM Ty
  | Pred        loc         .   isReQuExLoc =   True

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Is location in type a place where quantification of fixed tvar may be done?
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(4 hmtyinfer || hmtyast)
SEM Ty
  | App         loc         .   isQuFxLoc   =   @lhs.rank > 1
                                                ||  @lhs.rank == 1
                                                    &&  (@lhs.tyCtxt == TyQuCtxtArrow && not @arg.isArrow
                                                        || @lhs.tyCtxt == TyQuCtxtOther
                                                        )
  | Var         loc         .   isQuFxLoc   =   False
%%]

%%[(9 hmtyinfer || hmtyast)
SEM Ty
  | Pred        loc         .   isQuFxLoc   =   False
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Determine quantifiable tvars
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(4 hmtyinfer || hmtyast).tvBoundAdd hs
tvBoundAdd :: (TyVarId -> Bool) -> TyVarIdS -> TyVarId -> Bool
tvBoundAdd tvIsBound tvS = \v -> v `Set.member` tvS || tvIsBound v
%%]

%%[(4 hmtyinfer || hmtyast).tvarsToQuant hs
tvarsToQuant :: Bool -> TvCatMp -> (TyVarId -> Bool) -> (TyVarId -> Bool) -> TyVarIdS -> (TyVarIdS,TyVarIdS,TyVarId -> Bool)
tvarsToQuant isQuLoc _ mayQuFx tvIsBound tvS
  =  if isQuLoc
     then  let boundables = Set.filter (\tv -> not (tvIsBound tv)) tvS
           in (boundables,Set.empty,tvBoundAdd tvIsBound boundables)
     else  (Set.empty,Set.empty,tvIsBound)
%%]

%%[(6_4 hmtyinfer || hmtyast).tvarsToQuant -4.tvarsToQuant hs
tvarsToQuant :: Bool -> TvCatMp -> (TyVarId -> Bool) -> (TyVarId -> Bool) -> TyVarIdS -> (TyVarIdS,TyVarIdS,TyVarId -> Bool)
tvarsToQuant isQuLoc fxTvM mayQuFx tvIsBound tvS
  =  if isQuLoc
     then  let  tvFrS = Set.filter (\tv -> not (tvIsBound tv)) tvS
                (bndEx,bnd) = Set.partition (tvIsEx fxTvM) tvFrS
           in   (bnd,Set.filter mayQuFx bndEx,tvBoundAdd tvIsBound tvFrS)
     else  (Set.empty,Set.empty,tvIsBound)
%%]

%%[(4 hmtyinfer || hmtyast).tvMayQuFx hs
tvMayQuFx :: TyQu -> TvCatMp -> Bool -> TyVarId -> Bool
tvMayQuFx qu fxTvM isQuFxLoc tv
  = True
%%]

%%[(6_4 hmtyinfer || hmtyast).tvMayQuFx -4.tvMayQuFx hs
tvMayQuFx :: TyQu -> TvCatMp -> Bool -> TyVarId -> Bool
tvMayQuFx qu fxTvM isQuFxLoc tv
  = isQuFxLoc 
%%]

%%[(4 hmtyinfer || hmtyast).tvIsBound
ATTR AllTy [ tvIsBound: {TyVarId -> Bool} | | ]

SEM TyAGItf
  | AGItf       loc         .   (qBndTvS,qBndExTvS,tvIsBound)
                                                        =   tvarsToQuant True @fxTvM (const False) (tqoptTvIsBound @lhs.opts) @qHereTvS

SEM Ty
  | App Var     loc         .   (qBndTvS,qBndExTvS,tvIsBound)
                                                        =   tvarsToQuant @isQuLoc @lhs.fxTvM (tvMayQuFx @hereQu @lhs.fxTvM @isQuFxLoc) @lhs.tvIsBound @qHereTvS
  | Quant       loc         .   tvIsBound               =   tvBoundAdd @lhs.tvIsBound @introTVarS
%%]

%%[(9 hmtyinfer || hmtyast)
SEM Ty
  | App Var     loc         .   (qBndTvS,qBndExTvS,tvIsBound)
                                                        :=  tvarsToQuant @isQuLoc @lhs.fxTvM (tvMayQuFx @hereQu @lhs.fxTvM @isQuFxLoc) @lhs.tvIsBound @qHereTvS
%%]
SEM Ty
  | App Var     loc         .   (qBndTvS,qBndExTvS,tvIsBound)
                                                        :=  tvarsToQuant @isQuLoc @lhs.fxTvM (tvMayQuFx @hereQu @lhs.fxTvM @isQuFxLoc) @lhs.tvIsBound (@qHereTvS `Set.union` ftvSet @candPrL)

%%[(9 hmtyinfer || hmtyast)
SEM Ty
  | Pred        loc         .   (qBndTvS,qBndExTvS,tvIsBound)
                                                        =   tvarsToQuant @isQuLoc @lhs.fxTvM (const False) @lhs.tvIsBound @qHereTvS
%%]

%%[(11 hmtyinfer || hmtyast)
SEM Ty
  | Lam         loc         .   tvIsBound               =   tvBoundAdd @lhs.tvIsBound @introTVarS
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Which quantifier to use for quantification
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(4 hmtyinfer || hmtyast).hereQu
SEM TyAGItf
  | AGItf       loc         .   hereQu          =   tyQu_Forall

SEM Ty
  | App         loc         .   qAsExist        =   @appIsLikeProd || polIsContravariant @lhs.pol && not @appIsArrow
  | Var         loc         .   qAsExist        =   polIsContravariant @lhs.pol
  | App Var     loc         .   hereQu          =   if @qAsExist then tyQu_Exists else tyQu_Forall
  | Quant       loc         .   hereQu          =   @qu.self
%%]

%%[(6 hmtyinfer || hmtyast).hereQu
ATTR TyAGItf AllTy [ baseQu: TyQu | | ]

SEM TyAGItf
  | AGItf       loc         .   hereQu          :=  @lhs.baseQu

SEM Ty
  | App Var     loc         .   hereQu          :=  if @qAsExist then tyquExists @lhs.baseQu else @lhs.baseQu
%%]

%%[(9 hmtyinfer || hmtyast).hereQu
SEM Ty
  | App         loc         .   qAsExist        :=  (@appIsLikeProd || polIsContravariant @lhs.pol && not @appIsArrow)
  | Var         loc         .   qAsExist        :=  polIsContravariant @lhs.pol
%%]
SEM Ty
  | App         loc         .   qAsExist        :=  @hasNoInsPrL && (@appIsLikeProd || polIsContravariant @lhs.pol && not @appIsArrow)
  | Var         loc         .   qAsExist        :=  @hasNoInsPrL && polIsContravariant @lhs.pol

%%[(9 hmtyinfer || hmtyast)
SEM Ty
  | Pred        loc         .   qAsExist        =   polIsContravariant @lhs.pol
                            .   hereQu          =   if @qAsExist then tyquExists @lhs.baseQu else @lhs.baseQu
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Quantified type
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(4 hmtyinfer || hmtyast) hs
mkTyQuEx :: TyQuOpts -> TyQu -> TyVarIdS -> TyVarIdS -> Ty -> Ty
mkTyQuEx opts q tvS tvExS t
  = mkTyQu q (mkk $ Set.toList tvS) (mkTyQu (tyquExists q) (mkk $ Set.toList tvExS) t)
%%[[4
  where mkk = id
%%][6
  where mkk tvs = [ (v,tqoptTvKi opts v) | v <- tvs ]
%%]]
%%]

%%[(4 hmtyinfer || hmtyast).quTy
ATTR TyAGItf [ | | quTy: Ty ]
ATTR AllTyAndFlds [ | | quTy: SELF ]

SEM TyAGItf
  | AGItf       lhs         .   quTy            =   mkTyQuEx @lhs.opts @hereQu @qBndTvS @qBndExTvS @ty.quTy

SEM Ty
  | Var         lhs         .   quTy            =   mkTyQuEx @lhs.opts @hereQu @qBndTvS @qBndExTvS (Ty_Var @tv @categ.quTy)
  | App         loc         .   quTy            =   mkTyQuEx @lhs.opts @hereQu @qBndTvS @qBndExTvS (Ty_App @func.quTy @arg.quTy)
%%[[4
  | Quant       lhs         .   quTy            =   Ty_Quant @qu.self @tv @ty.quTy
%%][6
  | Quant       lhs         .   quTy            =   Ty_Quant @qu.self @tv (tqoptTvKi @lhs.opts @tv) @ty.quTy
%%]]
%%]

%%[(9 hmtyinfer || hmtyast) hs
mkTyQuForRank :: TyQuOpts -> Bool -> TyQu -> TyVarIdS -> TyVarIdS -> Ty -> Ty
mkTyQuForRank opts allow q tvS tvExS t = if allow then mkTyQuEx opts q tvS tvExS t else t
%%]

%%[(9 hmtyinfer || hmtyast)
SEM Ty
  | Var         lhs         .   quTy            :=  mkTyQuForRank @lhs.opts @isQuRank @hereQu @qBndTvS @qBndExTvS $ Ty_Var @tv @categ.quTy
  | App         loc         .   quTy            :=  let  (rwYTvS,rwNTvS) = Set.partition (`Set.member` @frRowTvS) @qBndTvS
                                                    in   mkTyQuForRank @lhs.opts @isQuRank @hereQu rwNTvS @qBndExTvS
                                                         $  mkTyQuForRank @lhs.opts @isQuRank @lhs.baseQu rwYTvS Set.empty
                                                         $  Ty_App @func.quTy @arg.quTy
  | Pred        lhs         .   quTy            =   mkTyQuForRank @lhs.opts @isQuRank @hereQu @qBndTvS @qBndExTvS (Ty_Pred @pr.quTy)
%%]

%%[(11 hmtyinfer || hmtyast)
SEM Ty
  | Lam         lhs         .   quTy            =   Ty_Lam @tv @ty.quTy
%%]

