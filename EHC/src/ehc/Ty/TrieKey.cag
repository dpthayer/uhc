%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell importable interface to computation of a TrieKey from a Ty
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

A TrieKey for a Ty is a breadthfirst walk through the type structure, where unknown, too complex,
or unifiable parts (like type variables) are marked as partial.
In this way search via a Trie proceeds top to bottom, in the same way unification would.

Some examples:
type                                Ty                                      [TrieKey Key]
----                                --                                      -------------
Int                                 Int                                     [Int]
Int -> Int                          (->) Int Int                            [->,Int,Int]
(Int -> Int) -> (Int -> Int)        (->) ((->) Int Int) ((->) Int Int)      [->,->,->,Int,Int,Int,Int]
(a -> b) -> (c -> d)                (->) ((->) a b) ((->) c d)              [->,->,->,a,b,c,d]
a -> (c -> d)                       (->) a ((->) c d)                       [->,a,->,c,d]
(a -> b) -> c                       (->) ((->) a b) c                       [->,->,c,a,b]

%%[9 hs module {%{EH}Ty.TrieKey} import({%{EH}Base.Common},{%{EH}Base.HsName},{%{EH}Base.Builtin},{%{EH}Ty})
%%]

%%[9 hs import(qualified Data.Set as Set,Data.List as Lst,EH.Util.FastSeq as Seq,{%{EH}Base.Trie (TrieKey(..),TrieKeyKind(..))},{%{EH}CHR.Key})
%%]

%%[9 ag import({Ty/AbsSyn},{Ty/CommonAG})
WRAPPER TyAGItf
%%]

%%[9 hs
tyTrieKeyParentChildren :: Ty -> ([TrieKey Key],[TrieKey Key])
tyTrieKeyParentChildren ty
  =  let  t =  wrap_TyAGItf
                 (sem_TyAGItf (TyAGItf_AGItf ty))
                 (Inh_TyAGItf)
     in   (toList $ trieKey_Syn_TyAGItf t, toList $ trieKeyNest_Syn_TyAGItf t)

instance Keyable Ty where
  toKeyParentChildren = tyTrieKeyParentChildren

instance Keyable Pred where
  toKeyParentChildren pr = toKeyParentChildren $ Ty_Pred pr

instance Keyable PredScope where
  toKey (PredScope_Var v) = [TK_One TKK_Partial $ Key_UID v]
  toKey (PredScope_Lev l) = [TK_One TKK_Normal  $ Key_Str $ show l]

instance Keyable PredOccId where
  toKey (PredOccId_Var v) = [TK_One TKK_Partial $ Key_UID v]
  toKey (PredOccId   _ i) = [TK_One TKK_Normal  $ Key_UID i]

instance Keyable PredOcc where
  toKey po = toKey (poPr po)

instance Keyable CHRPredOcc where
  toKeyParentChildren po
    = (ppr ++ toKey (cpoScope po),cpr)
    where (ppr,cpr) = toKeyParentChildren $ cpoPr po

%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% TrieKey
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[9
ATTR TyAGItf Ty Pred [ | | trieKey: {FastSeq (TrieKey Key)} ]
ATTR Ty  [ | | trieKeyFun, trieKeyArgs, trieKeyArgsNest: {FastSeq (TrieKey Key)} ]
ATTR TyAGItf Ty Pred [ | | trieKeyNest: {FastSeq (TrieKey Key)} ]

SEM Ty
  | App             lhs     .   (trieKey,trieKeyNest)
                                                =   if @isSpineRoot
                                                    then (@trieKeyFun, @trieKeyArgs :++: @trieKeyArgsNest)
                                                    else (empty,empty)
  | Ext             lhs     .   (trieKey,trieKeyNest)
                                                =   if @isSpineRoot
                                                    then ( singleton
                                                           $ TK_One
                                                               (if @ty.isFixed then TKK_Normal else TKK_Partial)
                                                               (Key_Str $ concat $ intersperse "," $ Lst.map show $ tyRowCanonLblOrder @ty.lblL)
                                                         , @trieKeyArgs :++: @trieKeyArgsNest
                                                         )
                                                    else (empty,empty)
  | Var             loc     .   trieKey         =   singleton $ TK_One
                                                                  (if tvCatIsPlain @categ.self then TKK_Partial else TKK_Normal)
                                                              $ Key_UID @tv
                            .   trieKeyNest     =   empty
  | Con             loc     .   trieKey         =   singleton $ TK_One TKK_Normal $ Key_HNm @nm
                            .   trieKeyNest     =   empty
  | Quant           loc     .   trieKey         =   singleton $ TK_One TKK_Partial $ Key_TyQu @qu.self
                            .   trieKeyNest     =   empty
  | Pred            loc     .   trieKey         =   @pr.trieKey
                            .   trieKeyNest     =   @pr.trieKeyNest
  | * - App Var Con Quant Ext Pred
                    loc     .   trieKey         =   singleton $ TK_One TKK_Partial $ Key_Ty @self
                            .   trieKeyNest     =   empty

SEM Ty
  | * - App Ext     lhs     .   trieKeyFun      =   @trieKey
                            .   trieKeyArgs     =   empty
                            .   trieKeyArgsNest =   empty
  | App             loc     .   trieKeyFun      =   @func.trieKeyFun
                            .   trieKeyArgs     =   @func.trieKeyArgs :++: @arg.trieKeyFun
                            .   trieKeyArgsNest =   @func.trieKeyArgsNest :++: @arg.trieKeyNest
  | Ext             loc     .   trieKeyArgs     =   @ty.trieKeyArgs :++: @extTy.trieKeyFun
                            .   trieKeyArgsNest =   @ty.trieKeyArgsNest :++: @extTy.trieKeyNest

SEM Pred
  | Var             lhs     .   trieKey         =   singleton $ TK_One TKK_Partial $ Key_UID @pv
                            .   trieKeyNest     =   empty
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% (Ext) record info
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[9
ATTR Ty [ | | lblL: {[HsName]}  isFixed: Bool ]

SEM Ty
  | Ext             lhs     .   lblL            =   @nm : @ty.lblL
  | * - Ext         lhs     .   lblL            =   []

SEM Ty
  | Ext             lhs     .   isFixed         =   @ty.isFixed
  | Var             lhs     .   isFixed         =   False
  | * - Ext Var     lhs     .   isFixed         =   True
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Test
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[9 hs
%%]
(_,u1,u2,u3,u4) = mkNewLevUID4 uidStart
v1 = mkTyVar u1
v2 = mkTyVar u2
v3 = mkTyVar u3
v4 = mkTyVar u4

t1 = tyInt
t2 = mkArrow [t1] t1
t3 = mkArrow [t2] t2
t4 = mkArrow [v1] v2
t5 = mkArrow [v3] v4
t6 = mkArrow [t4] t5
t7 = mkArrow [v1] t5
t8 = mkArrow [t4] v3
