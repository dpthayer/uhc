%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell importable interface to GRIN code
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs module {%{EH}GrinCode} import({%{EH}Base.Common},{%{EH}Base.Opts},EH.Util.Pretty,EH.Util.Utils)
%%]

%%[(8 codegen grin) hs import(qualified Data.Map as Map,qualified Data.Set as Set,qualified Data.List as List)
%%]

%%[(8 codegen grin) hs import({%{EH}Base.Builtin},{%{EH}Base.Builtin2}, {%{EH}Base.BasicAnnot}) export(module {%{EH}Base.BasicAnnot})
%%]

%%[(8 codegen grin) hs export(GrExpr(..), GrBind(..), GrBindL, GrGlobal(..), GrGlobalL)
%%]

%%[(8 codegen grin) hs export(GrAGItf(..), GrModule(..))
%%]

%%[(8 codegen grin) hs export(GrAlt(..), GrAltL, GrPatAlt(..), GrPatLam(..), GrVal(..), GrValL, GrTag(..), GrTagL, GrVar(..), GrVarL)
%%]

%%[(10 codegen grin) hs export(GrAdapt(..), GrAdaptL, GrSplit(..), GrSplitL)
%%]

%%[(10 codegen grin) hs export(GrNodeAdapt(..))
%%]

%%[(8 codegen grin) hs export(mkGrBox,mkGrRecNode,mkGrConNode)
%%]

%%[(8 codegen grin) hs export(mkGrPatRecNode,mkGrPatConNode,mkGrUnbox,mkGrUnboxFFI)
%%]

%%[(10 codegen grin) hs export(mkGrPatRecSplit,mkGrPatConSplit)
%%]

%%[(20 codegen grin) hs import(Control.Monad, {%{EH}Base.Binary})
%%]
%%[(20 codegen grin) hs import(Data.Typeable(Typeable), Data.Generics(Data), qualified {%{EH}Base.Serialize} as Ser)
%%]

%%[(94 codegen grin) hs import({%{EH}Foreign},{%{EH}Base.Target}) export(FFIWay(..),module {%{EH}Foreign})
%%]

%%[(99 codegen grin) hs export(GrFFIAnnot(..))
%%]

%%[(8 codegen grin) ag import({GrinCode/AbsSyn})
DERIVING * - GrTag
  : Show, Eq
%%[[20
  , Typeable, Data
%%]]
DERIVING GrTag
  : Show
%%[[20
  , Typeable, Data
%%]]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Special names
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs export(grBuiltinTyNmL)
grBuiltinTyNmL :: EHCOpts -> [HsName]
grBuiltinTyNmL opts = builtinKnownGrinBoxedTyNmL opts ++ builtinKnownRecTyNmL
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Tag categories
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Tag annotation

%%[(8 codegen grin) hs export(GrTagAnn(..),mkGrTagAnn,emptyGrTagAnn)
data GrTagAnn
  = GrTagAnn
      { gtannArity 		:: !Int
      , gtannMaxArity 	:: !Int
      }

instance Eq GrTag where
  GrTag_Con _ _ x1 == GrTag_Con _ _ x2 = x1==x2
  GrTag_Fun     x1 == GrTag_Fun     x2 = x1==x2
  GrTag_App     x1 == GrTag_App     x2 = x1==x2
  GrTag_PApp n1 x1 == GrTag_PApp n2 x2 = n1==n2 && x1==x2
  GrTag_Unboxed    == GrTag_Unboxed    = True
  GrTag_Hole       == GrTag_Hole       = True
  GrTag_Rec        == GrTag_Rec        = True
  _                == _                = False
  


instance Eq GrTagAnn where
  x == y = True

instance Ord GrTagAnn where
  x `compare` y = EQ

instance Show GrTagAnn where
  show (GrTagAnn a ma) = "{" ++ show a ++ "," ++ show ma ++ "}"

mkGrTagAnn :: Int -> Int -> GrTagAnn
mkGrTagAnn = GrTagAnn

emptyGrTagAnn = mkGrTagAnn 0 0
%%]

%%[(20 codegen grin) hs
deriving instance Typeable GrTagAnn
deriving instance Data GrTagAnn
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Binding categories
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs export(GrBindAnn(..))

-- Annotation for Grin Bindings
--   Normal:  normal binding
--   Class:    binds a dictionary with default definitions for al class
--      The list entries correspond 1-to-1 with the class members
--      They contain "Just" the name of the default implementation, or "Nothing" if there is none.
--      Note that the dictionary may also contain superclass pointers, but they are not recorded in the annotation.
--   Instance: binds a dictionary with definitions form an instance declaration
--      The first element of the list is a singleton of the name of the dictionary constructor.
--      The second element of the list is a singleton of the name of the dictionary containing the default definitions.
--      The remaining list entries correspond 1-to-1 with the class members
--      They contain the name of the instance implementation (possibly with some arguments), or [] if it relies on the default implementation.
--   Overloaded: binds a function with dictionary parameters
--      The numbers specify which dictionaries are needed:
--            [-1] if the dictionary of which the function is a member is needed
--            [0]  if the first superclass is needed (for example, the Eq dictionary for a member of Ord)
--            [1]  if the second superclass is needed, etc.
--            [2,1] if the third superclass of the second superclass is needed

data GrBindAnn
  = GrBindAnnNormal
  | GrBindAnnClass    [Maybe HsName]
  | GrBindAnnInstance [[HsName]]
  | GrBindAnnOverloaded [[Int]]
  | GrBindAnnSpecialized HsName Int [Maybe HsName]
  deriving (Eq,Ord,Show)

%%]

%%[(20 codegen grin) hs
deriving instance Typeable GrBindAnn
deriving instance Data GrBindAnn
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Alternative categories
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs export(GrAltAnn(..))

-- Annotation for Grin Alternatives
--   Normal:  this alternative has classic semantics
--   Ident:   this alternative just returns the scrutinee, but has classic semantics
--   Calling: the alternative calls a function
--   Reenter: this alternative returns a value which has to be scrutinized again against the other alternatives

data GrAltAnn
  = GrAltAnnNormal
  | GrAltAnnIdent
  | GrAltAnnCalling Int HsName
  | GrAltAnnReenter
  deriving (Eq,Ord,Show)

%%]

%%[(20 codegen grin) hs
deriving instance Typeable GrAltAnn
deriving instance Data GrAltAnn
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% FFI annotation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(99 codegen grin) hs export(grFFIAnnotIsResEvaluated)
grFFIAnnotIsResEvaluated :: GrFFIAnnot -> Bool
grFFIAnnotIsResEvaluated (GrFFIAnnot_IsResEval b) = b
-- comment away when GrFFIAnnot is extended, for this avoid ghc warnings
-- grFFIAnnotIsResEvaluated _                        = True
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Free var info used for (e.g.) inlining for GrinByteCode
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs export(FvInfo(..),FvUse(..),FvInfoMp)
data FvUse
  = FvUse_Call | FvUse_Val | FvUse_Other
  deriving (Eq,Ord,Show)

data FvInfo
  = FvInfo
      { fviUseCount		:: !Int
      , fviUseAs 		:: !(Set.Set FvUse)
      }
  deriving (Show)

type FvInfoMp = Map.Map HsName FvInfo
%%]

%%[(8 codegen grin) hs export(fviMpUnion,fviMpSingleton,fviMpSingleton',fviMpUnions,fviMpFromList,fviMpFromList',fviMpDifference)
fviMpDifference :: FvInfoMp -> FvInfoMp -> FvInfoMp
fviMpDifference = Map.difference

fviMpUnion :: FvInfoMp -> FvInfoMp -> FvInfoMp
fviMpUnion = Map.unionWith (\i1 i2 -> i1 {fviUseCount = fviUseCount i1 + fviUseCount i2, fviUseAs = Set.unions [fviUseAs i1,fviUseAs i2]})

fviMpUnions :: [FvInfoMp] -> FvInfoMp
fviMpUnions = foldr fviMpUnion Map.empty

fviMpSingleton' :: FvUse -> HsName -> FvInfoMp
fviMpSingleton' u n = Map.singleton n (FvInfo 1 (Set.singleton u))

fviMpSingleton :: HsName -> FvInfoMp
fviMpSingleton = fviMpSingleton' FvUse_Other

fviMpFromList' :: FvUse -> [HsName] -> FvInfoMp
fviMpFromList' u = fviMpUnions . map (fviMpSingleton' u)

fviMpFromList :: [HsName] -> FvInfoMp
fviMpFromList = fviMpFromList' FvUse_Other
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Name alias info used for alias removal
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs export(NmAlias(..),NmAliasMp, mkNmAliasMp)
data NmAlias
 = NmAlias_Nm       			!HsName                                                 -- name to name
 | NmAlias_NmAfterSideEffect	!HsName                                                 -- name to name, but after an eval
 | NmAlias_Eval     			!HsName                                                 -- name to evaluated name
 | NmAlias_Const    			{naliNm :: !HsName, naliVal  :: !GrVal        }         -- name to single constant (other than name)
 | NmAlias_Grp      			{naliNm :: !HsName, naliAlis :: ![NmAlias]    }         -- name to group of values, i.e. node constituents
 | NmAlias_Basic    			{naliNm :: !HsName, naliAli  :: !NmAlias, naliAnnot :: BasicAnnot  }
                                                                     		       	-- name to basic value, i.e. node element used for FFI
 | NmAlias_None

type NmAliasMp = Map.Map HsName NmAlias

mkNmAliasMp :: AssocL HsName HsName -> NmAliasMp
mkNmAliasMp = Map.fromList . assocLMapElt NmAlias_Nm
%%]

Assume only mappings to NmAlias_Nm, others are not replaced.

%%[(8 codegen grin) hs export(nmAliasRepl,nmAliasRepl')
nmAliasRepl' :: NmAliasMp -> HsName -> NmAlias
nmAliasRepl' m n
  = case Map.lookup n m of
      Just a -> a
      _      -> NmAlias_Nm n

nmAliasRepl :: NmAliasMp -> HsName -> HsName
nmAliasRepl m n
  = case Map.lookup n m of
      Just (NmAlias_Nm    n'  ) -> n'
      Just (NmAlias_Grp   n' _) -> n'
      Just (NmAlias_Const n' _) -> n'
      _                         -> n
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Inline optimisation map
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs export(GrInl(..),GrInlMp)
data GrInl
  = GrInl_Call
      { inlArgNmL   :: ![HsName]
      , inlGrExpr   :: !GrExpr
      }
  | GrInl_CAF
      { inlGrExpr   :: !GrExpr
      }
%%[[20
  deriving (Typeable, Data)
%%]]

type GrInlMp = Map.Map HsName GrInl
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Row/record
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(10 codegen grin) hs
data GrNodeAdapt = GrNodeUpd | GrNodeExt deriving (Show,Eq)

%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Node construction
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs
-- partial parametrizations of the GrVal_Node etc.

mkGrConNode :: GrTagAnn -> Int -> HsName -> GrValL -> GrVal
mkGrConNode ann i nm = GrVal_Node (GrTag_Con ann i nm)

mkGrRecNode ::  GrValL -> GrVal
mkGrRecNode xs
  = GrVal_Node (GrTag_Con (mkGrTagAnn a a) 0 (hsnProd a)) xs
  where a = length xs

mkGrPatConNode :: GrTagAnn -> Int -> HsName -> [HsName] -> GrPatAlt
mkGrPatConNode ann i nm = GrPatAlt_Node (GrTag_Con ann i nm)

mkGrPatRecNode :: [HsName] -> GrPatAlt
mkGrPatRecNode xs
  = GrPatAlt_Node (GrTag_Con (mkGrTagAnn a a) 0 (hsnProd a)) xs
  where a = length xs

mkGrBox :: HsName -> GrVal -> GrVal
mkGrBox tyNm v = mkGrConNode (mkGrTagAnn 1 1) 0 tyNm [v]

mkGrUnbox :: HsName -> HsName -> GrPatLam
mkGrUnbox tyNm n = let tag = GrTag_Con (mkGrTagAnn 1 1) 0 tyNm
                   in  GrPatLam_VarNode [ GrVar_KnownTag tag, GrVar_Var n ]

mkGrUnboxFFI :: HsName -> GrPatLam
mkGrUnboxFFI   n = let tag = GrTag_Unboxed
                   in  GrPatLam_VarNode [ GrVar_KnownTag tag, GrVar_Var n ]

%%]

%%[(10 codegen grin) hs
mkGrPatConSplit :: GrTagAnn -> Int -> HsName -> HsName -> GrSplitL -> GrPatAlt
mkGrPatConSplit ann i nm = GrPatAlt_NodeSplit (GrTag_Con ann i nm)

mkGrPatRecSplit :: HsName -> GrSplitL -> GrPatAlt
mkGrPatRecSplit  = GrPatAlt_NodeSplit GrTag_Rec
%%]

%%[(20 codegen grin) hs export(grModMerge)
grModMerge :: [GrModule] -> GrModule
grModMerge mL
  = foldr1 cmb mL
  where cmb (GrModule_Mod m1 g1 b1 t1) (GrModule_Mod m2 g2 b2 t2)
          = GrModule_Mod m2 (List.union g1 g2) (b1 ++ b2) (Map.union t1 t2)
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% How will name be evaluated, used in (e.g.) EvalElim, CommonWillEval
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

How a name will be used later on in code.
Used by CommonWillEval to indicate evaluation (WillUseFor_Eval).
EvalElim also must now whether a name is used as a field, or argument (WillUseFor_NodeField).

%%[(8 codegen grin) hs export(WillUseFor(..),WillUseForMp,WillUseForS,willUseIntersection,willUseUnion,willUseFor,willUseForEval,willUseForNodeField)
data WillUseFor
  = WillUseFor_Eval
  | WillUseFor_NodeField
  deriving (Eq,Ord,Show)

instance PP WillUseFor where
  pp = pp . show

type WillUseForS  = Set.Set WillUseFor
type WillUseForMp = Map.Map HsName WillUseForS

willUseUnion :: WillUseForMp -> WillUseForMp -> WillUseForMp
willUseUnion = Map.unionWith Set.union

willUseIntersection :: WillUseForMp -> WillUseForMp -> WillUseForMp
willUseIntersection = Map.intersectionWith Set.intersection

willUseFor :: HsName -> WillUseForMp -> WillUseForS
willUseFor n m = maybe Set.empty id $ Map.lookup n m

willUseForEval :: HsName -> WillUseForMp -> Bool
willUseForEval n m = maybe False (WillUseFor_Eval `Set.member`) $ Map.lookup n m

willUseForNodeField :: HsName -> WillUseForMp -> Bool
willUseForNodeField n m = maybe False (WillUseFor_NodeField `Set.member`) $ Map.lookup n m
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Instances: Binary
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(20 codegen grin) hs
instance Binary GrInl where
  put (GrInl_Call a b) = putWord8  0 >> put a >> put b
  put (GrInl_CAF  a  ) = putWord8  1 >> put a
  get = do t <- getWord8
           case t of
             0 -> liftM2 GrInl_Call get get
             1 -> liftM  GrInl_CAF  get

instance Binary GrExpr where
  put (GrExpr_Seq         a b c  ) = putWord8 0  >> put a >> put b >> put c
  put (GrExpr_Unit        a      ) = putWord8 1  >> put a
  put (GrExpr_UpdateUnit  a b    ) = putWord8 2  >> put a >> put b
  put (GrExpr_Case        a b    ) = putWord8 3  >> put a >> put b
  put (GrExpr_FetchNode   a      ) = putWord8 4  >> put a
  put (GrExpr_FetchUpdate a b    ) = putWord8 5  >> put a >> put b
  put (GrExpr_FetchField  a b c  ) = putWord8 6  >> put a >> put b >> put c
  put (GrExpr_Store       a      ) = putWord8 7  >> put a
  put (GrExpr_Call        a b    ) = putWord8 8  >> put a >> put b
%%[[20
  put (GrExpr_FFI         a b    ) = putWord8 9  >> put a >> put b
%%][94
  put (GrExpr_FFI         a b c  ) = putWord8 9  >> put a >> put b >> put c
%%][99
  put (GrExpr_FFI         a b c d) = putWord8 9  >> put a >> put b >> put c >> put d
%%]]
  put (GrExpr_Eval        a      ) = putWord8 10 >> put a
  put (GrExpr_App         a b    ) = putWord8 11 >> put a >> put b
  put _                            = panic "GrinCode.Binary.GrExpr.put"		-- unused are unimplemented
  get = do t <- getWord8
           case t of
             0  -> liftM3 GrExpr_Seq          get get get
             1  -> liftM  GrExpr_Unit         get
             2  -> liftM2 GrExpr_UpdateUnit   get get
             3  -> liftM2 GrExpr_Case         get get
             4  -> liftM  GrExpr_FetchNode    get
             5  -> liftM2 GrExpr_FetchUpdate  get get
             6  -> liftM3 GrExpr_FetchField   get get get
             7  -> liftM  GrExpr_Store        get
             8  -> liftM2 GrExpr_Call         get get
%%[[20
             9  -> liftM2 GrExpr_FFI          get get
%%][94
             9  -> liftM3 GrExpr_FFI          get get get
%%][99
             9  -> liftM4 GrExpr_FFI          get get get get
%%]]
             10 -> liftM  GrExpr_Eval         get
             11 -> liftM2 GrExpr_App          get get
             _  -> panic "GrinCode.Binary.GrExpr.get"		-- unused are unimplemented


instance Binary GrAlt where
  put (GrAlt_Alt          a b c  ) = putWord8 0  >> put a >> put b >> put c
  get = do t <- getWord8
           case t of
             0  -> liftM3 GrAlt_Alt          get get get

instance Binary GrTag where
  put (GrTag_Con         a b c  ) = putWord8 0  >> put a >> put b >> put c
  put (GrTag_Fun         a      ) = putWord8 1  >> put a
  put (GrTag_PApp        a b    ) = putWord8 2  >> put a >> put b
  put (GrTag_App         a      ) = putWord8 3  >> put a
  put (GrTag_Unboxed            ) = putWord8 4
  put (GrTag_Hole               ) = putWord8 5
  put (GrTag_Rec                ) = putWord8 6
  get = do t <- getWord8
           case t of
             0  -> liftM3 GrTag_Con          get get get
             1  -> liftM  GrTag_Fun          get
             2  -> liftM2 GrTag_PApp         get get
             3  -> liftM  GrTag_App          get
             4  -> return GrTag_Unboxed
             5  -> return GrTag_Hole
             6  -> return GrTag_Rec

instance Binary GrPatLam where
  put (GrPatLam_Empty              ) = putWord8 0
  put (GrPatLam_Var         a      ) = putWord8 1  >> put a
  put (GrPatLam_VarNode     a      ) = putWord8 2  >> put a
  put (GrPatLam_BasicNode   a b    ) = putWord8 3  >> put a >> put b
  put (GrPatLam_EnumNode    a      ) = putWord8 4  >> put a
  put (GrPatLam_PtrNode     a      ) = putWord8 5  >> put a
  put (GrPatLam_OpaqueNode  a      ) = putWord8 6  >> put a
  put (GrPatLam_BasicAnnot  a b    ) = putWord8 7  >> put a >> put b
  put (GrPatLam_EnumAnnot   a b    ) = putWord8 8  >> put a >> put b
  put (GrPatLam_PtrAnnot    a b    ) = putWord8 9  >> put a >> put b
  put (GrPatLam_OpaqueAnnot a      ) = putWord8 10 >> put a
  get = do t <- getWord8
           case t of
             0  -> return GrPatLam_Empty
             1  -> liftM  GrPatLam_Var          get
             2  -> liftM  GrPatLam_VarNode      get
             3  -> liftM2 GrPatLam_BasicNode    get get
             4  -> liftM  GrPatLam_EnumNode     get
             5  -> liftM  GrPatLam_PtrNode      get
             6  -> liftM  GrPatLam_OpaqueNode   get
             7  -> liftM2 GrPatLam_BasicAnnot   get get
             8  -> liftM2 GrPatLam_EnumAnnot    get get
             9  -> liftM2 GrPatLam_PtrAnnot     get get
             10 -> liftM  GrPatLam_OpaqueAnnot  get

instance Binary GrVal where
  put (GrVal_Empty              ) = putWord8 0
  put (GrVal_Var         a      ) = putWord8 1  >> put a
  put (GrVal_VarNode     a      ) = putWord8 2  >> put a
  put (GrVal_BasicNode   a b    ) = putWord8 3  >> put a >> put b
  put (GrVal_EnumNode    a      ) = putWord8 4  >> put a
  put (GrVal_PtrNode     a      ) = putWord8 5  >> put a
  put (GrVal_LitInt      a      ) = putWord8 6  >> put a
  put (GrVal_LitStr      a      ) = putWord8 7  >> put a
  put (GrVal_Tag         a      ) = putWord8 8  >> put a
  put (GrVal_Node        a b    ) = putWord8 9  >> put a >> put b
  put (GrVal_OpaqueNode  a      ) = putWord8 10 >> put a
  put _                           = panic "GrinCode.Binary.GrVal.put"		-- unused are unimplemented
  get = do t <- getWord8
           case t of
             0  -> return GrVal_Empty
             1  -> liftM  GrVal_Var          get
             2  -> liftM  GrVal_VarNode      get
             3  -> liftM2 GrVal_BasicNode    get get
             4  -> liftM  GrVal_EnumNode     get
             5  -> liftM  GrVal_PtrNode      get
             6  -> liftM  GrVal_LitInt       get
             7  -> liftM  GrVal_LitStr       get
             8  -> liftM  GrVal_Tag          get
             9  -> liftM2 GrVal_Node         get get
             10 -> liftM  GrVal_OpaqueNode   get
             _  -> panic "GrinCode.Binary.GrVal.get"		-- unused are unimplemented

instance Binary GrPatAlt where
  put (GrPatAlt_LitInt      a      ) = putWord8 0  >> put a
  put (GrPatAlt_Tag         a      ) = putWord8 1  >> put a
  put (GrPatAlt_Node        a b    ) = putWord8 2  >> put a >> put b
  put (GrPatAlt_Otherwise          ) = putWord8 3
  put _                              = panic "GrinCode.Binary.GrPatAlt.put"		-- unused are unimplemented
  get = do t <- getWord8
           case t of
             0  -> liftM  GrPatAlt_LitInt       get
             1  -> liftM  GrPatAlt_Tag          get
             2  -> liftM2 GrPatAlt_Node         get get
             3  -> return GrPatAlt_Otherwise
             _  -> panic "GrinCode.Binary.GrPatAlt.get"		-- unused are unimplemented

instance Binary GrVar where
  put (GrVar_Var           a      ) = putWord8 0  >> put a
  put (GrVar_KnownTag      a      ) = putWord8 1  >> put a
  put (GrVar_Ignore               ) = putWord8 2
  get = do t <- getWord8
           case t of
             0  -> liftM  GrVar_Var         get
             1  -> liftM  GrVar_KnownTag    get
             2  -> return GrVar_Ignore

instance Binary GrAltAnn where
  put (GrAltAnnNormal              ) = putWord8 0
  put (GrAltAnnIdent               ) = putWord8 1
  put (GrAltAnnCalling      a b    ) = putWord8 2  >> put a >> put b
  put (GrAltAnnReenter             ) = putWord8 3
  get = do t <- getWord8
           case t of
             0  -> return GrAltAnnNormal
             1  -> return GrAltAnnIdent
             2  -> liftM2 GrAltAnnCalling      get get
             3  -> return GrAltAnnReenter

instance Binary GrTagAnn where
  put (GrTagAnn a b) = put a >> put b
  get = liftM2 GrTagAnn get get


%%]

%%[(99 codegen grin) hs
instance Binary GrFFIAnnot where
  put (GrFFIAnnot_IsResEval a) = putWord8 0  >> put a 
  get = do t <- getWord8
           case t of
             0  -> liftM GrFFIAnnot_IsResEval get

%%]
