%%[0 hs
{
{-| 
  This module transforms a 'SilModule' to a Cil 'Assembly' via
  an AG transformation.
-}
}
%%]

%%[(8 codegen grin) hs module {%{EH}Silly.ToCil}
%%]
%%[(8 codegen grin) hs import({%{EH}Silly})
%%]
%%[(8 codegen grin) hs import({%{EH}Base.Common})
%%]
%%[(8 codegen grin) hs import({%{EH}Base.Opts})
%%]
%%[(8 codegen grin) import({Silly/AbsSyn})
%%]
%%[(8 codegen grin) hs import(Language.Cil)
%%]
%%[(8 codegen grin)
WRAPPER SilModule
%%]

%%[(8 codegen grin)
PRAGMA nocycle
%%]

%%[(8 codegen grin) hs export( silly2cil )
{-|
  Transform a 'SilModule' to a Cil 'Assembly'.
-} 
silly2cil :: EHCOpts -> SilModule -> Assembly
silly2cil opts silmod =
   let t = wrap_SilModule (sem_SilModule silmod) (Inh_SilModule)
   in cilCode_Syn_SilModule t
%%]

%%[(8 codegen grin)
ATTR SilModule
     [ | | cilCode : {Assembly} ]

ATTR Functions
     [ | | cilCode USE {:} {[]} : {[MethodDef]} ]

ATTR Function
     [ | | cilCode : {MethodDef} ]

ATTR AllNT
     [ | | copy : SELF ]


SEM SilModule
  | SilModule
                lhs.cilCode  = Assembly "EhcGenerated" [@loc.classDef]
                loc.classDef = Class AssemblyVisible "Haskell.Ehc.Generated" [] (@loc.main : @functions.cilCode)
                loc.main     = StaticMethod AssemblyVisible Void "AssemblyMain" []
                                 [ EntryPoint ]
                                 [ ldc_i4 42
                                 , call Static Void "mscorlib" "System.Console" "WriteLine" [Int32]
                                 , ret
                                 ]
  
SEM Function
  | Function
                lhs.cilCode = StaticMethod AssemblyVisible Void (show @name) @loc.params [] @loc.body
                loc.params  = map (\h -> Param Bool (show h)) @parameters
                loc.body    = map (comment . show) @body.copy

%%]

