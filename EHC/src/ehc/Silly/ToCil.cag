%%[0 hs
{
{-| 
  This module transforms a 'SilModule' to a Cil 'Assembly' via
  an AG transformation.
-}
}
%%]

%%[(8 codegen grin) hs module {%{EH}Silly.ToCil}
%%]
%%%%[(8 codegen grin) hs import({%{EH}LLVM})
%%%%]
%%[(8 codegen grin) hs import({%{EH}Silly})
%%]
%%[(8 codegen grin) hs import({%{EH}Base.Common})
%%]
%%[(8 codegen grin) hs import({%{EH}Base.Opts})
%%]
%%[(8 codegen grin) hs import({Debug.Trace})
%%]
%%%%[(8 codegen grin) hs import({%{EH}ConfigDefines})
%%%%]
%%[(8 codegen grin) import({Silly/AbsSyn})
%%]
%%%%[(8 codegen grin) hs import(qualified Data.Map)
%%%%]
%%%%[(8 codegen grin) hs import(qualified Data.List)
%%%%]
%%%%[(8 codegen grin) hs import(Data.Char)
%%%%]
%%[(8 codegen grin) hs import(Language.Cil)
%%]
%%[(8 codegen grin)
WRAPPER SilModule
%%]

%%[(8 codegen grin)
PRAGMA nocycle
%%]

%%[(8 codegen grin) hs export( silly2cil )
{-|
  Transform a 'SilModule' to a Cil 'Assembly'.
-} 
silly2cil :: EHCOpts -> SilModule -> Assembly
silly2cil opts silmod =
   let t = wrap_SilModule (sem_SilModule silmod) (Inh_SilModule)
   in trace "herex" $ trace (show silmod) $ cilCode_Syn_SilModule t
%%]

%%[(8 codegen grin)
ATTR SilModule
     [ | | cilCode : {Assembly} ]

ATTR Functions
     [ | | cilCode USE {:} {[]} : {[MethodDef]} ]

ATTR Function
     [ | | cilCode : {MethodDef} ] 

SEM SilModule
  | SilModule
                lhs.cilCode  = Assembly "EhcGenerated" [@loc.classDef]
                loc.classDef = Class AssemblyVisible "Haskell.Ehc.Generated" [] (@loc.main : @functions.cilCode)
                loc.main     = StaticMethod AssemblyVisible Void "AssemblyMain" []
                                 [ EntryPoint ]
                                 [ ldc_i4 42
                                 , call Static Void "mscorlib" "System.Console" "WriteLine" [Int32]
                                 , ret
                                 ]
  
SEM Function
  | Function
                lhs.cilCode = StaticMethod AssemblyVisible Void (show @name) [] [] []

%%]

