%%[0 hs
{
{-| 
  This module transforms a 'SilModule' to a Cil 'Assembly' via
  an AG transformation.
-}
}
%%]

%%[(8 codegen grin) hs module {%{EH}Silly.ToCil}
%%]
%%[(8 codegen grin) export (silly2cil, ctagDottedName, ctagTypeDef)
%%]
%%[(8 codegen grin) hs import({%{EH}Silly})
%%]
%%[(8 codegen grin) hs import({%{EH}Base.Common})
%%]
%%[(8 codegen grin) hs import({%{EH}Base.Opts})
%%]
%%[(8 codegen grin) import({Silly/AbsSyn})
%%]
%%[(8 codegen grin) hs import(Language.Cil)
%%]
%%[(8 codegen grin) hs import(Data.Char (toLower))
%%]
%%[(8 codegen grin)
WRAPPER SilModule
%%]

%%[(8 codegen grin)
PRAGMA nocycle
%%]

%%[(8 codegen grin) hs export( silly2cil, ctagTypeDef )
{-|
  Transform a 'SilModule' to a Cil 'Assembly'.
-} 
silly2cil :: EHCOpts -> SilModule -> Assembly
silly2cil opts silmod =
   let t = wrap_SilModule (sem_SilModule silmod) (Inh_SilModule)
   in cilCode_Syn_SilModule t

className :: String
className = "Haskell.Ehc.Generated"
%%]

%%[(8 codegen grin)
ATTR SilModule
     [ | | cilCode : {Assembly} ]

ATTR Functions
     [ | | cilCode USE {:} {[]} : {[MethodDef]} ]

ATTR Function
     [ | | cilCode : {MethodDef} ]

ATTR Statements
     [ | | cilCode USE {++} {[]} : {[MethodDecl]} ]

ATTR Statement
     [ | | cilCode : {[MethodDecl]} ]

ATTR Variable
     [ | | isLocal : {Bool}
           pos     : {Int} ]

ATTR Value
     [ | | cilCode : {[MethodDecl]}
           isCon   : {Bool} ]

ATTR Values
     [ | | cilCode USE {++} {[]} : {[MethodDecl]} ]

ATTR Constant
     [ | | intValue : {Int} ]

ATTR AllNT
     [ | | copy : SELF ]


SEM SilModule
  | SilModule
                lhs.cilCode  = Assembly [mscorlibRef] "EhcGenerated" (@loc.classDef : @loc.ctags)
                loc.classDef = classDef Public className [] (@loc.main : @functions.cilCode) []
                loc.main     = Method Static AssemblyVisible Void "AssemblyMain" []
                                 [ entryPoint
                                 , call StaticCallConv Object "" className "initialize" []
                                 , pop
                                 , call StaticCallConv Object "" className "fun_main" []
                                 , call StaticCallConv Void "mscorlib" "System.Console" "WriteLine" [Object]
                                 , ret
                                 ]
                loc.ctags    = map ctagTypeDef @ctagsMp
  
SEM Function
  | Function
                lhs.cilCode = Method Static AssemblyVisible Object (hsnShowAlphanumeric @name)
                                @loc.params (@loc.locals' ++ @loc.body)
                loc.params  = map (Param Object . show) @parameters
                loc.locals' = [ maxStack @loc.maxStk
                              , localsInit (map (Local Int32 . hsnShowAlphanumeric) @locals)
                              ]
                loc.maxStk  = 4 -- This should be calculated, but I don't know how, yet
                loc.body    = @body.cilCode
                                ++ (if (hsnShowAlphanumeric @name) == "fun_main"
                                   then [ ldloc 0 ]
                                   else [ ldc_i4 6 ])
                                ++ [ box Int32, ret ]

SEM Statement
  | * - Assignment lhs.cilCode = [ comment (show @copy) ]
  | Assignment     lhs.cilCode = if @dest.isLocal
                                 then @source.cilCode
                                        ++ [ stloc @dest.pos ]
                                 else [ comment (show @copy) ]

SEM Variable
  | * - Local   lhs.isLocal = False
  | Local       lhs.isLocal = True
                lhs.pos     = @pos

SEM Value
  | * - Con     lhs.isCon = False
  | * - Con Call lhs.cilCode = [ comment (show @copy) ]
  | Con         lhs.isCon = True
                lhs.cilCode = [ ldc_i4 @con.intValue ]
  | Call        lhs.cilCode = if @name == "primAddInt"
                              then @args.cilCode ++ [ add ]
                              else [ comment (show @copy) ]

SEM Constant
  | LiteralInt  lhs.intValue = @value

%%]

%%[(8 codegen grin) hs
ctagDottedName :: CTag -> DottedName
ctagDottedName (CTag tyNm taNm _ _ _) = hsnShowAlphanumeric tyNm ++ "/"
                                          ++ hsnShowAlphanumeric taNm

ctagTypeDef :: (HsName, [(HsName, CTag)]) -> TypeDef
ctagTypeDef (anm, hcx) = classDef Public tyNm [] [] (map subTys hcx)
  where
    tyNm = hsnShowAlphanumeric anm
    pNm ""     = ""
    pNm (c:cs) = toLower c : cs
    subTys (snm, (CTag _ _ t a ma)) =
      classDef Public subTyNm
        fields
        [ctor]
        []
      where
        subTyNm = hsnShowAlphanumeric snm 
        fields  = map (Field Static Public Object) (take a $ fieldNames ma)
        ctor    = Constructor Public (map (\(Field _ _ t n) -> Param t (pNm n)) fields)
                  $
                  [ ldarg 0
                  , call Instance Void "" tyNm ".ctor" []
                  ]
                  ++
                  concatMap (\((Field _ _ t n), x) -> [ldarg 0, ldarg x, stfld Object "" subTyNm n]) (zip fields [1..])
                  ++
                  [ ret ]
                 

fieldNames :: Int -> [DottedName]
fieldNames 1 = [ "Value" ]
fieldNames n | n < 11    = [ "First", "Second", "Third", "Fourth", "Fifth"
                           , "Sixth", "Seventh", "Eighth", "Ninth", "Tenth" ]
                           ++ drop 7 (fieldNames 99)
             | otherwise = map (\n -> "Field" ++ show n) [1..]
%%]

