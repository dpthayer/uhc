%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[(8 codegen grin) import({Silly/AbsSyn})
%%]

%%[(8 codegen grin).wrapper
WRAPPER SilModule
%%]

%%[(8 codegen grin) hs module {%{EH}Silly.Shortcut} export(shortcut)
%%]
%%[(8 codegen grin) hs import({%{EH}Silly})
%%]
%%[(8 codegen grin) hs import({%{EH}Base.Common})
%%]
%%[(8 codegen grin) hs import({%{EH}Base.Opts})
%%]
%%[(8 codegen grin) hs import(qualified Data.Map as Map)
%%]
%%[(8 codegen grin) hs import(qualified Data.Set as Set)
%%]

%%[(8 codegen grin) hs
shortcut :: EHCOpts -> SilModule -> SilModule
shortcut options input   
  = let t = wrap_SilModule (sem_SilModule input)
                           (Inh_SilModule {opts_Inh_SilModule = if ehcOptEmitLLVM options
                                                                then options{ ehcOptOwn = 0 }
                                                                else options
                                          } 
                           )
    in trf_Syn_SilModule t
%%]

%%[(8 codegen grin)

ATTR SilModule   [ opts : {EHCOpts} | | ]

-- Result of the AG transformation.
--
ATTR AllNT [ | | trf: SELF     ]

-- The non terminal self, for creating Sets containing it.
--
ATTR AllNT [ | | self: SELF ]


ATTR Variable [ multi : {Int} | | ]
ATTR Statement Statements Alternative Alternatives [  | defMap : {Map.Map Variable Int} | ]
ATTR Statement Statements Alternative Alternatives Variable Value Values [  | useMap : {Map.Map Variable Int} | ]
ATTR Statement Statements Alternative Alternatives [ allDefMap : {Map.Map Variable Int}  allUseMap : {Map.Map Variable Int} | | ]
ATTR Statement Statements Alternative Alternatives [ | env : {Map.Map Variable Value} | ]
ATTR Value Values [ env : {Map.Map Variable Value} | | ]

ATTR Value          [ | | isntCall : {Bool} ]

{-
  The Shortcut transformation tries to inline variables where possible.
  One assumption it makes, is that the tree is SSA, except for variables
  used in cases.
  But this does not hold for the global variable RP, which is clobbered
  after each function call.

  For example: we have the silly code
  x := RP[1]
  CALL fib( a )
  y := RP[1]
  CALL fib( b )
  z := primAddInt( x, y )

  Then Shortcut will optimize it to
  CALL fib( a )
  CALL fib( b )
  z := primAddInt( RP[1], RP[1] )

  which is obviously not correct.

  Not inlining RP is possible, but a waste. So we use the following strategy:
    * Collect all variables that are an alias of an RP[x]
    * When we encounter a call, we invalidate all variables in the previous
      mentioned Set
    * If we find an Variable that that refers to an variable in the invalidated
      set, we know that the RP[x] variable is used after a new Call
    * The Set with Variables that are invalid uses of RP[x] variables is used
      to test if an variable can be inline. If it is in the Set, it cannot.
-}

-- Attribute in which we collect all variables that are an alias of
-- RP[x] variables.
ATTR Statement Statements 
     Alternative Alternatives [ | rpAliases : {Set.Set Variable} | ]

-- Set with invalidated variables.
ATTR Statement Statements 
     Alternative Alternatives [ | invalRPs : {Set.Set Variable}  | ]
  
ATTR Value Values Variable    [ invalRPs : {Set.Set Variable}  | | ]

-- Set of variables which are used after being invalidated
ATTR Statement Statements
     Alternative Alternatives
     Value Values Variable    [ | | invalUse USE {`Set.union`} {Set.empty} : {Set.Set Variable} ]

-- Set of variable that may not be inline in the function because they
-- are used after the RP[x] value is clobbered.
ATTR Statement Statements
     Alternative Alternatives
     Value Values Variable    [ nonInlineableVars : {Set.Set Variable} | | ]

-- Initialize the attributes mentioned above
SEM Function     
  | Function     body.rpAliases = Set.empty
                 body.invalRPs  = Set.empty
                 body.nonInlineableVars
                                = @body.invalUse


SEM Statement
  -- If an assignment of the form x := RP[x] is encountered
  -- add x to the rpAliases set
  | Assignment   lhs.rpAliases  = if isRPValue @source.self
                                  then Set.insert @dest.self @lhs.rpAliases
                                  else @lhs.rpAliases
  -- If an assignment of the form x := y := RP[x] is encountered
  -- add x to the rpAliases set.
  -- We assume that y is not of the form RP[x]
  | Assignment2  lhs.rpAliases  = if isRPValue @source.self
                                  then Set.insert @dest2.self 
                                                 (Set.insert @dest1.self @lhs.rpAliases)
                                  else @lhs.rpAliases
  | Call         lhs.rpAliases  = Set.empty
                 lhs.invalRPs   = Set.union @lhs.rpAliases @lhs.invalRPs

SEM Variable
  -- If the Variable is part of the set @lhs.invalRPs, then we find a
  -- invalid use of the variable here.
  | Unembedded   lhs.invalUse   = let copy = @loc.self 
                                   in if Set.member copy @lhs.invalRPs
                                      then Set.singleton copy 
                                      else Set.empty

-- Fix to resolve the AG scheduling error between useMap and invalRP
SEM Alternatives
  | Cons         lhs.useMap < lhs.invalRPs

SEM Function
  | Function  body.useMap    =  @loc.startMap
              body.defMap    =  @loc.startMap   
              body.env       =  Map.empty
              body.allUseMap =  @body.useMap
              body.allDefMap =  @body.defMap
              loc.startMap   =  Map.fromList  [ (Variable_Unembedded nm, 0) | nm <- @locals ]

-- the "multi" attribute is a bit of a hack:
-- it makes uses in a Subs context count as 2, thus making it non-virtualizable for non-simple values

SEM Value
  | Var         var.multi = 1
  | Offset      var.multi = 2

SEM Variable
  | Subs        array.multi = 2

SEM Statement
  | Assignment  dest.multi = 1
  | Assignment2 dest1.multi = 1
                dest2.multi = 1




SEM Statement
  | Assignment  lhs.defMap  =  Map.adjust (+1) @dest.self @lhs.defMap
  | Assignment2 lhs.defMap  =  Map.adjust (+1) @dest1.self (Map.adjust (+1) @dest2.self @lhs.defMap)

SEM Variable
  | Unembedded  lhs.useMap  =  Map.adjust (+ @lhs.multi) (@loc.self) @lhs.useMap

SEM Statement
  | Assignment  (lhs.trf, lhs.env)  =  if @source.isntCall
                                          && Set.notMember @dest.self @lhs.nonInlineableVars
                                          && virtualizable (Map.lookup @dest.self @lhs.allDefMap)
                                                           (Map.lookup @dest.self @lhs.allUseMap)
                                                           (isSimpleValue @source.trf)
                                        then ( Statement_Comment [" (inlined)" ++ show @dest.self ++ " = " ++ show @source.trf ]
                                             , Map.insert @dest.self @source.trf @lhs.env 
                                             )
                                        else ( Statement_Assignment @dest.self @source.trf
                                             , @lhs.env
                                             )

                                             
SEM Value
  | Var          lhs.trf  =  Map.findWithDefault (@loc.self) @var.self @lhs.env
  | Call         lhs.isntCall  =  False
  | * - Call     lhs.isntCall  =  True

%%]

%%[(8 codegen grin) hs
isRP :: Variable -> Bool
isRP (Variable_RP)          = True
isRP (Variable_Subs var _)  = isRP var
isRP _                      = False 

isRPValue :: Value -> Bool
isRPValue (Value_Var var)   = isRP var
isRPValue _                 = False

isSimpleVariable :: Variable -> Bool
isSimpleVariable (Variable_Subs Variable_SP _) = True
isSimpleVariable (Variable_Subs _           _) = False
isSimpleVariable _                             = True

isSimpleValue :: Value -> Bool
isSimpleValue (Value_Alloc _ _) = False
isSimpleValue (Value_Offset _ _)= False
isSimpleValue (Value_Var v)     = isSimpleVariable v
isSimpleValue _                 = True

virtualizable (Just def) (Just use) simpleVal = def==1 && ( use==2 || simpleVal )
virtualizable _ _ _ = False
%%]
