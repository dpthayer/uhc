%%[0 hs
{
{-| 
  This module transforms a 'SilModule' to a 'LLVMModule' via an AG
  transformation. TODO more about the transformation later.
-}
}
%%]
%%[(8 codegen grin) hs module {%{EH}Silly.ToLLVM}
%%]
%%[(8 codegen grin) hs import({%{EH}LLVM})
%%]
%%[(8 codegen grin) hs import({%{EH}Silly})
%%]
%%[(8 codegen grin) hs import({%{EH}Base.Common})
%%]
%%[(8 codegen grin) hs import({%{EH}Opts})
%%]
%%[(8 codegen grin) hs import({%{EH}ConfigDefines})
%%]
%%[(8 codegen grin) import({Silly/AbsSyn})
%%]
%%[(8 codegen grin) hs import(qualified Data.Map)
%%]
%%[(8 codegen grin) hs import(qualified Data.Set)
%%]
%%[(8 codegen grin) hs import(qualified Data.List)
%%]
%%[(8 codegen grin) hs import(Data.Char)
%%]
%%[(8 codegen grin) hs import(Foreign.Marshal.Utils)
%%]
%%[(8 codegen grin)
WRAPPER SilModule
%%]

%%[(8 codegen grin)
PRAGMA nocycle
%%]

%%[(8 codegen grin) hs export( silly2llvm )
{-|
  Transform a 'SilModule' to a 'LLVMModule'. In this module, we use cells which
  have the size @sizeof(intptr_t)@, so that we can store both integers and
  pointers in them and cast freely.
-} 
silly2llvm :: EHCOpts -> SilModule -> LLVMModule
silly2llvm opts silmod = 
  let -- LLVMType of integers
      intType    = if sizeofPointer == 8 
                   then i64
                   else i32
      -- LLVMType of pointers to integers.
      ptrType    = pLift intType
      -- Global variables are always pointers to pointers to integers.
      gblType    = pLift ptrType
      t = wrap_SilModule (sem_SilModule silmod)
                         (Inh_SilModule { intType_Inh_SilModule = intType 
                                        , pointerType_Inh_SilModule = ptrType
                                        , globalType_Inh_SilModule = gblType
                                        , gUniq_Inh_SilModule = uidStart
                                        } 
                         )
   in llvmCode_Syn_SilModule t
%%]

%%[(8 codegen grin)
ATTR SilModule
     [ | | llvmCode : {LLVMModule} ]

ATTR Functions
     [ | | llvmCode : {LLVMFunctions} ]

ATTR Function
     [ | | llvmCode : {LLVMFunction} ] 
   
ATTR Statements Statement Alternative
     Values Value Variable
     [ | | llvmCode : {LLVMStatements} ]
  
ATTR Alternatives
     [ | | llvmCode : {[LLVMStatements]} ]  
     
ATTR Values
     [ | | llvmVar : {[LLVMVar]} ]

ATTR Value Variable Constant
     [ | | llvmVar : {LLVMVar} ]   
 
ATTR Alternatives
     [ | | jumpTargets : {[(LLVMVar,LLVMVar)]} ]
     
ATTR Alternative
     [ | | jumpTarget : {(LLVMVar,LLVMVar)} ]  

ATTR Value
     [ | | gcManaged : {SillyAllocManageType} ]

     
SEM SilModule
  | SilModule   lhs.llvmCode = LLVMModule_LLVMModule @loc.comment
                                                     @loc.namedTys
                                                     @loc.constants
                                                     @loc.globals 
                                                     ( stdlibPrintfFuncDecl 
                                                     : primPatternMatchFailureFuncDecl 
                                                     : primPatternMatchFailureDebugFuncDecl @lhs.intType
                                                     : gcRootFuncDecl

                                                     -- ehc gc
                                                     : gcEhcAllocFuncDecl       @lhs.intType
                                                     : gcEhcAllocResFuncDecl    @lhs.intType
                                                     : gcEhcGCFuncDecl          @lhs.intType
                                                     : gcEhcRegRootFuncDecl     @lhs.intType
                                                     : gcEhcRegRootsFuncDecl    @lhs.intType
                                                     : gcEhcDeallocResFuncDecl  @lhs.intType

                                                     -- runtime
                                                     : rtsInitFuncDecl
                                                     : rtsExitFuncDecl

                                                     : @functions.externFuncs 
                                                     )
                                                     ( @loc.main : @functions.llvmCode )

                loc.comment  = map (\ci -> constantInfoName ci ++ "(" ++ show (constantInfoSeqNr ci) ++ ") NodeSize: " ++ show (constantInfoNodeSize ci) 
                                                                                                      ++ " PayloadSize: " ++ show (constantInfoPayloadSize ci)
                                                                                                      ++ " HasPointers: " ++ show (constantInfoHasPointers ci)) @constants  
                loc.(globalResStr,resConst) = 
                                string2LLVMString @lhs.gUniq $
                                  if sizeofPointer == 8
                                  then "%lld\n"
                                  else "%d\n"
                loc.constants = (@loc.globalResStr,@loc.resConst) 
                                : mkGCFieldDescriptors @lhs.intType @constants 
                                : mkGCGlobalsDescr @variables @lhs.intType
                                : (GlobalVar "_llvm_globals_descriptor_count" @lhs.intType , Constant (length @variables) @lhs.intType)
                                : @functions.constants 

                loc.namedTys = [NamedTy "FDESCR" (Struct [@lhs.intType, @lhs.intType, i8])]
                loc.globals  = GlobalVar "RP" (@lhs.globalType) 
                                : mkVarList GlobalVar @variables @lhs.globalType                                                                          
                loc.main     = LLVMFunction_Func mainFuncDecl ExternallyVisible

                                 [ LLVMStatement_Call rtsInitFuncDecl StdCall []
                                 --, LLVMStatement_Assignment (LocalVar "cast.glob" (pLift @lhs.intType))
                                 --    (LLVMExpression_GetElemPtr (GlobalVar "_llvm_globals_descriptor" (pLift (Array (length @variables) (pLift $ pLift @lhs.intType)))) [0, 0 ])  


                                 -- , LLVMStatement_Call (gcEhcRegRootsFuncDecl @lhs.intType) StdCall [ (LocalVar "cast.glob" (pLift $ pLift $ pLift @lhs.intType))
                                 --                                                                  , (Constant (length @variables) @lhs.intType)]
                                 , LLVMStatement_Assignment (LocalVar "rpArr" @lhs.pointerType)
                                     (LLVMExpression_Call (gcEhcAllocResFuncDecl @lhs.intType) StdCall [Constant (1 + @functions.maxRPIndex) @lhs.intType] )
                                     -- (mkMalloc NotManaged @lhs.intType (1 + @functions.maxRPIndex))
                            

                                 , LLVMStatement_Assignment (LocalVar "rp.t" @lhs.pointerType)
                                     (LLVMExpression_GetElemPtr (LocalVar "rpArr" @lhs.pointerType) [1] )
                                 , LLVMStatement_Store (Constant (1 + @functions.maxRPIndex) @lhs.intType) (LocalVar "rp.t" @lhs.pointerType)

                                 -- , LLVMStatement_Call (gcEhcRegRootFuncDecl @lhs.intType) StdCall [LocalVar "rpArr" @lhs.pointerType]
                                 , LLVMStatement_Store (LocalVar "rpArr" @lhs.pointerType) (GlobalVar "RP" @lhs.globalType)
                                 , LLVMStatement_Call initializeFuncDecl StdCall []
%%[[8
                                 , LLVMStatement_Call fun_mainFuncDecl StdCall []
                                 , LLVMStatement_Assignment (LocalVar "rp.1" @lhs.pointerType)
                                     (LLVMExpression_GetElemPtr (LocalVar "rpArr" @lhs.pointerType) [1] )
                                 , LLVMStatement_Assignment (LocalVar "rp.1.val" @lhs.intType)
                                     (LLVMExpression_Load (LocalVar "rp.1" @lhs.pointerType))
                                , LLVMStatement_Assignment (LocalVar "cast.str.res" (pLift i8))
                                     (LLVMExpression_GetElemPtr @loc.globalResStr [0,0])  
                                 , LLVMStatement_Call stdlibPrintfFuncDecl TailCall
                                     [ LocalVar "cast.str.res" (pLift i8), LocalVar "rp.1.val" @lhs.intType ]
%%][99
                                 , LLVMStatement_Call fun_mainFullProgFuncDecl StdCall []
%%]]                                 
                                 , LLVMStatement_Call rtsExitFuncDecl StdCall []
                                 , LLVMStatement_Return (Constant 0 i32)  
                                 ]                    
                                 
SEM Functions
  | Cons        lhs.llvmCode = @hd.llvmCode : @tl.llvmCode
  | Nil         lhs.llvmCode = []
  
SEM Function
  | Function    lhs.llvmCode = let locals = map (\nm -> LLVMStatement_Assignment (LocalVar (hs2str nm) (pLift @lhs.pointerType) )
                                                         (LLVMExpression_Alloca @lhs.pointerType 1) ) (map fst @locals)
                                   params = concatMap (\nm -> (LLVMStatement_Assignment (LocalVar ("par_" ++ (hs2str nm)) (pLift @lhs.pointerType) )
                                                         (LLVMExpression_Alloca @lhs.pointerType 1)) 
                                                         : (LLVMStatement_Assignment (LocalVar ("cast1_par_" ++ (hs2str nm)) (pLift @lhs.pointerType)) 
                                                                $ LLVMExpression_Cast (LocalVar (hs2str nm) (@lhs.intType)) (@lhs.pointerType)) 
                                                         : (LLVMStatement_Store (LocalVar ("cast1_par_" ++ (hs2str nm)) @lhs.pointerType) (LocalVar ("par_" ++ (hs2str nm)) (pLift @lhs.pointerType)))
                                                         : (LLVMStatement_Assignment (LocalVar ("cast2_par_" ++ (hs2str nm)) (pLift @lhs.pointerType)) 
                                                                $ LLVMExpression_Cast (LocalVar ("par_" ++ (hs2str nm)) (pLift @lhs.pointerType)) (pLift $ pLift i8)) 
                                                         : (LLVMStatement_Call gcRootFuncDecl StdCall [ LocalVar ("cast2_par_" ++ (hs2str nm)) (pLift $ pLift i8)
                                                                                                     , (StrConstant "null" (pLift i8))
                                                                                                     ] ) 
                                                         : []
                                                 ) @parameters
                                in LLVMFunction_Func @loc.fnDecl Internal $ locals ++ params ++
                                   @body.llvmCode ++  
                                   -- [LLVMStatement_Call (gcEhcGCFuncDecl @lhs.intType) StdCall []] ++
                                   [LLVMStatement_Return $ LocalVar (error "ReturnNoVar") Void ]
 
SEM Statements
  | Cons        lhs.llvmCode = @hd.llvmCode ++ @tl.llvmCode
  | Nil         lhs.llvmCode = []
  
SEM Statement
  -- A Silly assign will translate to a store. We have the following steps
  --   * If the RHS is an expression, assign the RHS to a fresh var
  --   * Do the same for the LHS
  --   * check if the LHS is a pointertype, otherwise cast to pointer
  --   * check if the RHS type fits in the pointertype of the LHS, otherwise
  --     cast the LHS
  --   * Store
  | Assignment  lhs.llvmCode = @source.llvmCode ++ @dest.llvmCode ++ @loc.lhsptrCode ++ @loc.fitsCode ++
                               [LLVMStatement_Store @loc.fitsVar @loc.lhsptrVar] ++ @loc.gcrootCode 
 
                loc.(uniqNr1,lhsptrVar,lhsptrCode) =
                               cast2ptr @dest.gUniq @dest.llvmVar @lhs.pointerType
                loc.(uniqNr2,fitsVar,fitsCode) =
                               makeFitting @loc.uniqNr1 @source.llvmVar @loc.lhsptrVar   

                loc.(uniqNr3,gcfitsVar,gcfitsCode) = let  targetType   = pLift $ pLift i8
                                                          (nr', fresh) = newFresh @loc.uniqNr2 targetType 
                                                          nt           = LocalVar (getPlainName @loc.lhsptrVar) (getType @loc.lhsptrVar) in 
                                                                (nr', fresh, [LLVMStatement_Assignment fresh $ LLVMExpression_Cast nt targetType])
                loc.(updSet, gcrootCode) = 
                               case Data.Set.member (getPlainName @dest.llvmVar) @lhs.localPtrsSet of 
                                       True -> ( Data.Set.delete (getPlainName @dest.llvmVar) @lhs.localPtrsSet
                                                , @loc.gcfitsCode ++ 
                                                  [LLVMStatement_Call gcRootFuncDecl StdCall [ @loc.gcfitsVar
                                                                                             , (StrConstant "null" (pLift i8))
                                                                                             ] 
                                                  ])
                                       False -> (@lhs.localPtrsSet, [])
                lhs.localPtrsSet = @loc.updSet


  | Assignment2 lhs.llvmCode = @source.llvmCode ++ @dest.llvmCode ++ @loc.destptrCode ++ @loc.fits1Code ++
                               [ LLVMStatement_Store @loc.fits1Var @loc.destptrVar ] ++
                               @dest2.llvmCode ++ @loc.dest2ptrCode ++ @loc.fits2Code ++
                               [ LLVMStatement_Store @loc.fits2Var @loc.dest2ptrVar] 
                
                loc.(uniqNr1,destptrVar,destptrCode) =
                               cast2ptr @dest2.gUniq @dest.llvmVar @lhs.pointerType
                loc.(uniqNr2,dest2ptrVar,dest2ptrCode) =
                               cast2ptr @loc.uniqNr1 @dest2.llvmVar @lhs.pointerType                                        
                loc.(uniqNr3,fits1Var,fits1Code) =
                               makeFitting @loc.uniqNr2 @source.llvmVar @loc.destptrVar
                loc.(uniqNr4,fits2Var,fits2Code) =
                               makeFitting @loc.uniqNr3 @source.llvmVar @loc.dest2ptrVar  

  | Call        lhs.llvmCode = let fDecl = Data.Map.findWithDefault 
                                             (error $ "No such function: " ++ hs2str @name)
                                             (hs2str @name) @lhs.fnAvailDecls
                                in @args.llvmCode ++
                                   @loc.castCode ++
                                   [ LLVMStatement_Call fDecl (bool2calltype @tailJumps) @loc.castVars ]
 
                -- Some arguments can be pointers and need to be casted
                -- to inttypes 
                loc.(uniqNr1,castVars,castCode) =  
                               foldr (\x xs -> let (nr,val,stmt) = cast2int (getUID xs) x @lhs.intType
                                                in ( nr, val : getVars xs, stmt ++ (getCode xs) ) ) 
                                     (@args.gUniq,[],[]) @args.llvmVar

                loc.(uniqNr2,fresh) = newFresh @loc.uniqNr1 (pLift i8)
               
  | Comment     lhs.llvmCode = [LLVMStatement_Comment @comment]

  | IfThenElse  lhs.llvmCode = @condition.llvmCode ++
                               [ LLVMStatement_BranchIf @condition.llvmVar @loc.thenLabel @loc.elseLabel
                               , LLVMStatement_Label @loc.thenLabel ] ++                               
                               @thenpart.llvmCode ++
                               [ LLVMStatement_Branch @loc.resumeLabel
                               , LLVMStatement_Label @loc.elseLabel ] ++
                               @elsepart.llvmCode ++
                               [ LLVMStatement_Branch @loc.resumeLabel
                               , LLVMStatement_Label @loc.resumeLabel]                        
                                                                    
                loc.(uniqNr1, thenLabel) =
                               newFresh @condition.gUniq Label
                loc.(uniqNr2, elseLabel) =
                               newFresh @thenpart.gUniq Label
                loc.(uniqNr3, resumeLabel) =
                               newFresh @elsepart.gUniq Label              

  | Switch      lhs.llvmCode = @scrutinee.llvmCode ++
                               [ LLVMStatement_Switch @scrutinee.llvmVar @loc.defaultLabel @body.jumpTargets ] ++ 
                               @loc.altLLVMStatements ++ @loc.defaultBody ++ 
                               [ LLVMStatement_Branch @loc.resumeLabel] ++
                               [ LLVMStatement_Label  @loc.resumeLabel ]
                    
                loc.altLLVMStatements = concatMap ( ++ [LLVMStatement_Branch @loc.resumeLabel] ) @body.llvmCode  
                
                loc.(uniqNr1, defaultLabel, defaultBody) =
                               defaultCase @body.gUniq @scrutinee.llvmVar
                loc.(uniqNr2, resumeLabel) =
                               newFresh @loc.uniqNr1 Label

  | Label       lhs.llvmCode = error $ "Generated label instructions not"
                                     ++ " allowed in LLVM. Is -g set to 0?"
  
  | Return      lhs.llvmCode = [LLVMStatement_Return $ LocalVar (error "ReturnNoVar") Void ]  
                                    
  | * - Assignment Assignment2 Call Comment Jump Label Return Switch IfThenElse
                lhs.llvmCode = error "Unimplemented Statement"

SEM Alternatives
  | Cons        lhs.llvmCode    = @hd.llvmCode : @tl.llvmCode
                lhs.jumpTargets = @hd.jumpTarget : @tl.jumpTargets              
  | Nil         lhs.llvmCode    = []
                lhs.jumpTargets = []
                
SEM Alternative
  | Alternative lhs.llvmCode = LLVMStatement_Label @loc.label : @body.llvmCode
                lhs.jumpTarget = (@when.llvmVar, @loc.label)
                                        
                (loc.uniqNr1, loc.label) = 
                               newFresh @lhs.gUniq Label

SEM Values
  | Cons        lhs.llvmVar  = @hd.llvmVar : @tl.llvmVar
                lhs.llvmCode = @hd.llvmCode ++ @tl.llvmCode
  | Nil         lhs.llvmVar  = [] 
                lhs.llvmCode = []       

-- gcManaged spul

SEM Value
    | Alloc     lhs.gcManaged = @gcManaged
    | * - Alloc lhs.gcManaged = NotManaged

       
SEM Value
  {-|
    Assign a Malloc to a fresh variable
  -}
  | Alloc       lhs.llvmVar  = @loc.llvmVar
                lhs.llvmCode = @loc.llvmCode ++ @loc.regRootCode
                loc.(gUniq,llvmVar,llvmCode) =
                               assign2var @lhs.gUniq (mkMalloc @gcManaged @lhs.intType @size, @lhs.pointerType)
                loc.regRootCode = case @gcManaged of 
                                    GCManaged  -> []
                                    NotManaged -> [] -- [LLVMStatement_Call (gcEhcRegRootFuncDecl @lhs.intType) StdCall [@loc.llvmVar]]


  {-|
    For a call we need to do the following steps:
      * Cast the parameter values to integers
      * Assign the result of the call to a fresh variable
  -}                             
  | Call        lhs.llvmVar  = @loc.llvmVar
                lhs.llvmCode = @args.llvmCode ++ @loc.castCode ++ @loc.llvmCode
 
                loc.fnDecl  = LLVMFunctionDecl_LLVMFunctionDecl @name @lhs.intType FixedArgs @loc.formalParams Nothing
                
                -- Some arguments can be pointers and need to be casted
                -- to inttypes 
                loc.(uniqNr1,castVars,castCode) =  
                               foldr (\x xs -> let (nr,val,stmt) = cast2int (getUID xs) x @lhs.intType
                                                in (nr, val : getVars xs, stmt ++ (getCode xs)) ) 
                                     (@args.gUniq,[],[]) @args.llvmVar 

                -- Assign the call expression to a fresh variable
                --                     
                loc.(uniqNr2,llvmVar,llvmCode) =
                               assign2var @loc.uniqNr1 (LLVMExpression_Call @loc.fnDecl StdCall @loc.castVars, @lhs.intType)
                                                   
                -- We generate the formal parameters by generating new names
                -- for the actual ones
                loc.(uniqNr3,formalParams) =  
                               foldr (\x xs -> let (nr,fresh) = newFresh (fst xs) (getType x)
                                                in (nr, fresh : (snd xs)) ) 
                                     (@loc.uniqNr2,[]) @loc.castVars                                

  {-|
    A Con just wraps a constant. No actions needed.
  -}
  | Con         lhs.llvmVar  = @con.llvmVar
                lhs.llvmCode = []
  
  {-|
    The llvmVar inherited from the @var child needs to be loaded to an integer value
  -}                                                                               
  | Var         lhs.llvmVar  = @loc.llvmCastVar
                lhs.llvmCode = @var.llvmCode ++ @loc.llvmCode ++ @loc.llvmCastCode
                
                loc.(uniqNr1,llvmVar,llvmCode) =                
                               if getType @var.llvmVar /= @lhs.intType
                               then load @var.gUniq @var.llvmVar
                               else (@var.gUniq,@var.llvmVar,[])  
                loc.(uniqNr2,llvmCastVar,llvmCastCode) =
                               cast2int @loc.uniqNr1 @loc.llvmVar @lhs.intType

  {-|
    Compare a value to a constant. The value is cast to an integer
  -}
  | CompareGT   lhs.llvmVar  = @loc.cmpRes
                lhs.llvmCode = @val.llvmCode ++ @loc.lhsToIntCode ++ @loc.cmpCode
                
                loc.(uniqNr1, lhsIntVar, lhsToIntCode) =
                              cast2int @val.gUniq @val.llvmVar @lhs.intType
                loc.(uniqNr2, cmpRes, cmpCode) =
                              assign2var @loc.uniqNr1 ( LLVMExpression_Compare CMPSGT @loc.lhsIntVar @con.llvmVar, i1)
                                                            
  | Offset      lhs.llvmVar  = @loc.offsetVar
                lhs.llvmCode = @var.llvmCode ++ @loc.loadCode ++
                               @loc.castCode ++ @loc.offsetCode

                loc.(uniqNr1,loadVar,loadCode) =
                              load @lhs.gUniq @var.llvmVar
                loc.(uniqNr2,castVar,castCode) =
                              cast2ptr @loc.uniqNr1 @loc.loadVar @lhs.pointerType
                loc.(uniqNr3,offsetVar,offsetCode) =
                              assign2var @loc.uniqNr2 ( LLVMExpression_GetElemPtr @loc.castVar [@off], getType @loc.castVar )

  | * - Alloc Call Con Var CompareGT Offset
                lhs.llvmVar  = error $ "No Label or Cast Value expected"
                lhs.llvmCode = error $ "No Label or Cast Value expected"       
 
SEM Variable
  | Global      lhs.llvmVar  = GlobalVar (hs2str @name) @lhs.globalType
                lhs.llvmCode = []
                
  | Local       lhs.llvmVar  = LocalVar (hs2str @name) (pLift @lhs.pointerType)
                lhs.llvmCode = []               
  
  | Param       lhs.llvmVar  = @loc.intVar -- LocalVar ("load_" ++ (hs2str @name)) @lhs.intType -- LocalVar (hs2str @name) @lhs.intType
                lhs.llvmCode = @loc.loadCode ++ @loc.toIntCode -- [LLVMStatement_Assignment (LocalVar ("load_" ++ (hs2str @name)) @lhs.pointerType)
                                     -- (LLVMExpression_Load (LocalVar ("par_" ++ (hs2str @name)) (pLift @lhs.pointerType)))]                                             
                loc.(uniqNr1,loadVar,loadCode) =
                               load @lhs.gUniq (LocalVar ("par_" ++ (hs2str @name)) (pLift @lhs.pointerType))

                loc.(uniqNr2, intVar, toIntCode) =
                               cast2int @loc.uniqNr1 @loc.loadVar @lhs.intType

                                               
  | RP          lhs.llvmVar  = GlobalVar "RP" @lhs.globalType 
                lhs.llvmCode = []
                
  | Subs        lhs.llvmVar  = @loc.offsetVar
                lhs.llvmCode = @array.llvmCode ++ @loc.loadCode ++ @loc.ptrCode ++ @loc.offsetCode 
                
                -- Tricky: The variable could be a global indirection or a indirection
                -- resulting from an alloca. If that is the case, then we need to
                -- resolve this redirection by loading.
                loc.(uniqNr1,loadVar,loadCode) =
                               if isGlobal @array.llvmVar || @array.isLocal
                               then load @array.gUniq @array.llvmVar
                               else (@array.gUniq, @array.llvmVar, []) 
                loc.(uniqNr2,ptrVar,ptrCode) =
                               cast2ptr @loc.uniqNr1 @loc.loadVar @lhs.pointerType  
                loc.(uniqNr3,offsetVar,offsetCode) =
                               assign2var @loc.uniqNr2 (LLVMExpression_GetElemPtr @loc.ptrVar [@index], getType @loc.ptrVar)
 
   | * - Global Local Param RP Subs
                lhs.llvmVar  = error "Variable contains an impossible construct"
                lhs.llvmCode = error "Variable contains an impossible construct"                                                                                                           
                
SEM Constant
  | LiteralInt  lhs.llvmVar  = Constant @value @lhs.intType
  | LiteralStr  lhs.llvmVar  = @loc.globStrVar
  | Alias       lhs.llvmVar  = let value = Data.Map.findWithDefault
                                             (error ("Alias \'" ++ @name ++ "\' not in constantMap"))
                                             @name @lhs.constantMap 
                                in Constant value @lhs.intType                                                                 
%%]

%%[(8 codegen grin)
--------------------------------------------------------------------------------
-- Thread a UID through the program in a way that the numbering follow
-- the flow of the code.
--------------------------------------------------------------------------------
ATTR AllNT     [ | gUniq: UID | ]      
 
SEM SilModule
  -- The first UID is used by the string constant for the integer result
  -- (variant 8).
  | SilModule   functions.gUniq = uidNext @lhs.gUniq 

SEM Statement
  -- Set the order source -> dest -> local explicit, because this order is
  -- different from the data type definition.
  | Assignment  source.gUniq = @lhs.gUniq
                dest  .gUniq = @source.gUniq
                lhs   .gUniq = @loc.uniqNr3

  -- Set the order source -> dest -> dest2 explicit, because it is differs
  -- from the data type definition.
  | Assignment2 source.gUniq = @lhs.gUniq
                dest  .gUniq = @source.gUniq
                dest2 .gUniq = @dest.gUniq
                lhs   .gUniq = @loc.uniqNr4

  -- The passing down to the args is performed by the copy rules.
  | Call        lhs .gUniq   = @loc.uniqNr2

  -- Although the order condition -> thenpart -> elsepart is equal to the order
  -- set by the datatype, we have to intersperse the code with labels.
  | IfThenElse  condition.gUniq = @lhs.gUniq
                thenpart .gUniq = @loc.uniqNr1
                elsepart .gUniq = @loc.uniqNr2
                lhs      .gUniq = @loc.uniqNr3
                       
  -- The passing from scrutinee to the body is handled by the data type order.
  | Switch      lhs.      gUniq = @loc.uniqNr2

SEM Alternative
  -- The order is local (for the label) -> body
  | Alternative body.gUniq   = @loc.uniqNr1

SEM Value
  -- Passing to args via copy rule
  | Call        lhs .gUniq   = @loc.uniqNr3
  -- Passing to var via copy rule                         
  | Var         lhs.gUniq    = @loc.uniqNr2
  -- Passing to val via copy rule.
  | CompareGT   lhs.gUniq    = @loc.uniqNr2
  | Offset      lhs.gUniq    = @loc.uniqNr3
              
SEM Variable
  -- Passing to array via copy rule
  | Param       lhs  .gUniq  = @loc.uniqNr2
  | Subs        lhs  .gUniq  = @loc.uniqNr3

                 
%%]

%%[(8 codegen grin)
--------------------------------------------------------------------------------
-- Passing up the signatures of the functions declared and the functions 
-- defined in this module. If we have the set of these functions, we can 
-- query them for Calls and we can warn if undeclared/undefined functions are
-- called
--------------------------------------------------------------------------------
ATTR Functions Function
     Statements Statement
     Alternatives Alternative
     Values Value
     Variable
     [ fnAvailDecls : {Data.Map.Map String LLVMFunctionDecl} | | ]

ATTR Functions
     [ | | fnDecls : {[(String,LLVMFunctionDecl)]} ]

ATTR Function
     [ | | fnDecl : {(String,LLVMFunctionDecl)} ]

SEM SilModule
  | SilModule   functions.fnAvailDecls
                           = Data.Map.fromList @functions.fnDecls

SEM Functions
  | Cons        lhs.fnDecls
                           = @hd.fnDecl : @tl.fnDecls
  | Nil         lhs.fnDecls
                           = []

SEM Function
  | Function    lhs.fnDecl = (hs2str @name, @loc.fnDecl)
                loc.fnDecl : {LLVMFunctionDecl}
                loc.fnDecl = let prms = mkVarList LocalVar @parameters 
                                                           @lhs.intType
                              in LLVMFunctionDecl_LLVMFunctionDecl (hs2str @name) Void FixedArgs prms (Just "shadow-stack")
%%]
  
%%[(8 codegen grin)
--------------------------------------------------------------------------------
-- Passing up the string constants used in functions 
--------------------------------------------------------------------------------
ATTR Functions Function
     Statements Statement
     Alternatives Alternative
     Values Value
     Variable
     Constant
     [ | | constants USE {++} {[]}: {[(LLVMVar,LLVMVar)]} ]

SEM Constant
  | LiteralStr  lhs.constants = [ ( @loc.globStrVar , @loc.strConst) ]
                loc.(globStrVar,strConst) =
                                string2LLVMString @lhs.gUniq @value
  | * - LiteralStr
                lhs.constants = [ ]
%%]

%%[(8 codegen grin)
--------------------------------------------------------------------------------
-- Passing down platform depended types.
--------------------------------------------------------------------------------

ATTR AllNT
     [ intType, pointerType, globalType : {LLVMType} | | ]
%%]

%%[(8 codegen grin)
--------------------------------------------------------------------------------
-- We pass down a map, containing the alias name and the 
-- corresponding Int value of constructor tags
--------------------------------------------------------------------------------
ATTR Functions Function 
     Statements Statement
     Alternatives Alternative
     Values Value
     Variable
     Constant
     [ constantMap : {Data.Map.Map String Int} | | ]


SEM SilModule
  | SilModule   functions.constantMap = Data.Map.fromList (map (\ci->(constantInfoName ci, constantInfoSeqNr ci)) @constants)
%%]

%%[(8 codegen grin)
--------------------------------------------------------------------------------
-- Pass type mapping of locals to statements
--------------------------------------------------------------------------------
ATTR Function Statements Statement Alternatives Alternative
     [ | localPtrsSet : {Data.Set.Set String } | ]
                          
SEM Function
  | Function    body.localPtrsSet = Data.Set.fromList $ localsHs2str $ filterPtrs @locals




%%]


%%[(8 codegen grin)
--------------------------------------------------------------------------------
-- TODO: Bubble up if a variable is a Local variable. This is needed, because
-- those are implemented with an address on the stack.
--------------------------------------------------------------------------------
ATTR Variable
     [ | | isLocal : {Bool} ]
                          
SEM Variable
  | Local       lhs.isLocal  = True
  | * - Local
                lhs.isLocal  = False                           
%%]

%%[(8 codegen grin)
--------------------------------------------------------------------------------
-- Pass the max size of the closure that is stored in RP up
-- so that we can initialize it at the start up.
--------------------------------------------------------------------------------
ATTR Functions Function 
     Statements Statement
     Alternatives Alternative
     Values Value
     Variable
     [ | | maxRPIndex USE {`max`} {0}: {Int} ]

SEM Variable
  | Subs        lhs.maxRPIndex =
                             if @array.isRP then @index else 0  

ATTR Variable
     [ | | isRP : {Bool} ]
                          
SEM Variable
  | RP          lhs.isRP   = True
  | * - RP
                lhs.isRP   = False                           
%%]

%%[(8 codegen grin)
--------------------------------------------------------------------------------
-- Pass function declarations that are defined extern
--------------------------------------------------------------------------------
ATTR Functions Function 
     Statements Statement
     Alternatives Alternative
     Values Value
     Variable
     [ | | externFuncs USE {++} {[]}: {[LLVMFunctionDecl]} ]
                       
SEM Value
  | Call        lhs.externFuncs = [@loc.fnDecl]                  
%%]

%%[(8 codegen grin)
{
-------------------------------------------------------------------------------
-- Functions for extraction of values from the (UID,[LLVMVar],LLVMStatements) 
-- tuples as used in 'LLVMExpression_Call' and 'LLVMStatement_Call' argument 
-- preparation.
-------------------------------------------------------------------------------
{-|
Return the 'UID' element from the tuple. 
-}
getUID :: (UID,[LLVMVar],LLVMStatements) -> UID
getUID (x,_,_) = x

{-|
Return the ['LLVMVar'] element from the tuple. 
-}
getVars :: (UID,[LLVMVar],LLVMStatements) -> [LLVMVar]
getVars (_,x,_) = x

{-|
Return the 'LLVMStatements' element from the tuple. 
-}
getCode :: (UID,[LLVMVar],LLVMStatements) -> LLVMStatements
getCode (_,_,x) = x
}
%%]

%%[(8 codegen grin)
{
-------------------------------------------------------------------------------
-- Some 'LLVMLLVMFunctionDecl_LLVMFunctionDecltionDecl's for usage in calls and forward declarations.
-------------------------------------------------------------------------------
{-|
Function declaration for the entry point of the binary.
-}
mainFuncDecl :: LLVMFunctionDecl
mainFuncDecl =
  LLVMFunctionDecl_LLVMFunctionDecl "main" i32 FixedArgs [] Nothing

{-|
Function declaration for the Silly generated initialize function.
-}
initializeFuncDecl :: LLVMFunctionDecl
initializeFuncDecl =
  LLVMFunctionDecl_LLVMFunctionDecl "initialize" Void FixedArgs [] Nothing

{-|
Function declaration for the GRIN generated fun_main function.
-}
fun_mainFuncDecl :: LLVMFunctionDecl
fun_mainFuncDecl =
  LLVMFunctionDecl_LLVMFunctionDecl "fun_fun0tildemain" Void FixedArgs [] Nothing
  
fun_mainFullProgFuncDecl =  
  LLVMFunctionDecl_LLVMFunctionDecl "fun_mainFullProg" Void FixedArgs [] Nothing

{-|
Function declaration of printf from the standard C library.
-}
stdlibPrintfFuncDecl :: LLVMFunctionDecl
stdlibPrintfFuncDecl = 
  LLVMFunctionDecl_LLVMFunctionDecl "printf" i32 VarArgs [(LocalVar "str" (pLift i8))] Nothing

{-|
Function declaration for a run-time function that reports an pattern match
failure and terminates the program.
-}
primPatternMatchFailureFuncDecl :: LLVMFunctionDecl
primPatternMatchFailureFuncDecl =
  LLVMFunctionDecl_LLVMFunctionDecl "primPatternMatchFailure" Void FixedArgs [] Nothing 

primPatternMatchFailureDebugFuncDecl :: LLVMType -> LLVMFunctionDecl
primPatternMatchFailureDebugFuncDecl intType =
  LLVMFunctionDecl_LLVMFunctionDecl "primPatternMatchFailureDebug" Void FixedArgs [LocalVar "x" intType] Nothing 

gcRootFuncDecl :: LLVMFunctionDecl
gcRootFuncDecl = 
  LLVMFunctionDecl_LLVMFunctionDecl "llvm.gcroot" Void FixedArgs [(LocalVar "ptrloc" (pLift $ pLift i8)), (LocalVar "metadata" (pLift i8))] Nothing

gcEhcAllocFuncDecl :: LLVMType -> LLVMFunctionDecl
gcEhcAllocFuncDecl intType = 
  LLVMFunctionDecl_LLVMFunctionDecl "mm_itf_alloc_ext" (pLift intType) FixedArgs [(LocalVar "sz" intType), (LocalVar "gcInfo" intType)] Nothing

gcEhcAllocResFuncDecl :: LLVMType -> LLVMFunctionDecl
gcEhcAllocResFuncDecl intType = 
  LLVMFunctionDecl_LLVMFunctionDecl "mm_itf_allocResident_ext" (pLift intType) FixedArgs [(LocalVar "sz" intType)] Nothing

gcEhcDeallocResFuncDecl :: LLVMType -> LLVMFunctionDecl
gcEhcDeallocResFuncDecl intType = 
  LLVMFunctionDecl_LLVMFunctionDecl "mm_itf_deallocResident_ext" Void FixedArgs [(LocalVar "p" (pLift intType))] Nothing

gcEhcRegRootFuncDecl :: LLVMType -> LLVMFunctionDecl
gcEhcRegRootFuncDecl intType = 
  LLVMFunctionDecl_LLVMFunctionDecl "mm_itf_registerGCRoot_ext" Void FixedArgs [(LocalVar "p" (pLift intType))] Nothing

gcEhcRegRootsFuncDecl :: LLVMType -> LLVMFunctionDecl
gcEhcRegRootsFuncDecl intType = 
  LLVMFunctionDecl_LLVMFunctionDecl "mm_itf_registerGCRoots_ext" Void FixedArgs [(LocalVar "p" (pLift $ pLift $ pLift intType)), (LocalVar "n" intType)] Nothing

gcEhcGCFuncDecl :: LLVMType -> LLVMFunctionDecl
gcEhcGCFuncDecl intType = 
  LLVMFunctionDecl_LLVMFunctionDecl "mm_itf_gc_ext" intType FixedArgs [] Nothing

rtsInitFuncDecl :: LLVMFunctionDecl
rtsInitFuncDecl = 
  LLVMFunctionDecl_LLVMFunctionDecl "main_llvm_Init1" Void FixedArgs [] Nothing

rtsExitFuncDecl :: LLVMFunctionDecl
rtsExitFuncDecl = 
  LLVMFunctionDecl_LLVMFunctionDecl "main_llvm_Exit" Void FixedArgs [] Nothing


}
%%]

%%[(8 codegen grin)
{
-------------------------------------------------------------------------------
-- Cast functions
-------------------------------------------------------------------------------
{-|
Cast a 'LLVMVar' to the given 'LLVMType' 'LLVMInt' type. Note: There is no check
on the 'LLVMType' if it is an integer type. If you pass an non integer type,
then the result of the cast is undefined.
-}
cast2int :: UID -> LLVMVar -> LLVMType -> (UID,LLVMVar,LLVMStatements)   
cast2int nr var intType =
  if isInt (getType var)
  then (nr,var,[])
  else let (nr', fresh) = newFresh nr intType
        in (nr', fresh, [LLVMStatement_Assignment fresh $ LLVMExpression_Cast var intType])
 
{-|
Cast a 'LLVMVar' to the given 'LLVMType' 'Pointer' type. Note: There is no check
on the 'LLVMType' if it is a pointer type. If you pass an non pointer type,
then the result of the cast is undefined.
-}       
cast2ptr :: UID -> LLVMVar -> LLVMType -> (UID,LLVMVar,LLVMStatements)
cast2ptr nr var ptrType
  | isPointer (getType var) =
    (nr,var,[])
  | otherwise =
    let (nr', fresh) = newFresh nr ptrType
     in (nr', fresh, [LLVMStatement_Assignment fresh $ LLVMExpression_Cast var ptrType])         

{-|
Cast a 'LLVMVar' in such a way that is fits in the location as defined by the second
'LLVMVar'. For example, the first var is an i32 and the second var is an i32**. Then
a cast will be generated to transform the first var to an i32*.
-}   
makeFitting :: UID -> LLVMVar -> LLVMVar -> (UID,LLVMVar,LLVMStatements)
makeFitting nr what hole 
  -- Case 1 it already fits, no casting needed
  | getType what == pLower (getType hole) =
    (nr,what,[])
  -- Cast 'what' to the lowered type of 'hole'.
  | otherwise = 
    let targetType   = pLower $ getType hole 
        (nr', fresh) = newFresh nr targetType
     in (nr', fresh, [LLVMStatement_Assignment fresh $ LLVMExpression_Cast what targetType])
}
%%]

%%[(8 codegen grin)
{
-------------------------------------------------------------------------------
-- Variable loading functions.
-------------------------------------------------------------------------------
{-|
Load a 'LLVMVar'.
-}
load :: UID -> LLVMVar -> (UID,LLVMVar,LLVMStatements)
load nr var =
  let loadType     = pLower (getType var)
      (nr', fresh) = newFresh nr loadType
   in (nr', fresh, [LLVMStatement_Assignment fresh (LLVMExpression_Load var)])
   
{-|
Load a 'LLVMVar' to an integer.
-}   
load2value :: UID -> LLVMVar -> (UID,LLVMVar,LLVMStatements)
load2value nr var 
  | isInt (getType var) = (nr,var,[])
  | otherwise           =
    let (nr1,var1,stmts1) = load nr var
        (nr2,var2,stmts2) = load2value nr1 var1
     in (nr2,var2, stmts1 ++ stmts2)       
}
%%]

%%[(8 codegen grin)
{
-------------------------------------------------------------------------------
-- Assign an 'LLVMExpression' to a 'LLVMVar'.
-------------------------------------------------------------------------------
{-|
Return a fresh local variable of the requested 'LLVMType'
-}
newFresh :: UID -> LLVMType -> (UID,LLVMVar)
newFresh nr tp = 
  (uidNext nr, LocalVar ("fresh" ++ show nr) tp)

{-|
Assign the given 'LLVMExpression' with the given 'LLVMType' to 
a fresh local 'LLVMVar'.
-}
assign2var :: UID -> (LLVMExpression,LLVMType) -> (UID,LLVMVar,LLVMStatements)
assign2var nr (expr,tp) =
  let (nr', fresh) = newFresh nr tp
   in (nr', fresh, [LLVMStatement_Assignment fresh expr])
}
%%]

%%[(8 codegen grin)
{
-------------------------------------------------------------------------------
-- Often used constants.
-------------------------------------------------------------------------------
{-|
The default arm for a 'LLVMStatement_Switch'.
-}
defaultCase :: UID -> LLVMVar -> (UID,LLVMVar,LLVMStatements)
defaultCase nr var =
  let (nr1, fresh1) = newFresh nr Label
   in (nr1, fresh1, [ LLVMStatement_Label fresh1, LLVMStatement_Call (primPatternMatchFailureDebugFuncDecl $ getType var ) StdCall [var] 
                    , LLVMStatement_Unreachable ])
}

%%]

%%[(8 codegen grin)
{
-------------------------------------------------------------------------------
-- Construct LLVM Data
-------------------------------------------------------------------------------
{-|
Create a 'LLVMExpression' that allocates @nr * sizeof( LLVMType )@ bytes.
-}
mkMalloc :: SillyAllocManageType -> LLVMType -> Int -> LLVMExpression
mkMalloc manageType intType nr =
  if rtsUseGC
  then let size = nr * sizeofPointer
        in case manageType of
           NotManaged -> LLVMExpression_Call (gcEhcAllocFuncDecl intType)    StdCall [Constant size intType, Constant 0 intType] -- (gcEhcAllocResFuncDecl intType) StdCall [Constant size intType]
           GCManaged  -> LLVMExpression_Call (gcEhcAllocFuncDecl intType)    StdCall [Constant size intType, Constant 0 intType]
  else LLVMExpression_Malloc intType nr
  
  
mkGCFieldDescriptors :: LLVMType -> [ConstantInfo] -> (LLVMVar, LLVMVar)
mkGCFieldDescriptors intType ci = (GlobalVar "_llvm_node_descriptor" i8 , ArrayConstant (map toFieldDesc ci) (Array (length ci) (TyVar "FDESCR")))
    where toFieldDesc fd = StructConstant [ Constant (constantInfoNodeSize fd)               intType
                                          , Constant (constantInfoPayloadSize fd)            intType
                                          , Constant (fromBool $ constantInfoHasPointers fd) i8] (TyVar "FDESCR")


mkGCGlobalsDescr :: [HsName] -> LLVMType -> (LLVMVar, LLVMVar)
mkGCGlobalsDescr vars intType = (GlobalVar "_llvm_globals_descriptor" i8 , ArrayConstant globals (Array (length vars) (pLift $ pLift intType)))
    where 
        rp      = GlobalVar "RP" (pLift $ pLift intType)
        globals = map (\hsn -> GlobalVar (hs2str hsn) (pLift $ pLift intType)) vars
  
}
%%]

%%[(8 codegen grin)
{
-------------------------------------------------------------------------------
-- Auxiliary functions
-------------------------------------------------------------------------------
{-|
Fetch the string representation of a 'HsName'
-}
hs2str :: HsName -> String
hs2str = hsnShowAlphanumeric

localsHs2str :: [HsName] -> [String]
localsHs2str = map hs2str

filterPtrs :: [(a, SilTp)] -> [a]
filterPtrs xs = map fst $ filter (\(s, t) -> isptr t) xs
    where 
        isptr SilTpPtr = True
        isptr _        = False


{-|
Return a list of variables with a given constructor, a list of HsNames and
one type. used primary for parameter lists
-}
mkVarList :: (String -> LLVMType -> LLVMVar) -> [HsName] -> LLVMType -> [LLVMVar]
mkVarList constr names tp =
  zipWith (\x y -> constr (hs2str x) y) names (repeat tp)

{-|
Generate a valid global variable which contains a LLVM representation of a Haskell String. 
-}
string2LLVMString :: UID -> String -> (LLVMVar,LLVMVar)
string2LLVMString uid hsStr =
  let hsStr'       = concatMap escapeHex hsStr
      llvmType     = Array (length hsStr + 1) i8
      llvmStr      = "c\"" ++ hsStr' ++ "\\00\""
      (uid',fresh) = newFresh uid llvmType
   in (GlobalVar (getPlainName fresh) (pLift $ llvmType), StrConstant llvmStr llvmType)
  where escapeHex c | isAlphaNum c  = [c]
                    | otherwise     = "\\" ++ strHex 2 (ord c)
{-|
Convert a Bool to a 'LLVMCallType', True indicating a 'TailCall' while any other
value indicates 'StdCall'
-} 
bool2calltype :: Bool -> LLVMCallType
bool2calltype (True)  = TailCall
bool2calltype (False) = StdCall 
}
%%]
