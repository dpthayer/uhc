%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[(8 codegen grin) ag import({GrinCode/AbsSyn})
%%]

%%[(8 codegen grin)
WRAPPER GrAGItf
WRAPPER GrTag
%%]

%%[(8 codegen grin) hs

data Scope
  = ScGlobal
  | ScLocal
  | ScParam

data VarInfo = VarInfo
  { varScope :: Scope
  , varType  :: TyTag
  }

%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Infer Scopes and TyTags for GrVars and GrTags
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%[(8 codegen grin)

ATTR GrGlobal GrGlobalL
  [
  |
  | grValues  USE {`Map.union`} {Map.empty} : {Map.Map HsName GrVal}
  ]

ATTR GrTag
  [
  |
  | tyTag                   : {TyTag}
  ]

ATTR AllExpr --GrExpr GrPatLam
  [ scopes : {Map.Map HsName Scope}  -- In the future, this will contain all useful information for all variables.
  |
  | typedLocals   USE {`Map.union`} {Map.empty} : {Map.Map HsName PrimitiveType}
  ]

ATTR AllNTNoMod
  [ constrs : {Map.Map HsName TyTag}
    globals : {Map.Map HsName TyTag}
  |
  | grTags USE {`Map.union`} {Map.empty} : {Map.Map HsName GrTag}
  ]

ATTR AllNT
  [
  |
  | self : SELF
  ]

%%]

%%[(8 codegen grin)

SEM GrModule
  | Mod
      bindL.constrs     = @loc.constrs
      bindL.globals     = @loc.globals
      globalL.globals   = @loc.globals
      globalL.constrs   = @loc.constrs

      loc.ctyTags       = concatMap (map (fromCTag . snd) . snd) @ctagsMp
      loc.tyNames       = foldr (\(TyCon tnm cnm _ _ _) m -> Map.insert cnm tnm m) Map.empty @loc.ctyTags
      loc.constrs       = foldr (\t@(TyCon tnm cnm _ _ _) m -> Map.insert cnm t m) Map.empty @loc.ctyTags
      loc.tyTags        = nub (@loc.ctyTags ++ Map.elems @loc.globals)
      loc.globals       = Map.foldWithKey (globals @loc.tyNames @loc.grTags) Map.empty @globalL.grValues
      loc.grTags        = @bindL.grTags `Map.union` @globalL.grTags
                          -- Make sure to put bindL on the lhs of Map.union, otherwise globalL takes precedence

{
globals :: Map.Map HsName HsName -> Map.Map HsName GrTag -> HsName -> GrVal
             -> Map.Map HsName TyTag -> Map.Map HsName TyTag
globals tyNames grTags nm grValue tyTags =
  case grValue of
    (GrVal_Node (GrTag_Con _ _ ccnm) _) ->
      case Map.lookup nm grTags of
        (Just (GrTag_Con _ _ cnm)) ->
          case Map.lookup cnm tyNames of
            (Just tyNm) -> Map.insert nm (TyCon tyNm ccnm (-1) (-1) (-1)) tyTags
            _    -> tyTags
        _ -> tyTags
    (GrVal_Node (GrTag_Fun fnm) _) ->
      case Map.lookup nm grTags of
        (Just (GrTag_Con _ _ cnm)) ->
          case Map.lookup cnm tyNames of
            (Just tyNm) -> Map.insert nm (TyFun tyNm fnm) tyTags
            _    -> tyTags
        _ -> tyTags
    _ -> tyTags
}

SEM GrGlobal
  | Global
      lhs.grValues      = Map.singleton @nm @val.self
      lhs.grTags        = Map.singleton @nm ((\(GrVal_Node tg _) -> tg) @val.self)
      val.scopes        = error "Should not use variables"

SEM GrBind
  | Bind
      expr.scopes       = buildScopes (Map.keys @lhs.globals) (Map.keys @expr.typedLocals) @argNmL

SEM GrExpr
  | FetchField
      lhs.grTags        = maybe Map.empty (Map.singleton @nm) @mbTag
      loc.tyTag         = maybe (error "Cannot fetch field of unknown tag")
                                (\(GrTag_Con _ _ nm) -> lookupTag nm @lhs.constrs)
                                @mbTag

SEM GrPatLam
  | Var
      lhs.typedLocals   = Map.singleton @nm Object
  | BasicNode
      lhs.typedLocals   = Map.singleton @nm Int32
  | BasicAnnot
      loc.typedLocals   = Map.singleton @nm Int32

SEM GrTag
  | Con
      loc.tyTag         = lookupTag @nm @lhs.constrs
      loc.tyName        = toConDottedName @loc.tyTag
      lhs.tyTag         = @loc.tyTag
  | Fun
      loc.tyTag         = head [ty | ty@(TyFun _ fnm) <- Map.elems @lhs.globals, fnm == @nm]
      loc.tyName        = toConDottedName @loc.tyTag
  | * - Con
      lhs.tyTag         = error "GrinCode/TyTags: Cannot (yet) get tyTag for non-Con Tag"
%%]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Helper functions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%[(8 codegen grin) hs

fromJustE :: String -> Maybe a -> a
fromJustE err = maybe (error err) id

buildScopes :: [HsName] -> [HsName] -> [HsName] -> Map.Map HsName Scope
buildScopes gs ls ps = Map.unions [mup ScGlobal gs, mup ScLocal ls, mup ScParam ps]
  where mup s = foldr (flip Map.insert s) Map.empty

-- TODO this function should already exists somewhere else. Use that one.
lookupTag :: HsName -> Map.Map HsName TyTag -> TyTag
lookupTag n ts = case Map.lookup n ts of
  Nothing -> error $ "Use of an undefined tag " ++ show n ++ "." ++ show ts
  Just t  -> t

funTyTag :: GrTag -> GrVal -> TyTag
funTyTag (GrTag_Con _ _ nm) (GrVal_Node (GrTag_Fun fnm) _) = undefined

grTag2primType :: GrTag -> PrimitiveType
grTag2primType (GrTag_Con _ _ nm) =
  case hsnShowAlphanumeric nm of
    "Int"          -> Int32
    "Char"         -> Char
    "PackedString" -> String
    _              -> Object


type GrTagAttr a = Syn_GrTag -> a

grTag2tyTag = grTag2A tyTag_Syn_GrTag

grTag2A :: GrTagAttr a -> String -> Map.Map HsName TyTag -> Map.Map HsName TyTag -> [Label] -> Map.Map HsName Scope -> GrTag -> a
grTag2A f cls constrs globals labels scopes tg =
  let t = wrap_GrTag (sem_GrTag tg)
                     (Inh_GrTag { className_Inh_GrTag = cls
                                , constrs_Inh_GrTag   = constrs
                                , globals_Inh_GrTag   = globals
                                , labels_Inh_GrTag    = labels
                                , scopes_Inh_GrTag    = scopes
                                })
  in f t


%%]

