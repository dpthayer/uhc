%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[(8 codegen grin) ag import({GrinCode/AbsSyn})
%%]

%%[(8 codegen grin)
WRAPPER GrAGItf
WRAPPER GrTag
%%]

%%[(8 codegen grin) hs

data Scope
  = ScGlobal
  | ScLocal
  | ScParam

data VarInfo = VarInfo
  { varScope :: Scope
  , varType  :: TyTag
  }

%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Infer Scopes and TyTags for GrVars and GrTags
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%[(8 codegen grin)

ATTR GrGlobal GrGlobalL
  [
  |
  | grValues  USE {`Map.union`} {Map.empty} : {Map.Map HsName GrVal}
  ]

ATTR GrVarL GrVar
  [
  |
  | tyTag : {TyTag}
  ]

ATTR GrTag
  [ maybeTyTag : {Maybe TyTag}
  |
  | tyTag                   : {TyTag}
  ]

ATTR GrVar GrVarL
  [ index     : {Int}
    nodeTyTag : {TyTag}
  |
  |
  ]

ATTR AllExpr
  [ scopes : {Map.Map HsName Scope}
  |
  | typedLocals   USE {`Map.union`} {Map.empty} : {Map.Map HsName PrimitiveType}
    maybeTyTag    USE {`const`} {Nothing} : {Maybe TyTag}
  ]

ATTR GrPatLam GrPatAlt
  [ maybeTyTag : {Maybe TyTag}
  |
  |
  ]

ATTR AllNTNoMod
  [ constrs : {Map.Map HsName TyTag}
    globals : {Map.Map HsName TyTag}
    funs    : {Map.Map HsName TyTag}
  |
  | grTags USE {`Map.union`} {Map.empty} : {Map.Map HsName GrTag}
    tyTags USE {`Map.union`} {Map.empty} : {Map.Map HsName TyTag}
  ]

ATTR AllNT
  [
  |
  | self : SELF
  ]

%%]

%%[(8 codegen grin)

SEM GrModule
  | Mod
      bindL.constrs     = @loc.constrs
      bindL.funs        = @loc.funs
      bindL.globals     = @loc.globals
      globalL.globals   = @loc.globals
      globalL.funs      = @loc.funs
      globalL.constrs   = @loc.constrs

      loc.ctyTags       = concatMap (map (fromCTag . snd) . snd) @ctagsMp
      loc.tyNames       = foldr (\(TyCon tnm cnm _ _ _) m -> Map.insert cnm tnm m) Map.empty @loc.ctyTags
      loc.constrs       = foldr (\t@(TyCon tnm cnm _ _ _) m -> Map.insert cnm t m) Map.empty @loc.ctyTags
      loc.tyTags        = nub (@loc.ctyTags ++ [ x | x@(TyFun _ _) <- Map.elems @loc.globals])
      loc.funs          = @bindL.tyTags
      loc.globals       = Map.foldWithKey (globals @loc.tyNames @loc.grTags) Map.empty @globalL.grValues
      loc.grTags        = @bindL.grTags `Map.union` @globalL.grTags
                          -- Make sure to put bindL on the lhs of Map.union, otherwise globalL takes precedence

{
globals :: Map.Map HsName HsName -> Map.Map HsName GrTag -> HsName -> GrVal
             -> Map.Map HsName TyTag -> Map.Map HsName TyTag
globals tyNames grTags nm grValue tyTags =
  case grValue of
    (GrVal_Node (GrTag_Con _ _ ccnm) _) ->
      case Map.lookup nm grTags of
        (Just (GrTag_Con _ _ cnm)) ->
          case Map.lookup cnm tyNames of
            (Just tyNm) -> Map.insert nm (TyCon tyNm ccnm (-1) (-1) (-1)) tyTags
            _    -> tyTags
        _ -> tyTags
    (GrVal_Node (GrTag_Fun fnm) _) ->
      case Map.lookup nm grTags of
        (Just (GrTag_Con _ _ cnm)) ->
          case Map.lookup cnm tyNames of
            (Just tyNm) -> Map.insert nm (TyFun tyNm fnm) tyTags
            _    -> tyTags
        _ -> tyTags
    _ -> tyTags
}

SEM GrGlobal
  | Global
      lhs.grValues      = Map.singleton @nm @val.self
      lhs.grTags        = Map.singleton @nm ((\(GrVal_Node tg _) -> tg) @val.self)
      val.scopes        = error "Should not use variables"

SEM GrBind
  | Bind
      expr.scopes       = buildScopes (Map.keys @lhs.globals) (Map.keys @expr.typedLocals) @argNmL

SEM GrExpr
  | Seq
      pat.maybeTyTag    = @expr.maybeTyTag
  | UpdateUnit
      lhs.maybeTyTag    = @val.maybeTyTag
  | FetchField
      lhs.grTags        = maybe Map.empty (Map.singleton @nm) @mbTag
      lhs.maybeTyTag    = @loc.maybeTyTag
      loc.tyTag         = maybe (error "Cannot fetch field of unknown tag") id @loc.maybeTyTag
      loc.maybeTyTag    = maybe Nothing
                                (\(GrTag_Con _ _ nm) -> Just $ lookupTag nm @lhs.constrs)
                                @mbTag


SEM GrPatAlt
  | Tag
     tag.maybeTyTag     = @lhs.maybeTyTag

SEM GrAlt
  | Alt
      pat.maybeTyTag   = @expr.maybeTyTag

SEM GrPatLam
  | Var
      lhs.typedLocals   = Map.singleton @nm (maybe Object toPrimitiveType @lhs.maybeTyTag)
  | VarNode
      fldL.index        = -1
      fldL.nodeTyTag    = @fldL.tyTag
  | BasicNode
      lhs.typedLocals   = Map.singleton @nm Int32
  | BasicAnnot
      loc.typedLocals   = Map.singleton @nm Int32

SEM GrVarL
  | Nil
      lhs.tyTag         = error "GrinCode/TyTags.GrValL.tyTag: Empty List has no TyTag."
  | Cons
      lhs.tyTag         = @hd.tyTag
      hd.index          = @lhs.index
      tl.index          = @lhs.index + 1

SEM GrVar
  | Var
      lhs.tyTag         = @loc.tyTag
      loc.tyTag         = error "GrinCode/TyTags.GrVal.tyTag: Not implemented yet for Var constructor."
      lhs.typedLocals = Map.singleton @nm (toPrimitiveType @lhs.nodeTyTag)
  | KnownTag
      lhs.tyTag         = @loc.tyTag
      loc.tyTag         = @tag.tyTag
  | Ignore
      lhs.tyTag         = @loc.tyTag
      loc.tyTag         = error "GrinCode/TyTags.GrVal.tyTag: No tyTag for Ignore constructor."

SEM GrVal
  | Tag
      lhs.maybeTyTag    = Just @tag.tyTag

SEM GrTag
  | Con
      loc.tyTag         = lookupTag @nm @lhs.constrs
      loc.tyName        = toConDottedName @loc.tyTag
      lhs.tyTag         = @loc.tyTag
  | Fun
      lhs.tyTags        = maybe Map.empty (Map.singleton @nm) @lhs.maybeTyTag
      loc.tyTag         = head $ [ty | ty@(TyFun _ fnm) <- Map.elems @lhs.globals, fnm == @nm]
                                   ++ (Map.foldWithKey (\k x xs -> if k == @nm then x : xs else xs) [] @lhs.funs)
                                   ++ [error "Don't ever take the head of an empty list!"]
      loc.tyName        = toConDottedName @loc.tyTag
  | * - Con
      lhs.tyTag         = error "GrinCode/TyTags: Cannot (yet) get tyTag for non-Con Tag"
%%]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Helper functions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%[(8 codegen grin) hs

headE :: String -> [a] -> a
headE err []    = error err
headE _   (x:_) = x

fromJustE :: String -> Maybe a -> a
fromJustE err = maybe (error err) id

buildScopes :: [HsName] -> [HsName] -> [HsName] -> Map.Map HsName Scope
buildScopes gs ls ps = Map.unions [mup ScGlobal gs, mup ScLocal ls, mup ScParam ps]
  where mup s = foldr (flip Map.insert s) Map.empty

-- TODO this function should already exists somewhere else. Use that one.
lookupTag :: HsName -> Map.Map HsName TyTag -> TyTag
lookupTag n ts = case Map.lookup n ts of
  Nothing -> error $ "Use of an undefined tag " ++ show n ++ "." ++ show ts
  Just t  -> t

funTyTag :: GrTag -> GrVal -> TyTag
funTyTag (GrTag_Con _ _ nm) (GrVal_Node (GrTag_Fun fnm) _) = undefined

grTag2primType :: GrTag -> PrimitiveType
grTag2primType (GrTag_Con _ _ nm) =
  case hsnShowAlphanumeric nm of
    "Int"          -> Int32
    "Char"         -> Char
    "PackedString" -> String
    _              -> Object


type GrTagAttr a = Syn_GrTag -> a

grTag2tyTag = grTag2A tyTag_Syn_GrTag

grTag2A :: GrTagAttr a -> String -> Map.Map HsName TyTag -> Map.Map HsName TyTag -> [Label] -> Map.Map HsName Scope -> GrTag -> a
grTag2A f cls constrs globals labels scopes tg =
  let t = wrap_GrTag (sem_GrTag tg)
                     (Inh_GrTag { className_Inh_GrTag = cls
                                , constrs_Inh_GrTag   = constrs
                                , globals_Inh_GrTag   = globals
                                , labels_Inh_GrTag    = labels
                                , scopes_Inh_GrTag    = scopes
                                })
  in f t


%%]

