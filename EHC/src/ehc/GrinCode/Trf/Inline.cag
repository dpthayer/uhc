%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Inline
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[doesWhat doclatex

Replace references to global values with their actual code.
Use of the following are inlined:
one-time used functions and values, if not exported;
wrappers for primitives (to allow their inline replacement with operators);
wrappers for constructors;
small enough functions (not yet done).

Requires FlattenSeq to be the next transformation.

%%]

Implementation:
Free vars are gathered and passed topdown via 'fviMp', bound to a count
and type of usage. Based on this inline candidates are selected, passed
in 'inlMp'. Inlined names are returned in 'gathInlNmS' and passed in
'inlNmS' which determines whether a binding can be removed, together
with other criteria (not exported).

Tricky:
Recursive inlining is accomplished by letting 'inlMp' holding
transformed code. A bit of cycle, so only non mutual recursive values
are allowed to participate. Inlining mutual recursive values would lead
to a loop.

%%[(8 codegen grin) ag import({GrinCode/AbsSyn})
%%]

%%[(8 codegen grin) hs module {%{EH}GrinCode.Trf.Inline}
%%]

%%[(8 codegen grin) hs import(qualified EH.Util.FastSeq as Seq,qualified Data.Set as Set,qualified Data.Map as Map,Data.Maybe)
%%]

%%[(8 codegen grin) hs import({%{EH}Base.Builtin}, {%{EH}Base.Common}, {%{EH}GrinCode.Common}, {%{EH}GrinCode})
%%]

%%[(20 codegen grin) hs import({%{EH}GrinCode.FreeVars})
%%]

-- for debugging:
%%[(8 codegen grin) hs import(EH.Util.Pretty,EH.Util.Utils,EH.Util.Debug)
%%]

%%[(8 codegen grin) hs import(qualified {%{EH}Config} as Cfg)
%%]

%%[(8 codegen grin) ag import({GrinCode/Trf/CommonFreeVar},{GrinCode/Trf/CommonWillEval},{GrinCode/Trf/CommonAliasAG})
%%]


%%[(8 codegen grin) hs import(EH.Util.Pretty,EH.Util.Utils)
%%]
%%[(8 codegen grin) hs import({%{EH}Base.Debug})
%%]

--Added
%%[(8 codegen grin) hs import(qualified Data.Graph as Graph,qualified Data.Tree as Tree,Data.List)
%%]

%%[(8 codegen grin) ag import({GrinCode/InsideCase})
%%]

%%[(8 codegen grin) ag import({GrinCode/Trf/UniqueIds})
%%]

%%[(8 codegen grin) ag import({GrinCode/Trf/LoopBreakers})
%%]

%%[(8 codegen grin) hs import({%{EH}GrinCode.Trf.MkUniqueBindings})
%%]

%%[(8 codegen grin) hs import({%{EH}GrinCode.Trf.SubstExpr})
%%]
%%[(8 codegen grin) hs import(EH.Util.Pretty)
%%]
%%[(8 codegen grin) hs import({%{EH}GrinCode.Pretty})
%%]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Wrapper
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin).wrapper
WRAPPER GrAGItf
%%]

%%[(8 codegen grin).grInline hs export(grInline)
grInline :: Bool -> GrModule -> (Maybe GrModule)
grInline allow grmod
  = if Map.null (gathInlMp_Syn_GrAGItf t) then Nothing else Just (trf_Syn_GrAGItf t)
  where t = wrap_GrAGItf (sem_GrAGItf $ GrAGItf_AGItf grmod)
            $ Inh_GrAGItf
                { allowOmitBind_Inh_GrAGItf = allow
                }
            
%%]

%%[(20 codegen grin) -8.grInline hs export(grInline)
grInline :: Bool -> HsNameS -> GrInlMp -> GrModule -> Maybe (GrModule,GrInlMp,VarSubs)
grInline allow expNmS inlMp grmod
  = if changed_Syn_GrAGItf t 
    then Just ( trf_Syn_GrAGItf t
              , gathInlMp_Syn_GrAGItf t
              , varSubs_Syn_GrAGItf t
              ) 
    else Nothing 
  where t = wrap_GrAGItf (sem_GrAGItf $ GrAGItf_AGItf grmod)
            $ Inh_GrAGItf
                { expNmS_Inh_GrAGItf = expNmS
                , inlMp_Inh_GrAGItf = inlMp
                , allowOmitBind_Inh_GrAGItf = allow
                }
%%]

There is a cyclic dependency, but it is by design:

*** UU.AG warning  ***
problem  : Direct circular dependency pattern for inherited attribute inlMp
            and synthesized attribute gathInlMp of nonterminal GrBindL
pattern  : see help
help     : The following attributes formed the cycle:
           GrModule.Mod, inherited attribute bindL.inlMp ("build/8/lib-grinc/GRIN8/GrinCode/Trf/Inline.ag"(line 92, column 33))
           GrBindL.Cons, inherited attribute lhs.inlMp
           GrBindL.Cons, inherited attribute hd.inlMp ("build/8/lib-grinc/GRIN8/GrinCode/Trf/Inline.ag"(line 54, column 26))
           GrBind.Bind, inherited attribute lhs.inlMp
           GrBind.Bind, inherited attribute expr.inlMp ("build/8/lib-grinc/GRIN8/GrinCode/Trf/Inline.ag"(line 54, column 26))
           GrExpr.App, inherited attribute lhs.inlMp
           GrExpr.App, synthesized attribute lhs.trf ("build/8/lib-grinc/GRIN8/GrinCode/Trf/Inline.ag"(line 152, column 22))
           GrBind.Bind, synthesized attribute expr.trf
           GrBind.Bind, synthesized attribute lhs.gathInlMp ("build/8/lib-grinc/GRIN8/GrinCode/Trf/Inline.ag"(line 57, column 22))
           GrBindL.Cons, synthesized attribute hd.gathInlMp
           GrBindL.Cons, synthesized attribute lhs.gathInlMp ("build/8/lib-grinc/GRIN8/GrinCode/Trf/Inline.ag"(line 53, column 20))
           GrModule.Mod, synthesized attribute bindL.gathInlMp
           GrModule.Mod, inherited attribute bindL.inlMp ("build/8/lib-grinc/GRIN8/GrinCode/Trf/Inline.ag"(line 92, column 33))

%%[(8 codegen grin)
PRAGMA nocycle
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
[0/0] Reading HI                         UHC.Enum               (d:/inlineEHC-acc/EHC/install/99/lib/C/pkg/base/UHC/Enum.hi)
[0/0] Reading HI                         UHC.Eq                 (d:/inlineEHC-acc/EHC/install/99/lib/C/pkg/base/UHC/Eq.hi)
[0/0] Reading HI                         UHC.Float              (d:/inlineEHC-acc/EHC/install/99/lib/C/pkg/base/UHC/Float.hi)
[0/0] Reading HI                         UHC.MutVar             (d:/inlineEHC-acc/EHC/install/99/lib/C/pkg/base/UHC/MutVar.hi)
[0/0] Reading HI                         UHC.Ord                (d:/inlineEHC-acc/EHC/install/99/lib/C/pkg/base/UHC/Ord.hi)
[0/0] Reading HI                         UHC.Read               (d:/inlineEHC-acc/EHC/install/99/lib/C/pkg/base/UHC/Read.hi)
[0/0] Reading HI                         UHC.ST                 (d:/inlineEHC-acc/EHC/install/99/lib/C/pkg/base/UHC/ST.hi)
[0/0] Reading HI                         UHC.STRef              (d:/inlineEHC-acc/EHC/install/99/lib/C/pkg/base/UHC/STRef.hi)
[0/0] Reading HI                         UHC.Show               (d:/inlineEHC-acc/EHC/install/99/lib/C/pkg/base/UHC/Show.hi)
[0/0] Reading HI                         UHC.Ix                 (d:/inlineEHC-acc/EHC/install/99/lib/C/pkg/base/UHC/Ix.hi)
[0/0] Reading HI                         UHC.Types              (d:/inlineEHC-acc/EHC/install/99/lib/C/pkg/base/UHC/Types.hi)
[0/0] Reading HI                         UHC.Prims              (d:/inlineEHC-acc/EHC/install/99/lib/C/pkg/base/UHC/Prims.hi)
[0/0] Reading HI                         UHC.Ptr                (d:/inlineEHC-acc/EHC/install/99/lib/C/pkg/base/UHC/Ptr.hi)

%%% Globally used vars
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(20 codegen grin)
ATTR GrAGItf GrModule AllBind [ expNmS: HsNameS | | ]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Introduced global names
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(20 codegen grin)
ATTR AllBind [ | | introNmS USE {`Set.union`} {Set.empty}: {Set.Set HsName} ]

SEM GrBind
  | Bind        lhs         .   introNmS        =   Set.singleton @nm
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Free var, usage info
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin)
ATTR AllBind [ fviMp: FvInfoMp | | ]

SEM GrModule
  | Mod         bindL       .   fviMp           =   @bindL.gathFviMp
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Will eval defined here because could not be factored out
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin)
SEM GrBind
  | Bind        expr        .   willUseFor      =   Set.empty
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Control whether omitting of bindings is allowed
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin)
ATTR GrAGItf GrModule AllBind [ allowOmitBind : {Bool} | | ]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Inlineable functions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin)
ATTR AllBind [ | | gathInlMp USE {`Map.union`} {Map.empty}: GrInlMp ]
ATTR AllGrExpr AllBind [ inlMp: GrInlMp | | ]

-- CAF: Constant applicative function, a function without parameters, for example Pi.
-- J: make the descision to inline a binding or not.
-- CAF's are treated special, because the can easily result in work duplication
-- for example: costly calculation of PI.

SEM GrBind
  | Bind  (lhs.gathInlMp,loc.omitBind)    
              =  let  isLoopBreaker = elem @nm @lhs.loopBreakers
                      callInline = Map.singleton @nm (GrInl_Call @argNmL @expr.trf isLoopBreaker @loc.idsCreated)
                      cafInline = Map.singleton @nm (GrInl_CAF @expr.trf isLoopBreaker)
                      exported = not (@nm `Set.member` @lhs.expNmS)
                      trivialExpr = (  @expr.isFFIWrapper                  -- wrappers are inlined
                                    || @expr.isConWrapper
                                    || @expr.inlineCost <= 10              -- and low cost values as well
                                    )
                 in   case Map.lookup @nm @lhs.fviMp of
                        -- a once used function can be inlined and its binding removed
                        Just (FvInfo 1 use)
                          -- once used, not CAF and not exported
                          | not @isCAF
                            && FvUse_Call `Set.member` use
%%[[20
                            && not exported         -- only inline if not exported as global value
                            -- inline possible but keep the bind. (Code duplication).
%%]]                                                          
                            -> (callInline, True)
                        Just (FvInfo 1 use)                               -- a once used, evaluated value can be inlined and its binding removed
                          | @isCAF
                            && False -- willUseForEval @nm @expr.willUseForMp
                            && FvUse_Val `Set.member` use
%%[[20
                            && not exported         -- only inline if not exported as global value
%%]]
                            -> (cafInline, True)
                        Just _ 
                          | -- Code duplication because bind is used more than once.
                            not @isCAF
                            && True -- trivialExpr
                            -> (callInline, False)    --False because the bind is used more often.
                        _
                            -> (Map.empty, False) -- don't inline
  | Rec lhs.gathInlMp = Map.empty
%%]

%%[(8 codegen grin)
ATTR GrExpr [ | | isFFIWrapper USE {||} {False}: Bool ]

SEM GrExpr
  | FFI         lhs         .   isFFIWrapper    =   True
%%]

%%[(8 codegen grin)
ATTR GrExpr [ | | isConWrapper: Bool ]

SEM GrExpr
  | Unit         lhs        .   isConWrapper    =   True
  | * - Unit     lhs        .   isConWrapper    =   False
%%]

%%[(8 codegen grin)
ATTR AllGrExpr [ | | inlineCost USE {+} {1}: Int ]
%%]

%%[(8 codegen grin).inlMp.init
SEM GrModule
  | Mod         bindL       .   inlMp           =   @bindL.gathInlMp
%%]

%%[(20 codegen grin) hs
inlMayExport :: HsNameS -> HsNameS -> HsName -> GrInl -> Bool
inlMayExport onlyInThisModule expNmS n inl
  = case inl of
      GrInl_Call _ e _ _
        -> n `Set.member` expNmS
           && Set.null (onlyInThisModule `Set.intersection` Map.keysSet (grFreeVars e))
      _ -> False
%%]

%%[(20 codegen grin) -8.inlMp.init
ATTR GrAGItf GrModule [ inlMp: GrInlMp | | gathInlMp: GrInlMp ]

SEM GrModule
  | Mod         bindL       .   inlMp           =   @bindL.gathInlMp `Map.union` @lhs.inlMp
                lhs         .   gathInlMp       =   let onlyInThisModule = @bindL.introNmS `Set.difference` @lhs.expNmS
                                                    in  Map.filterWithKey (inlMayExport onlyInThisModule @lhs.expNmS) @bindL.gathInlMp
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Which names are inlined
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin)
ATTR AllGrExpr AllBind [ | | gathInlNmS USE {`Set.union`} {Set.empty}: FvS ]
ATTR AllBind [ inlNmS: FvS | | ]

SEM GrModule
  | Mod         loc         .   inlNmS          =   @bindL.gathInlNmS
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% GrVal as name
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin)
ATTR AllGrVal [ | | asNmL USE {++} {[]}: {[Maybe HsName]} ]

SEM GrVal
  | Var         lhs         .   asNmL           =   [Just @nm]
  | * - Var     lhs         .   asNmL           =   [Nothing]
  
-- TODO: How to handle NodeAdapt?
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Inside a CAF?
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin)
ATTR AllGrExpr [ isCAF: Bool | | ]

SEM GrBind
  | Bind        loc         .   isCAF           =   null @argNmL
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% UniqueIdsNeeded
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin)
ATTR AllNTNoMod [ | | inlinedCallIds USE {+} {0} : Int ]
ATTR AllNTNoMod [ | | idsCreated USE {+} {0} : Int ]

{-
-}
SEM GrExpr
  | Seq lhs.idsCreated = length @pat.introNmL + @expr.idsCreated + @body.idsCreated

SEM GrAlt
  | Alt lhs.idsCreated = length @pat.introNmL + @expr.idsCreated

SEM GrBindL
  | Cons  
SEM GrBind
  | Bind  (expr.uniqueIds,lhs.uniqueIds) =  --(\(a,b) -> "bind " ++ show @nm 
                                              -- ++ " idsNeeded = " ++ show @expr.idsNeeded 
                                            --  ++ " uniqueIds = " ++ show a) >>>
                                            splitAt @expr.inlinedCallIds @lhs.uniqueIds
          loc.idsCreated = @expr.idsCreated + @expr.inlinedCallIds
                                      
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Transformation: inline
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin)
ATTR GrAGItf [ | | trf: GrModule ]
ATTR AllNT [ | | trf: SELF ]

{ 
type VarSubs = [(HsName,HsName)] 
}

ATTR GrAGItf GrModule AllExpr AllBind [ || varSubs USE {++} {[]} : {VarSubs} ]

ATTR GrAGItf GrModule AllBind AllGrExpr  [ | | changed USE {||} {False} : {Bool} ]
%%]

%%[(8 codegen grin) hs

showInlines = False

inlGrVar :: GrInlMp -> [HsName] -> (GrExpr -> GrExpr,FvS,Bool)
inlGrVar inlMp nmL
  = (foldr (.) id mks,Set.unions inls,or changes)
  where inl nm = case Map.lookup nm inlMp of
                   Just (GrInl_CAF e _) -> (showInlines,const $ "inlining caf " ++ show nm ++ "\nval = " ++ show e) >?>
                                           (GrExpr_Seq e (GrPatLam_Var nm),Set.singleton nm,True)
                   _ -> (id,Set.empty,False)
        (mks,inls,changes) = unzip3 $ map inl nmL

inlNmsAreInlineable :: [Maybe HsName] -> Bool
inlNmsAreInlineable = and . map isJust

%%]

%%[(8 codegen grin)
SEM GrExpr
  | Call  loc.(grVarTrf,grVarInlNmS,inlGrVarChanges) =   
            if   @lhs.isCAF
            then inlGrVar @lhs.inlMp (Map.keys @argL.gathFviMp)
            else (id,Set.empty,False)
%%]

%%[(8 codegen grin)


SEM GrExpr
  | Call  (lhs.trf,loc.gathInlNmS,lhs.varSubs,lhs.uniqueIds,lhs.inlinedCallIds,lhs.changed) =  
            case Map.lookup @nm @lhs.inlMp of
                Just (GrInl_Call as e lb idsCreated) 
                  | not (lb {-&& @lhs.insideCase-})
                    && inlNmsAreInlineable @argL.asNmL ->  
                        (showInlines,const $ "inlining call " ++ show @nm) >?>
                        let argumentSubstitutions = Map.fromList (zip as (map fromJust @argL.asNmL))
                            argumentedCallBody = substExpr argumentSubstitutions e
                            (finalInlinableCode,remUniqueIds,varSubs) = mkUniqueBindings @lhs.uniqueIds argumentedCallBody
                                                                        {- <<< (const $ "calling mkbinding for call to " ++ show @nm ++ " with idsCreated = " ++ show idsCreated
                                                                              ++ " and uniqueIds = " ++ show (length @lhs.uniqueIds)
                                                                              ++ "\ntrf = " ++ disp (ppGrExpr argumentedCallBody) 0 "") -}
                        in  ( @grVarTrf finalInlinableCode                    
                            , Set.insert @nm @grVarInlNmS    
                            , varSubs
                            , remUniqueIds
                            , idsCreated
                            , True)
                          
                _ ->  (@grVarTrf @trf,@grVarInlNmS, [], @lhs.uniqueIds, 0, False)
                            
  | App  (lhs.trf,loc.gathInlNmS,lhs.changed) = 
            if   @lhs.isCAF
            then let (grVarTrf,grVarInlNmS,changed) = inlGrVar @lhs.inlMp (@nm : Map.keys @argL.gathFviMp)
                 in  (grVarTrf @trf, grVarInlNmS, changed)
            else (@trf, Set.empty, False)
  | Eval  -- What is this about? I really don't get it. How is this related to globals? CAFS can only be inlined from CAFS, okay.
          (lhs.trf,loc.gathInlNmS,lhs.changed) =  
            case Map.lookup @nm @lhs.inlMp of
              Just (GrInl_CAF e lb) | @lhs.isCAF && not lb
                -> (e, Set.singleton @nm, True)
              _ -> (@trf, Set.empty, False) 
%%]

%%[(8 codegen grin)
ATTR AllBind [ | | trfSq USE {Seq.:++:} {Seq.empty}: {Seq.FastSeq GrBind} ]

SEM GrModule
  | Mod         lhs         .   trf             =   GrModule_Mod @moduleNm @globalL.trf (Seq.toList @bindL.trfSq) @tagsMp

SEM GrBind
  | Bind        lhs         .   trfSq           =   -- (const $ "remUniqueIds = " ++ show @expr.uniqueIds) >>>
                                                    if @lhs.allowOmitBind && @loc.omitBind && @nm `Set.member` @lhs.inlNmS
                                                    then Seq.empty
                                                    else Seq.singleton @trf
  | Rec         lhs         .   trfSq           =   Seq.singleton $ GrBind_Rec $ Seq.toList @bindL.trfSq
%%]
