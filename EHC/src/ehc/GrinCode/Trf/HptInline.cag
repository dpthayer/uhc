
%%[(8 codegen grin) hs import({%{EH}GrinCode.Trf.Inline(grInline)})
%%]

%%[(8 codegen grin) hs import({%{EH}GrinCode.PointsToAnalysis(continuedHeapPointsToAnalysis,heapPointsToAnalysis)})
%%]

%%[(8 codegen grin) hs import({%{EH}Base.Builtin}, {%{EH}Base.Common}, {%{EH}GrinCode.Common}, {%{EH}GrinCode})
%%]

%%[(8 codegen grin) hs module {%{EH}GrinCode.Trf.HptInline}
%%]

%%[(8 codegen grin) hs import(EH.Util.Debug)
%%]
%%[(8 codegen grin) hs import({%{EH}GrinCode.Pretty})
%%]
%%[(8 codegen grin) hs import(EH.Util.Pretty)
%%]
%%[(8 codegen grin) hs import(Data.Array)
%%]


%%[(20 codegen grin) -8.grInline hs export(hptInline)
hptInline :: Bool -> HsNameS -> GrInlMp -> (GrModule,HptMap) -> Maybe ((GrModule,HptMap),GrInlMp)
hptInline allow expNmS inlMp (grMod,hptMap) = 
  let inlineResult = grInline allow  expNmS inlMp grMod
      (_,safeHptMap) = (0,hptMap) -- heapPointsToAnalysis grMod      
  in  fmap (processInline safeHptMap) inlineResult

processInline :: HptMap -> (GrModule,GrInlMp,[(HsName,HsName)]) -> ((GrModule,HptMap),GrInlMp)
processInline hptMap (grMod,inlMp,varSubs) = 
    ((grMod,updatedHpt),inlMp)          
    <<< (const $ "hptExtended = " ++ disp (pp hptBottomExtended) 80 [])
    -- <<< (const $ "hptHPT = " ++ disp (pp updatedHpt) 80 [])
    -- <<< (const $ "diffHpt = " ++ disp (pp diffHpt) 80 [])     
    <?< (False, const $ "hptInlinedgrin = \n" ++ disp (ppGrModule (grMod)) 0 [])
    <?< (debug, const $ "varSubs length = " ++ show (length varSubs) ++ "\nvarsubs = " ++ show varSubs)
    <?< (debug, const $ "hptAddedBinds = \n" ++ show hptExtended)
    <?< (debug, const $ "hptOld = \n" ++ show hptMap)
  where
  debug = False
  hptExtended = hptBottomExtended
  hptDefensiveExtended = 
    let hptAddedBinds :: [(Int,AbstractValue)]
        hptAddedBinds = -- (\a -> "additions are: " ++ show a) >>>
           map (\(fromId,toId) -> (getNr toId,getEnvVar hptDefensiveExtended (getNr fromId))) varSubs       
    in addEnvNamedElems hptMap hptAddedBinds

  hptBottomExtended :: HptMap
  hptBottomExtended = 
    let hptAddedBinds :: [(Int,AbstractValue)]
        hptAddedBinds = map (\(fromId,toId) -> (getNr toId,AbsBottom)) varSubs  
    in addEnvNamedElems hptMap hptAddedBinds
               
  diffHpt = diffMap hptExtended (snd $ heapPointsToAnalysis grMod)               
  (count,updatedHpt) =  -- (0,hptWithNewBindings) 
                        -- heapPointsToAnalysis grMod 
                        continuedHeapPointsToAnalysis (hptExtended,grMod)
                        
%%]












            