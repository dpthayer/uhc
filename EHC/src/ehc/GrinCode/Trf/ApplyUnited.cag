%%[doesWhat doclatex

do not do \textit{APPLY} on variables that bind the result of a previous \textit{UNIT} of a P-node.
Instead, do a \textit{CALL} of the function if it is now saturated, or build a new P-node if it is undersaturated.

%%]


For each pattern
   UNIT (#P/needs/f x y) ;\r ->
   ...
   APPLY r a b
replace the APPLY expression by
   CALL f x y a b           if n==needs
   UNIT (#P/m/f x y a b)    if n< needs
where n = |a b|
      m = needs - n


%%[(8 codegen grin) ag import({GrinCode/AbsSyn})
%%]
%%[(8 codegen grin) hs import (qualified Data.Map as Map, qualified Data.Set as Set)
%%]
%%[(8 codegen grin) hs import ({%{EH}Base.Common}, {%{EH}GrinCode.Common}, {%{EH}GrinCode}, {%{EH}Base.HsName} )
%%]
%%[(8 codegen grin) hs import({%{EH}Base.Debug})
%%]
%%[(8 codegen grin) hs import(EH.Util.Debug)
%%]
%%[(8 codegen grin)
WRAPPER GrAGItf
%%]
%%[(8 codegen grin) hs module {%{EH}GrinCode.Trf.ApplyUnited} export(applyUnited)
                    
applyUnited :: GrModule -> Maybe GrModule
applyUnited grmod = let t = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf grmod))
                                         (Inh_GrAGItf)
                     in  if   (changed_Syn_GrAGItf t)
                         then Just (grTrf_Syn_GrAGItf t)
                         else Nothing
%%]


%%[(8 codegen grin)
ATTR GrAGItf [ | | grTrf: GrModule ]
ATTR AllNT [ | | grTrf: SELF ]
%%]


%%[(8 codegen grin)

-- Environment passes information about variables that hold a P-node.

ATTR AllGrExpr  [  env : {Map.Map HsName GrVal} | | ]

ATTR GrExpr [  | | mbUnitPNode : {Maybe GrVal} ]
                   
ATTR GrPatLam [ | | getName : {HsName} ]

ATTR GrVal [ | | hasPAppTag : {Bool} ]

ATTR AllNT GrAGItf [ | | changed USE {||} {False} : {Bool} ]

SEM GrPatLam
  | Var       lhs.getName  =  @nm
  | * - Var   lhs.getName  =  error "ApplyUnited: getName from non-variable"

SEM GrVal
  | Node      lhs.hasPAppTag  =  isPAppTag @tag.grTrf
  | * - Node  lhs.hasPAppTag  =  False


SEM GrBind
  | Bind      expr.env     =  Map.empty 

SEM GrExpr
  | Seq       body.env  =   maybe (--(const $ "did not insert expr = " ++ show @expr.grTrf) >>>
                                  @lhs.env)
                                 (\val -> --(const $ "\ninserting " ++ show @pat.getName ++ " with expr = " ++ show @expr.grTrf) >>>
                                          Map.insert @pat.getName val @lhs.env)
                                 (case @expr.grTrf of
                                    GrExpr_Unit val@(GrVal_Node (GrTag_PApp _ _) _) -> Just val
                                    _                                           -> Nothing
                                  )
                                 
  | Unit            lhs.mbUnitPNode    =  
                                          if @val.hasPAppTag
                                          then --(const $ "found PTAGunit, val = " ++ show @val.grTrf) >>>
                                                Just @val.grTrf
                                          else --(const $ "found notPTAGunit, val = " ++ show @val.grTrf) >>>
                                                Nothing
  | * - Unit        lhs.mbUnitPNode    =  Nothing
 
  | App             (lhs.grTrf,lhs.changed)
                                       =  --(const $ "\nfound apply, nm = " ++ show @nm) >>>
                                          maybe (@loc.grTrf,False)
                                          (\node -> (applyNode @nm @argL.grTrf node,True))
                                          (Map.lookup @nm @lhs.env)

%%]

%%[(8 codegen grin) hs


applyNode nm2 flds2 node@(GrVal_Node (GrTag_PApp needs nm) flds1) 
  =  --(const $ "\napplyNode " ++ show nm2 ++ "\nnode = " ++ show node) >>>
     let n = length flds2
     in  if n<needs
         then GrExpr_Unit  (GrVal_Node (GrTag_PApp (needs-n) nm) (flds1++flds2)) GrType_None
         else if n==needs
              then GrExpr_Call  nm  (flds1++flds2)
              else let newname = HNmNr 666 (OrigLocal (hsnFromString "ApplyUnitedApplyNode"))
                       flds2a  = take needs flds2
                       flds2b  = drop needs flds2
                   in  GrExpr_Seq (GrExpr_Call  nm  (flds1++flds2a))
                                  (GrPatLam_Var newname)
                                  (GrExpr_App  newname flds2b)

%%]
