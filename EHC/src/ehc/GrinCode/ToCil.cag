%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[(8 codegen grin) hs module {%{EH}GrinCode.ToCil} export(grin2cil)
%%]
%%[(8 codegen grin) hs import(Language.Cil)
%%]

%%[(8 codegen grin) ag import({GrinCode/AbsSyn})
%%]

%%[(8 codegen grin) hs import(Debug.Trace)
%%]
%%[(8 codegen grin) hs import(Data.List((\\)), Data.Maybe, qualified Data.Map as Map, qualified Data.Set as Set, Data.Bits)
%%]
%%[(8 codegen grin) hs import(Control.Arrow(first, second))
%%]
%%[(8 codegen grin) hs import(EH.Util.Pretty, EH.Util.Utils)
%%]
%%[(8 codegen grin) hs import({%{EH}Base.Common}, {%{EH}Base.Opts}, {%{EH}GrinCode})
%%]
%%[(8 codegen grin) hs import({%{EH}GrinCode.Common} hiding (Variable(..)), {%{EH}Config}, {%{EH}Silly})
%%]
%%[(8 codegen grin) hs import({%{EH}Cil.Common})
%%]

%%[(8 codegen grin)
WRAPPER GrAGItf
%%]

%%[(8 codegen grin) hs
grin2cil :: HptMap -> GrModule -> EHCOpts -> Assembly
grin2cil hptmap gr opts
  = let t = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf gr)) (Inh_GrAGItf)
   in cilAssembly_Syn_GrAGItf t

%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Code generation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%[(8 codegen grin)

ATTR GrAGItf GrModule [ | | cilAssembly : {Assembly} ]

ATTR GrGlobal GrGlobalL
  [
  |
  | cilFields USE {++} {[]} : {[FieldDef]}
    cilValues USE {++} {[]} : {[MethodDecl]}
  ]

ATTR GrBind GrBindL [ | | cilMethods USE {++} {[]} : {[MethodDef]} ]

ATTR GrExpr GrPatLam GrVal GrValL GrTag [ | | cilCode USE {++} {[]} : {[MethodDecl]} ]

ATTR GrExpr GrPatLam [ | | locals USE {++} {[]} : {[Local]} ]

ATTR AllNT [ | | self : SELF ]

ATTR AllNTNoMod
 [ className : {DottedName}
   grintags : {AssocL HsName GrinTag}
 |
 | thunks USE {++} {[]} : GrTagL
 ]


SEM GrModule
  | Mod lhs.cilAssembly = Assembly [] "EhcGenerated" (@loc.classDef : @loc.typeDefs)
        loc.classDef    = classDef Public @loc.className noExtends [] @globalL.cilFields (@loc.mainDef : @loc.initialize : @bindL.cilMethods) []
        loc.mainDef     = Method Static AssemblyVisible Void "AssemblyMain" [] $
                            [ entryPoint
                            , call StaticCallConv Void "" @loc.className "initialize" []
                            , call StaticCallConv Object "" @loc.className "fun_main" []
                            , isinst (str2DottedName "Int")
                            , ldfld Int32 "" (str2DottedName "Int") "Value"
                            , call StaticCallConv Void "mscorlib" "System.Console" "WriteLine" [Int32]
                            , ret
                            ]
                            ++ map (comment . show) @globalL.thunks
        loc.initialize   = Method Static Private Void "initialize" [] (@globalL.cilValues ++ [ret])
        loc.grintagsMp    = map (second (map (second ctag2grintag))) @ctagsMp
        loc.typeDefs     = map grintagTypeDef @grintagsMp
        loc.className    = hsn2TypeDottedName @moduleNm
        globalL.className = @loc.className
        bindL.className   = @loc.className
        -- pass ctag mapping without type names
        loc.grintags      = concatMap snd @grintagsMp
        globalL.grintag   = @loc.grintags
        bindL.grintags    = @loc.grintags


SEM GrGlobal
  | Global lhs.cilFields = [ Field Static AssemblyVisible Object @loc.name ]
           lhs.cilValues = @val.cilCode ++
                           [ stfld Object "" @lhs.className @loc.name ]
           loc.name      = hsnShowAlphanumeric @nm

SEM GrBind
  | Bind  lhs.cilMethods  = [Method Static AssemblyVisible Object (hsnShowAlphanumeric @nm) @loc.params @loc.cilCode]
          loc.params      = map (Param Object . hsnShowAlphanumeric) @argNmL
          loc.cilCode     = localsInit @expr.locals : @expr.cilCode ++ [ret]


SEM GrExpr
  | Seq         lhs.cilCode = @expr.cilCode ++ @pat.cilCode ++ @body.cilCode
  | Unit        lhs.cilCode = debugComment @self @val.cilCode
  | UpdateUnit  lhs.cilCode = [no @self]
  | Case        lhs.cilCode = [no @self]
  | FetchNode   lhs.cilCode = [no @self]
  | FetchUpdate lhs.cilCode = [no @self]
  | FetchField  lhs.cilCode = [no @self]
  | Store       lhs.cilCode = [no @self]
  | Call        lhs.cilCode = [no @self]
  | FFI         lhs.cilCode = debugComment @self $ @argL.cilCode ++ ffcall @nm
  | Eval        lhs.cilCode = [no @self]
  | App         lhs.cilCode = [no @self]
  | Throw       lhs.cilCode = [no @self]
  | Catch       lhs.cilCode = [no @self]


SEM GrVal
  | Empty       lhs.cilCode = debugComment @self [newobj "" (str2DottedName "comma0") []]
  | LitInt      lhs.cilCode = debugComment @self [ldc_i4 @int]
  | Tag         lhs.cilCode = [no @self]
  | Var         lhs.cilCode = debugComment @self $ [ldlocN $ hsnShowAlphanumeric @nm]
  | Node        lhs.cilCode = debugComment @self $ @fldL.cilCode ++ @tag.cilCode
  | VarNode     lhs.cilCode = [no @self]
  | BasicNode   lhs.cilCode = debugComment @self $ [ldlocN $ hsnShowAlphanumeric @nm] ++ @tag.cilCode
  | EnumNode    lhs.cilCode = [no @self]
  | OpaqueNode  lhs.cilCode = [no @self]
  | PtrNode     lhs.cilCode = [no @self]
  -- TODO NodeAdapt in variant 10


SEM GrPatLam
  | Empty       lhs.cilCode = debugComment @self []
  | Var         lhs.cilCode = debugComment @self [stlocN @varName]
                lhs.locals  = [Local Object @varName]
  | VarNode     lhs.cilCode = [no @self]
  | BasicNode   lhs.cilCode = debugComment @self [ldfld Int32 "" (str2DottedName "Int") "Value", stlocN @varName]
                lhs.locals  = [Local Int32 @varName]
  | EnumNode    lhs.cilCode = [no @self]
  | PtrNode     lhs.cilCode = [no @self]
  | OpaqueNode  lhs.cilCode = [no @self]
  | BasicAnnot  lhs.cilCode = debugComment @self [stlocN @varName]
                loc.locals  = [Local Int32 @varName]
  | EnumAnnot   lhs.cilCode = [no @self]
  | PtrAnnot    lhs.cilCode = [no @self]
  | OpaqueAnnot lhs.cilCode = [no @self]
  | * - VarNode Empty
                loc.varName = hsnShowAlphanumeric @nm


SEM GrTag
  | Con         lhs.cilCode = debugComment @self [newobj "" (grintag2ConstrDottedName $ @loc.grintag) (grintag2ParamTypes @loc.grintag)]
                loc.grintag = lookupTag @nm @lhs.grintags
  | Fun         lhs.cilCode = [no @self]
  | PApp        lhs.cilCode = [no @self]
  | App         lhs.cilCode = [no @self]
  | Unboxed     lhs.cilCode = [no @self]
  | Hole        lhs.cilCode = [no @self]
  | Rec         lhs.cilCode = [no @self]
  | World       lhs.cilCode = [no @self]
  | Any         lhs.cilCode = [no @self]
  | *           lhs.thunks  = [ @self ]
%%]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Helper functions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%[(8 codegen grin) hs

no a = comment $ "TODO   " ++ show a

-- Idea: replace debugComment in the AG by an attribute that gets initialized
-- to debugComment or fakeComment, according to some compiler option.
type DebugComment = Show a => a -> [MethodDecl] -> [MethodDecl]
debugComment, fakeComment :: DebugComment
debugComment a []  = [comment $ "NOP    " ++ show a]
debugComment a [m] = [comment $ "SINGLE " ++ show a, m]
debugComment a ms  = [comment $ "BEGIN  " ++ show a]
                     ++ ms ++
                     [comment $ "END    " ++ show a]
fakeComment = flip const

ffcall :: String -> [MethodDecl]
ffcall "primAddInt" = [add]

-- TODO this function should already exists somewhere else. Use that one.
lookupTag :: HsName -> AssocL HsName GrinTag -> GrinTag
lookupTag n ts = case lookup n ts of
  Nothing -> error $ "Use of an undefined tag " ++ show n ++ "."
  Just t  -> t

%%]
