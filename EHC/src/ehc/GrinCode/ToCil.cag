%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[(8 codegen grin) hs module {%{EH}GrinCode.ToCil} export(grin2cil)
%%]
%%[(8 codegen grin) hs import(Language.Cil)
%%]

%%[(8 codegen grin) ag import({GrinCode/AbsSyn})
%%]

%%[(8 codegen grin) hs import(Debug.Trace)
%%]
%%[(8 codegen grin) hs import(Data.List((\\), nub), Data.Maybe (maybe, isJust, fromJust), qualified Data.Map as Map, qualified Data.Set as Set, Data.Bits)
%%]
%%[(8 codegen grin) hs import(Control.Arrow(first, second))
%%]
%%[(8 codegen grin) hs import(EH.Util.Pretty, EH.Util.Utils)
%%]
%%[(8 codegen grin) hs import({%{EH}Base.Common}, {%{EH}Base.Opts}, {%{EH}GrinCode})
%%]
%%[(8 codegen grin) hs import({%{EH}GrinCode.Common} hiding (Variable(..)), {%{EH}Config}, {%{EH}Silly})
%%]
%%[(8 codegen grin) hs import({%{EH}Cil.Common}, {%{EH}Cil.TyTag})
%%]

%%[(8 codegen grin)
WRAPPER GrAGItf
WRAPPER GrTag
%%]

%%[(8 codegen grin) hs
grin2cil :: HptMap -> GrModule -> EHCOpts -> Assembly
grin2cil hptmap gr opts
  = let t = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf gr)) (Inh_GrAGItf)
   in cilAssembly_Syn_GrAGItf t

%%]

%%[(8 codegen grin) hs

data Scope = GlobalVar | LocalVar | Parameter

data VarInfo = VarInfo
  { varScope :: Scope
  , varType  :: TyTag
  }

%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Code generation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%[(8 codegen grin)

ATTR GrAGItf GrModule [ | | cilAssembly : {Assembly} ]

ATTR GrGlobal GrGlobalL
  [
  |
  | cilFields USE {++} {[]} : {[FieldDef]}
    cilValues USE {++} {[]} : {[MethodDecl]}
    grValues  USE {`Map.union`} {Map.empty} : {Map.Map HsName GrVal}
  ]

ATTR GrBind GrBindL
  [
  |
  | cilMethods USE {++} {[]} : {[MethodDef]}
  ]

ATTR GrExpr GrPatLam GrVal GrValL GrAlt GrAltL GrPatAlt [ | | cilCode USE {++} {[]} : {[MethodDecl]} ]

ATTR GrTag
  [
  |
  | constCode USE {++} {[]} : {[MethodDecl]} -- code to construct this tag
    matchCode USE {++} {[]} : {[MethodDecl]} -- code to match this tag
    tyTag                   : {TyTag}
  ]

ATTR GrVar GrVarL
  [
  |
  | names USE {++} {[]} : {[HsName]}
  ]

ATTR AllExpr --GrExpr GrPatLam
  [ scopes : {Map.Map HsName Scope}  -- In the future, this will contain all useful information for all variables.
  |
  | typedLocals   USE {`Map.union`} {Map.empty} : {Map.Map HsName PrimitiveType}
    untypedLocals USE {`Set.union`} {Set.empty} : {Set.Set HsName}
  ]

ATTR GrAlt GrAltL [ caseLabel : {String} | | ]

ATTR AllNT [ | labels : {[Label]} | self : SELF ]

ATTR AllNTNoMod
  [ className : {DottedName}
    globals : {Map.Map HsName TyTag} -- In the future this will contain all globals, now just the thunks
    constrs : {Map.Map HsName TyTag}
  |
  | grTags USE {`Map.union`} {Map.empty} : {Map.Map HsName GrTag}
  ]


SEM GrAGItf
  | AGItf  module.labels = map (('L':) . show) (iterate (+1) 0)


SEM GrModule
  | Mod lhs.cilAssembly   = Assembly [] "EhcGenerated" (@loc.classDef : @loc.typeDefs)
        loc.classDef      = classDef Public @loc.className noExtends noImplements @globalL.cilFields
                              (@loc.mainDef : @loc.initialize : @bindL.cilMethods) []
        loc.className     = hsn2TypeDottedName @moduleNm
        loc.mainDef       = Method Static AssemblyVisible Void "AssemblyMain" []
                            [ entryPoint
                            , call StaticCallConv Void "" @loc.className "initialize" []
                            , call StaticCallConv Object "" @loc.className "fun_main" []
                            , isinst (toConDottedName intTyTag)
                            , ldfld Int32 "" (toConDottedName intTyTag) (toFieldName intTyTag 0)
                            , call StaticCallConv Void "mscorlib" "System.Console" "WriteLine" [Int32]
                            , ret
                            ]
        loc.initialize    = Method Static Private Void "initialize" []
                              (@globalL.cilValues ++ [ret])
        loc.typeDefs      = toTypeDefs @loc.className @loc.tyTags

        bindL.className   = @loc.className
        bindL.globals     = @loc.globals
        bindL.constrs     = @loc.constrs
        globalL.className = @loc.className
        globalL.globals   = @loc.globals
        globalL.constrs   = @loc.constrs

        loc.ctyTags       = concatMap (map (fromCTag . snd) . snd) @ctagsMp
        loc.tyNames       = foldr (\(TyCon tnm cnm _ _ _) m -> Map.insert cnm tnm m) Map.empty @loc.ctyTags
        loc.constrs       = foldr (\t@(TyCon tnm cnm _ _ _) m -> Map.insert cnm t m) Map.empty @loc.ctyTags
        loc.tyTags        = nub (@loc.ctyTags ++ Map.elems @loc.globals)
        loc.globals       = Map.foldWithKey (globals @loc.tyNames @loc.grTags) Map.empty @globalL.grValues
        loc.grTags        = @globalL.grTags `Map.union` @bindL.grTags


{
globals :: Map.Map HsName HsName -> Map.Map HsName GrTag -> HsName -> GrVal
             -> Map.Map HsName TyTag -> Map.Map HsName TyTag
globals tyNames grTags nm grValue tyTags =
  case grValue of
    (GrVal_Node (GrTag_Fun fnm) _) ->
      case Map.lookup nm grTags of
        (Just (GrTag_Con _ _ cnm)) ->
          case Map.lookup cnm tyNames of
            (Just tyNm) -> Map.insert nm (TyFun tyNm fnm) tyTags
            _    -> tyTags
        _ -> tyTags
    _ -> tyTags
}

SEM GrGlobal
  | Global lhs.cilFields = [ Field Static AssemblyVisible Object @loc.name ]
           lhs.cilValues = @val.cilCode ++
                           [ stsfld Object "" @lhs.className @loc.name ]
           loc.name      = hsnShowAlphanumeric @nm
           lhs.grValues  = Map.singleton @nm @val.self
           val.scopes    = error "Should not use variables"

SEM GrBind
  | Bind  lhs.cilMethods  = [Method Static AssemblyVisible Object (hsnShowAlphanumeric @nm) @loc.params @loc.cilCode]
          loc.params      = map (Param Object . hsnShowAlphanumeric) @argNmL
          loc.cilCode     = localsInit @loc.locals : @expr.cilCode ++ [ret]
          expr.scopes     = buildScopes (Map.keys @lhs.globals) (Map.keys @loc.localsMap) @argNmL
          lhs.grTags      = Set.fold Map.delete @expr.grTags @expr.untypedLocals
          loc.locals      = Map.foldWithKey (\nm pt xs -> Local pt (hsnShowAlphanumeric nm) : xs) [] @loc.localsMap
          loc.localsMap   = @expr.typedLocals
                              `Map.union`
                              Set.fold (\nm m -> maybe m (\pt -> Map.insert nm (grTag2primType pt) m)
                                                       (Map.lookup nm @expr.grTags))
                                       Map.empty @expr.untypedLocals


SEM GrExpr
  | Seq         lhs.cilCode = @expr.cilCode ++ @pat.cilCode ++ @body.cilCode
  | Unit        lhs.cilCode = debugComment @self @val.cilCode
  | UpdateUnit  lhs.cilCode = [no @self]
  | Case        lhs.cilCode = debugComment ("Case on " ++ show @val.self) $
                              @val.cilCode
                              ++ @altL.cilCode
                              ++ [label @loc.caseLabel nop]
                loc.caseLabel   = head @lhs.labels
                altL.caseLabel  = @loc.caseLabel
                altL.labels = Prelude.tail @lhs.labels
  | FetchNode   lhs.cilCode = [no @self]
  | FetchUpdate lhs.cilCode = [no @self]
  | FetchField  lhs.cilCode = debugComment @self
                              @loc.load ++ @doField
                loc.load    = case fromJust $ Map.lookup @nm @lhs.scopes of
                              LocalVar  ->  [ldlocN @loc.varName]
                              GlobalVar ->  [ldsfld Object "" @lhs.className @loc.varName]
                              Parameter ->  [ldargN @loc.varName]
                loc.doField = case @offset of
                              0 ->  [] 
                              o ->  [ isinst $ toConDottedName @loc.tyTag
                                    , ldfld (toFieldTypes @loc.tyTag !! (o - 1))
                                            ""
                                            (toConDottedName @loc.tyTag)
                                            (toFieldName @loc.tyTag (o - 1))
                                    ]
                loc.tyTag  = maybe (error "Cannot fetch field of unknown tag")
                                   (\(GrTag_Con _ _ nm) -> lookupTag nm @lhs.constrs)
                                   @mbTag
                lhs.grTags  = maybe Map.empty (Map.singleton @nm) @mbTag
  | Store       lhs.cilCode = [no @self]
  | Call        lhs.cilCode = [no @self]
  | FFI         lhs.cilCode = debugComment @self $ @argL.cilCode ++ ffcall @nm
  | Eval        lhs.cilCode = [no @self]
  | App         lhs.cilCode = [no @self]
  | Throw       lhs.cilCode = [no @self]
  | Catch       lhs.cilCode = [no @self]
  | UpdateUnit FetchNode FetchField Call Eval App Throw
                loc.varName = hsnShowAlphanumeric @nm

SEM GrAlt
  | Alt         lhs.cilCode   = debugComment @self $ 
                                  @pat.cilCode -- should return a boolean-like
                                  ++ [brfalse @loc.label]
                                  ++ @loc.exprCode
                                  ++ [br @lhs.caseLabel]
                                  ++ [label @loc.label nop]
                loc.exprCode  = case @ann of
                                  GrAltAnnIdent   -> []
                                  GrAltAnnReenter -> [no "Reenter Alt"]
                                  _               -> @expr.cilCode
                loc.label     = head @lhs.labels
                lhs.labels    = Prelude.tail @lhs.labels


SEM GrPatAlt
  | Tag         lhs.cilCode = debugComment @self @tag.matchCode
  | * - Tag     lhs.cilCode = [no @self]


SEM GrVal
  | Empty       lhs.cilCode = debugComment @self [newobj "" (toConDottedName unitTyTag) []]
  | LitInt      lhs.cilCode = debugComment @self [ldc_i4 @int]
  | Tag         lhs.cilCode = [no @self]
  | Var         lhs.cilCode = debugComment @self $ [ if isJust (Map.lookupIndex @nm @lhs.globals)
                                                     then ldsfld Object "" @lhs.className (hsnShowAlphanumeric @nm)
                                                     else ldlocN (hsnShowAlphanumeric @nm)]
  | Node        lhs.cilCode = debugComment @self $ @fldL.cilCode ++ @tag.constCode
  | VarNode     lhs.cilCode = [no @self]
  | BasicNode   lhs.cilCode = debugComment @self $ [ldlocN $ hsnShowAlphanumeric @nm] ++ @tag.constCode
  | EnumNode    lhs.cilCode = [no @self]
  | OpaqueNode  lhs.cilCode = [no @self]
  | PtrNode     lhs.cilCode = [no @self]
  -- TODO NodeAdapt in variant 10

SEM GrVar
  | Var         lhs.names = [@nm]

SEM GrPatLam
  | Empty       lhs.cilCode = debugComment @self []
  | Var         lhs.cilCode = debugComment @self [stlocN @varName]
                lhs.typedLocals = Map.singleton @nm Object
  | VarNode     lhs.cilCode = [no @self]
                lhs.untypedLocals = Set.fromList @fldL.names
  | BasicNode   lhs.cilCode = debugComment @self [ldfld Int32 "" (toConDottedName intTyTag) (toFieldName intTyTag 0), stlocN @varName]
                lhs.typedLocals = Map.singleton @nm Int32
  | EnumNode    lhs.cilCode = [no @self]
  | PtrNode     lhs.cilCode = [no @self]
  | OpaqueNode  lhs.cilCode = [no @self]
  | BasicAnnot  lhs.cilCode = debugComment @self [stlocN @varName]
                loc.typedLocals = Map.singleton @nm Int32
  | EnumAnnot   lhs.cilCode = [no @self]
  | PtrAnnot    lhs.cilCode = [no @self]
  | OpaqueAnnot lhs.cilCode = [no @self]
  | * - VarNode Empty
                loc.varName = hsnShowAlphanumeric @nm


SEM GrTag
  | Con         lhs.constCode = debugComment @self [newobj "" (toConDottedName @loc.tyTag) (toFieldTypes @loc.tyTag)]
                lhs.matchCode = debugComment @self [dup, isinst @loc.tyName]
                loc.tyTag     = lookupTag @nm @lhs.constrs
                loc.tyName    = toConDottedName @loc.tyTag
                lhs.tyTag     = @loc.tyTag
  | Fun         lhs.constCode = debugComment @self [newobj "" (toConDottedName @loc.tyTag) []]
                lhs.matchCode = [no @self]
                loc.tyTag     = head [ty | ty@(TyFun _ fnm) <- Map.elems @lhs.globals, fnm == @nm]
  | PApp        lhs.constCode = [no @self]
                lhs.matchCode = [no @self]
  | App         lhs.constCode = [no @self]
                lhs.matchCode = [no @self]
  | * - Con     lhs.tyTag     = error "Blegh"
  | Unboxed Hole Rec World Any
                lhs.constCode = [no @self]
                lhs.matchCode = [no @self]
%%]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Helper functions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%[(8 codegen grin) hs

no a = comment $ "TODO   " ++ show a

-- Idea: replace debugComment in the AG by an attribute that gets initialized
-- to debugComment or fakeComment, according to some compiler option.
type DebugComment = Show a => a -> [MethodDecl] -> [MethodDecl]
debugComment, fakeComment :: DebugComment
debugComment a []  = [comment $ "NOP    " ++ show a]
debugComment a [m] = [comment $ "SINGLE " ++ show a, m]
debugComment a ms  = [comment $ "BEGIN  " ++ show a]
                     ++ ms ++
                     [comment $ "END    " ++ show a]
fakeComment = flip const

ffcall :: String -> [MethodDecl]
ffcall "primAddInt" = [add]

buildScopes :: [HsName] -> [HsName] -> [HsName] -> Map.Map HsName Scope
buildScopes gs ls ps = Map.unions [mup GlobalVar gs, mup LocalVar ls, mup Parameter ps]
  where mup s = foldr (flip Map.insert s) Map.empty

-- TODO this function should already exists somewhere else. Use that one.
lookupTag :: HsName -> Map.Map HsName TyTag -> TyTag
lookupTag n ts = case Map.lookup n ts of
  Nothing -> error $ "Use of an undefined tag " ++ show n ++ "." ++ show ts
  Just t  -> t

funTyTag :: GrTag -> GrVal -> TyTag
funTyTag (GrTag_Con _ _ nm) (GrVal_Node (GrTag_Fun fnm) _) = undefined

grTag2primType :: GrTag -> PrimitiveType
grTag2primType (GrTag_Con _ _ nm) =
  case hsnShowAlphanumeric nm of
    "Int"          -> Int32
    "Char"         -> Char
    "PackedString" -> String
    _              -> Object


type GrTagAttr a = Syn_GrTag -> a

grTag2tyTag = grTag2A tyTag_Syn_GrTag

grTag2A :: GrTagAttr a -> String -> Map.Map HsName TyTag -> Map.Map HsName TyTag -> [Label] -> Map.Map HsName Scope -> GrTag -> a
grTag2A f cls constrs globals labels scopes tg =
  let t = wrap_GrTag (sem_GrTag tg)
                     (Inh_GrTag { className_Inh_GrTag = cls
                                , constrs_Inh_GrTag   = constrs
                                , globals_Inh_GrTag   = globals
                                , labels_Inh_GrTag    = labels
                                , scopes_Inh_GrTag    = scopes
                                })
  in f t



%%]
