%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[(8 codegen grin) hs module {%{EH}GrinCode.ToCil} export(grin2cil)
%%]
%%[(8 codegen grin) hs import(Language.Cil hiding(tail))
%%]

%%[(8 codegen grin) ag import({GrinCode/AbsSyn})
%%]

%%[(8 codegen grin) hs import(Debug.Trace)
%%]
%%[(8 codegen grin) hs import(Data.List((\\), nub), Data.Maybe (maybe, isJust, fromJust), qualified Data.Map as Map, Data.Map (Map), qualified Data.Set as Set, Data.Set (Set), Data.Bits)
%%]
%%[(8 codegen grin) hs import(Control.Arrow(first, second))
%%]
%%[(8 codegen grin) hs import(EH.Util.Pretty, EH.Util.Utils)
%%]
%%[(8 codegen grin) hs import({%{EH}Base.Common}, {%{EH}Base.Opts}, {%{EH}GrinCode})
%%]
%%[(8 codegen grin) hs import({%{EH}GrinCode.Common} hiding (Variable(..)), {%{EH}Config}, {%{EH}Silly})
%%]
%%[(8 codegen grin) hs import({%{EH}Cil.Common}, {%{EH}Cil.TyTag})
%%]

%%[(8 codegen grin)
WRAPPER GrAGItf
WRAPPER GrTag
%%]

%%[(8 codegen grin) hs
grin2cil :: HptMap -> GrModule -> EHCOpts -> Assembly
grin2cil hptMap gr opts
  = let t = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf gr)) (Inh_GrAGItf hptMap)
   in cilAssembly_Syn_GrAGItf t

refObjNm :: DottedName
refObjNm = hsn2TypeDottedName (HNm "ReferenceObject")

refObj :: TypeDef
refObj = 
  classDef Public refObjNm noExtends noImplements
    [ Field Instance2 Public Object "Value" ]
    [ Constructor Public [ Param Object "value" ]
        [ ldarg 0
        , call Instance Void "" "object" ".ctor" []
        , ldarg 0
        , ldarg 1
        , stfld Object "" refObjNm "Value"
        , ret
        ]
    ]
    []

loadRefVal :: MethodDecl
loadRefVal = ldfld Object "" refObjNm "Value"

storeRefVal :: MethodDecl
storeRefVal = stfld Object "" refObjNm "Value"

newRefObj :: MethodDecl
newRefObj = newobj "" refObjNm [Object]

%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Code generation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%[(8 codegen grin)

ATTR GrAGItf AllNT
  [ hptMap : {HptMap}
  |
  |
  ]

ATTR GrAGItf GrModule
  [
  |
  | cilAssembly : {Assembly}
  ]

ATTR GrGlobal GrGlobalL
  [
  |
  | cilFields USE {++} {[]} : {[FieldDef]}
    cilValues USE {++} {[]} : {[MethodDecl]}
  ]

ATTR GrBind GrBindL
  [
  |
  | cilMethods USE {++} {[]} : {[MethodDef]}
  ]

ATTR GrExpr GrPatLam GrVal GrValL GrAlt GrAltL GrPatAlt
  [
  |
  | cilCode USE {++} {[]} : {[MethodDecl]}
  ]

ATTR GrTag
  [
  |
  | cilMatch USE {++} {[]} : {[MethodDecl]} -- code to match this tag
  ]

ATTR GrTag GrVal
  [
  |
  | cilConst USE {++} {[]} : {[MethodDecl]} -- code to construct this tag
  ]

ATTR GrVar GrVarL
  [ index     : {Int}
    nodeTyTag : {TyTag}
  |
  | cilLoad USE {++} {[]} : {[MethodDecl]}
    tyTag     : {TyTag}
  ]

ATTR AllExpr
  [ methodParams : {Set HsName}
  |
  | locals USE {`Set.union`} {Set.empty} : {Set.Set HsName}
  ]

ATTR GrAlt GrAltL
  [ caseStartLabel : {String}
    caseEndLabel   : {String}
  |
  |
  ]

ATTR GrValL
  [
  |
  | cilConsts : {[[MethodDecl]]}
    cilCodes  : {[[MethodDecl]]}
  ]

ATTR AllNT
  [
  | labels    : {[Label]}
  | self      : SELF
  ]

ATTR AllNTNoMod
  [ className : {DottedName}
    grTagsMap : {Map GrTag TyTag}
  |
  | allCons  USE {`Set.union`} {Set.empty} : {Set.Set GrTag}
    allFuns  USE {`Set.union`} {Set.empty} : {Set.Set GrTag}
    allPApps USE {`Set.union`} {Set.empty} : {Set.Set GrTag}
  ]


SEM GrAGItf
  | AGItf  module.labels = map (('L':) . show) (iterate (+1) 0)


SEM GrModule
  | Mod lhs.cilAssembly   = Assembly [] "EhcGenerated" (@loc.classDef : refObj : @loc.typeDefs)
        loc.classDef      = classDef Public @loc.className noExtends noImplements @globalL.cilFields
                              (@loc.mainDef : @loc.initialize : @bindL.cilMethods) []
        loc.className     = hsn2TypeDottedName @moduleNm
        loc.mainDef       = Method Static AssemblyVisible Void "AssemblyMain" []
                            [ entryPoint
                            , call StaticCallConv Void "" @loc.className "initialize" []
                            , call StaticCallConv Object "" @loc.className "fun_main" []
                            , loadRefVal
                            , isinst (toConDottedName intTyTag)
                            , ldfld Int32 "" (toConDottedName intTyTag) (toFieldName intTyTag 0)
                            , call StaticCallConv Void "mscorlib" "System.Console" "WriteLine" [Int32]
                            , ret
                            ]
        loc.initialize    = Method Static Private Void "initialize" []
                              (@globalL.cilValues ++ [ret])
        loc.typeDefs      = toTypeDefs @loc.className (Map.elems @loc.grTagsMap)

        globalL.grTagsMap = @loc.grTagsMap
        bindL.grTagsMap   = @loc.grTagsMap

        loc.usedCtyTags   = filter (\tytag -> toConName tytag `elem` @loc.usedConNms) @loc.ctyTags
        loc.ctyTags       = concatMap (map (fromCTag . snd) . snd) @ctagsMp

        loc.grTagsMap     = @loc.cons `Map.union` @loc.funs `Map.union` @loc.papps

        loc.cons          = Set.fold (\cntag@(GrTag_Con _ _ nm) mp -> maybe mp (\ty -> Map.insert cntag ty mp) (Map.lookup nm @loc.constrs)) Map.empty @bindL.allCons

        loc.funs          = Set.fold (\fntag@(GrTag_Fun nm) mp -> maybe (maybe mp (\ty -> Map.insert fntag (TyFun (toTypeName ty) nm) mp) (Map.lookup (absGrTag nm @lhs.hptMap) @loc.papps)) (\tynm -> Map.insert fntag (TyFun tynm nm) mp) (Map.lookup (conName (absGrTag nm @lhs.hptMap)) @loc.tyNames)) Map.empty @bindL.allFuns

        loc.papps         = Set.fold (\patag@(GrTag_PApp needs nm) mp -> maybe mp (\tynm -> Map.insert patag (TyPApp tynm nm needs) mp) (Map.lookup (conName (absGrTag nm @lhs.hptMap)) @loc.tyNames)) Map.empty @bindL.allPApps

        loc.tyNames       = foldr (\(TyCon tnm cnm _ _ _) m -> Map.insert cnm tnm m) Map.empty @loc.ctyTags
        loc.constrs       = foldr (\t@(TyCon tnm cnm _ _ _) m -> Map.insert cnm t m) Map.empty @loc.ctyTags
        loc.usedConNms    = map conName (Set.toList @bindL.allCons)

        bindL.className   = @loc.className
        globalL.className = @loc.className

SEM GrGlobal
  | Global lhs.cilFields = [ Field Static AssemblyVisible Object @loc.name ]
           lhs.cilValues = @val.cilCode ++
                           [ stsfld Object "" @lhs.className @loc.name ]
           val.methodParams = Set.empty
           loc.name      = hsnShowAlphanumeric @nm

SEM GrBind
  | Bind  lhs.cilMethods  = [Method Static AssemblyVisible Object (hsnShowAlphanumeric @nm) @loc.params @loc.cilCode]
          expr.methodParams = Set.fromList @argNmL
          loc.params      = map (Param Object . hsnShowAlphanumeric) @argNmL
          loc.cilCode     = localsInit @loc.locals : @expr.cilCode ++ [ret]
          loc.locals      = Set.fold (\nm xs -> Local (absPrimitiveType nm @lhs.hptMap) (hsnShowAlphanumeric nm) : xs) [] @expr.locals -- undefined -- @expr.typedLocals


SEM GrExpr
  | Seq         lhs.cilCode = @expr.cilCode ++ @pat.cilCode ++ @body.cilCode
  | Unit        lhs.cilCode = debugComment @self @val.cilCode
  | UpdateUnit  lhs.cilCode = debugComment @self $ @loc.load ++ @val.cilCode ++ [loadRefVal, storeRefVal] ++ @loc.load
                loc.load    = loadVar @lhs.className @lhs.methodParams @nm
  | Case        lhs.cilCode = debugComment ("Case on " ++ show @val.self) $
                              @val.cilCode
                              ++ [label @loc.caseStartLabel nop]
                              ++ @altL.cilCode
                              ++ [label @loc.caseEndLabel nop]
                loc.caseStartLabel  = head @lhs.labels
                val.labels          = tail @lhs.labels
                loc.caseEndLabel    = head @altL.labels
                lhs.labels          = tail @altL.labels
                altL.caseStartLabel = @loc.caseStartLabel
                altL.caseEndLabel   = @loc.caseEndLabel
  | FetchNode   lhs.cilCode = [no @self]
  | FetchUpdate lhs.cilCode = [no @self]
  | FetchField  lhs.cilCode = debugComment @self $
                                @loc.load ++ @doField
                loc.load    = loadVar @lhs.className @lhs.methodParams @nm
                loc.doField = case @offset of
                              0 -> [] 
                              o -> [ loadRefVal
                                   -- , isinst $ toConDottedName @loc.tyTag
                                   , ldfld (toFieldTypes @loc.tyTag !! (o - 1))
                                           ""
                                           (toConDottedName @loc.tyTag)
                                           (toFieldName @loc.tyTag (o - 1))
                                   ]
                loc.tyTag   = case @mbTag of
                              Nothing  -> error "Cannot fetch field of unknown type"
                              Just tag -> lookupTag tag @lhs.grTagsMap
  | Store       lhs.cilCode = [no @self]
  | Call        lhs.cilCode = debugComment @self $ @argL.cilCode ++ [call StaticCallConv Object "" @lhs.className @loc.varName @loc.params]
                loc.params  = replicate (length @argL.self) Object
  | FFI         lhs.cilCode = debugComment @self $ @argL.cilCode ++ ffcall @nm
  | Eval        lhs.cilCode = [no @self]
  | App         lhs.cilCode = [no @self]
  | Throw       lhs.cilCode = [no @self]
  | Catch       lhs.cilCode = [no @self]
  | UpdateUnit FetchNode FetchField Call Eval App Throw
                loc.varName = hsnShowAlphanumeric @nm

SEM GrAlt
  | Alt         lhs.cilCode   = debugComment @self $ 
                                  @pat.cilCode -- should return a boolean-like
                                  ++ [brfalse @loc.label]
                                  ++ @loc.exprCode
                                  ++ [label @loc.label nop]
                loc.exprCode  = case @ann of
                                  GrAltAnnIdent   -> [br @lhs.caseEndLabel]
                                  GrAltAnnReenter -> [pop] ++ @expr.cilCode ++ [br @lhs.caseStartLabel]
                                  _               -> [pop] ++ @expr.cilCode ++ [br @lhs.caseEndLabel]
                loc.label     = head @lhs.labels
                pat.labels    = tail @lhs.labels


SEM GrPatAlt
  | Tag         lhs.cilCode = debugComment @self @tag.cilMatch
  | * - Tag     lhs.cilCode = [no @self]


SEM GrVal
  | Empty       lhs.cilCode = debugComment @self [newobj "" (toConDottedName unitTyTag) [], newRefObj]
  | LitInt      lhs.cilCode = debugComment @self [ldc_i4 @int]
  | Tag         lhs.cilCode = [no @self]
                lhs.cilConst = @tag.cilConst
                -- lhs.cilConst = undefined
                -- loc.tyTag   = grTag2tyTag @tag
  | Var         lhs.cilCode = debugComment @self $ loadVar @lhs.className @lhs.methodParams @nm
  | Node        lhs.cilCode = debugComment @self $ @fldL.cilCode ++ @tag.cilConst
  | VarNode     lhs.cilCode = debugComment @self $ (concat (tail @fldL.cilCodes)) ++ head @fldL.cilConsts
  | BasicNode   lhs.cilCode = debugComment @self $ loadVar @lhs.className @lhs.methodParams @nm ++ @tag.cilConst
  | EnumNode    lhs.cilCode = [no @self]
  | OpaqueNode  lhs.cilCode = [no @self]
  | PtrNode     lhs.cilCode = [no @self]
  | * - Tag     lhs.cilConst = [no $ "cilConst not defined on " ++ show @self]
  -- TODO NodeAdapt in variant 10

SEM GrValL  -- shouldn't this be GrVarL?
  | Nil         lhs.cilConsts = []
                lhs.cilCodes  = []
  | Cons        lhs.cilConsts = @hd.cilConst : @tl.cilConsts
                lhs.cilCodes  = @hd.cilCode  : @tl.cilCodes

SEM GrVarL
  | Nil
      lhs.tyTag = error "Empty VarNode list has no Tag"
  | Cons
      lhs.tyTag = @hd.tyTag
      hd.index  = @lhs.index
      tl.index  = @lhs.index + 1

SEM GrVar
  | Var
      lhs.cilLoad    = if @lhs.index < 0
                       then []
                       else [ ldfld (toFieldTypes @lhs.nodeTyTag !! @lhs.index) "" (toConDottedName @lhs.nodeTyTag)
                                    (toFieldName @lhs.nodeTyTag @lhs.index)
                            , stlocN (hsnShowAlphanumeric @nm) ]
      lhs.tyTag = lookupTag (absGrTag @nm @lhs.hptMap) @lhs.grTagsMap
  | KnownTag
      lhs.tyTag = lookupTag @tag.self @lhs.grTagsMap
  | Ignore
      lhs.tyTag = error "Ignore has no TyTag"

SEM GrPatLam
  | Empty
      lhs.cilCode     = debugComment @self []
  | Var
      lhs.cilCode     = debugComment @self [stlocN @varName]
      lhs.locals      = Set.singleton @nm
  | VarNode
      lhs.cilCode     = debugComment @self (loadRefVal : @fldL.cilLoad)
      fldL.index      = -1
      fldL.nodeTyTag  = @fldL.tyTag
  | BasicNode
      lhs.cilCode     = debugComment @self [loadRefVal, ldfld Int32 "" (toConDottedName intTyTag) (toFieldName intTyTag 0), stlocN @varName]
      lhs.locals      = Set.singleton @nm
  | EnumNode
      lhs.cilCode     = [no @self]
  | PtrNode
      lhs.cilCode     = [no @self]
  | OpaqueNode
      lhs.cilCode     = [no @self]
  | BasicAnnot
      lhs.cilCode     = debugComment @self [stlocN @varName]
      lhs.locals      = Set.singleton @nm
  | EnumAnnot
      lhs.cilCode     = [no @self]
  | PtrAnnot
      lhs.cilCode     = [no @self]
  | OpaqueAnnot
      lhs.cilCode     = [no @self]
  | * - VarNode Empty
      loc.varName     = hsnShowAlphanumeric @nm


SEM GrTag
  | Con         lhs.cilConst  = debugComment @self [newobj "" (toConDottedName @loc.tyTag) (toFieldTypes @loc.tyTag), newRefObj]
                lhs.cilMatch  = debugComment @self [dup, loadRefVal, isinst (toConDottedName @loc.tyTag)]
                lhs.allCons   = Set.singleton @self
                loc.tyTag     = lookupTag @self @lhs.grTagsMap
  | Fun         lhs.cilConst  = debugComment @self [newobj "" (toConDottedName @loc.tyTag) (toFieldTypes @loc.tyTag), newRefObj]
                lhs.cilMatch  = debugComment @self [dup, loadRefVal, isinst (toConDottedName @loc.tyTag)]
                lhs.allFuns   = Set.singleton @self
                loc.tyTag     = lookupTag @self @lhs.grTagsMap
  | PApp        lhs.cilConst  = [no @self]
                lhs.cilMatch  = [no @self]
                lhs.allPApps  = Set.singleton @self
                loc.tyTag     = lookupTag @self @lhs.grTagsMap
  | App         lhs.cilConst  = [no @self]
                lhs.cilMatch  = [no @self]
  | Unboxed Hole Rec World Any
                lhs.cilConst  = [no @self]
                lhs.cilMatch  = [no @self]
%%]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Helper functions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%[(8 codegen grin) hs

absValue :: HsName -> HptMap -> AbstractValue
absValue hsName hptMap = getEnvVar hptMap (getNr hsName) -- Todo: write heap lookup code

absGrTag :: HsName -> HptMap -> GrTag
absGrTag hsName hptMap =
  case absValue hsName hptMap of
    (AbsNodes gav) ->
      if Map.size gav == 1
      then Map.keys gav !! 0
      else error "GrinCode.ToCil.absGrTag: AbsNodes map is not a singleton."
    _ -> error "GrinCode.ToCil.absGrTag: Code not implemented yet, please implement."

absPrimitiveType :: HsName -> HptMap -> PrimitiveType
absPrimitiveType hsName hptMap =
  case absValue hsName hptMap of
    (AbsNodes gav) ->
      if Map.size gav == 1
      then Object
      else error "GrinCode.ToCil.absPrimitiveType: AbsNodes map is not a singleton."
    (AbsBasic) -> Int32
    _ -> error "GrinCode.ToCil.absPrimitiveType: Code not implemented yet, please implement."

no :: (Show a) => a -> MethodDecl
no a = comment $ "TODO   " ++ show a

-- Idea: replace debugComment in the AG by an attribute that gets initialized
-- to debugComment or fakeComment, according to some compiler option.
type DebugComment = Show a => a -> [MethodDecl] -> [MethodDecl]
debugComment, fakeComment :: DebugComment
debugComment a []  = [comment $ "NOP    " ++ show a]
debugComment a [m] = [comment $ "SINGLE " ++ show a, m]
debugComment a ms  = [comment $ "BEGIN  " ++ show a]
                     ++ ms ++
                     [comment $ "END    " ++ show a]
fakeComment = flip const

ffcall :: String -> [MethodDecl]
ffcall "primAddInt" = [add]

loadVar :: DottedName -> Set HsName -> HsName -> [MethodDecl]
loadVar className params nm = case Set.member nm params of
    True          -> [ldargN varName]
    False         -> case nm of
      HNmNr _ (OrigGlobal _) -> [lglobal]
      HNmNr _ (OrigFunc   _) -> error "Cannot load function"
      HNmNr _ _              -> [ldlocN varName]
      _                      -> error "Loading non-HNmNr variable"
  where varName = hsnShowAlphanumeric nm
        lglobal = ldsfld Object "" className varName

lookupTag :: GrTag -> Map GrTag TyTag -> TyTag
lookupTag k mp = Map.findWithDefault (error $ "Tag " ++ show k ++ " not in map: " ++ show mp) k mp

%%]
