%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[(8 codegen grin) hs module {%{EH}GrinCode.ToCil} export(grin2cil)
%%]
%%[(8 codegen grin) hs import(Language.Cil hiding(tail))
%%]

%%[(8 codegen grin) ag import({GrinCode/AbsSyn})
%%]

%%[(8 codegen grin) hs import(Debug.Trace)
%%]
%%[(8 codegen grin) hs import(Data.List((\\), nub), Data.Maybe (maybe, isJust, fromJust), qualified Data.Map as Map, Data.Map (Map), qualified Data.Set as Set, Data.Set (Set), Data.Bits)
%%]
%%[(8 codegen grin) hs import(Control.Arrow(first, second))
%%]
%%[(8 codegen grin) hs import(EH.Util.Pretty, EH.Util.Utils)
%%]
%%[(8 codegen grin) hs import({%{EH}Base.Common}, {%{EH}Base.Opts}, {%{EH}GrinCode})
%%]
%%[(8 codegen grin) hs import({%{EH}GrinCode.Common} hiding (Variable(..)), {%{EH}Config}, {%{EH}Silly})
%%]
%%[(8 codegen grin) hs import({%{EH}Cil.Common}, {%{EH}Cil.TyTag})
%%]

%%[(8 codegen grin)
WRAPPER GrAGItf
WRAPPER GrTag
%%]

%%[(8 codegen grin) hs
grin2cil :: HptMap -> GrModule -> EHCOpts -> Assembly
grin2cil hptMap gr opts
  = let t = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf gr)) (Inh_GrAGItf hptMap)
   in cilAssembly_Syn_GrAGItf t

refObjNm :: DottedName
refObjNm = hsn2TypeDottedName (HNm "ReferenceObject")

refObj :: TypeDef
refObj = 
  classDef Public refObjNm noExtends noImplements
    [ Field Instance2 Public Object "Value" ]
    [ Constructor Public [ Param Object "value" ]
        [ ldarg 0
        , call Instance Void "" "object" ".ctor" []
        , ldarg 0
        , ldarg 1
        , stfld Object "" refObjNm "Value"
        , ret
        ]
    ]
    []

loadRefVal :: MethodDecl
loadRefVal = ldfld Object "" refObjNm "Value"

storeRefVal :: MethodDecl
storeRefVal = stfld Object "" refObjNm "Value"

newRefObj :: MethodDecl
newRefObj = newobj "" refObjNm [Object]

%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Code generation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%[(8 codegen grin)

ATTR GrAGItf AllNT
  [ hptMap : {HptMap}
  |
  |
  ]

ATTR GrAGItf GrModule
  [
  |
  | cilAssembly : {Assembly}
  ]

ATTR GrGlobal GrGlobalL
  [
  |
  | cilFields USE {++} {[]} : {[FieldDef]}
    cilValues USE {++} {[]} : {[MethodDecl]}
  ]

ATTR GrBind GrBindL
  [
  |
  | cilMethods USE {++} {[]} : {[MethodDef]}
    funArities USE {`Map.union`} {Map.empty} : {Map HsName Int}
  ]

ATTR GrExpr GrPatLam GrVal GrValL GrAlt GrAltL GrPatAlt
  [
  |
  | cilCode USE {++} {[]} : {[MethodDecl]}
  ]

ATTR GrTag
  [
  |
  | cilMatch USE {++} {[]} : {[MethodDecl]} -- code to match this tag
  ]

ATTR GrTag GrVal
  [
  |
  | cilConst USE {++} {[]} : {[MethodDecl]} -- code to construct this tag
  ]

ATTR GrVar GrVarL
  [ index     : {Int}
    nodeTyTag : {TyTag}
  |
  | cilLoad USE {++} {[]} : {[MethodDecl]}
    tyTag     : {TyTag}
  ]

ATTR AllExpr
  [ methodParams : {Set HsName}
  |
  | locals USE {`Map.union`} {Map.empty} : {Map DottedName PrimitiveType}
  ]

ATTR GrAlt GrAltL
  [ caseStartLabel : {String}
    caseEndLabel   : {String}
  |
  |
  ]

ATTR GrValL
  [
  |
  | cilConsts : {[[MethodDecl]]}
    cilCodes  : {[[MethodDecl]]}
  ]

ATTR AllNT
  [
  | labels    : {[Label]}
  | self      : SELF
  ]

ATTR AllNTNoMod
  [ className : {DottedName}
    grTagsMap : {Map GrTag TyTag}
  |
  | allCons    USE {`Set.union`} {Set.empty} : {Set GrTag}
    allFuns    USE {`Set.union`} {Set.empty} : {Set GrTag}
    allPApps   USE {`Set.union`} {Set.empty} : {Set GrTag}
  ]


SEM GrAGItf
  | AGItf  module.labels = map (('L':) . show) (iterate (+1) 0)


SEM GrModule
  | Mod lhs.cilAssembly   = Assembly [] "EhcGenerated" (@loc.classDef : refObj : @loc.typeDefs)
        loc.classDef      = classDef Public @loc.className noExtends noImplements @globalL.cilFields
                              (@loc.mainDef : @loc.initialize : @bindL.cilMethods) []
        loc.className     = hsn2TypeDottedName @moduleNm
        loc.mainDef       = Method Static AssemblyVisible Void "AssemblyMain" []
                            [ entryPoint
                            , call StaticCallConv Void "" @loc.className "initialize" []
                            , call StaticCallConv Object "" @loc.className "fun_main" []
                            , loadRefVal
                            , ldfld Int32 "" (toConDottedName intTyTag) (toFieldName intTyTag 0)
                            , call StaticCallConv Void "mscorlib" "System.Console" "WriteLine" [Int32]
                            , ret
                            ]
        loc.initialize    = Method Static Private Void "initialize" []
                              (@globalL.cilValues ++ [ret])
        loc.typeDefs      = toTypeDefs @loc.className (@loc.defaultTyTags ++ Map.elems @loc.grTagsMap)

        globalL.grTagsMap = @loc.grTagsMap
        globalL.className = @loc.className
        bindL.grTagsMap   = @loc.grTagsMap
        bindL.className   = @loc.className

        loc.defaultTyTags = [unitTyTag]
        loc.ctyTags       = concatMap (map (fromCTag . snd) . snd) @ctagsMp

        loc.grTagsMap     = @loc.cons `Map.union` @loc.funs `Map.union` @loc.papps
        loc.cons          = cons @loc.constrs (@bindL.allCons `Set.union` @globalL.allCons)
        loc.funs          = funs @lhs.hptMap @loc.papps @loc.tyNames @bindL.funArities (@bindL.allFuns `Set.union` @globalL.allFuns)
        loc.papps         = papps @lhs.hptMap @loc.tyNames @bindL.funArities (@bindL.allPApps `Set.union` @globalL.allPApps)

        loc.tyNames       = foldr (\(TyCon tnm cnm _ _ _) m -> Map.insert cnm tnm m) Map.empty @loc.ctyTags
        loc.constrs       = foldr (\t@(TyCon tnm cnm _ _ _) m -> Map.insert cnm t m) Map.empty @loc.ctyTags

{
-- These functions create maps from GrTags to TyTags for each con, fun and papp tag in the module.

cons :: Map HsName TyTag -> Set GrTag -> Map GrTag TyTag
cons constrs allCons = Set.fold f Map.empty allCons
  where
    f cntag@(GrTag_Con _ _ nm) mp = maybe mp g (Map.lookup nm constrs)
      where
        g ty = Map.insert cntag ty mp

funs :: HptMap -> Map GrTag TyTag -> Map HsName HsName -> Map HsName Int -> Set GrTag -> Map GrTag TyTag
funs hptMap papps tyNames funArities allFuns = Set.fold f Map.empty allFuns
  where
    arity nm = Map.findWithDefault (error $ "Can't find function " ++ show nm ++ " in arities Map.") nm funArities
    f fntag@(GrTag_Fun nm) mp = maybe g (\tynm -> Map.insert fntag (TyFun tynm nm (arity nm)) mp)
                                        (Map.lookup (conName (absGrTag nm hptMap)) tyNames)
      where
        g = maybe mp (\ty -> Map.insert fntag (TyFun (toTypeName ty) nm (arity nm)) mp)
                     (Map.lookup (absGrTag nm hptMap) papps)

papps :: HptMap -> Map HsName HsName -> Map HsName Int -> Set GrTag -> Map GrTag TyTag
papps hptMap tyNames funArities allPApps = Set.fold f Map.empty allPApps
  where
    arity nm = Map.findWithDefault (error $ "Can't find function " ++ show nm ++ " in arities Map.") nm funArities
    f patag@(GrTag_PApp needs nm) mp = maybe mp g (Map.lookup (conName (absGrTag nm hptMap)) tyNames)
      where
        g tynm = Map.insert patag (TyPApp tynm nm needs (arity nm)) mp
}

SEM GrGlobal
  | Global lhs.cilFields = [ Field Static AssemblyVisible Object @loc.name ]
           lhs.cilValues = @val.cilCode ++
                           [ stsfld Object "" @lhs.className @loc.name ]
           val.methodParams = Set.empty
           loc.name      = hsnShowAlphanumeric @nm

SEM GrBind
  | Bind  lhs.cilMethods  = [Method Static AssemblyVisible Object (hsnShowAlphanumeric @nm) @loc.params @loc.cilCode]
          expr.methodParams = Set.fromList @argNmL
          loc.params      = map (Param Object . hsnShowAlphanumeric) @argNmL
          loc.cilCode     = localsInit @loc.locals : @expr.cilCode ++ [ret]
          loc.locals      = Map.foldWithKey (\nm pt xs -> Local pt nm : xs) [] @expr.locals
          loc.funArities  = Map.singleton @nm (length @argNmL)


SEM GrExpr
  | Seq         lhs.cilCode = @expr.cilCode ++ @pat.cilCode ++ @body.cilCode
  | Unit        lhs.cilCode = debugComment @self @val.cilCode
  | UpdateUnit  lhs.cilCode = debugComment @self $ @loc.load ++ @val.cilCode ++ [loadRefVal, storeRefVal] ++ @loc.load
                loc.load    = loadVar @lhs.className @lhs.methodParams @nm
  | Case        lhs.cilCode = debugComment ("Case on " ++ show @val.self) $
                              @val.cilCode
                              ++ [label @loc.caseStartLabel nop]
                              ++ @altL.cilCode
                              ++ [label @loc.caseEndLabel nop]
                loc.caseStartLabel  = head @lhs.labels
                val.labels          = tail @lhs.labels
                loc.caseEndLabel    = head @altL.labels
                lhs.labels          = tail @altL.labels
                altL.caseStartLabel = @loc.caseStartLabel
                altL.caseEndLabel   = @loc.caseEndLabel
  | FetchNode   lhs.cilCode = [no @self]
  | FetchUpdate lhs.cilCode = [no @self]
  | FetchField  lhs.cilCode = debugComment @self $
                                @loc.load ++ @loc.doField
                loc.load    = loadVar @lhs.className @lhs.methodParams @nm
                loc.doField = case @offset of
                              0 -> [] 
                              o -> [ loadRefVal
                                   , ldfld (trace (show (@loc.tyTag) ++ " !! " ++ show o) $ toFieldTypes @loc.tyTag !! (o - 1))
                                           ""
                                           (toConDottedName @loc.tyTag)
                                           (toFieldName @loc.tyTag (o - 1))
                                   ]
                loc.tyTag   = case @mbTag of
                              Nothing  -> error $ "Cannot fetch field of unknown type: " ++ show @self
                              Just tag -> lookupTag tag @lhs.grTagsMap
  | Store       lhs.cilCode = debugComment @self $ @val.cilCode ++ [newRefObj]
  | Call        lhs.cilCode = debugComment @self $ @argL.cilCode ++ [call StaticCallConv Object "" @lhs.className @loc.varName @loc.params]
                loc.params  = replicate (length @argL.self) Object
  | FFI         lhs.cilCode = debugComment @self $ @argL.cilCode ++ ffcall @nm
  | Eval        lhs.cilCode = [no @self]
  | App         lhs.cilCode = [no @self]
  | Throw       lhs.cilCode = [no @self]
  | Catch       lhs.cilCode = [no @self]
  | UpdateUnit FetchNode FetchField Call Eval App Throw
                loc.varName = hsnShowAlphanumeric @nm

SEM GrAlt
  | Alt         lhs.cilCode   = debugComment @self $ 
                                  @pat.cilCode -- should return a boolean-like
                                  ++ [brfalse @loc.label]
                                  ++ @loc.exprCode
                                  ++ [label @loc.label nop]
                loc.exprCode  = case @ann of
                                  GrAltAnnIdent   -> [br @lhs.caseEndLabel]
                                  GrAltAnnReenter -> [pop] ++ @expr.cilCode ++ [br @lhs.caseStartLabel]
                                  _               -> [pop] ++ @expr.cilCode ++ [br @lhs.caseEndLabel]
                loc.label     = head @lhs.labels
                pat.labels    = tail @lhs.labels


SEM GrPatAlt
  | Tag         lhs.cilCode = debugComment @self @tag.cilMatch
  | * - Tag     lhs.cilCode = [no @self]


SEM GrVal
  | Empty       lhs.cilCode = debugComment @self [newobj "" (toConDottedName unitTyTag) [], newRefObj]
  | LitInt      lhs.cilCode = debugComment @self [ldc_i4 @int]
  | Tag         lhs.cilCode = [no @self]
                lhs.cilConst = @tag.cilConst
  | Var         lhs.cilCode = debugComment @self $ loadVar @lhs.className @lhs.methodParams @nm
                lhs.cilConst = constructTag (absGrTag @nm @lhs.hptMap) @lhs.grTagsMap
  | Node        lhs.cilCode = debugComment @self $ @fldL.cilCode ++ @tag.cilConst
  | VarNode     lhs.cilCode = debugComment @self $ (concat (tail @fldL.cilCodes)) ++ head @fldL.cilConsts
  | BasicNode   lhs.cilCode = debugComment @self $ loadVar @lhs.className @lhs.methodParams @nm ++ @tag.cilConst
  | EnumNode    lhs.cilCode = [no @self]
  | OpaqueNode  lhs.cilCode = [no @self]
  | PtrNode     lhs.cilCode = [no @self]
  | * - Tag Var
                lhs.cilConst = [no $ "cilConst not defined on " ++ show @self]
  -- TODO NodeAdapt in variant 10

SEM GrValL
  | Nil         lhs.cilConsts = []
                lhs.cilCodes  = []
  | Cons        lhs.cilConsts = @hd.cilConst : @tl.cilConsts
                lhs.cilCodes  = @hd.cilCode  : @tl.cilCodes

SEM GrVarL
  | Nil
      lhs.tyTag = error "Empty VarNode list has no Tag"
  | Cons
      lhs.tyTag = @hd.tyTag
      hd.index  = @lhs.index
      tl.index  = @lhs.index + 1

SEM GrVar
  | Var
      lhs.cilLoad    = if @lhs.index < 0
                       then []
                       else [ ldfld (toFieldTypes @lhs.nodeTyTag !! @lhs.index) "" (toConDottedName @lhs.nodeTyTag)
                                    (toFieldName @lhs.nodeTyTag @lhs.index)
                            , stlocN @varName ]
      lhs.tyTag      = lookupTag (absGrTag @nm @lhs.hptMap) @lhs.grTagsMap
      lhs.locals     = Map.singleton @varName (absPrimitiveType @nm @lhs.hptMap)
      loc.varName    = hsnShowAlphanumeric @nm
  | KnownTag
      lhs.tyTag      = lookupTag @tag.self @lhs.grTagsMap
  | Ignore
      lhs.tyTag      = error "Ignore has no TyTag"

SEM GrPatLam
  | Empty
      lhs.cilCode    = debugComment @self []
  | Var
      lhs.cilCode    = debugComment @self [stlocN @varName]
      lhs.locals     = Map.singleton @varName (absPrimitiveType @nm @lhs.hptMap)
  | VarNode
      lhs.cilCode    = debugComment @self (loadRefVal : @fldL.cilLoad)
      fldL.index     = -1
      fldL.nodeTyTag = @fldL.tyTag
  | BasicNode
      lhs.cilCode    = debugComment @self [loadRefVal, ldfld Int32 "" (toConDottedName intTyTag) (toFieldName intTyTag 0), stlocN @varName]
      lhs.locals     = Map.singleton @varName Int32
  | EnumNode
      lhs.cilCode    = [no @self]
  | PtrNode
      lhs.cilCode    = [no @self]
  | OpaqueNode
      lhs.cilCode    = [no @self]
  | BasicAnnot
      lhs.cilCode    = debugComment @self [stlocN @varName]
      lhs.locals     = Map.singleton @varName Int32
  | EnumAnnot
      lhs.cilCode    = [no @self]
  | PtrAnnot
      lhs.cilCode    = [no @self]
  | OpaqueAnnot
      lhs.cilCode    = [no @self]
  | * - VarNode Empty
      loc.varName    = hsnShowAlphanumeric @nm


SEM GrTag
  | Con         lhs.cilMatch  = debugComment @self [dup, loadRefVal, isinst (toConDottedName @loc.tyTag)]
                lhs.allCons   = Set.singleton @self
                loc.tyTag     = lookupTag @self @lhs.grTagsMap
  | Fun         lhs.cilMatch  = debugComment @self [dup, loadRefVal, isinst (toConDottedName @loc.tyTag)]
                lhs.allFuns   = Set.singleton @self
                loc.tyTag     = lookupTag @self @lhs.grTagsMap
  | PApp        lhs.cilMatch  = debugComment @self [dup, loadRefVal, isinst (toConDottedName @loc.tyTag)]
                lhs.allPApps  = Set.singleton @self
                loc.tyTag     = lookupTag @self @lhs.grTagsMap
  | App         lhs.cilMatch  = [no $ "Match " ++ show @self]
  | Unboxed Hole Rec World Any
                lhs.cilMatch  = [no $ "Match " ++ show @self]
  | *           lhs.cilConst  = constructTag @self @lhs.grTagsMap
%%]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Helper functions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%[(8 codegen grin) hs

absValue :: HsName -> HptMap -> AbstractValue
absValue hsName hptMap = case absValues hsName hptMap of
  []  ->  error $ "GrinCode.ToCil.absValue: No known AbstractValue for " ++ show hsName
  [v] ->  v
  _   ->  error $ "GrinCode.ToCil.absValue: Multiple possible AbstractValues for " ++ show hsName

absValueGuess :: HsName -> HptMap -> AbstractValue
absValueGuess hsName hptMap = case absValues hsName hptMap of
  []   -> error $ "GrinCode.ToCil.absValueGuess: No known AbstractValue for " ++ show hsName
  [v]  -> v
  vals -> trace ("GrinCode.ToCil.absValueGuess: Multiple AbstractValues for "
                    ++ show hsName ++ ": " ++ show vals) $ head vals
  

absValues :: HsName -> HptMap -> [AbstractValue]
absValues hsName hptMap = Set.toList $ handleVal (getEnvVar hptMap (getNr hsName))
  where
    getHeapLoc' x = handleVal (getHeapLoc hptMap x)
    handleVal val = 
      case val of
        (AbsLocs locs _) -> Set.fold (\l s -> getHeapLoc' l `Set.union` s) Set.empty locs
        _                -> Set.singleton val

absGrTag :: HsName -> HptMap -> GrTag
absGrTag hsName hptMap =
  case absValueGuess hsName hptMap of
    (AbsNodes gav) -> handleGav $ Map.keys gav
    (AbsTags  gav) -> handleGav $ Set.toList gav
    val            -> error $ "GrinCode.ToCil.absGrTag: Code not implemented yet, please implement: "
                      ++ show hsName ++ " is " ++ show val
  where handleGav [g] = g
        handleGav gs  = trace ("GrinCode.ToCil.absGrTag: AbsNodes/AbsTags has zero or multiple GrTags for "
                        ++ show hsName) $ head gs

absPrimitiveType :: HsName -> HptMap -> PrimitiveType
absPrimitiveType hsName hptMap = case absValueGuess hsName hptMap of
    AbsBasic     -> Int32
    AbsTags _    -> Object
    AbsNodes _   -> Object
    AbsError err -> Object -- error $ "GrinCode.ToCil.absPrimitiveType: AbsError on " ++ show hsName ++ ": " ++ err
                    -- ^ (should become error again when HPT-bugs are fixed)
    AbsBottom    -> Int32 -- error $ "GrinCode.ToCil.absPrimitiveType: AbsBottom in " ++ show hsName
                    -- ^ (should become error again when HPT-bugs are fixed)
    val          -> error $ "GrinCode.ToCil.absPrimitiveType: Code not implemented yet, please implement: "
                  ++ show hsName ++ " is " ++ show val

no :: (Show a) => a -> MethodDecl
no a = comment $ "TODO   " ++ show a

-- Idea: replace debugComment in the AG by an attribute that gets initialized
-- to debugComment or fakeComment, according to some compiler option.
type DebugComment = Show a => a -> [MethodDecl] -> [MethodDecl]
debugComment, fakeComment :: DebugComment
debugComment a []  = [comment $ "NOP    " ++ show a]
debugComment a [m] = [comment $ "SINGLE " ++ show a, m]
debugComment a ms  = [comment $ "BEGIN  " ++ show a]
                     ++ ms ++
                     [comment $ "END    " ++ show a]
fakeComment = flip const

ffcall :: String -> [MethodDecl]
ffcall "primAddInt" = [add]
ffcall "primSubInt" = [sub]
ffcall "primEqInt"  = [ceq]
ffcall "primGtInt"  = [cgt]
ffcall "primNegInt" = [neg]
ffcall f            = error $ "Please teach me how to compile the foreign function " ++ f

loadVar :: DottedName -> Set HsName -> HsName -> [MethodDecl]
loadVar className params nm = case Set.member nm params of
    True          -> [ldargN varName]
    False         -> case nm of
      HNmNr _ (OrigGlobal _) -> [lglobal]
      HNmNr _ (OrigFunc   _) -> error "Cannot load function"
      HNmNr _ _              -> [ldlocN varName]
      _                      -> error "Loading non-HNmNr variable"
  where varName = hsnShowAlphanumeric nm
        lglobal = ldsfld Object "" className varName

lookupTag :: GrTag -> Map GrTag TyTag -> TyTag
lookupTag k mp = Map.findWithDefault (error $ "Tag " ++ show k ++ " not in map: " ++ show mp) k mp

constructTag :: GrTag -> Map GrTag TyTag -> [MethodDecl]
constructTag tag grTagsMap = case Map.lookup tag grTagsMap of
    Nothing    -> [no $ "constructTag on " ++ show tag]
    Just tyTag -> let
        name  = toConDottedName tyTag
        types = toFieldTypes tyTag
      in debugComment tag [newobj "" name types, newRefObj]

%%]
