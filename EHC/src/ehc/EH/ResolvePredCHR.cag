%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Pred occurrence gathering
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[9
ATTR NTPrf [ | | gathCnstrMp USE {`cnstrMpUnion`} {Map.empty}: CHRPredOccCnstrMp ]

SEM Expr
  | IConst CConst Var Con
                lhs         .   gathCnstrMp         =   foGathCnstrMp @fo_
  | App         lhs         .   gathCnstrMp         =   cnstrMpUnions [gathPredLToProveCnstrMp $ @prOccL, @func.gathCnstrMp, @arg.gathCnstrMp]
  | TypeAs      lhs         .   gathCnstrMp         =   cnstrMpUnions [foGathCnstrMp @fo_, foGathCnstrMp @fo_fitDown, @expr.gathCnstrMp]
  | Let         loc         .   gathCnstrMp         =   cnstrMpUnions [@toProveElsewhereCnstrMp,@body.gathCnstrMp] -- for now
  | Lam LamImpl lhs         .   gathCnstrMp         =   cnstrMpUnions [gathPredLToAssumeCnstrMp @knPrL,@body.gathCnstrMp]
  | AppTop      lhs         .   gathCnstrMp         =   cnstrMpUnions [gathPredLToAssumeCnstrMp @knPrL,@expr.gathCnstrMp]
%%]

%%[10
SEM Expr
  | Sel         lhs         .   gathCnstrMp         =   cnstrMpUnions [gathPredLToProveCnstrMp @prOccL, @expr.gathCnstrMp]
  | Rec         lhs         .   gathCnstrMp         =   cnstrMpUnions [foGathCnstrMp @fo_, @recExpr.gathCnstrMp]

SEM RecExpr
  | Ext Upd     lhs         .   gathCnstrMp         =   cnstrMpUnions [gathPredLToProveCnstrMp @prOccL, @recExpr.gathCnstrMp, @expr.gathCnstrMp]

SEM RecPatExpr
  | Ext         lhs         .   gathCnstrMp         =   cnstrMpUnions [gathPredLToProveCnstrMp @prOccL, @recPatExpr.gathCnstrMp, @patExpr.gathCnstrMp]
%%]

%%[97
SEM PatExpr
  | Expr        lhs         .   gathCnstrMp         =   cnstrMpUnions [foGathCnstrMp @fo_, @expr.gathCnstrMp]
%%]

%%[9
SEM Decl
  | Instance    loc         .   (chrCtxtAssumeCnstrMp,chrSuperProveCnstrMp,chrInstAssumeCnstrMp,chrCtxtArgUIDL,chrCtxtArgNmL,chrSuperProveUIDL,chrSuperProveNmL,chrInstNm)
                                                    =   let (u:us) = mkNewUIDL (lc + ls + 1) @lUniq6
                                                            (usc,uss) = splitAt lc us
                                                            lc = length @ctxtPrFixL
                                                            ls = length @supPrTyL
                                                            d = case @instVariant of {InstDefault -> @dictSelfNm ; _ -> @dictBuildNm}
                                                        in  ( cnstrMpFromList $ zipWith (\p u -> mkAssumeConstraint p u @predScope) @ctxtPrFixL            usc
                                                            , cnstrMpFromList $ zipWith (\p u -> mkProveConstraint  p u @predScope) (map tyPred @supPrTyL) uss
                                                            , cnstrMpFromList [mkAssumeConstraint' (tyPred @hdPrTyFix) u d @predScope]
                                                            , usc
                                                            , map mkHNm usc
                                                            , uss
                                                            , map mkHNm uss
                                                            , d
                                                            )
%%]
SEM Decl
  | Instance    loc         .   (instPrElimTGam,ctxtArgNmL,_)
                                                    =   peTGamInsertKnPrL @lhs.opts @prfCtxtId @lUniq6 @ctxtPrFixL
                                                        $ tgamPushNew @lhs.prfCtxtId @prfCtxtId @lhs.prElimTGam
                            .   supPrUIDL           =   map (mkPrId @prfCtxtId) . mkNewUIDL (length @supPrTyL) $ @lUniq4
                            .   delPrElimTGam       =   peTGamDel @prfCtxtId @instClsNm @elimRule @instPrElimTGam
                            .   supPrElimTGam       =   @delPrElimTGam
                            .   declsPrElimTGam     =   if ehcCfgInstFldHaveSelf @lhs.opts
                                                        then @delPrElimTGam
                                                        else let d = case @instVariant of {InstDefault -> @dictSelfNm ; _ -> @dictBuildNm}
                                                             in  peTGamInsertKnPr @lhs.opts @prfCtxtId d (mkPrId @prfCtxtId @lUniq2) (tyPred @hdPrTyFix) @delPrElimTGam
                decls       .   prElimTGam          =   @declsPrElimTGam
                lhs         .   prElimTGam          =   @lhs.prElimTGam

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Proving (predicates) via CHR's
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[9 hs
simplify env chrStore heur toProveHereCnstrMp
  = (chrSolveRemCnstrMp2,chrSolveEvidBindMp,chrSolveEvidBinds,chrSolveErrs,chrSolveState,chrRedGraph)
  where (_,u1,u2,u3) = mkNewLevUID3 $ fiUniq env
        ((chrSolveRemCnstrMp,chrSolveEvidMp,chrSolveErrs),chrSolveState,chrRedGraph)
          = chrSimplifyToEvidence (env {fiUniq = u1}) chrStore heur toProveHereCnstrMp
        (chrSolveRemCnstrMp2,chrSolveEvidMp2)
          = patchUnresolvedWithAssumption (env {fiUniq = u2}) chrSolveRemCnstrMp chrSolveEvidMp
        chrSolveEvidCoreMp
          = evidMpToCore (env {fiUniq = u3}) chrSolveEvidMp2
        (chrSolveEvidBindMp,chrSolveEvidBinds)
          = evidKeyCoreMpToBinds chrSolveEvidCoreMp
%%]

%%[9
SEM Expr
  | Let         loc         .   toProveCnstrMp      =   @decls.tyCnstr `chrAppSubst` @decls.gathCnstrMp
                            .   (toProveHereCnstrMp,toProveElsewhereCnstrMp)
                                                    =   Map.partitionWithKey (\k _ -> isLetProveCandidate (Set.fromList @gTyTvL) $ cnstrPred k) @toProveCnstrMp
                            .   (chrSolveRemCnstrMp,chrSolveEvidBindMp,chrSolveEvidBinds,chrSolveErrs,chrSolveState,chrSolveRedGraph)
                                                    =   simplify (@chrFIIn {fiUniq = @lUniq5}) @lhs.chrStore (heurScopedEHC @chrFIIn) @toProveHereCnstrMp
                            .   (chrSolveDoneConstraints,chrSolveTrace)
                                                    =   (chrSolveStateDoneConstraints @chrSolveState,chrSolveStateTrace @chrSolveState)
%%]

%%[9
SEM Decl
  | Instance    loc         .   toProveDeclsCnstrMp =   cnstrMpUnions [@chrInstAssumeCnstrMp,@chrCtxtAssumeCnstrMp,@decls.tyCnstr `chrAppSubst` @decls.gathCnstrMp]
                            .   (chrSolveDeclsRemCnstrMp,chrSolveDeclsEvidBindMp,chrSolveDeclsEvidBinds,chrSolveDeclsErrs,chrSolveDeclsState,chrSolveDeclsRedGraph)
                                                    =   simplify (@chrFIIn {fiUniq = @lUniq7}) @lhs.chrStore (heurScopedEHC @chrFIIn) @toProveDeclsCnstrMp
                            .   (chrSolveDeclsDoneConstraints,chrSolveDeclsTrace)
                                                    =   (chrSolveStateDoneConstraints @chrSolveDeclsState,chrSolveStateTrace @chrSolveDeclsState)

                            .   toProveSuperCnstrMp =   cnstrMpUnions [@chrCtxtAssumeCnstrMp,@chrSuperProveCnstrMp]
                            .   (chrSolveSuperRemCnstrMp,chrSolveSuperEvidBindMp,chrSolveSuperEvidBinds,chrSolveSuperErrs,chrSolveSuperState,chrSolveSuperRedGraph)
                                                    =   simplify (@chrFIIn {fiUniq = @lUniq5}) @lhs.chrStore (heurScopedEHC @chrFIIn) @toProveSuperCnstrMp
                            .   (chrSolveSuperDoneConstraints,chrSolveSuperTrace)
                                                    =   (chrSolveStateDoneConstraints @chrSolveSuperState,chrSolveStateTrace @chrSolveSuperState)
%%]
SEM Decl
  | Instance    loc         .   gathDeclSubsPredL   =   @decls.tyCnstr |=> @decls.gathPredL
                            .   toResolvePrOccL     =   @gathDeclSubsPredL
                            .   (prfFrPoiCxBindLM,prfIntroCBindL,prfCSubst,prfArgPrOccL,_,prfErrs
                                  ,(dbg2PrfG,dbg2PrfPruneG,dbg2PrfOrG,dbg2PrfIntermG1,dbg2PrfIntermG2,dbg2PrElimTGam,dbg2PrLeaves,prfPoiFwdMp,prfPoiBackMp,dbg2TrPPL))
                                                    =   prfPredsDbg @lUniq7 (@fe {fePrElimTGam = @decls.prElimTGam}) @toResolvePrOccL
                            .   supForPrfPrOccL     =   zipWith3 mkPredOcc (map tyPred @supPrTyL) @supPrUIDL (repeat @predScope)
                            .   (supPrfFrPoiCxBindLM,supPrfIntroCBindL,supPrfCSubst,supPrfArgPrOccL,supPrfEvidL,supPrfErrs
                                  ,(dbgSup2PrfG,dbgSup2PrfPruneG,dbgSup2PrfOrG,dbgSup2PrfIntermG1,dbgSup2PrfIntermG2,dbgSup2PrElimTGam,dbgSup2PrLeaves,prfSupPoiFwdMp,prfSupPoiBackMp,dbgSup2TrPPL))
                                                    =   prfPredsDbg @lUniq5 (@fe {fePrElimTGam = @supPrElimTGam}) @supForPrfPrOccL
                lhs         .   gathPredL           =   []

Interaction with existing impl:

%%[9
SEM Expr
  | Let         loc         .   quantPrOccL         =   if ehcCfgClassViaCHR @lhs.opts
                                                        then [ mkPredOcc (cpoPr o) (mkPrIdCHR i) sc | (Assume o,[RedHow_Assumption i _ sc]) <- Map.toList @chrSolveRemCnstrMp ]
                                                        else @prfArgPrOccL
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Propagation of bindings resulting from assumptions downwards
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[9
ATTR NTPrf [ chrEvidBindMp: EvidKeyToCBindMap | | ]

SEM AGItf
  | AGItf       loc         .   chrEvidBindMp       =   Map.empty

SEM Decl
  | Instance    loc         .   chrEvidBindMp       =   @chrSolveDeclsEvidBindMp `Map.union` @lhs.chrEvidBindMp

SEM Expr
  | Let         loc         .   chrEvidBindMp       =   @chrSolveEvidBindMp `Map.union` @lhs.chrEvidBindMp
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Bindings for assumed preds
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[9 hs
mkAssumeBindings :: [UID] -> EvidKeyToCBindMap -> [CBind]
mkAssumeBindings ids mp
  = concat [ maybe [] id $ Map.lookup i mp | i <- ids ]
%%]

%%[9
SEM Decl
  | Instance    loc         .   chrAssumeSuperBindL =   mkAssumeBindings @chrCtxtArgUIDL @chrSolveSuperEvidBindMp

SEM Expr
  | Lam AppTop LamImpl
                loc         .   chrAssumeBindL      =   mkAssumeBindings (map poiId @poiL) @lhs.chrEvidBindMp
%%]
