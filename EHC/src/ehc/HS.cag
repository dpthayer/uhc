%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell importable interface to HS/AbsSyn (was: UHA_Syntax)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[1 hs module {%{EH}HS} import({%{EH}Base.Common}, UU.Scanner.Position, EH.Util.ScanUtils) export(module UU.Scanner.Position)
%%]

%%[1 hs export(AGItf(..), Module(..), Body(..), Declaration(..), Declarations, MaybeDeclarations, Type(..), Types, Expression(..), Expressions, MaybeExpression, FunctionBinding(..), FunctionBindings, LeftHandSide(..), RightHandSide(..), Pattern(..), Patterns, Literal(..), Name, Names, MaybeName, MaybeNames, Strings, MaybeInt, Range(..), Fixity(..))
%%]

%%[1 hs export(mkRange1,mkRange2,emptyRange,mkQName,mkQNames)
%%]

%%[1 hs export(mkRngNm,mkRngStr)
%%]

%%[5 hs export(Constructor(..), Constructors)
%%]

%%[5 hs export(GuardedExpression(..), GuardedExpressions, Alternative(..), Alternatives, Qualifier(..), Qualifiers)
%%]

%%[5 hs export(SimpleType(..), AnnotatedType(..), AnnotatedTypes)
%%]

%%[7 hs export(FieldDeclaration(..), FieldDeclarations)
%%]

%%[77 hs export(RowExtension(..), RowExtensions, RowType(..))
%%]

%%[77 hs export(RecordPatternBinding(..), RecordPatternBindings)
%%]

%%[7 hs export(RecordExpressionBinding(..), RecordExpressionBindings)
%%]

%%[7 hs export(RowRecordExpressionUpdate(..), RowRecordExpressionUpdates, RowRecordPatternBinding(..), RowRecordPatternBindings, RowTypeUpdate(..), RowTypeUpdates)
%%]

%%[8 hs export(Export(..), Exports, MaybeExports, ImportDeclaration(..), ImportDeclarations, ImportSpecification(..), MaybeImportSpecification, Import(..), Imports)
%%]

%%[9 hs export(ContextItem(..), ContextItems, ContextedExpression(..), ContextedExpressions, ContextedPattern(..), ContextedPatterns, FunctionalDependency(..), FunctionalDependencies)
%%]

%%[99 hs export(Statement(..), Statements)
%%]

%%[1.Token hs import(UU.Scanner.Token)
%%]

%%[5 -1.Token hs import({%{EH}Base.Scanner.Token})
%%]

%%[1 import({HS/AbsSyn})
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Additional defs
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[1 hs
type Name = HsName
type Names = [Name]
type MaybeName = Maybe Name
type MaybeNames = Maybe Names
%%]

%%[1 hs
mkPos :: Position p => p -> Pos
mkPos p = Pos (line p) (column p) (file p)

mkRange1 :: Position p => p -> Range
mkRange1 p = Range_Range (mkPos p) noPos

mkRange2 :: Position p => p -> p -> Range
mkRange2 p1 p2 = Range_Range (mkPos p1) (mkPos p2)

emptyRange :: Range
emptyRange = Range_Unknown
%%]

%%[5 hs
-- Assumption: tokTpIsInt (genTokTp t) == True
mkInt :: Token -> Int
mkInt t
  = case genTokTp t of
      Just TkInteger10 -> read v
      _                -> 0
  where v = genTokVal t
%%]

%%[1.mkQName hs
mkQName :: Token -> HsName
mkQName = HNm . genTokVal
%%]

%%[7 -1.mkQName hs
mkQName :: Token -> HsName
mkQName t
  = case genTokTp t of
      Just tp | tokTpIsInt tp -> HNPos $ mkInt t
      _                       -> HNm   $ genTokVal t
%%]

%%[1 hs
mkQNames :: [Token] -> [HsName]
mkQNames = map mkQName

instance HSNM Token where
  mkHNm = mkQName
%%]

%%[1 hs
mkRngNm :: (Position t,HSNM t) => (Range -> HsName -> r) -> t -> r
mkRngNm ast t = ast (mkRange1 t) (mkHNm t)

mkRngStr :: (Range -> String -> r) -> Token -> r
mkRngStr ast t = ast (mkRange1 t) (genTokVal t)
%%]
mkRngStr :: (Position t,HSNM t) => (Range -> String -> r) -> t -> r
mkRngStr ast t = ast (mkRange1 t) (genTokVal t)

%%[1 hs
instance Show Range where
  show (Range_Range p _) = show p
  show Range_Unknown     = "??"
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% SemApp instances
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[1 hs
instance SemApp Type where
  semApp       = \e1 e2 -> Type_Application emptyRange False e1 [e2]
  semAppTop    = id
  semCon       = mkRngNm Type_Constructor
  semParens    = Type_Parenthesized emptyRange
  mkApp (a:as) = Type_Application emptyRange False a as
%%]

%%[1 hs
instance SemApp Expression where
  semApp       = \e1 e2 -> Expression_NormalApplication emptyRange e1 [e2]
  semAppTop    = id
  semCon       = mkRngNm Expression_Constructor
  semParens    = Expression_Parenthesized emptyRange
  mkApp (a:as) = Expression_NormalApplication emptyRange a as
%%]


