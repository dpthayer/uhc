%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[doesWhat doclatex
Analyse Core, using relevance analysis, to relate properties (like relevance) of function args and result, and annotate core expressions with their relevance.

20100811 AD: note this is just in the early design stages.
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Type based simplifications
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen) hs module {%{EH}Core.Trf.AnaRelevance} import({%{EH}Ty},{%{EH}Base.Common},{%{EH}Gam},{%{EH}Base.Opts},{%{EH}Core},{%{EH}VarMp},{%{EH}Substitutable})
%%]

%%[(8 codegen) hs import(Data.Maybe, qualified Data.Map as Map, qualified Data.Set as Set)
%%]

%%[(90 codegen) hs import({%{EH}BuiltinPrims},{%{EH}Foreign},{%{EH}Foreign.Extract})
%%]

%%[(8 codegen) hs import({%{EH}AbstractCore},{%{EH}AnaDomain},{%{EH}AnaDomain.Utils})
%%]

%%[(8 codegen) hs import({%{EH}Gam},{%{EH}Gam.DataGam})
%%]

%%[(8 codegen) hs import({%{EH}AnaDomain.Trf.Instantiate})
%%]

-- debug only
%%[(8 codegen) hs import({%{EH}Base.Debug},EH.Util.Pretty,{%{EH}AnaDomain.Pretty})
%%]

%%[(8 codegen).WRAPPER ag import({Core/AbsSyn},{Core/CommonLev},{Core/CommonFFI},{Core/CommonBindNm},{Core/Trf/CommonStructureInfo},{Core/CommonCtxtPred},{Core/Trf/CommonFv})
WRAPPER CodeAGItf
%%]

%%[(99 codegen)
PRAGMA strictcase
-- PRAGMA nocycle
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell itf
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen) hs export(cmodTrfAnaRelevance)
cmodTrfAnaRelevance :: EHCOpts -> DataGam -> CModule -> CModule
cmodTrfAnaRelevance opts dataGam cmod
  =  let  t = wrap_CodeAGItf (sem_CodeAGItf (CodeAGItf_AGItf cmod))
                             (Inh_CodeAGItf
                               { opts_Inh_CodeAGItf = opts
                               , dataGam_Inh_CodeAGItf = dataGam
                               })
     in   cTrf_Syn_CodeAGItf t
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Options
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR AllCodeNT CodeAGItf [ opts: EHCOpts | | ]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% DataGam required tags (strictness info), FFI
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin)
ATTR AllCodeNT CodeAGItf [ dataGam: DataGam | | ]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Type sigs for AG
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
SEM *
  | *           loc         .   amso            :   {AMSOut RelevTy}
                loc         .   amsoUp          :   {AMSOut RelevTy}
                loc         .   amsoDw          :   {AMSOut RelevTy}
                loc         .   ams             :   AnaMatchState
                loc         .   amsUp           :   AnaMatchState
                loc         .   amsDw           :   AnaMatchState
                loc         .   bindTy          :   RelevTy
                loc         .   quantTy         :   RelevTy
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Utils: subst
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen) hs
type REnv    = Gam HsName RelevTy
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Unique counter
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR AllCodeNT [ | gUniq: UID | ]

SEM CodeAGItf
  | AGItf       loc         .   gUniq           =   uidStart


%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Type env
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR AllCodeNT [ env: REnv | | ]

SEM CodeAGItf
  | AGItf       loc         .   env             =   emptyGam

SEM CBindAspect
  | Bind        expr        .   env             =   gamAddGam @exprEnv @lhs.env

SEM CExpr
  | Var         loc         .   mbEnvTy         =   fmap (relevtyInst @lUniq) (gamLookup @nm @lhs.env)
                            .   (envTy,envQualS)=   maybe (top, Set.empty) id @mbEnvTy
                loc         .   envTy           :   RelevTy
                loc			.	envQualS		:	RelevQualS
                loc         .   lUniq           :   UNIQUEREF gUniq
  | Let         binds       .   env             =   gamAddGam @binds.gathRecEnv @lhs.env
                body        .   env             =   gamAddGam @binds.gathEnv    @lhs.env

SEM CAlt
  | Alt         loc         .   mbCTagEnv       =   do { ct <- @pat.mbCTag
                                                       ; argTyL <- relevTyArgsFromCTag ct (length @pat.nmL) @lhs.dataGam @lUniq
                                                       ; return $ gamFromAssocL $ zip @pat.nmL argTyL
                                                       }
                loc         .   patEnv          =   maybe (gamFromAssocL $ zipWith (\n u -> (n,fresh u)) @pat.nmL $ mkNewLevUIDL (length @pat.nmL) @lUniq2)
                                                          id @mbCTagEnv
                expr        .   env             =   gamAddGam @patEnv @lhs.env
                loc         .   lUniq           :   UNIQUEREF gUniq
                loc         .   lUniq2          :   UNIQUEREF gUniq
%%]
SEM CAlt
  | Alt         expr        .   env             =   gamAddGam @pat.gathEnv    @lhs.env

%%[(8 codegen)
ATTR AllBind -- AllPatFld AllPat
              [ | | gathEnv    USE {`gamUnion`} {emptyGam}: REnv ]
ATTR AllBind  [ | | gathRecEnv USE {`gamUnion`} {emptyGam}: REnv ]

SEM CBindAspect
  | Bind        lhs         .   gathEnv         =   gamSingleton @lhs.nm @quantTy
                            .   gathRecEnv      =   gamSingleton @lhs.nm @ty


%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Type down
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR AllExpr [ knTy: RelevTy | | ]

SEM CModule
  | Mod         expr        .   knTy            =   RelevTy_None

SEM CBindAspect
  | Bind        expr        .   knTy            =   @exprKnTy

SEM CExpr
  | App         arg         .   knTy            =   @argTy
                func        .   knTy            =   case @lhs.knTy of
                                                      RelevTy_Fun v q as r -> RelevTy_Fun v  q  (fresh @lUniq : as) r
                                                      t                    -> RelevTy_Fun [] [] [fresh @lUniq     ] t
                loc         .   lUniq           :   UNIQUEREF gUniq
  | Case        expr        .   knTy            =   @lhs.knTy -- freshStrict @lUniq2
                loc         .   lUniq2          :   UNIQUEREF gUniq

SEM CPatFld
  | Fld         offset      .   knTy            =   freshStrict @lUniq
                loc         .   lUniq           :   UNIQUEREF gUniq
%%]

%%[(8 codegen)
SEM CAltL
  | Cons        hd          .   knTy            =   @altKnDwTy
%%]

%%[(97 codegen)
%%]
SEM CPat
  | BoolExpr    cexpr       .   knTy            =   bot

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Analysis
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
SEM CExpr
  | Int Char    loc         .   litTy           =   bot
                            .   (amso,ams)      =   amsLE @lhs.rvarMp @litTy @lhs.knTy
                loc         .   litTy           :   RelevTy
  | Var         loc         .   (amso,ams)      =   let mk envTy knTy
     													  = case (envTy,knTy) of
                                                              (RelevTy_Ana ana,t@(RelevTy_Fun _ _ a r@(RelevTy_Ana rAna)))
                                                                {-
                                                                -> ( amso' {amsoCoe = RelevCoe_CastTy envTy envTy' <.> amsoCoe amso'}
                                                                   , ams'  {amsGathQual = Set.insert (RelevQual_SubEval ana rAna) $ amsGathQual ams'}
                                                                   )
                                                                -}
                                                                -> ( amso' {amsoCoe = (RelevCoe_Cast $ RelevCoe_Eval ana ana') <.> RelevCoe_CastTy ty' envTy' <.> amsoCoe amso'}
                                                                   , ams'  {amsGathQual = Set.insert (RelevQual_SubEval ana' rAna) $ amsGathQual ams'}
                                                                   )
                                                                where (amso',ams') = amsLE @lhs.rvarMp envTy' t
                                                                      envTy' = anaMkBotFun $ length a
                                                                      ty'@(RelevTy_Ana ana') = fresh @lUniq2
                                                              (t1,t2)
                                                                -> ( amsoMkOk t1 t2 (RelevCoe_CastTy t1 t2)
                                                                   , emptyAnaMatchState
                                                                   )
                                                    in  case @mbEnvTy of
                                                          Just (envTy,_)
                                                            | amsoIsOk amso -> o
                                                            | otherwise     -> mk envTy @lhs.knTy
                                                            where o@(amso,ams) = amsLE @lhs.rvarMp envTy @lhs.knTy
                                                          _                 -> mk top @lhs.knTy
                loc         .   lUniq2          :   UNIQUEREF gUniq
  | Tup         loc         .   tupTy           =   maybe (RelevTy_Err "CExpr.Tup.tupTy") (\a -> RelevTy_Fun [] [] a (freshStrict @lUniq2))
                                                    $ relevTyArgsFromCTag @tag (whatExprAppArity @lhs.whatAbove) @lhs.dataGam @lUniq
                            .   (amso,ams)      =   amsLE @lhs.rvarMp @tupTy @lhs.knTy
                loc         .   tupTy           :   RelevTy
                loc         .   lUniq           :   UNIQUEREF gUniq
                loc         .   lUniq2          :   UNIQUEREF gUniq
  | FFI         loc         .   ffiTy           =   let (ur:ua) = mkNewLevUIDL (1 + length @argTyL) @lUniq
                                                        lOrS l u | l         = freshLazy u
                                                                 | otherwise = freshStrict u
                                                    in  RelevTy_Fun [] [] [lOrS (not e) u | (e,u) <- zip @primArgNeedsEvalL ua] (lOrS @primResNeedsEval ur)
                            .   (amso,ams)      =   amsLE @lhs.rvarMp @ffiTy @lhs.knTy
                loc         .   ffiTy           :   RelevTy
                loc         .   lUniq           :   UNIQUEREF gUniq
  | App         loc         .   funTy           =   case @func.ty of
                                                      t@(RelevTy_Fun _ _ (_:_) _) -> t
                                                      _                           -> anaMkBotFun 1
                            .   (argTy,resTy,resFunTy)
                                                =   case @funTy of
                                                      RelevTy_Fun v q (a:as) r -> (a,r,RelevTy_Fun v q as r)
                loc         .   funTy           :   RelevTy
                loc         .   argTy           :   RelevTy
%%]
                            .   (amso,ams)      =   if @lhs.isTopApp
                                                    then amsLE @arg.rvarMp @resTy @lhs.knTy
                                                    else (emptyAMSOut,emptyAnaMatchState)

%%[(8 codegen)
SEM CAltL
  | Cons        loc         .   (amsoDw,amsDw)  =   amsLE @lhs.rvarMp @altKnDwTy @altKnUpTy     -- both are guaranteed vars, so this enforces a Qual
                            .   rvarMpDw        =   amsLocalVarMp @amsDw `varmpPlus` @lhs.rvarMp
                            .   (amsoUp,amsUp)  =   amsLE @rvarMpDw @altKnUpTy @lhs.knTy        -- which only now we match with above
                            .   rvarMpUp        =   amsLocalVarMp @amsUp `varmpPlus` @rvarMpDw
                            .   aQualS          =   Set.map (\q -> RelevQual_Alt q @lhs.altId @altNr @lhs.altNrMax) $ amsGathQual @amsDw

%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Alts of case
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR CAltL [ altId: UID  altNrMax: Int | | altNr: Int ]

SEM CAltL
  | Nil         loc         .   altNr           =   0
  | Cons        loc         .   altNr           =   @tl.altNr + 1
  | *           loc         .   altNr           :   Int

SEM CExpr
  | Case        alts        .   altNrMax        =   @alts.altNr
                            .   altId           =   @lUniq
                loc         .   lUniq           :   UNIQUEREF gUniq
%%]

%%[(8 codegen)
SEM CAltL
  | Cons        loc         .   altKnUpTy       =   fresh @lUniq
                loc         .   altKnUpTy       :   RelevTy
                loc         .   altKnDwTy       =   fresh @lUniq2
                loc         .   altKnDwTy       :   RelevTy
                loc         .   lUniq           :   UNIQUEREF gUniq
                loc         .   lUniq2          :   UNIQUEREF gUniq
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Coe up over app spine
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR CExpr [ | | coe: RelevCoe ]

SEM CExpr
  | Var Int Char Tup FFI
                lhs         .   coe             =   last $ relevCoeToComposeList $ amsoCoe @amso
  | App         (loc.argCoe,loc.resCoe,lhs.coe) =   case @func.coe of
                                                      RelevCoe_Fun (a:as) r -> (a,r,RelevCoe_Fun as r)
                                                      _                     -> (RelevCoe_Err "CExpr.App.a", RelevCoe_Err "CExpr.App.r", RelevCoe_Err "CExpr.App.f")
  | * - Var Int Char Tup FFI App Ann CaseAltFail
                lhs         .   coe             =   RelevCoe_Err "CExpr.unimpl"
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Type up
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR CExpr CAltL [ | | ty: RelevTy ]

SEM CExpr
  | Var Int Char Tup FFI
                lhs         .   ty              =   amsoHi @amso
  | App         lhs         .   ty              =   if @lhs.isTopApp then @resTy else @resFunTy
  | Case        lhs         .   ty              =   @alts.ty
  | * - Var Int Char Tup FFI App Case Ann CaseAltFail
                lhs         .   ty              =   RelevTy_Err "unimpl"
%%]

%%[(8 codegen)
SEM CAltL
  | *           lhs         .   ty              =   @lhs.knTy

%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% VarMp gathering
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR AllNT [ | rvarMp: RVarMp | ]

SEM CodeAGItf
  | AGItf       loc         .   rvarMp          =   emptyVarMp

SEM CBindAspect
  | Bind        lhs         .   rvarMp          =   @quantVarMp `varmpPlus` @expr.rvarMp
%%]

%%[(8 codegen)
SEM CExpr
  | Var Int Char Tup FFI
                lhs         .   rvarMp          =   amsLocalVarMp @ams `varmpPlus` @lhs.rvarMp
  | Case        lhs         .   rvarMp          =   @alts.rvarMp        -- skip @dflt
%%]

%%[(8 codegen)
SEM CAltL
  | Cons        hd          .   rvarMp          =   @rvarMpUp
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Final VarMp distribution
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR AllNT [ finalRVarMp: RVarMp | | ]

SEM CodeAGItf
  | AGItf       module      .   finalRVarMp     =   @module.rvarMp
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Constraint gathering
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR AllCodeNT [ | | qualS USE {`Set.union`} {Set.empty} : RelevQualS ]

SEM CExpr
  | Var
                lhs         .   qualS           =   Set.union @envQualS (amsGathQual @ams)
  | Int Char Tup FFI
                lhs         .   qualS           =   amsGathQual @ams
  | Case        lhs         .   qualS           =   Set.unions [@expr.qualS, @alts.qualS]       -- skip @dflt
%%]
  | App         lhs         .   qualS           =   Set.unions [amsGathQual @ams, @func.qualS, @arg.qualS]

%%[(8 codegen)
SEM CAltL
  | Cons        lhs         .   qualS           =   Set.unions [@aQualS, amsGathQual @amsUp, @hd.qualS, @tl.qualS]

%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Type of a binding
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
SEM CBindAspect
  | Bind        loc         .   (ty,exprKnTy,exprEnv,mbBindCoe)
                                                =   case @expr.mbLam of
                                                      Just nmL
                                                        -> (RelevTy_Fun [] [] as' r', r', exprEnv, Nothing)
                                                        where (r:as) = mkNewLevUIDL (1 + length nmL) @lUniq
                                                              r' = fresh r
                                                              as' = map fresh as
                                                              exprEnv = gamFromAssocL (zip nmL as')
                                                      _ | isStrict  -> let t = @lhs.knTy -- freshStrict @lUniq
                                                                       in  (t, t, emptyGam, Nothing)
                                                        | otherwise -> let (_,u1,u2) = mkNewLevUID2 @lUniq
                                                                           eTy@(RelevTy_Ana eAna) = fresh u1
                                                                           bTy@(RelevTy_Ana bAna) = fresh u2
                                                                       in  (bTy, bTy, emptyGam, Nothing)
                                                                           -- (bTy, eTy, emptyGam, Just $ RelevCoe_Cast $ RelevCoe_Eval eAna bAna)
                                                        where isStrict = @lhs.letBindingsCateg == CBindings_Strict
                            .   (quantTy,quantVarMp)
                                                =   case @ty of
                                                      t@(RelevTy_Fun _ _ _ _)
                                                        -> relevtyQuant False @expr.rvarMp @expr.qualS t
                                                      t -> (t, emptyVarMp)
                            .   bindTy          =   @lhs.finalRVarMp |=> @quantTy
                            .   debugTy1        =   case @expr.rvarMp |=> @ty of
                                                      RelevTy_Fun _ _ a r
                                                        -> RelevTy_Fun v q a r
                                                        where q = @expr.rvarMp |=> Set.toList @expr.qualS
                                                              v = Set.toList $ Set.unions [ftvSet q, ftvSet a, ftvSet r]
                                                      t -> t
                            .   debugTy2        =   case @lhs.finalRVarMp |=> @ty of
                                                      RelevTy_Fun _ _ a r
                                                        -> RelevTy_Fun [] q a r
                                                        where q = @lhs.finalRVarMp |=> Set.toList @expr.qualS
                                                      t -> t
                            .   tyAspectL       =   [ CBindAspect_RelevTy acbaspkeyDefault @bindTy
                                                    -- , CBindAspect_RelevTy @debugTy1
                                                    -- , CBindAspect_RelevTy acbaspkeyDebug @debugTy2
                                                    ]
                loc         .   ty              :   RelevTy
                loc         .   exprKnTy        :   RelevTy
                loc			.	exprEnv			:	REnv
                loc			.	mbBindCoe		:	{Maybe RelevCoe}
                loc         .   lUniq           :   UNIQUEREF gUniq
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Transformation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR AllBindAspect [ | | tyAspectL USE {++} {[]}: {[CBindAspect]} ]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Transformation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen) hs
dbg opts t1 t2 amso ams = CExpr_Ann (CExprAnn_Debug $ showPP $ "?:" >#< t1 >#< "<=" >#< t2 >-< "ams:" >#< ams >-< "amso:" >#< amso)
dbgApp opts a f f2 = CExpr_Ann (CExprAnn_Debug $ showPP $ "argTy:" >#< a >#< "funTy:" >#< f >#< "func.ty:" >#< f2)
%%]

%%[(8 codegen)
SEM CExpr
  | Var         loc         .   dbg             =   dbg @lhs.opts @envTy @lhs.knTy @amso @ams
  | Int Char    loc         .   dbg             =   dbg @lhs.opts @litTy @lhs.knTy @amso @ams
  | Tup         loc         .   dbg             =   dbg @lhs.opts @tupTy @lhs.knTy @amso @ams
  | FFI         loc         .   dbg             =   dbg @lhs.opts @ffiTy @lhs.knTy @amso @ams
%%]

%%[(8 codegen)
ATTR AllCodeNT [ | | cTrf: SELF ]
ATTR CodeAGItf [ | | cTrf: CModule ]

SEM CBindAspect
  | Bind        lhs         .   cTrf            =   CBindAspect_Bind @bindMeta.cTrf $ maybe id (\c e -> CExpr_Ann (CExprAnn_Coe $ @lhs.finalRVarMp |=> c) e) @mbBindCoe $ @expr.cTrf

SEM CBind
  | Bind        loc         .   cTrf            =   CBind_Bind @nm (@bindAspects.tyAspectL ++ @bindAspects.cTrf)

SEM CExpr
  | Var Int Char Tup FFI
                lhs         .   cTrf            =   -- @dbg $
                                                    CExpr_Ann (CExprAnn_Coe $ @lhs.finalRVarMp |=> amsoCoe @amso) @cTrf
  | App         lhs         .   cTrf            =   let a = -- dbgApp @lhs.opts @argTy @funTy @func.ty $
                                                            CExpr_Ann (CExprAnn_Coe $ @lhs.finalRVarMp |=> @argCoe) @arg.cTrf
                                                        app = CExpr_App @func.cTrf a
                                                    in  if @lhs.isTopApp
                                                        then CExpr_Ann (CExprAnn_Coe $ @lhs.finalRVarMp |=> @resCoe) app
                                                        else app

SEM CAltL
  | Cons        lhs         .   cTrf            =   case @hd.cTrf of
                                                      CAlt_Alt p e -> CAlt_Alt p (mka @amsoUp $ mka @amsoDw e) : @tl.cTrf
                                                                   where mka amso e = CExpr_Ann (CExprAnn_Coe $ @lhs.finalRVarMp |=> amsoCoe amso) e
%%]

