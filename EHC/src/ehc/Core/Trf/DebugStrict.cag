%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Fully lazy code
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs module {%{EH}Core.Trf.DebugStrict} import(Data.Maybe,qualified Data.Map as Map,{%{EH}Base.Common},{%{EH}Core},{%{EH}Ty}, Data.Function(on), Data.List,{%{EH}Core.Utils}) export(cmodTrfDebugStrict)
%%]

%%[8 hs import({%{EH}Base.Debug},UU.DData.Scc,{%{EH}Core},qualified Data.Set as Set,Debug.Trace)
%%]


%%[8.WRAPPER ag import({Core/AbsSyn})
WRAPPER CodeAGItf
%%]

%%[99
PRAGMA strictcase
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell itf
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs

cmodTrfDebugStrict :: CModule -> CModule
cmodTrfDebugStrict cmod
  =  let  t = wrap_CodeAGItf (sem_CodeAGItf (CodeAGItf_AGItf cmod)) Inh_CodeAGItf
     in   cTrf_Syn_CodeAGItf t
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Transformation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR AllCodeNT [ | | cTrf: SELF ]
ATTR CodeAGItf [ | | cTrf: CModule ]

ATTR AllExpr [ moduleNm : {HsName} | | ]

%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Usage (assumption: unique names) XXX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



%%[8

ATTR CExpr AllBind [  | | whnf USE {&&} {False}: {Bool} ]

SEM CExpr
    | Lam      lhs. whnf = True
    | * - Lam  lhs. whnf = False



SEM CModule
    | Mod expr . moduleNm = @moduleNm

SEM CExpr
    | App         loc         .   cTrf = strictifyApp @func.cTrf @arg.cTrf @argMeta.cTrf
    | Let         loc         .   cTrf = let tr = trace (show $ CExpr_Let @categ @binds.cTrf @body.cTrf)
                                         in case @categ of
                                              CBindRec   
                                                        -> trace ("recursive bind in DBGS stage")
                                                           $ CExpr_Let @categ @binds.cTrf @body.cTrf
                                              CBindPlain ->
                                                  case @binds.cTrf of
                                                    []  -> @body.cTrf
                                                    [CBind_Bind v m e]
                                                        | not @binds.whnf && False
                                                        -> strictifyLet v m e @body.cTrf
                                                    [_] -> CExpr_Let @categ @binds.cTrf @body.cTrf
                                                    _   -> error "Core.Trf.DBGS: more than one bind in plain let"
                                              _           ->
                                                  CExpr_Let @categ @binds.cTrf @body.cTrf
                                                           
%%]


%%[8 hs
%%]
%%[8
{

{-
  turns an application

  f x

  into

  case primNextOracle of
        False -> e1 (error "oracle")
        True -> letstrict h = e2
                in e1 h

-}
strictifyApp :: CExpr -> CExpr -> CMeta -> CExpr
strictifyApp f x m
    = ifThenElse (libcall "primNextOracle" [])
      (letS (qualify "h") x (appV "h" f))
      (letS (qualify "h") (libcall "underscore" []) (appV "h" f))
      


{-
  turns a declaration

  let v = e1 in e2

  into

  case primNextOracle of
    False -> let x = error "oracle!"
             in e2
    True -> letstrict x = e1
            in e2
-}


strictifyLet :: HsName -> CMeta -> CExpr -> CExpr -> CExpr
strictifyLet v m e1 e2 
    = ifThenElse (libcall "primNextOracle" [])
      (letS v e1 e2)
      (letL v (libcall "underscore" []) e2)


ifThenElse :: CExpr -> CExpr -> CExpr -> CExpr
ifThenElse c a b = CExpr_Case c [alt] b
    where alt = CAlt_Alt truePat a
          truePat = undefined -- XXX how is the pattern for "True" encoded?



qualify :: String -> HsName
qualify n = hsnFromString n

localVar :: String -> CExpr
localVar s = CExpr_Var $ qualify s

letS :: HsName -> CExpr -> CExpr -> CExpr
letS v e1 e2 = CExpr_Let CBindStrict [CBind_Bind v CMeta_Val e1] e2

letL :: HsName -> CExpr -> CExpr -> CExpr
letL v e1 e2 = CExpr_Let CBindPlain [CBind_Bind v CMeta_Val e1] e2

dumpOrc, newEntry :: CExpr
dumpOrc   = libcall "primDumpOracle" []
newEntry  = libcall "primOracleNewEntry" []

enterOrc :: String -> CExpr
enterOrc x = libcall "primOracleEnter" [x]

leaveOrc :: String -> String -> CExpr
leaveOrc x y = libcall "primOracleLeave" [x, y]

libcall :: String -> [String] -> CExpr
libcall f xs = foldr appV prelfun xs
    where
      prelfun = CExpr_Var $ mkHNm $ map hsnFromString ["EHC", "Prelude", f]

appV :: String -> CExpr -> CExpr
appV v f = CExpr_App f (localVar v) CMeta_Val
}
%%]
