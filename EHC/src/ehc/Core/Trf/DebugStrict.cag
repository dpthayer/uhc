%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Fully lazy code
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs module {%{EH}Core.Trf.DebugStrict} import(Data.Maybe,qualified Data.Map as Map,{%{EH}Base.Common},{%{EH}Core},{%{EH}Ty}, Data.Function(on), Data.List,{%{EH}Core.Utils}) export(cmodTrfDebugStrict)
%%]

%%[8 hs import({%{EH}Base.Debug},UU.DData.Scc,{%{EH}Core},qualified Data.Set as Set,Debug.Trace)
%%]


%%[8.WRAPPER ag import({Core/AbsSyn})
WRAPPER CodeAGItf
%%]

%%[99
PRAGMA strictcase
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell itf
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs

cmodTrfDebugStrict :: CModule -> CModule
cmodTrfDebugStrict cmod
  =  let  t = wrap_CodeAGItf (sem_CodeAGItf (CodeAGItf_AGItf cmod)) Inh_CodeAGItf
     in   cTrf_Syn_CodeAGItf t
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Transformation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR AllCodeNT [ | | cTrf: SELF ]
ATTR CodeAGItf [ | | cTrf: CModule ]

ATTR AllExpr [ moduleNm : {HsName} | | ]

%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Usage (assumption: unique names) XXX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



%%[8

ATTR CExpr AllBind [  | | whnf USE {&&} {False}: {Bool} ]

SEM CExpr
    | Lam      lhs. whnf = True
    | * - Lam  lhs. whnf = False



SEM CModule
    | Mod expr . moduleNm = @moduleNm

SEM CExpr
    | App         loc         .   cTrf = -- XXX only for non-hnf, non-DICT arguments
                                           libcallE "bindOracleStrict" [@arg.cTrf, @func.cTrf]
    | Let         loc         .   cTrf = let tr = trace (show $ CExpr_Let @categ @binds.cTrf @body.cTrf)
                                         in case @categ of
                                              CBindRec   
                                                        -> trace ("recursive bind in DBGS stage")
                                                           $ CExpr_Let @categ @binds.cTrf @body.cTrf
                                              CBindPlain ->
                                                  case @binds.cTrf of
                                                    []  -> @body.cTrf
                                                    [CBind_Bind v m e]
                                                        | not @binds.whnf && False 
                                                          -- XXX only non-DICT
                                                        -> let lambody = CExpr_Lam v m @body.cTrf
                                                           in libcallE "bindOracleStrict" [e, lambody]
                                                    [_] -> CExpr_Let @categ @binds.cTrf @body.cTrf
                                                    _   -> error "Core.Trf.DBGS: more than one bind in plain let"
                                              _           ->
                                                  CExpr_Let @categ @binds.cTrf @body.cTrf
                                                           
%%]


%%[8 hs
%%]
%%[8
{


libcallV :: String -> [String] -> CExpr
libcallV f xs = foldr appV (prelfun f) xs


libcallE :: String -> [CExpr] -> CExpr
libcallE f xs = foldr appE (prelfun f) xs

prelfun :: String -> CExpr
prelfun f = CExpr_Var $ mkHNm $ map hsnFromString ["EHC", "Prelude", f]


appE :: CExpr -> CExpr -> CExpr
appE x f = CExpr_App f x CMeta_Val


appV :: String -> CExpr -> CExpr
appV v f = appE (localVar v) f

localVar :: String -> CExpr
localVar s = CExpr_Var $ qualify s

qualify :: String -> HsName
qualify n = hsnFromString n

}
%%]
