%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Fully lazy code
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs module {%{EH}Core.Trf.DebugStrict} import(Data.Maybe,qualified Data.Map as Map,{%{EH}Base.Common},{%{EH}Core},{%{EH}Ty}, Data.Function(on), Data.List,{%{EH}Core.Utils}) export(cmodTrfDebugStrict)
%%]

%%[8 hs import({%{EH}Base.Debug},UU.DData.Scc,{%{EH}Core},qualified Data.Set as Set,Debug.Trace)
%%]


%%[8.WRAPPER ag import({Core/AbsSyn})
WRAPPER CodeAGItf
%%]

%%[99
PRAGMA strictcase
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell itf
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs
cmodTrfDebugStrict :: CModule -> CModule
cmodTrfDebugStrict cmod
  =  let  t = wrap_CodeAGItf (sem_CodeAGItf (CodeAGItf_AGItf cmod)) Inh_CodeAGItf
     in   trace (show cmod) $ cTrf_Syn_CodeAGItf t
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Transformation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR AllCodeNT [ | | cTrf: SELF ]
ATTR CodeAGItf [ | | cTrf: CModule ]

ATTR AllExpr [ moduleNm : {HsName} | | ]

%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Usage (assumption: unique names) XXX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



%%[8

ATTR CExpr AllBind [  | | whnf USE {&&} {False}: {Bool} ]

SEM CExpr
    | Lam      lhs. whnf = True
    | * - Lam  lhs. whnf = False



SEM CModule
    | Mod expr . moduleNm = @moduleNm

SEM CExpr
    | Let         loc         .   cTrf = let tr = trace (show $ CExpr_Let @categ @binds.cTrf @body.cTrf)
                                         in case @categ of
                                              CBindRec  |False 
                                                        -> error "recursive bind in DBGS stage"
                                              CBindPlain ->
                                                  case @binds.cTrf of
                                                    []            -> @body.cTrf
                                                    [CBind_Bind v m e]
                                                                   | not @binds.whnf && False
                                                                   -> strictifyLet @lhs.moduleNm v m e @body.cTrf
                                                    [_] -> trace "*"$CExpr_Let @categ @binds.cTrf @body.cTrf
                                                    _             -> error "Core.Trf.DBGS: more than one bind in plain let"
                                              _           ->
                                                  CExpr_Let @categ @binds.cTrf @body.cTrf
                                                           
%%]


%%[8 hs
%%]
%%[8
{
strictifyLet :: HsName -> HsName -> CMeta -> CExpr -> CExpr -> CExpr
strictifyLet modNm v m e1 e2 
    = let  inner = letS (qualify modNm "o'" ) enterOrc inner'
           inner' = letS (qualify modNm "r") e1 leave
           leave = CExpr_App (CExpr_App leaveOrc (qualvar modNm "o'") CMeta_Val) (qualvar modNm "r") CMeta_Val
      in letS (qualify modNm "o") newEntry (trace ("letL v:" ++ show v) $ letL v inner e2)

qualify :: HsName -> String -> HsName
qualify q n = hsnSetQual q $ hsnFromString n

qualvar :: HsName -> String -> CExpr
qualvar q n
  = CExpr_Var $ qualify q n


letS, letL :: HsName -> CExpr -> CExpr -> CExpr
letS v e1 e2 = CExpr_Let CBindStrict [CBind_Bind v CMeta_Val e1] e2
letL v e1 e2 = CExpr_Let CBindPlain [CBind_Bind v CMeta_Val e1] e2

dumpOrc, enterOrc, leaveOrc, newEntry :: CExpr
dumpOrc   = prelvar "primDumpOracle"
newEntry  = prelvar "primOracleNewEntry"
enterOrc  = prelvar "primOracleEnter"
leaveOrc  = prelvar "primOracleLeave"

prelvar :: String -> CExpr
prelvar n = CExpr_Var $ mkHNm [ehcname, prelname, hsnFromString n]
    where  ehcname = hsnFromString "EHC"
           prelname = hsnFromString "Prelude"


}
%%]