%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Fully lazy code
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs module {%{EH}Core.Trf.LetUnMutual} import(Data.Maybe,qualified Data.Map as Map,{%{EH}Base.Common},{%{EH}Core},{%{EH}Ty}, Data.Function(on), Data.List,{%{EH}Core.Utils}) export(cmodTrfLetUnMutual)
%%]

%%[8 hs import({%{EH}Base.Debug},UU.DData.Scc,{%{EH}Core},qualified Data.Set as Set,Debug.Trace)
%%]

%%[8.WRAPPER ag import({Core/AbsSyn},{Core/Trf/CommonFv})
WRAPPER CodeAGItf
%%]

%%[99
PRAGMA strictcase
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell itf
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs
cmodTrfLetUnMutual :: CModule -> CModule
cmodTrfLetUnMutual cmod
  =  let  t = wrap_CodeAGItf (sem_CodeAGItf (CodeAGItf_AGItf cmod)) Inh_CodeAGItf
     in   cTrf_Syn_CodeAGItf t
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Transformation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR AllCodeNT [ | | cTrf: SELF ]
ATTR CodeAGItf [ | | cTrf: CModule ]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Usage 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Bound id's
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs
type BindMp = Map.Map HsName (CExpr,CMeta)
%%]

%%[8
ATTR AllExpr [ moduleNm : {HsName} | | ]

SEM CModule    
    | Mod expr . moduleNm = @moduleNm


ATTR AllBind [ | | bindMp USE {`Map.union`} {Map.empty}: BindMp ]


SEM CBind
  | Bind        lhs         .   bindMp      =   @nm `Map.singleton` (@expr.cTrf,@bindMeta.cTrf)
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Finding SCC's, constructing transformation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
SEM CExpr
    | Let  loc  .  cTrf
               =   if @categ == CBindRec
                   then  let  mk n b = let (e,m) = rhs n
                                         in mkCExprLet CBindPlain [ mkCBind1Meta n m e] b
                              mkLets = foldr mk
                              (bs, rs, fbs) 
                                  = feedbackSet @body.fvS @binds.fvSMp
                              rhs x = let err= error "internal error"
                                      in  Map.findWithDefault err x @binds.bindMp
                              recname = qualify @lhs.moduleNm "r"
                              recs  = mkFbSelectors recname fbs $ mkLets (feedbackTuple rhs fbs) rs
                              body  = mkFbSelectors recname fbs $ mkLets @body.cTrf  bs
                         in mkCExprLet CBindRec [mkCBind1Meta recname CMeta_Val recs] body
                   else  CExpr_Let @categ @binds.cTrf @body.cTrf
%%]


%%[8 hs


{-
  from a list of feedback vars and a function that retrieves their
  right hand sides, create an expression that builds a tuple:

  (...(Tup (rhs f1) (rhs f2)) ... (rhs fn))
-}
feedbackTuple :: (a-> (CExpr, CMeta)) -> [a] -> CExpr
feedbackTuple rhs = foldr (\f t -> let (e,m) = rhs f 
                             in CExpr_App t e m) (CExpr_Tup CTagRec)


{-
  from a list of feedback vars, create a pattern
  that matches a tuple:

  (Tup f1 f2 ... fn)
-}
fbPat :: [HsName] -> CPat
fbPat fbs = mkCPatCon (CTagRec) (length fbs) (Just fbs)


{-
  from a variable name and a feedback set, create an expression that
  retrieves this value from the feedbackTuple:

  case rec of (Tup f1 f2 .. fn) -> v
-}
mkFeedbackRhs :: HsName -> HsName -> [HsName] -> CExpr
mkFeedbackRhs r v fvs = CExpr_Case (CExpr_Var r) [alt] (preludeVar "undefined")
    where alt :: CAlt
          alt = CAlt_Alt (fbPat fvs) (CExpr_Var v)


{-
  surrounds the body with defintions for the
  feebback vars:

  let f1 = case r of (Tup f1 ..) -> f1
  in let f2 = case r of (Tup f1 f2 ..) -> f2
     in body
-}
mkFbSelectors :: HsName -> [HsName] -> CExpr -> CExpr
mkFbSelectors v fbs body = foldr mkFbLet body fbs
    where mkFbLet f b = let e = mkFeedbackRhs v f fbs
                            m = CMeta_Val
                        in mkCExprLet CBindPlain [ mkCBind1Meta f m e] b


{-
  compute where the variables will be defined
-}
feedbackSet :: FvS -> FvSMp -> ([HsName], [HsName], [HsName]) -- (body, recs, fbs)
feedbackSet pulling deps = let sccs      = sccFromMap deps (Map.keys deps)
                               (sr, nsr) =  foldr singlerecs ([],[]) sccs
                               (b,r,f)    = fbSet pulling nsr
                           in (b, r, sr ++ f)
    where singlerecs (Left ns) (sr, nsr) = let (a,b) = partition (\n->n `Set.member` refs n) ns
                                           in  (a ++ sr, sccFromMap deps b ++ nsr)
          singlerecs (Right n) (sr, nsr) = (sr, Right n : nsr) 

          refs n = Map.findWithDefault Set.empty n deps
          fbSet :: FvS -> SCC -> ([HsName], [HsName], [HsName])
          fbSet pull []      = ([], [], [])
          fbSet pull (Left []:ds)
              = fbSet pull ds
          fbSet pull (Right n:ds) 
              | n `Set.member` pull      -- needed in body and in recs
              = let pull' = refs n `Set.union` pull
                    (body, recs, fbs) = fbSet pull' ds
                in (n:body, n:recs, fbs)
              | otherwise          -- needed only in recs
              = let  
                     (body, recs, fbs) = fbSet pull ds
                in (body, n:recs, fbs)
          fbSet pull (Left d:ds)
              = let n         = maximumBy (compare `on` weight) d
                    d'        = filter (/= n) d
                    weight x  = let xs = refs x
                                in (x `Set.member` pull, Set.size $ Set.filter (`elem` d) xs)
                    sccs      = sccFromMap deps d'
                    (body, recs, fbs) = fbSet pull (sccs ++ ds)
                in (body, recs, n:fbs)



qualify :: HsName -> String -> HsName
qualify q n = hsnSetQual q $ hsnFromString n


qualvar :: HsName -> String -> CExpr
qualvar q n
    = CExpr_Var $ qualify q n

preludeVar :: String -> CExpr
preludeVar n = CExpr_Var $ mkHNm [ehcname, prelname, hsnFromString n]
    where  ehcname = hsnFromString "EHC"
           prelname = hsnFromString "Prelude"



{-
  interface to scc,
  (scc differs from the functions in Data.Graph: every node that
  another node points to will be contained in the SCC list.
  This is not what we want here.)
 -}
type SCC = [Either [HsName] HsName]

sccFromMap :: FvSMp -> [HsName] -> SCC
sccFromMap m n = let m' = filter (\(x,_)->x `elem` n) $ Map.toList m
                     m'' = map (\(x,ys) -> (x, filter (`elem` n) $ Set.toList ys)) m'
                     f [x] | x  `Set.member` Map.findWithDefault Set.empty x m
                               = Left [x]
                           | otherwise
                               = Right x
                     f xs = Left xs
                 in map f (scc m'')


-- trc t x= trace (t ++ ": " ++ show x) x 

%%]



%%[8 hs import(EH.Util.Utils)
%%]
