%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

Pass all free variables of lambda expressions explicitly.
Later, these lambda expressions can then be lifted globally.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Globals as args
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs module {%{EH}Core.Trf.LamGlobalAsArg} import(EH.Util.Utils,Data.Maybe,qualified Data.Set as Set,Data.List,qualified Data.Map as Map,{%{EH}Base.Common},{%{EH}Core},{%{EH}Ty}) export(cmodTrfLamGlobalAsArg)
%%]

-- for debug
%%[8 hs import({%{EH}Base.Debug},EH.Util.Pretty)
%%]

%%[8.WRAPPER ag import({Core/AbsSyn},{Core/CommonLev},{Core/Trf/CommonFv},{Core/Trf/CommonLev})
WRAPPER CodeAGItf
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell itf
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs
cmodTrfLamGlobalAsArg :: CModule -> CModule
cmodTrfLamGlobalAsArg cmod
  =  let  t = wrap_CodeAGItf  (sem_CodeAGItf (CodeAGItf_AGItf cmod))
                              (Inh_CodeAGItf)
     in   cTrf_Syn_CodeAGItf t
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Unique
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR AllCodeNT [ | gUniq: Int | ]

SEM CodeAGItf
  | AGItf       module      .   gUniq       =   0
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Level
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
SEM CExpr
  | Let         binds       .   lev         =   @lhs.lev + 1
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Which id's are functions resp values
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR AllBind [ | | bindVarS, bindLamS USE {`Set.union`} {Set.empty}: FvS ]

SEM CBind
  | Bind        lhs         .   (bindVarS,bindLamS)
                                            =   if @expr.isLam
                                                then (Set.empty,Set.singleton @nm)
                                                else (Set.singleton @nm,Set.empty)
  | FFI         lhs         .   bindVarS    =   Set.singleton @nm
%%]

%%[8
ATTR AllCodeNT [ varS, lamS: FvS | | ]

SEM CodeAGItf
  | AGItf       module      .   varS        =   Set.empty
                            .   lamS        =   Set.empty

SEM CExpr
  | Let         loc         .   varS        =   @lhs.varS `Set.union` @binds.bindVarS
                            .   lamS        =   @lhs.lamS `Set.union` @binds.bindLamS
  | Lam         loc         .   varS        =   @arg `Set.insert` @lhs.varS

SEM CAlt
  | Alt         expr        .   varS        =   @lhs.varS `Set.union` Set.fromList @pat.nmL
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Free var of lam's for which arg lifting is done
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs
startFvSLamMp :: FvS -> FvS -> FvS -> FvSMp -> FvSMp -> (FvSMp,FvSMp)
startFvSLamMp bLamS lamS varS fvm bFvm
  =  let  bFvm2    =  Map.filterWithKey (\n _ -> n `Set.member` bLamS) bFvm
          fvlam  s =  lamS `Set.intersection` s
          fvvar  s =  varS `Set.intersection` s
          fv     s =  fvvar s `Set.union`
                        (Set.unions $ map (\n -> Map.findWithDefault Set.empty n fvm) $ Set.toList $ fvlam $ s)
     in   (Map.map fv bFvm2,Map.map (`Set.intersection` bLamS) bFvm2)

iterFvSLamMp :: FvSMp -> FvSMp -> FvSMp
iterFvSLamMp frLamMp frVarMp
  =  let  frVarMp2 = Map.mapWithKey
                       (\n s -> s `Set.union` (Set.unions
                                               $ map (\n -> panicJust "iterFvSLamMp.1" $ Map.lookup n $ frVarMp)
                                               $ Set.toList
                                               $ panicJust "iterFvSLamMp.2"
                                               $ Map.lookup n frLamMp
                       )                      )
                       frVarMp
          sz = sum . map Set.size . Map.elems
     in   if sz frVarMp2 > sz frVarMp
          then iterFvSLamMp frLamMp frVarMp2
          else frVarMp
%%]

%%[8
ATTR AllCodeNT [ fvSLamMp: FvSMp | | ]

SEM CodeAGItf
  | AGItf       module      .   fvSLamMp    =   Map.empty

SEM CExpr
  | Let         loc         .   fvSLamMp    =   (let  start varS = startFvSLamMp @binds.bindLamS @lhs.lamS varS @lhs.fvSLamMp $ @binds.fvSMp
                                                 in   case @categ of
                                                        CBindRec  ->  iterFvSLamMp lm m
                                                                  where (m,lm)  = start (@lhs.varS `Set.union` @binds.bindVarS)
                                                        _         ->  m
                                                                  where (m,_)   = start @lhs.varS
                                                )
                                                `Map.union` @lhs.fvSLamMp
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Is expr a let?
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
%%]
ATTR CExpr [ | | isLet: Bool ]

SEM CExpr
  | Let         lhs         .   isLet       =   True
  | * - Let     lhs         .   isLet       =   False

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Has a strictness?
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
%%]
ATTR CExpr [ | | hasStrict: Bool ]

SEM CExpr
  | TupIns TupDel Case
                lhs         .   hasStrict   =   True
  | * - TupIns TupDel Case
                lhs         .   hasStrict   =   False

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Mapping of argument names
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR AllCodeNT [ argSubst: {Map.Map HsName HsName} | | ]

SEM CodeAGItf
  | AGItf       module      .   argSubst    =   Map.empty

SEM CBind
  | Bind        expr        .   argSubst    =   @argMp `Map.union` @lhs.argSubst
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Adding parameters to lam call sites
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs
type LamArgMp = Map.Map HsName [HsName]
%%]

%%[8
ATTR AllBind [ | | bindLamArgMp USE {`Map.union`} {Map.empty}: LamArgMp ]
ATTR AllCodeNT [ lamArgMp: LamArgMp | | ]

SEM CodeAGItf
  | AGItf       module      .   lamArgMp    =   Map.empty

SEM CExpr
  | Let         loc         .   lamArgMp    =   @binds.bindLamArgMp `Map.union` @lhs.lamArgMp
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Additional used identifiers for mutual recursive definitions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR AllCodeNT [ mutRecMp: LevMp | | ]

SEM CodeAGItf
  | AGItf       module      .   mutRecMp    =   Map.empty

SEM CExpr
  | Let         binds       .   mutRecMp    =   (if @categ == CBindRec
                                                 then Map.fromList (zip @binds.nmL (repeat @lhs.lev)) `Map.union` @lhs.mutRecMp
                                                 else @lhs.mutRecMp
                                                )
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Transformation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs
fvLAsArg :: LevMp -> FvS -> AssocL HsName Int
fvLAsArg levMp fvS
  =  sortOn snd
     $ filter (\(_,l) -> l > cLevModule)
     $ map (\n -> (n,fvLev levMp n))
     $ Set.toList fvS

mkFvNm :: Int -> HsName -> HsName
mkFvNm i n = hsnSuffix n ("~" ++ show i)

fvLArgRepl :: Int -> AssocL HsName Int -> ([HsName],[HsName],Map.Map HsName HsName)
fvLArgRepl uniq argLevL
  =  let  argOL = assocLKeys argLevL
          argNL = zipWith (\u n -> mkFvNm u n) [uniq..] argOL
     in   (argOL,argNL,Map.fromList (zip argOL argNL))

varRepl :: Map.Map HsName HsName -> HsName -> CExpr
varRepl nMp n = maybe (CExpr_Var n) CExpr_Var $ Map.lookup n nMp
%%]

%%[8
ATTR AllCodeNT [ | | cTrf: SELF ]
ATTR CodeAGItf [ | | cTrf: CModule ]

SEM CBind
  | Bind        (expr.gUniq,loc.argMp,lhs.cTrf,loc.bindLamArgMp)
                                            =   if @expr.isLam
                                                then  let  argLevL = fvLAsArg @lhs.introLevMp $ panicJust "CBind.Bind.argLevL" $ Map.lookup @nm $ @lhs.fvSLamMp
                                                           (argOL,argNL,argONMp) = fvLArgRepl @lhs.gUniq $ argLevL
                                                      in   ( @lhs.gUniq + length argOL
                                                           , argONMp
                                                           , CBind_Bind @nm (mkCExprLam argNL @expr.cTrf)
                                                           , @nm `Map.singleton` argOL
                                                           )
                                                else  ( @lhs.gUniq, Map.empty, @cTrf, Map.empty )
  | FFI         loc         .   bindVarBindL=   [@cTrf]
%%]

%%[8
SEM CExpr
  | Var         lhs         .   cTrf        =   let  r n = varRepl @lhs.argSubst n
                                                     v1 = r @nm
                                                     v2 = maybe v1 (mkCExprApp v1 . map r) $ Map.lookup @nm $ @lhs.lamArgMp
                                                in   v2
%%]
