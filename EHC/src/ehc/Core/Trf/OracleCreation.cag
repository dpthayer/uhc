%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Fully lazy code
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs module {%{EH}Core.Trf.OracleCreation} import(Data.Maybe,qualified Data.Map as Map,{%{EH}Base.Common},{%{EH}Core},{%{EH}Ty}, Data.Function(on), Data.List,{%{EH}Core.Utils}) export(cmodTrfOracleCreation)
%%]

%%[8 hs import({%{EH}Base.Debug},UU.DData.Scc,{%{EH}Core},qualified Data.Set as Set,Debug.Trace)
%%]


%%[8.WRAPPER ag import({Core/AbsSyn})
WRAPPER CodeAGItf
%%]

%%[99
PRAGMA strictcase
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell itf
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs

cmodTrfOracleCreation :: CModule -> CModule
cmodTrfOracleCreation cmod
  =  let  t = wrap_CodeAGItf (sem_CodeAGItf (CodeAGItf_AGItf cmod)) Inh_CodeAGItf
     in   cTrf_Syn_CodeAGItf t
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Transformation
%%%
%%% We have to move all FFI declarations to the outermost level, because otherwise
%%% invalid GRIN code will be generated.
%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR AllCodeNT [ | | cTrf: SELF ]
ATTR CodeAGItf [ | | cTrf: CModule ]

ATTR AllExpr [ moduleNm : {HsName} | | ]

ATTR AllExpr [ isHead : {Bool} | | ]



SEM CModule
    | Mod expr . isHead   = True

SEM CExpr
    | Let binds.isHead  = False



ATTR AllExpr [ | | ffiDecls USE {++} {[]}: CBindL ]

SEM CBind
    | FFI  lhs . ffiDecls = [CBind_FFI @callconv @safety @impEnt @nm @ty]

%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Usage (assumption: unique names) XXX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



%%[8

ATTR CExpr AllBind [  | | whnf USE {&&} {True}: {Bool} ]

SEM CExpr
    | Lam      lhs. whnf = True
    | * - Lam  lhs. whnf = False



SEM CModule
    | Mod expr . moduleNm = @moduleNm
    | Mod loc  . cTrf     =  let expr' = CExpr_Let CBindPlain @expr.ffiDecls
                                         (letS "x_o" (libcall @moduleNm "primInitOracle" [])
                                         (letS "x_r" @expr.cTrf
                                          (letS "x_l" (libcall @moduleNm "primDumpOracle" [])
                                           (libcall @moduleNm "print" ["x_l"])
                                          )
                                         ))
                             in CModule_Mod @moduleNm  expr' @ctagsMp
                             

SEM CExpr
    | App    loc   .   cTrf = strictifyApp @lhs.moduleNm @func.cTrf @arg.cTrf @argMeta.cTrf
    | Let    loc   .   cTrf = let tr = trace (show $ CExpr_Let @categ @binds.cTrf @body.cTrf)
                                  binds = filter noFFI @binds.cTrf
                                  noFFI (CBind_FFI _ _ _ _ _) = False
                                  noFFI _               = True
                              in if null binds then
                                     @body.cTrf
                                 else case @categ of
                                        CBindPlain ->
                                            case binds of
                                              []  -> @body.cTrf
                                              [CBind_Bind v m e]
                                                | not @binds.whnf -- && False
                                                    -> strictifyLet @lhs.moduleNm v m e @body.cTrf
                                              [_] -> CExpr_Let @categ binds @body.cTrf
                                              _   -> error $ "Core.Trf.ORC: more than one bind in plain let"
                                                     ++ show binds
                                        _  ->  -- if the bound expr is in whnf, then it may be recursive
                                             CExpr_Let @categ binds @body.cTrf


%%]


%%[8 hs
%%]
%%[8
{

{-
  turns an application

  f x

  into

  letstrict o = primOracleNewEntry
  in  f (letstrict o2 = primOracleEnter o
         in letstrict r = x
            in primOracleLeave o2 r)

-}
strictifyApp :: HsName -> CExpr -> CExpr -> CMeta -> CExpr
strictifyApp m f x meta
    = letS "o" (newEntry m)
      (CExpr_App f 
       (letS "o2" (enterOrc m "o")
        (letS "r" x
         (leaveOrc m "o2" "r")))
       meta)


{-
  turns a declaration

  let v = e1 in e2

  into

  letstrict o = primOracleNewEntry
  in  let v = letstrict o2 = primOracleEnter o
              in letstrict r = e1
                 in primOracleLeave o2 r
      in e2
-}
strictifyLet :: HsName -> HsName -> CMeta -> CExpr -> CExpr -> CExpr
strictifyLet m v meta e1 e2 
    = let inner = letS "o2" (enterOrc m "o")
                  (letS "r" e1
                   (leaveOrc m "o2" "r"))
      in letS "o" (newEntry m)
             (letL v inner
                   e2)

-- qualify q n = hsnSetQual q $ hsnFromString n


localVar :: String -> CExpr
localVar s = CExpr_Var $ hsnFromString s

letS :: String -> CExpr -> CExpr -> CExpr
letS v e1 e2 = CExpr_Let CBindStrict [CBind_Bind (hsnFromString v) CMeta_Val e1] e2

letL :: HsName -> CExpr -> CExpr -> CExpr
letL v e1 e2 = CExpr_Let CBindPlain [CBind_Bind v CMeta_Val e1] e2

dumpOrc, newEntry :: HsName -> CExpr
dumpOrc  m = libcall m "primDumpOracle" []
newEntry m = libcall m "primOracleNewEntry" []

enterOrc :: HsName -> String -> CExpr
enterOrc m x = libcall m "primOracleEnter" [x]

leaveOrc :: HsName -> String -> String -> CExpr
leaveOrc m x y = libcall m "primOracleLeave" [x, y]

libcall :: HsName -> String -> [String] -> CExpr
libcall modname f xs = foldr appV prelfun xs
    where
      -- prelfun = CExpr_Var $ mkHNm $ map hsnFromString ["EHC", "Prelude", f]
      prelfun = CExpr_Var $ hsnSetQual modname $ hsnFromString f
      appV :: String -> CExpr -> CExpr
      appV v f = CExpr_App f (localVar v) CMeta_Val
}
%%]
