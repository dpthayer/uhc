%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Fully lazy code
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs module {%{EH}Core.Trf.OracleCreation} import(Data.Maybe,qualified Data.Map as Map,{%{EH}Base.Common},{%{EH}Core},{%{EH}Ty}, Data.Function(on), Data.List,{%{EH}Core.Utils}) export(cmodTrfOracleCreation)
%%]

%%[8 hs import({%{EH}Base.Debug},UU.DData.Scc,{%{EH}Core},qualified Data.Set as Set,Debug.Trace)
%%]


%%[8.WRAPPER ag import({Core/AbsSyn})
WRAPPER CodeAGItf
%%]

%%[99
PRAGMA strictcase
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell itf
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs

cmodTrfOracleCreation :: CModule -> CModule
cmodTrfOracleCreation cmod
  =  let  t = wrap_CodeAGItf (sem_CodeAGItf (CodeAGItf_AGItf cmod)) Inh_CodeAGItf
     in   cTrf_Syn_CodeAGItf t
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Transformation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR AllCodeNT [ | | cTrf: SELF ]
ATTR CodeAGItf [ | | cTrf: CModule ]

ATTR AllExpr [ moduleNm : {HsName} | | ]

%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Usage (assumption: unique names) XXX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



%%[8

ATTR CExpr AllBind [  | | whnf USE {&&} {False}: {Bool} ]

SEM CExpr
    | Lam      lhs. whnf = True
    | * - Lam  lhs. whnf = False



SEM CModule
    | Mod expr . moduleNm = @moduleNm
    | Mod loc  . cTrf     =  let expr' = letS "o" (libcall "primInitOracle" [])
                                         (letS "r" @expr.cTrf
                                          (letS "l" (libcall "primDumpOrace" [])
                                           (libcall "print" ["l"])
                                          )
                                         )
                             in CModule_Mod @moduleNm  @expr.cTrf @ctagsMp
                             

SEM CExpr
    | App         loc         .   cTrf = strictifyApp @func.cTrf @arg.cTrf @argMeta.cTrf
    | Let         loc         .   cTrf = let tr = trace (show $ CExpr_Let @categ @binds.cTrf @body.cTrf)
                                         in case @categ of
                                              CBindRec   
                                                        -> trace ("recursive bind in DBGS stage")
                                                           $ CExpr_Let @categ @binds.cTrf @body.cTrf
                                              CBindPlain ->
                                                  case @binds.cTrf of
                                                    []  -> @body.cTrf
                                                    [CBind_Bind v m e]
                                                        | not @binds.whnf && False
                                                        -> strictifyLet v m e @body.cTrf
                                                    [_] -> CExpr_Let @categ @binds.cTrf @body.cTrf
                                                    _   -> error "Core.Trf.DBGS: more than one bind in plain let"
                                              _           ->
                                                  CExpr_Let @categ @binds.cTrf @body.cTrf
                                                           
%%]


%%[8 hs
%%]
%%[8
{

{-
  turns an application

  f x

  into

  letstrict o = primOracleNewEntry
  in  f (letstrict o2 = primOracleEnter o
         in letstrict r = x
            in primOracleLeave o2 r)

-}
strictifyApp :: CExpr -> CExpr -> CMeta -> CExpr
strictifyApp f x m
    = letS "o" newEntry 
      (CExpr_App f 
       (letS "o2" (enterOrc "o")
        (letS "r" x
         (leaveOrc "o2" "r")))
       m)


{-
  turns a declaration

  let v = e1 in e2

  into

  letstrict o = primOracleNewEntry
  in  let v = letstrict o2 = primOracleEnter o
              in letstrict r = e1
                 in primOracleLeave o2 r
      in e2
-}
strictifyLet :: HsName -> CMeta -> CExpr -> CExpr -> CExpr
strictifyLet v m e1 e2 
    = let inner = letS "o2" (enterOrc "o")
                  (letS "r" e1
                   (leaveOrc "o2" "r"))
      in letS "o" newEntry
             (letL v inner
                   e2)


qualify :: String -> HsName
qualify n = hsnFromString n

localVar :: String -> CExpr
localVar s = CExpr_Var $ qualify s

letS :: String -> CExpr -> CExpr -> CExpr
letS v e1 e2 = CExpr_Let CBindStrict [CBind_Bind (qualify v) CMeta_Val e1] e2

letL :: HsName -> CExpr -> CExpr -> CExpr
letL v e1 e2 = CExpr_Let CBindPlain [CBind_Bind v CMeta_Val e1] e2

dumpOrc, newEntry :: CExpr
dumpOrc   = libcall "primDumpOracle" []
newEntry  = libcall "primOracleNewEntry" []

enterOrc :: String -> CExpr
enterOrc x = libcall "primOracleEnter" [x]

leaveOrc :: String -> String -> CExpr
leaveOrc x y = libcall "primOracleLeave" [x, y]

libcall :: String -> [String] -> CExpr
libcall f xs = foldr appV prelfun xs
    where
      prelfun = CExpr_Var $ mkHNm $ map hsnFromString ["EHC", "Prelude", f]
      appV :: String -> CExpr -> CExpr
      appV v f = CExpr_App f (localVar v) CMeta_Val
}
%%]
