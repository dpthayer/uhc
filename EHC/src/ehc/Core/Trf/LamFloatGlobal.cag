%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

Float all lambda's to global level.
Assume that each lambda has no free variables, other than the globally available ones.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Float lambda's to global level
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs module {%{EH}Core.Trf.LamFloatGlobal} import(EH.Util.Utils,qualified EH.Util.FastSeq as Seq,{%{EH}Base.Common},{%{EH}Core},{%{EH}Ty}) export(cmodTrfLamFloatGlobal)
%%]

%%[8 hs import(Data.Maybe)
%%]

-- for debug
%%[8 hs import({%{EH}Base.Debug},EH.Util.Pretty)
%%]

%%[8.WRAPPER ag import({Core/AbsSyn},{Core/CommonLev})
WRAPPER CodeAGItf
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell itf
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs
cmodTrfLamFloatGlobal :: CModule -> CModule
cmodTrfLamFloatGlobal cmod
  =  let  t = wrap_CodeAGItf  (sem_CodeAGItf (CodeAGItf_AGItf cmod))
                              (Inh_CodeAGItf)
     in   cTrf_Syn_CodeAGItf t
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Level
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
SEM CExpr
  | Let         binds       .   lev         =   @lhs.lev + 1
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Transformation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR AllCodeNT [ | | cTrf: SELF  cFloatedBinds USE {Seq.:++:} {Seq.empty}: {Seq.FastSeq (CBindCateg,Seq.FastSeq CBind)} ]
ATTR AllBind   [ | | cLamBinds, cOtherBinds USE {Seq.:++:} {Seq.empty}: {Seq.FastSeq CBind} ]
ATTR CodeAGItf [ | | cTrf: CModule ]

SEM CBind
  | Bind        lhs         .   (cOtherBinds,cLamBinds)
                                            =   if @expr.isLam
                                                then (Seq.empty,Seq.singleton @cTrf)
                                                else (Seq.singleton @cTrf,Seq.empty)
  | FFI         lhs         .   cOtherBinds =   Seq.singleton @cTrf

SEM CExpr
  | Let         lhs         .   (cTrf,cFloatedBinds)
                                            =   if @lhs.lev == cLevModule
                                                then ( foldr (\(c,b) e -> mkCExprLet c (Seq.toList b) e) @body.cTrf
                                                       $ Seq.toList (@binds.cFloatedBinds Seq.:++: Seq.singleton (@categ,@binds.cLamBinds Seq.:++: @binds.cOtherBinds))
                                                     , Seq.empty
                                                     )
                                                else ( mkCExprLet @categ (Seq.toList @binds.cOtherBinds) @body.cTrf
                                                     , Seq.singleton (@categ,@binds.cLamBinds) Seq.:++: @binds.cFloatedBinds Seq.:++: @body.cFloatedBinds
                                                     )
%%]

