-------------------------------------------------------------------------
-- Convert Text to UniformContent
-------------------------------------------------------------------------

{
module Text.Trf.UniformContent
  ( textTrfUniformContent
  )
  where

import qualified Data.Map as Map
import qualified Data.Set as Set

import EH.Util.Utils
-- import EH.Util.Pretty
import qualified EH.Util.FastSeq as Seq

import Common
import Text
import Text.Parser.Common
import Plugin


}

-------------------------------------------------------------------------
-- Interfacing
-------------------------------------------------------------------------

WRAPPER AGItf

{
textTrfUniformContent :: Opts -> PluginMp -> AGItf -> (AGItf,[Err])
textTrfUniformContent opts pluginMp txt
  = (trf_Syn_AGItf t, Seq.toList $ errs_Syn_AGItf t)
  where t = wrap_AGItf (sem_AGItf txt)
                       (Inh_AGItf { opts_Inh_AGItf 		= opts
                                  , pluginMp_Inh_AGItf 	= pluginMp
                                  })
}

-------------------------------------------------------------------------
-- AST
-------------------------------------------------------------------------

INCLUDE "Text/AbsSyn.ag"

-------------------------------------------------------------------------
-- Global info
-------------------------------------------------------------------------

ATTR AGItf AllNT [ opts: Opts  pluginMp: PluginMp | | ]

-------------------------------------------------------------------------
-- Errors
-------------------------------------------------------------------------

ATTR AGItf AllText [ | | errs USE {`Seq.union`} {Seq.empty}: {Seq.Seq Err} ]

SEM TextItem
  | T2T             lhs         .   errs		=	@text.errs `Seq.union` @errs

-------------------------------------------------------------------------
-- Partial replacement to be fed in parser
-------------------------------------------------------------------------

ATTR AllText [ | | scInput USE {`Seq.union`} {Seq.empty}: {Seq.Seq ScInput} ]

SEM TextItem
  | Line  			loc			.	scInput		=   Seq.fromList [ScInput_Uninterpreted @str, ScInput_Uninterpreted "\n"]
  | LineFeed		loc			.	scInput		=   Seq.singleton (ScInput_Uninterpreted "\n")
  | * - Line LineFeed
  					loc			.	scInput		=   Seq.singleton (ScInput_TextAST [@trf])

-------------------------------------------------------------------------
-- Replacement, as TextItems
-------------------------------------------------------------------------

ATTR AllText [ | | textItems USE {`Seq.union`} {Seq.empty}: {Seq.Seq TextItem} ]

SEM TextItem
  | T2T             loc         .   (textItems,errs)
                                                =   case Map.lookup @texttype @lhs.pluginMp of
                                                      Just plg -> (res,Seq.fromList $ map (Err_Out . out . show) $ err)
                                                               where toks = scan (plgScanOptsMp plg) (plgScanInitState plg) (Seq.toList @text.scInput)
                                                                     (res,err) = parseToResMsgs (plgParseTextItems plg) toks -- (tr "XX" (show toks) toks)
                                                      _        -> (Seq.singleton (TextItem_NonSpace ("no uniformification for " ++ show @texttype)),Seq.singleton (Err_NoPlugin @texttype))
  | * - T2T  		loc			.	textItems	=   Seq.singleton @trf

-------------------------------------------------------------------------
-- Replacement, as Text
-------------------------------------------------------------------------

ATTR AGItf AllNT [ | | trf: SELF ]

SEM AGItf
  | AGItf			lhs			.	trf			=	AGItf_AGItf (Seq.toList @text.textItems)

SEM TextItem
  | RefTo	  		loc			.	trf			=   TextItem_RefTo @reftype.trf (Seq.toList @reftext.textItems) (Seq.toList @text.textItems)
  | Header  		loc			.	trf			=   TextItem_Header @level.trf (Seq.toList @text.textItems)
  | Styled  		loc			.	trf			=   TextItem_Styled @style.trf (Seq.toList @text.textItems)
  | Group  			loc			.	trf			=   TextItem_Group @envtype.trf (Seq.toList @text.textItems)
  | T2T			  	loc			.	trf			=   TextItem_T2T @texttype []



