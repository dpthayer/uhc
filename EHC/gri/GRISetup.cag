% $Id: EHC.lag 199 2004-05-12 19:11:13Z andres $

%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell importable interface to Code's Java gen
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs import(GRIRun,EHCommon,GrinCode) export(grGriSetup)
%%]

%%[8 hs import(FiniteMap,Data.Array,Data.Array.IO)
%%]

%%[8.WRAPPER import(GrinCodeAbsSyn)
WRAPPER GrAGItf
%%]

%%[8 hs
grGriSetup :: GrModule -> RunState
grGriSetup cmod
  =  let  t = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf cmod)) Inh_GrAGItf
     in   (rs_Syn_GrAGItf t)
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Initial run state
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8 hs
mkLamGlob :: Int -> AssocL HsName RunVal -> (AssocL HsName RunVal,AssocL Int RunVal)
mkLamGlob st = unzip . zipWith (\p (n,v) -> ((n,RVPtr p),(p,v))) [st..]

mkCafGlob :: Int -> AssocL HsName RunVal -> (AssocL Int RunVal,AssocL HsName RunVal,AssocL Int RunVal)
mkCafGlob st g
  =  let  (p2vCode,binds)
            = unzip
            . zipWith (\p (n,v)
                         ->  ((p,v)
                             ,((n,RVPtr (p+1)),(p+1,mkRN [RVCat NdFun,RVPtr p]))
                             )
                      ) [st,st+2..]
            $ g
          (n2pCaf,p2vCaf)
            = unzip binds
     in   (p2vCode,n2pCaf,p2vCaf)
%%]

%%[8
ATTR GrAGItf GrModule [ | | rs: RunState ]

SEM GrModule
  | Mod         lhs         .   rs          =   let  (n2pLam,p2vLam)
                                                                 = mkLamGlob 0 @bindL.lamGlobL
                                                     (p2vCode,n2pCaf,p2vCaf)
                                                                 = mkCafGlob (length n2pLam) @bindL.cafGlobL
                                                     n2p'        = listToFM n2pLam `plusFM` listToFM n2pCaf
                                                     p2v'        = listToFM p2vLam `plusFM` listToFM p2vCaf `plusFM` listToFM p2vCode
                                                     sz          = sizeFM p2v'
                                                     h           = RunHeap { rhMem = p2v', rhSize = sz, rhFree = sz }
                                                     initGrExpr  = GrExpr_Eval (HNm "_main")
                                                in   RunState
                                                        { rsNext = Just initGrExpr
                                                        , rsStack = []
                                                        , rsEnv = n2p', rsGlobEnv = n2p'
                                                        , rsHeap = h
                                                        , rsHalted = Nothing, rsNrSteps = 0
                                                        }
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Clone
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR AllBind [ | | lamGlobL, cafGlobL USE {++} {[]}: {AssocL HsName RunVal} ]
ATTR AllExpr [ | | self: SELF ]

SEM GrBind
  | Bind        lhs         .   (lamGlobL,cafGlobL)
                                            =   let g = [(@nm,RVGlob @nm @argNmL @expr.self)]
                                                in  if null @argNmL then ([],g) else (g,[])
%%]

