-------------------------------------------------------------------------
-- Optimisation: ARule/Expr rename of AVar
-------------------------------------------------------------------------

{
module ARuleAVarRename
  ( arlElimAlphaRename
  )
  where

-- import Data.List
-- import qualified Data.Set as Set
import qualified Data.Map as Map
-- import Utils
import Common
import Expr
-- import ExprIsRw
-- import ExprToAEqn
import ARule
-- import ARulePrettyPrint
import FmGam
-- import ECnstrGam
-- import RwExprGam
}

INCLUDE "ExprAbsSynAG.ag"
INCLUDE "ARuleAbsSynAG.ag"

INCLUDE "ExprSelfAG.ag"
INCLUDE "ARuleSelfAG.ag"

INCLUDE "ARuleEqnDest1NmAG.ag"
INCLUDE "ARuleInCompDestAG.ag"

WRAPPER AGExprItf AGARuleItf

{
exprASubst :: RnMp -> Expr -> Expr
exprASubst rnm e
  = replRn_Syn_AGExprItf r2
  where r1 = sem_AGExprItf (AGExprItf_AGItf e)
        r2 = wrap_AGExprItf r1
                (Inh_AGExprItf { rnMp_Inh_AGExprItf = rnm
                               })

arlElimAlphaRename :: ARule -> ARule
arlElimAlphaRename r
  = replRn_Syn_AGARuleItf r2
  where r1 = sem_AGARuleItf (AGARuleItf_AGItf r)
        r2 = wrap_AGARuleItf r1
                (Inh_AGARuleItf)
}


-------------------------------------------------------------------------
-- Part I: Elimination of alpha renaming
-------------------------------------------------------------------------

-------------------------------------------------------------------------
-- Rename map gather
-------------------------------------------------------------------------

{
rnRepl :: RnMp -> RnSrc -> RnSrc
rnRepl m e
  = case e of
      RnExpr (Expr_AVar (ANm_Loc n _)) -> r n
      RnNm   (ANm_Loc n _)             -> r n
      _                                -> e
  where r n = maybe e (RnExpr . exprASubst (Map.delete n m) . rnSrc2Expr . snd) (Map.lookup n m)
}

ATTR AEqns AEqn ANm AllExpr AExpr [ | | gathRnMp USE {`rnMpUnion`} {Map.empty}: RnMp ]
ATTR AllARuleButARule AllExpr AGExprItf [ rnMp: RnMp | | ]

SEM AEqn
  | Eqn             loc     .   gathRnMp    =   let m = case @dest.mbSingleANm of
                                                            Just (ANm_Loc dn p) | AtRetain `notElem` p
                                                              -> Map.singleton dn (0,v)
                                                              where v = case (@val.mbSingleANm,@val.self) of
                                                                          (Just sn,_           ) -> RnNm sn
                                                                          (_      ,AExpr_Expr e) -> RnExpr e
                                                            _ -> Map.empty
                                                in  m `rnMpUnion` @val.gathRnMp

SEM ANm
  | Loc             lhs     .   gathRnMp    =   Map.singleton @nm (1,RnNone)

SEM ARule
  | Rule            eqns    .   rnMp        =   Map.filter (\(c,v)
                                                             -> case v of 
                                                                  RnNone           -> False
                                                                  RnExpr _ | c > 1 -> False
                                                                  _                -> True
                                                           )
                                                           @eqns.gathRnMp

{-
SEM AttrEqn
  | Eqn             loc     .   rnMp        =   Map.empty

SEM RExprEqn
  | Expr            loc     .   rnMp        =   Map.empty

SEM Decl
  | Fmt ShpJudge Explain
  					loc     .   rnMp        =   Map.empty
-}

-------------------------------------------------------------------------
-- Replica
-------------------------------------------------------------------------

ATTR AllARule AllExpr [ | | replRn: SELF ]
ATTR AGARuleItf [ | | replRn: ARule ]
ATTR AGExprItf [ | | replRn: Expr ]
ATTR AEqns AEqn [ | | replRnEqns USE {++} {[]}: {[AEqn]} ]

SEM Expr
  | AVar            lhs     .   replRn      =   rnSrc2Expr (rnRepl @lhs.rnMp (RnExpr @replRn))

SEM AEqn
  | Eqn             lhs     .   replRnEqns  =   case @dest.mbSingleANm of
                                                    Just (ANm_Loc n _)
                                                      -> case Map.lookup n @lhs.rnMp of
                                                           Just _ -> []
                                                           _      -> [@replRn]
                                                    _ -> [@replRn]
  | * - Eqn         lhs     .   replRnEqns  =   [@replRn]

SEM ARule
  | Rule            lhs     .   replRn      =   ARule_Rule @ndNmL @rlNm @info @eqns.replRnEqns

