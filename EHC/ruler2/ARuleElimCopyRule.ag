-------------------------------------------------------------------------
-- Optimisation: ARule copy rule elimination
-------------------------------------------------------------------------

{
module ARuleElimCopyRule
  ( module Gam

  , AtDefdGam
  , CrOrdGam
  
  , arlElimCopyRule
  )
  where

import qualified Data.Map as Map
import Common
import Expr
import ARule
import Gam
}

INCLUDE "ExprAbsSynAG.ag"
INCLUDE "ARuleAbsSynAG.ag"

INCLUDE "ExprSelfAG.ag"
INCLUDE "ARuleSelfAG.ag"

INCLUDE "ARuleCopyRuleNmAG.ag"

INCLUDE "ARuleEqnDest1NmAG.ag"
INCLUDE "ARuleInCompDestAG.ag"

WRAPPER  AGARuleItf

{
arlElimCopyRule :: [Nm] -> AtDefdGam -> ARule -> ARule
arlElimCopyRule co ag rl
  = self_Syn_AGARuleItf r2
  where r1 = sem_AGARuleItf (AGARuleItf_AGItf rl)
        r2 = wrap_AGARuleItf r1
                (Inh_AGARuleItf {croNmL_Inh_AGARuleItf = co
                                ,adGam_Inh_AGARuleItf = ag
                                })
}

-------------------------------------------------------------------------
-- Copy rule order, ref to previous node
-------------------------------------------------------------------------

{
type CrOrdGam = Gam Nm Nm
}

-------------------------------------------------------------------------
-- Non local attr's defined, threaded?
-------------------------------------------------------------------------

{
type AtDefdGam = Gam Nm Bool
}

-------------------------------------------------------------------------
-- Context
-------------------------------------------------------------------------

ATTR AllARuleRule AllARuleEqn AGARuleItf [ adGam: AtDefdGam | | ]
ATTR AllARuleRule AllARuleEqn [ croGam: CrOrdGam | | ]

SEM AGARuleItf
  | AGItf           rule    .   croGam      =   fst . foldl (\(g,pn) n -> (Map.insert n pn g,n)) (emptyGam,head @lhs.croNmL) $ tail @lhs.croNmL

-------------------------------------------------------------------------
-- Replica
-------------------------------------------------------------------------

ATTR AEqns AEqn [ | | replCrEqns USE {++} {[]}: {[AEqn]} ]

SEM AEqn
  | Eqn             lhs     .   replCrEqns  =   let isThr n = Map.findWithDefault False n @lhs.adGam
                                                    isPrev n1 n2 = maybe False (==n1) $ Map.lookup n2 @lhs.croGam
                                                in  case (@dest.mbSingleANm,@val.mbSingleANm) of
                                                      (Just (ANm_Node nn dn),Just (ANm_Lhs sn _)) | dn == sn && not (isThr sn)
                                                        -> []
                                                      (Just (ANm_Node nn dn),Just (ANm_Lhs sn _)) | dn == sn && (isThr sn) && nmLhs `isPrev` nn
                                                        -> []
                                                      (Just (ANm_Node nn1 dn),Just (ANm_Node nn2 sn)) | dn == sn && (isThr sn) && nn2 `isPrev` nn1
                                                        -> []
                                                      (Just (ANm_Lhs dn _),Just (ANm_Node nn sn)) | dn == sn {- && (isThr sn) -} && nn `isPrev` nmLhs
                                                        -> []
                                                      (Just (ANm_Lhs dn _),Just (ANm_Lhs sn _)) | dn == sn && (isThr sn) && nmLhs `isPrev` nmLhs
                                                        -> []
                                                      _ -> [@self]
  | * - Eqn         lhs     .   replCrEqns  =   [@self]

SEM ARule
  | Rule            lhs     .   self        =   ARule_Rule @ndNmL @rlNm @info @eqns.replCrEqns


