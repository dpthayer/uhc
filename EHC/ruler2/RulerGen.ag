-- $Id: Ruler.ag 231 2005-06-07 14:39:41Z atze $

-------------------------------------------------------------------------
-- Use of attrs
-------------------------------------------------------------------------

{
type AtUsage  = (Expr,FmGam Expr)
type AtUsInfo = (Nm,FmGam Expr,[(AtDir,AtUsage)])

emptyAtUsInfo = (nmUnk,emptyGam,[])

type AtUsGam = Gam Nm AtUsInfo

rlAtUsage :: Opts -> ScGam Expr ->  FmGam Expr -> VwRlInfo Expr -> (AtUsGam,FmGam Expr,ChOrdGam,AtDefdGam,ECnstrGam)
rlAtUsage opts scGam fmGam vwRlInfo
  = (preDfG `Map.union` postDfG
    ,preExtraG `fmGamUnion` postExtraG
    ,postCoG
    ,preAdG `Map.union` postAdG
    ,preEcG `Map.union` postEcG
    )
  where (preDfG ,preExtraG ,_      ,preAdG ,preEcG ) = mk True  (vwrlFullPreGam  vwRlInfo)
        (postDfG,postExtraG,postCoG,postAdG,postEcG) = mk False (vwrlFullPostGam vwRlInfo)
        opts' = opts {optSubstFullNm=False}
        sbsn = nmSubst opts' fmGam
        sbse = exprSubst opts' fmGam
        mk isPre g
          = Map.foldWithKey
              (\jdNm reInfo (atDefG,atExtraG,coG,adG,ecG)
                -> let (Just (scInfo,vwScInfo)) = scVwGamLookup (reScNm reInfo) (vwrlNm vwRlInfo) scGam
                       isJd         = scKind scInfo == ScJudge
                       flipDir      = not isPre
                       scAtGam      = vwscFullAtGam vwScInfo
                       jaGam        = reJAGam reInfo
                       atLkup n     = maybe exprUnk jaExpr . Map.lookup n $ jaGam
                       -- nmWtProp f p = Map.keys . Map.filter (\i -> p (f i)) $ scAtGam
                       nmWtProp f p = [ (atNm i,atTy i) | i <- Map.elems scAtGam, p (f i) ]
                       
                       -- node
                       nNd          = maybeHd nmUnk fst . nmWtProp atProps $ (AtNode `elem`)
                       eNd          = atLkup nNd
                       eNdSubs      = sbse eNd
                       eNdNm        = exprAsNm eNdSubs
                       eNdNmS       = exprNmS eNd
                       eNdFmGam     = fmGamFromList [ (n,mkAFld . sbsn $ n) | n <- Set.toList eNdNmS ]
                       eNdCoGam     = exprCoGam . exprSubst opts' eNdFmGam $ eNd
                       
                       -- in/out attr's
                       nmWtDir at   = [ nt | nt@(n,_) <- nmWtProp atDirs (at `elem`), n `notElem` [nNd] ]
                       nInL         = nmWtDir (if flipDir then AtSyn else AtInh)
                       nOuL         = nmWtDir (if flipDir then AtInh else AtSyn)
                       nBiDirL      = nmWtProp atProps (let ps = Map.elems propsMp in \psn -> not (null (psn `intersect` ps)))
                       
                       -- construction of rhs of eqn
                       mkInRhs, mkOuRhs :: Nm -> Nm -> Expr
                       mkInRhs n _  = atLkup n
                       mkOuRhs _ n' = if flipDir then mkALhs n' else mkANd eNdNm n'
                       
                       -- construction of lhs of eqn
                       mkInLhs, mkOuLhs :: (Nm -> Expr) -> (Nm -> Nm) -> Nm -> Nm -> (Expr,FmGam Expr,FmGam Expr,[Nm])
                       mkInLhs _ _ n n'
                         = (nd,fmGamFromList [(n,nd)],fmGamFromList [(n,atUse n')],[n'])
                         where nd = if flipDir then mkALhs n' else mkANd eNdNm n'
                               atUse = if flipDir then mkANd eNdNm else mkALhs
                       mkOuLhs atUse nmAdapt n _
                         = (r',fmr,fmr',[])
                         where r = atLkup n
                               b = [ (n,Nm . nmShowAG . nmAdapt $ sbsn n) | n <- Set.toList (exprNmS r), n /= nmWild ]
                               fmr  = fmGamFromList [ (n,mkALoc' n') | (n,n') <- b ]
                               fmr' = fmGamFromList [ (n,atUse n') | (n,n') <- b ]
                               r' = exprSubst opts' fmr r
                       
                       -- construction of eqn
                       mkDef dir nmAdapt mkL mkR (n,ty)
                         = if fmNull fmDef then [] else [(fmDef, (dir,(eqn,fmUse)), (n,l), atNmL, eqnEcG `Map.union` ecG)]
                         where n' = Nm . nmShowAG . sbsn . nmAdapt $ n
                               (l,fmDef,fmUse,atNmL) = mkL preUse' nmAdapt' n n'
                               r = mkR n n'
                               (nmAdapt',preUse') = if flipDir then (nmInit,mkALhs) else (id,mkALoc')
                               c = ECnstr_Ty [ty]
                               (eqn,eqnEcG) = exprElimCnstr (mkExprEqn l r)
                               ecG = Map.fromList [ (l,c), (r,c) ]
                       mkDefs mk nL
                         = (Map.unions fg,dirL,atL,atNmL,Map.unions ecG)
                         where (fg,dirL,atL,atNmL,ecG) = unzip5 . concat . map mk $ nL
                       
                       -- construction of the whole lot
                       (fmInBi   ,inBiL   ,_     ,atInBiLL   ,ecGInBi   ) = mkDefs (mkDef AtIn  nmInit mkInLhs mkInRhs) $ (nInL `intersect` nBiDirL)
                       (fmInNonBi,inNonBiL,_     ,atInNonBiLL,ecGInNonBi) = mkDefs (mkDef AtIn  id     mkInLhs mkInRhs) $ (nInL \\          nBiDirL)
                       (fmOuBi   ,ouBiL   ,_     ,_          ,ecGOuBi   ) = mkDefs (mkDef AtOut nmInit mkOuLhs mkOuRhs) $ (nOuL `intersect` nBiDirL)
                       (fmOuNonBi,ouNonBiL,ouAscL,_          ,ecGOuNonBi) = mkDefs (mkDef AtOut id     mkOuLhs mkOuRhs) $ (nOuL \\          nBiDirL)
                       fmOf l = fmGamUnions [ g | (_,(_,g)) <- l ]
                       fmNd = fmGamFromList [(eNdNm,mkALoc eNdNm)]
                       mkAdGam d l = Map.fromList [ (n,d) | n <- concat l ]
                       (r,extraG)
                         = if isJd
                           then if isPre
                                then ((eNdNm
                                      ,fmInBi `fmGamUnion` fmInNonBi `fmGamUnion` fmOuBi `fmGamUnion` fmOuNonBi
                                      ,inBiL ++ inNonBiL ++ ouBiL ++ ouNonBiL
                                      )
                                     ,emptyGam
                                     )
                                else ((eNdNm
                                      ,fmInBi `fmGamUnion` fmInNonBi
                                      ,inBiL ++ inNonBiL
                                      )
                                     ,eNdFmGam `fmGamUnion` fmOf ouBiL `fmGamUnion` fmOf ouNonBiL
                                     )
                           else let fma = fmGamFromList ouAscL
                                    fmja = fma `Map.union` jaGamToFmGam id jaGam
                                    jd = fkGamLookup exprUnk jdExpr FmAG . vwscJdGam $ vwScInfo
                                    jd' = exprSubst opts fmja jd
                                    jdLines (Expr_LF l r) = l : jdLines r
                                    jdLines j             = [j]
                                in  ((eNdNm,fmOuNonBi,[(AtInOut,(j,fmOf ouNonBiL)) | j <- jdLines jd'])
                                    ,emptyGam
                                    )
                   in  (Map.singleton jdNm r `Map.union` atDefG
                       ,extraG `fmGamUnion` atExtraG
                       ,eNdCoGam
                       ,mkAdGam False atInNonBiLL `Map.union` mkAdGam True atInBiLL `Map.union` adG
                       ,ecGInBi `Map.union` ecGInNonBi `Map.union` ecGOuBi `Map.union` ecGOuNonBi `Map.union` ecG
                       )
              )
              (emptyGam,emptyGam,emptyGam,emptyGam,emptyGam)
              g
}

-------------------------------------------------------------------------
-- Abstractions for generation
-------------------------------------------------------------------------

{
data Gen
  = Gen
      { -- data
        genOpts         :: Opts
      , genScGam        :: ScGam Expr
      , genFmGam        :: FmGam Expr
      , genInFmGam      :: FmGam Expr
      , genRwGam        :: RwExprGam
      , genRsInfo       :: RsInfo Expr
      , genRlInfo       :: RlInfo Expr
      , genScInfo       :: ScInfo Expr
      , genVwScInfo     :: VwScInfo Expr
      , genVwRlInfo     :: VwRlInfo Expr
        -- functions
      , genRlSelIsSel   :: RlSelIsSel
      , genNmDef        :: Nm -> PP_Doc -> PP_Doc
      , genNmUse        :: Nm -> PP_Doc
      , genRl           :: Gen -> (Nm,Nm,Nm) -> PP_Doc
      , genRs           :: Gen -> (Nm,Nm) -> PP_Doc -> [Nm] -> [PP_Doc] -> PP_Doc
      , genJdExpr       :: Gen -> (Nm -> Maybe Bool) -> FmGam Expr -> FmGam Expr -> Expr -> PP_Doc
      , genMkJdInfo     :: Gen -> (Nm,Nm) -> REGam Expr -> (ScInfo Expr,VwScInfo Expr,REInfo Expr,FmGam Expr,Expr)
      }

genDflt
  = Gen
      { genOpts         = defaultOpts
      , genScGam        = emptyGam
      , genFmGam        = emptyGam
      , genInFmGam      = emptyGam
      , genRwGam        = emptyGam
      , genRlInfo       = emptyRlInfo
      , genRsInfo       = emptyRsInfo
      , genScInfo       = emptyScInfo
      , genVwScInfo     = emptyVwScInfo
      , genVwRlInfo     = emptyVwRlInfo
      --
      , genRlSelIsSel   = \_ _ _ -> True
      , genNmDef        = \n def -> empty
      , genNmUse        = \n -> empty
      , genRl           = \gen (nFull,nVw,nRl) -> empty
      , genRs           = \gen (nScMeta,nVwFull) meta defNms defVals -> empty
      , genJdExpr       = \gen atIsChanged jaFmGam fmGam e -> empty
      , genMkJdInfo     = \gen (nVw,nJd) reGam ->
          let reInfo = maybe (panic "genMkJdInfo") id (Map.lookup nJd reGam)
              (scInfo,vwScInfo) = fromJust (scVwGamLookup (reScNm reInfo) nVw (genScGam gen))
              fg = jaGamToFmGam (exprSubst (genOpts gen) (genFmGam gen)) . reJAGam $ reInfo
              scVwExpr = jdGamFmExpr (optGenFM . genOpts $ gen) . vwscJdGam $ vwScInfo
          in  (scInfo,vwScInfo,reInfo,fg,scVwExpr)
      }

genTeX
  = genDflt
      { genNmDef = \n def ->
          mkCmdNmDef n def
      , genNmUse = \n ->
          mkCmdNmUse n
      , genRl = \gen (nRlFull,nVw,nRl) ->
          let atIsChanged
                = case vwrlMbChGam (genVwRlInfo gen) of
                    Just g  -> \j a -> maybe (Just False) (const (Just True)) $ dblGamLookup id j a g
                    Nothing -> \_ _ -> Nothing
              mkJd nJd atIsChanged reGam
                = switchLaTeXLhs ePP
                where (scInfo,vwScInfo,reInfo,fg,scVwExpr) = genMkJdInfo gen (gen {genOpts = (genOpts gen) {optSubstFullNm=False}}) (nVw,nJd) reGam
                      gen' = gen {genScInfo=scInfo, genVwScInfo=vwScInfo}
                      ePP = genJdExpr gen' gen' atIsChanged fg (genFmGam gen') scVwExpr
              mkJds reGam order
                = map (\nJd -> mkJd nJd (atIsChanged nJd) reGam) order
              prePPL   = mkJds (vwrlFullPreGam (genVwRlInfo gen)) (concat . vwrlPreScc $ genVwRlInfo gen)
              postPPL  = mkJds (vwrlFullPostGam (genVwRlInfo gen)) (Map.keys . vwrlFullPostGam $ genVwRlInfo gen)
              r = "\\ehinfruleB" >|< ppCurly nRl >|< ppCurly nVw
                  >-< ppListSepVV "{%" "}" "\\\\" prePPL
                  >-< ppListSepVV "{%" "}" "\\\\" postPPL
          in  mkCmdNmDef nRlFull r
      , genRs = \gen (nScMeta,nVwFull) meta defNms defVals ->
          let eFigPP
                = "\\begin{RulesFigureB}" >|< ppCurly (mkCmdNmUse nScMeta) >|< ppCurly (pp (rsDescr (genRsInfo gen))) >|< ppCurly nVwFull
                  >-< vlist (intersperse (pp "\\hspace{1ex}") . map mkCmdNmUse $ defNms)
                  >-< "\\end{RulesFigureB}"
          in  vlist defVals
              >-< mkCmdNmDef nScMeta (ensureTeXMath . mkInLhs2Tex $ meta)
              >-< mkCmdNmDef nVwFull eFigPP
      , genJdExpr   = \gen atIsChanged jaFmGam fmGam e ->
          let mkChng
                = case optMbMarkChange (genOpts gen) of
                    Just _  -> \nAt -> case atIsChanged nAt of
                                         Just isCh -> Expr_Wrap (if isCh then WrIsChanged else WrIsSame)
                                         Nothing   -> id
                    Nothing -> \_   -> id
              (jaFmGam',wrFullJd)
                = if null chs    then (jaFmGam,id)
                  else if or chs then (fmGamMap mkChng jaFmGam,id)
                                 else (jaFmGam,Expr_Wrap WrIsSame)
                where chs = catMaybes . map atIsChanged . Map.keys $ jaFmGam
          in  exprFmtTeXSubst (genOpts gen) fmGam . wrFullJd . exprSubst (genOpts gen) jaFmGam' $ e
      }

genAG
  = genDflt
      { genRl = \gen (nRlFull,nVw,nRl) ->
          let (atUsGam,fmNd,choGam,adGam,ecGam)
                = rlAtUsage (genOpts gen) (genScGam gen) (genFmGam gen) (genVwRlInfo gen)
              atUseFmGam  = Map.unions [ g | (_,_,as) <- Map.elems atUsGam, (_,(_,g)) <- as ] `fmGamUnion` fmNd
              atUseFmGam2 = atUseFmGam `fmGamUnion` genFmGam gen
              ecGam' = Map.mapKeys (exprSubst (genOpts gen) atUseFmGam) ecGam
              mkJds reGam order
                = (concat eqnL,fmGamUnions eqnGamL)
                where (eqnL,eqnGamL)
                        = unzip
                        . map (\nJd
                                -> let (scInfo,vwScInfo,reInfo,fg,scVwExpr) = genMkJdInfo gen gen (nVw,nJd) reGam
                                       atUsInfo@(_,_,atL) = maybe (panic "genRl") id (Map.lookup nJd atUsGam)
                                       gen' = gen {genScInfo=scInfo, genVwScInfo=vwScInfo}
                                       mk e
                                         = (aEqnL,g)
                                         where (_,aEqnL,g) = exprRewrite' (genOpts gen') atUseFmGam2 (genRwGam gen') ecGam' e
                                       (eqnL,gL) = unzip . map (\(_,(eqn,_)) -> mk eqn) $ atL
                                   in  (concat eqnL,fmGamUnions gL)
                              )
                        $ order
              (preL ,preEqnG ) = mkJds (vwrlFullPreGam (genVwRlInfo gen)) (concat . vwrlPreScc $ genVwRlInfo gen)
              (postL,postEqnG) = mkJds (vwrlFullPostGam (genVwRlInfo gen)) (Map.keys . vwrlFullPostGam $ genVwRlInfo gen)
              eqnG = preEqnG `fmGamUnion` postEqnG
              rl = ARule_Rule [maybe (scNm (genScInfo gen)) Nm (scMbAGStr (genScInfo gen))]
                              (maybe nRl Nm (rlMbAGStr (genRlInfo gen)))
                              ["rule " ++ show nRl,"view " ++ show nVw]
                              (preL ++ postL)
              croNmL
                = [nmLhs] ++ l ++ [nmLhs]
                where l = map fst . sortBy (\(_,o1) (_,o2) -> compare o1 o2) . Map.toList $ choGam
              -- croGam = foldl (\(g,pn) (n,_) -> (Map.insert n pn g,n)) (Map.empty,last croNmL) (init croNmL)
              wrapFrag
                = if optFragWrap (genOpts gen)
                  then \x -> "%%[" >|< nVw `nmApd` scNm (genScInfo gen) `nmApd` rlNm (genRlInfo gen) >-< x >-< "%%]"
                  else id
              r = (>-< "") . wrapFrag . ppARule . arlElimWild . arlElimCopyRule croNmL adGam . arlElimAlphaRename . arlUniq croNmL . arlSubst eqnG $ rl
          in  {- trp "ZZ" (vlist [ pp (Expr_Cnstr n v) | (n,v) <- Map.toList ecGam']) -}
              r
      , genRs = \gen (_,nVwFull) _ _ defVals ->
          "--" >#< pp (rsDescr (genRsInfo gen)) >#< nVwFull
          >-< vlist defVals
      }

type GenGam = Gam FmKind Gen

genGam :: GenGam
genGam = Map.fromList [ (FmTeX,genTeX), (FmAG,genAG) ]
}

-------------------------------------------------------------------------
-- Generation of lhs2tex/AG for rules
-------------------------------------------------------------------------

{
rlGen :: Gen -> (Nm,Nm->Nm) -> Gam Nm (Nm,PP_Doc)
rlGen gen (nRl',mkFullNm)
  = Map.mapWithKey
      (\nVw vwRlInfo
        ->  let nRlFull = mkFullNm nVw
                gen' = gen {genVwRlInfo=vwRlInfo}
                r = genRl gen' gen' (nRlFull,nVw,nRl')
            in  (nRlFull,r)
      )
    . Map.filterWithKey
      (\nVw vwRlInfo -> genRlSelIsSel gen nVw (rsNm $ genRsInfo gen) (rlNm $ genRlInfo gen))
    $ (rlVwGam (genRlInfo gen))

rlLtxGamTranspose :: Ord k => Gam k (Gam k (n,v)) -> Gam k (Gam k (n,v))
rlLtxGamTranspose g
  = Map.fromListWith Map.union [ (v,Map.singleton r (n,d)) | (r,vm) <- Map.toList g, (v,(n,d)) <- Map.toList vm ]

vwRlLtxGen :: Gen -> Gam Nm (Gam Nm (Nm,PP_Doc)) -> Gam Nm PP_Doc
vwRlLtxGen gen vwRlLtxGam
  = Map.mapWithKey
      (\nVw rMp
        ->  let rs = catMaybes [ Map.lookup n rMp | n <- rsRlOrder (genRsInfo gen) ]
                nVwFull = nmInit . fst . head $ rs
                nScMeta = nVwFull `nmApd` Nm "scheme"
                vwScInfo = fromJust $ Map.lookup nVw $ scVwGam $ genScInfo gen
                gen' = gen {genVwScInfo=vwScInfo}
                eScmPP
                  = genJdExpr gen' gen' (const Nothing) emptyGam (genFmGam gen')
                    . jdGamFmExpr (optGenFM . genOpts $ gen')
                    . vwscJdGam
                    $ vwScInfo
            in  genRs gen' gen'
                      (nScMeta,nVwFull)
                      eScmPP (map fst rs) (map snd rs)
      )
    . Map.filterWithKey
      (\nVw _ -> genRlSelIsSel gen nVw nmAny nmAny)
    $ vwRlLtxGam

rsGen :: Gen -> [Nm] -> RsGam Expr -> Gam Nm (Gam Nm PP_Doc)
rsGen gen vwOrder rsGam
  = Map.mapWithKey
      (\nRs rsInfo
        -> let gen' = gen {genRsInfo=rsInfo}
           in  case rsInfo of
                 RsInfo nRs nSc _ rlGam
                   -> vwRlLtxGen gen'' (rlLtxGamTranspose r)
                   where scInfo = fromJust (Map.lookup nSc (genScGam gen'))
                         gen'' = gen' {genScInfo=scInfo}
                         r = Map.mapWithKey
                               (\nRl rlInfo
                                 -> let nRl' = nmLaTeX nRl
                                    in  rlGen (gen'' {genRlInfo=rlInfo})
                                              (nRl',\nVw -> mkRlNm nBs nVw nRs nRl')
                               )
                               rlGam
                 RsInfoGroup nRs nSc _ rlNms
                   -> vwRlLtxGen gen'' (Map.unions r)
                   where scInfo = fromJust (Map.lookup nSc (genScGam gen'))
                         gen'' = gen' {genScInfo=scInfo}
                         r = map
                               (\nVw
                                 -> let rs = [ let nRl' = nmLaTeX nRl
                                                   nd = mkRlNm nBs nVw nRs  nRl'
                                                   nu = mkRlNm nBs nVw nRs' nRl'
                                               in  Map.singleton nRl (nd,genNmDef gen'' nd (genNmUse gen'' nu))
                                             | (nRs',nRl) <- rlNms, rlVwIsDef nRs' nRl nVw
                                             ]
                                    in  if null rs then emptyGam else Map.singleton nVw (Map.unions rs)
                               )
                               vwOrder
      )
    . Map.filterWithKey
      (\nRs _ -> genRlSelIsSel gen nmAny nRs nmAny)
    $ rsGam
  where nBs = Nm (optBaseNm (genOpts gen))
        mkRlNm b v rs r
          = nmApd b $ (if v == nmNone then id else nmApd v) $ nmApd rs $ r
        rlVwIsDef rs r v
          = isJust (do rsInfo <- Map.lookup rs rsGam
                       rlGam <- rsInfoMbRlGam rsInfo
                       rlVwGamLookup r v rlGam
                   )

}

ATTR AllDecl [ | | mkRsFmtGam USE {++} {[]} : {[FmKind -> Gam Nm (Gam Nm PP_Doc)]} ]
ATTR AGItf [ | | mkPP: {FmKind -> PP_Doc} ]

SEM AGItf
  | AGItf           lhs     .   mkPP        =   \fm -> fkGamLookup empty pp fm @decls.paGam
                                                       >-< (vlist . Map.elems . Map.map (vlist . Map.elems) . Map.unions . map ($ fm) $ @decls.mkRsFmtGam)

SEM Decl
  | Rules RulesGroup
                    loc     .   mkGen       =   \gen -> gen { genOpts = @lhs.opts
                                                            , genScGam = @lhs.scGam
                                                            , genFmGam = @lhs.fmGam
                                                            , genRwGam = @lhs.rwGam
                                                            , genRlSelIsSel = @lhs.rlSelIsSel
                                                            }
                    lhs     .   mkRsFmtGam  =   [\fm -> let gen = @mkGen (maybe genDflt id (Map.lookup fm genGam))
                                                        in  rsGen gen (vgTopSort @lhs.vwDpdGr) @lhs.rsGam
                                                ]

